((typeof self !== 'undefined' ? self : this)["webpackJsonpDgiotamisEditor"] = (typeof self !== 'undefined' ? self : this)["webpackJsonpDgiotamisEditor"] || []).push([[7],{

/***/ "0269":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "insertdatetime" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/insertdatetime')
//   ES2015:
//     import 'tinymce/plugins/insertdatetime'
__webpack_require__("1d9e");

/***/ }),

/***/ "0537":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var setContent = function (editor, html) {
      editor.focus();
      editor.undoManager.transact(function () {
        editor.setContent(html);
      });
      editor.selection.setCursorLocation();
      editor.nodeChanged();
    };
    var getContent = function (editor) {
      return editor.getContent({ source_view: true });
    };

    var open = function (editor) {
      var editorContent = getContent(editor);
      editor.windowManager.open({
        title: 'Source Code',
        size: 'large',
        body: {
          type: 'panel',
          items: [{
              type: 'textarea',
              name: 'code'
            }]
        },
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: { code: editorContent },
        onSubmit: function (api) {
          setContent(editor, api.getData().code);
          api.close();
        }
      });
    };

    var register$1 = function (editor) {
      editor.addCommand('mceCodeEditor', function () {
        open(editor);
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceCodeEditor');
      };
      editor.ui.registry.addButton('code', {
        icon: 'sourcecode',
        tooltip: 'Source code',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('code', {
        icon: 'sourcecode',
        text: 'Source code',
        onAction: onAction
      });
    };

    function Plugin () {
      global.add('code', function (editor) {
        register$1(editor);
        register(editor);
        return {};
      });
    }

    Plugin();

}());


/***/ }),

/***/ "18f5":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global$b = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var hasProPlugin = function (editor) {
      if (editor.hasPlugin('powerpaste', true)) {
        if (typeof window.console !== 'undefined' && window.console.log) {
          window.console.log('PowerPaste is incompatible with Paste plugin! Remove \'paste\' from the \'plugins\' option.');
        }
        return true;
      } else {
        return false;
      }
    };

    var get = function (clipboard) {
      return { clipboard: clipboard };
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isArray = isType('array');
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from$1 = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from$1
    };

    var nativeSlice = Array.prototype.slice;
    var nativePush = Array.prototype.push;
    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var filter$1 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var foldl = function (xs, f, acc) {
      each(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };
    var from = isFunction(Array.from) ? Array.from : function (x) {
      return nativeSlice.call(x);
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };
    var endsWith = function (str, suffix) {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    var repeat = function (s, count) {
      return count <= 0 ? '' : new Array(count + 1).join(s);
    };

    var global$a = tinymce.util.Tools.resolve('tinymce.Env');

    var global$9 = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var global$8 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var global$7 = tinymce.util.Tools.resolve('tinymce.util.VK');

    var firePastePreProcess = function (editor, html, internal, isWordHtml) {
      return editor.fire('PastePreProcess', {
        content: html,
        internal: internal,
        wordContent: isWordHtml
      });
    };
    var firePastePostProcess = function (editor, node, internal, isWordHtml) {
      return editor.fire('PastePostProcess', {
        node: node,
        internal: internal,
        wordContent: isWordHtml
      });
    };
    var firePastePlainTextToggle = function (editor, state) {
      return editor.fire('PastePlainTextToggle', { state: state });
    };
    var firePaste = function (editor, ieFake) {
      return editor.fire('paste', { ieFake: ieFake });
    };

    var global$6 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var shouldBlockDrop = function (editor) {
      return editor.getParam('paste_block_drop', false);
    };
    var shouldPasteDataImages = function (editor) {
      return editor.getParam('paste_data_images', false);
    };
    var shouldFilterDrop = function (editor) {
      return editor.getParam('paste_filter_drop', true);
    };
    var getPreProcess = function (editor) {
      return editor.getParam('paste_preprocess');
    };
    var getPostProcess = function (editor) {
      return editor.getParam('paste_postprocess');
    };
    var getWebkitStyles = function (editor) {
      return editor.getParam('paste_webkit_styles');
    };
    var shouldRemoveWebKitStyles = function (editor) {
      return editor.getParam('paste_remove_styles_if_webkit', true);
    };
    var shouldMergeFormats = function (editor) {
      return editor.getParam('paste_merge_formats', true);
    };
    var isSmartPasteEnabled = function (editor) {
      return editor.getParam('smart_paste', true);
    };
    var isPasteAsTextEnabled = function (editor) {
      return editor.getParam('paste_as_text', false);
    };
    var getRetainStyleProps = function (editor) {
      return editor.getParam('paste_retain_style_properties');
    };
    var getWordValidElements = function (editor) {
      var defaultValidElements = '-strong/b,-em/i,-u,-span,-p,-ol,-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,' + '-p/div,-a[href|name],sub,sup,strike,br,del,table[width],tr,' + 'td[colspan|rowspan|width],th[colspan|rowspan|width],thead,tfoot,tbody';
      return editor.getParam('paste_word_valid_elements', defaultValidElements);
    };
    var shouldConvertWordFakeLists = function (editor) {
      return editor.getParam('paste_convert_word_fake_lists', true);
    };
    var shouldUseDefaultFilters = function (editor) {
      return editor.getParam('paste_enable_default_filters', true);
    };
    var getValidate = function (editor) {
      return editor.getParam('validate');
    };
    var getAllowHtmlDataUrls = function (editor) {
      return editor.getParam('allow_html_data_urls', false, 'boolean');
    };
    var getPasteDataImages = function (editor) {
      return editor.getParam('paste_data_images', false, 'boolean');
    };
    var getImagesDataImgFilter = function (editor) {
      return editor.getParam('images_dataimg_filter');
    };
    var getImagesReuseFilename = function (editor) {
      return editor.getParam('images_reuse_filename');
    };
    var getForcedRootBlock = function (editor) {
      return editor.getParam('forced_root_block');
    };
    var getForcedRootBlockAttrs = function (editor) {
      return editor.getParam('forced_root_block_attrs');
    };
    var getTabSpaces = function (editor) {
      return editor.getParam('paste_tab_spaces', 4, 'number');
    };
    var getAllowedImageFileTypes = function (editor) {
      var defaultImageFileTypes = 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp';
      return global$6.explode(editor.getParam('images_file_types', defaultImageFileTypes, 'string'));
    };

    var internalMimeType = 'x-tinymce/html';
    var internalMark = '<!-- ' + internalMimeType + ' -->';
    var mark = function (html) {
      return internalMark + html;
    };
    var unmark = function (html) {
      return html.replace(internalMark, '');
    };
    var isMarked = function (html) {
      return html.indexOf(internalMark) !== -1;
    };
    var internalHtmlMime = constant(internalMimeType);

    var hasOwnProperty = Object.hasOwnProperty;
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    var global$5 = tinymce.util.Tools.resolve('tinymce.html.Entities');

    var isPlainText = function (text) {
      return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text);
    };
    var toBRs = function (text) {
      return text.replace(/\r?\n/g, '<br>');
    };
    var openContainer = function (rootTag, rootAttrs) {
      var attrs = [];
      var tag = '<' + rootTag;
      if (typeof rootAttrs === 'object') {
        for (var key in rootAttrs) {
          if (has(rootAttrs, key)) {
            attrs.push(key + '="' + global$5.encodeAllRaw(rootAttrs[key]) + '"');
          }
        }
        if (attrs.length) {
          tag += ' ' + attrs.join(' ');
        }
      }
      return tag + '>';
    };
    var toBlockElements = function (text, rootTag, rootAttrs) {
      var blocks = text.split(/\n\n/);
      var tagOpen = openContainer(rootTag, rootAttrs);
      var tagClose = '</' + rootTag + '>';
      var paragraphs = global$6.map(blocks, function (p) {
        return p.split(/\n/).join('<br />');
      });
      var stitch = function (p) {
        return tagOpen + p + tagClose;
      };
      return paragraphs.length === 1 ? paragraphs[0] : global$6.map(paragraphs, stitch).join('');
    };
    var convert = function (text, rootTag, rootAttrs) {
      return rootTag ? toBlockElements(text, rootTag === true ? 'p' : rootTag, rootAttrs) : toBRs(text);
    };

    var global$4 = tinymce.util.Tools.resolve('tinymce.html.DomParser');

    var global$3 = tinymce.util.Tools.resolve('tinymce.html.Serializer');

    var nbsp = '\xA0';

    var global$2 = tinymce.util.Tools.resolve('tinymce.html.Node');

    var global$1 = tinymce.util.Tools.resolve('tinymce.html.Schema');

    var isRegExp = function (val) {
      return val.constructor === RegExp;
    };
    var filter = function (content, items) {
      global$6.each(items, function (v) {
        if (isRegExp(v)) {
          content = content.replace(v, '');
        } else {
          content = content.replace(v[0], v[1]);
        }
      });
      return content;
    };
    var innerText = function (html) {
      var schema = global$1();
      var domParser = global$4({}, schema);
      var text = '';
      var shortEndedElements = schema.getShortEndedElements();
      var ignoreElements = global$6.makeMap('script noscript style textarea video audio iframe object', ' ');
      var blockElements = schema.getBlockElements();
      var walk = function (node) {
        var name = node.name, currentNode = node;
        if (name === 'br') {
          text += '\n';
          return;
        }
        if (name === 'wbr') {
          return;
        }
        if (shortEndedElements[name]) {
          text += ' ';
        }
        if (ignoreElements[name]) {
          text += ' ';
          return;
        }
        if (node.type === 3) {
          text += node.value;
        }
        if (!node.shortEnded) {
          if (node = node.firstChild) {
            do {
              walk(node);
            } while (node = node.next);
          }
        }
        if (blockElements[name] && currentNode.next) {
          text += '\n';
          if (name === 'p') {
            text += '\n';
          }
        }
      };
      html = filter(html, [/<!\[[^\]]+\]>/g]);
      walk(domParser.parse(html));
      return text;
    };
    var trimHtml = function (html) {
      var trimSpaces = function (all, s1, s2) {
        if (!s1 && !s2) {
          return ' ';
        }
        return nbsp;
      };
      html = filter(html, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        /<!--StartFragment-->|<!--EndFragment-->/g,
        [
          /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
          trimSpaces
        ],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
      ]);
      return html;
    };
    var createIdGenerator = function (prefix) {
      var count = 0;
      return function () {
        return prefix + count++;
      };
    };
    var getImageMimeType = function (ext) {
      var lowerExt = ext.toLowerCase();
      var mimeOverrides = {
        jpg: 'jpeg',
        jpe: 'jpeg',
        jfi: 'jpeg',
        jif: 'jpeg',
        jfif: 'jpeg',
        pjpeg: 'jpeg',
        pjp: 'jpeg',
        svg: 'svg+xml'
      };
      return global$6.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;
    };

    var isWordContent = function (content) {
      return /<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^']*\bmso-|w:WordDocument/i.test(content) || /class="OutlineElement/.test(content) || /id="?docs\-internal\-guid\-/.test(content);
    };
    var isNumericList = function (text) {
      var found = false;
      var patterns = [
        /^[IVXLMCD]+\.[ \u00a0]/,
        /^[ivxlmcd]+\.[ \u00a0]/,
        /^[a-z]{1,2}[\.\)][ \u00a0]/,
        /^[A-Z]{1,2}[\.\)][ \u00a0]/,
        /^[0-9]+\.[ \u00a0]/,
        /^[\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d]+\.[ \u00a0]/,
        /^[\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d\u62fe]+\.[ \u00a0]/
      ];
      text = text.replace(/^[\u00a0 ]+/, '');
      global$6.each(patterns, function (pattern) {
        if (pattern.test(text)) {
          found = true;
          return false;
        }
      });
      return found;
    };
    var isBulletList = function (text) {
      return /^[\s\u00a0]*[\u2022\u00b7\u00a7\u25CF]\s*/.test(text);
    };
    var convertFakeListsToProperLists = function (node) {
      var currentListNode, prevListNode, lastLevel = 1;
      var getText = function (node) {
        var txt = '';
        if (node.type === 3) {
          return node.value;
        }
        if (node = node.firstChild) {
          do {
            txt += getText(node);
          } while (node = node.next);
        }
        return txt;
      };
      var trimListStart = function (node, regExp) {
        if (node.type === 3) {
          if (regExp.test(node.value)) {
            node.value = node.value.replace(regExp, '');
            return false;
          }
        }
        if (node = node.firstChild) {
          do {
            if (!trimListStart(node, regExp)) {
              return false;
            }
          } while (node = node.next);
        }
        return true;
      };
      var removeIgnoredNodes = function (node) {
        if (node._listIgnore) {
          node.remove();
          return;
        }
        if (node = node.firstChild) {
          do {
            removeIgnoredNodes(node);
          } while (node = node.next);
        }
      };
      var convertParagraphToLi = function (paragraphNode, listName, start) {
        var level = paragraphNode._listLevel || lastLevel;
        if (level !== lastLevel) {
          if (level < lastLevel) {
            if (currentListNode) {
              currentListNode = currentListNode.parent.parent;
            }
          } else {
            prevListNode = currentListNode;
            currentListNode = null;
          }
        }
        if (!currentListNode || currentListNode.name !== listName) {
          prevListNode = prevListNode || currentListNode;
          currentListNode = new global$2(listName, 1);
          if (start > 1) {
            currentListNode.attr('start', '' + start);
          }
          paragraphNode.wrap(currentListNode);
        } else {
          currentListNode.append(paragraphNode);
        }
        paragraphNode.name = 'li';
        if (level > lastLevel && prevListNode) {
          prevListNode.lastChild.append(currentListNode);
        }
        lastLevel = level;
        removeIgnoredNodes(paragraphNode);
        trimListStart(paragraphNode, /^\u00a0+/);
        trimListStart(paragraphNode, /^\s*([\u2022\u00b7\u00a7\u25CF]|\w+\.)/);
        trimListStart(paragraphNode, /^\u00a0+/);
      };
      var elements = [];
      var child = node.firstChild;
      while (typeof child !== 'undefined' && child !== null) {
        elements.push(child);
        child = child.walk();
        if (child !== null) {
          while (typeof child !== 'undefined' && child.parent !== node) {
            child = child.walk();
          }
        }
      }
      for (var i = 0; i < elements.length; i++) {
        node = elements[i];
        if (node.name === 'p' && node.firstChild) {
          var nodeText = getText(node);
          if (isBulletList(nodeText)) {
            convertParagraphToLi(node, 'ul');
            continue;
          }
          if (isNumericList(nodeText)) {
            var matches = /([0-9]+)\./.exec(nodeText);
            var start = 1;
            if (matches) {
              start = parseInt(matches[1], 10);
            }
            convertParagraphToLi(node, 'ol', start);
            continue;
          }
          if (node._listLevel) {
            convertParagraphToLi(node, 'ul', 1);
            continue;
          }
          currentListNode = null;
        } else {
          prevListNode = currentListNode;
          currentListNode = null;
        }
      }
    };
    var filterStyles = function (editor, validStyles, node, styleValue) {
      var outputStyles = {};
      var styles = editor.dom.parseStyle(styleValue);
      global$6.each(styles, function (value, name) {
        switch (name) {
        case 'mso-list':
          var matches = /\w+ \w+([0-9]+)/i.exec(styleValue);
          if (matches) {
            node._listLevel = parseInt(matches[1], 10);
          }
          if (/Ignore/i.test(value) && node.firstChild) {
            node._listIgnore = true;
            node.firstChild._listIgnore = true;
          }
          break;
        case 'horiz-align':
          name = 'text-align';
          break;
        case 'vert-align':
          name = 'vertical-align';
          break;
        case 'font-color':
        case 'mso-foreground':
          name = 'color';
          break;
        case 'mso-background':
        case 'mso-highlight':
          name = 'background';
          break;
        case 'font-weight':
        case 'font-style':
          if (value !== 'normal') {
            outputStyles[name] = value;
          }
          return;
        case 'mso-element':
          if (/^(comment|comment-list)$/i.test(value)) {
            node.remove();
            return;
          }
          break;
        }
        if (name.indexOf('mso-comment') === 0) {
          node.remove();
          return;
        }
        if (name.indexOf('mso-') === 0) {
          return;
        }
        if (getRetainStyleProps(editor) === 'all' || validStyles && validStyles[name]) {
          outputStyles[name] = value;
        }
      });
      if (/(bold)/i.test(outputStyles['font-weight'])) {
        delete outputStyles['font-weight'];
        node.wrap(new global$2('b', 1));
      }
      if (/(italic)/i.test(outputStyles['font-style'])) {
        delete outputStyles['font-style'];
        node.wrap(new global$2('i', 1));
      }
      var outputStyle = editor.dom.serializeStyle(outputStyles, node.name);
      if (outputStyle) {
        return outputStyle;
      }
      return null;
    };
    var filterWordContent = function (editor, content) {
      var validStyles;
      var retainStyleProperties = getRetainStyleProps(editor);
      if (retainStyleProperties) {
        validStyles = global$6.makeMap(retainStyleProperties.split(/[, ]/));
      }
      content = filter(content, [
        /<br class="?Apple-interchange-newline"?>/gi,
        /<b[^>]+id="?docs-internal-[^>]*>/gi,
        /<!--[\s\S]+?-->/gi,
        /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi,
        [
          /<(\/?)s>/gi,
          '<$1strike>'
        ],
        [
          /&nbsp;/gi,
          nbsp
        ],
        [
          /<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi,
          function (str, spaces) {
            return spaces.length > 0 ? spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join(nbsp) : '';
          }
        ]
      ]);
      var validElements = getWordValidElements(editor);
      var schema = global$1({
        valid_elements: validElements,
        valid_children: '-li[p]'
      });
      global$6.each(schema.elements, function (rule) {
        if (!rule.attributes.class) {
          rule.attributes.class = {};
          rule.attributesOrder.push('class');
        }
        if (!rule.attributes.style) {
          rule.attributes.style = {};
          rule.attributesOrder.push('style');
        }
      });
      var domParser = global$4({}, schema);
      domParser.addAttributeFilter('style', function (nodes) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i];
          node.attr('style', filterStyles(editor, validStyles, node, node.attr('style')));
          if (node.name === 'span' && node.parent && !node.attributes.length) {
            node.unwrap();
          }
        }
      });
      domParser.addAttributeFilter('class', function (nodes) {
        var i = nodes.length, node, className;
        while (i--) {
          node = nodes[i];
          className = node.attr('class');
          if (/^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(className)) {
            node.remove();
          }
          node.attr('class', null);
        }
      });
      domParser.addNodeFilter('del', function (nodes) {
        var i = nodes.length;
        while (i--) {
          nodes[i].remove();
        }
      });
      domParser.addNodeFilter('a', function (nodes) {
        var i = nodes.length, node, href, name;
        while (i--) {
          node = nodes[i];
          href = node.attr('href');
          name = node.attr('name');
          if (href && href.indexOf('#_msocom_') !== -1) {
            node.remove();
            continue;
          }
          if (href && href.indexOf('file://') === 0) {
            href = href.split('#')[1];
            if (href) {
              href = '#' + href;
            }
          }
          if (!href && !name) {
            node.unwrap();
          } else {
            if (name && !/^_?(?:toc|edn|ftn)/i.test(name)) {
              node.unwrap();
              continue;
            }
            node.attr({
              href: href,
              name: name
            });
          }
        }
      });
      var rootNode = domParser.parse(content);
      if (shouldConvertWordFakeLists(editor)) {
        convertFakeListsToProperLists(rootNode);
      }
      content = global$3({ validate: getValidate(editor) }, schema).serialize(rootNode);
      return content;
    };
    var preProcess$1 = function (editor, content) {
      return shouldUseDefaultFilters(editor) ? filterWordContent(editor, content) : content;
    };

    var preProcess = function (editor, html) {
      var parser = global$4({}, editor.schema);
      parser.addNodeFilter('meta', function (nodes) {
        global$6.each(nodes, function (node) {
          node.remove();
        });
      });
      var fragment = parser.parse(html, {
        forced_root_block: false,
        isRootContent: true
      });
      return global$3({ validate: getValidate(editor) }, editor.schema).serialize(fragment);
    };
    var processResult = function (content, cancelled) {
      return {
        content: content,
        cancelled: cancelled
      };
    };
    var postProcessFilter = function (editor, html, internal, isWordHtml) {
      var tempBody = editor.dom.create('div', { style: 'display:none' }, html);
      var postProcessArgs = firePastePostProcess(editor, tempBody, internal, isWordHtml);
      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    var filterContent = function (editor, content, internal, isWordHtml) {
      var preProcessArgs = firePastePreProcess(editor, content, internal, isWordHtml);
      var filteredContent = preProcess(editor, preProcessArgs.content);
      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {
        return postProcessFilter(editor, filteredContent, internal, isWordHtml);
      } else {
        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
      }
    };
    var process = function (editor, html, internal) {
      var isWordHtml = isWordContent(html);
      var content = isWordHtml ? preProcess$1(editor, html) : html;
      return filterContent(editor, content, internal, isWordHtml);
    };

    var pasteHtml$1 = function (editor, html) {
      editor.insertContent(html, {
        merge: shouldMergeFormats(editor),
        paste: true
      });
      return true;
    };
    var isAbsoluteUrl = function (url) {
      return /^https?:\/\/[\w\?\-\/+=.&%@~#]+$/i.test(url);
    };
    var isImageUrl = function (editor, url) {
      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), function (type) {
        return endsWith(url.toLowerCase(), '.' + type.toLowerCase());
      });
    };
    var createImage = function (editor, url, pasteHtmlFn) {
      editor.undoManager.extra(function () {
        pasteHtmlFn(editor, url);
      }, function () {
        editor.insertContent('<img src="' + url + '">');
      });
      return true;
    };
    var createLink = function (editor, url, pasteHtmlFn) {
      editor.undoManager.extra(function () {
        pasteHtmlFn(editor, url);
      }, function () {
        editor.execCommand('mceInsertLink', false, url);
      });
      return true;
    };
    var linkSelection = function (editor, html, pasteHtmlFn) {
      return editor.selection.isCollapsed() === false && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;
    };
    var insertImage = function (editor, html, pasteHtmlFn) {
      return isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
    };
    var smartInsertContent = function (editor, html) {
      global$6.each([
        linkSelection,
        insertImage,
        pasteHtml$1
      ], function (action) {
        return action(editor, html, pasteHtml$1) !== true;
      });
    };
    var insertContent = function (editor, html, pasteAsText) {
      if (pasteAsText || isSmartPasteEnabled(editor) === false) {
        pasteHtml$1(editor, html);
      } else {
        smartInsertContent(editor, html);
      }
    };

    var isCollapsibleWhitespace = function (c) {
      return ' \f\t\x0B'.indexOf(c) !== -1;
    };
    var isNewLineChar = function (c) {
      return c === '\n' || c === '\r';
    };
    var isNewline = function (text, idx) {
      return idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;
    };
    var normalizeWhitespace = function (editor, text) {
      var tabSpace = repeat(' ', getTabSpaces(editor));
      var normalizedText = text.replace(/\t/g, tabSpace);
      var result = foldl(normalizedText, function (acc, c) {
        if (isCollapsibleWhitespace(c) || c === nbsp) {
          if (acc.pcIsSpace || acc.str === '' || acc.str.length === normalizedText.length - 1 || isNewline(normalizedText, acc.str.length + 1)) {
            return {
              pcIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              pcIsSpace: true,
              str: acc.str + ' '
            };
          }
        } else {
          return {
            pcIsSpace: isNewLineChar(c),
            str: acc.str + c
          };
        }
      }, {
        pcIsSpace: false,
        str: ''
      });
      return result.str;
    };

    var doPaste = function (editor, content, internal, pasteAsText) {
      var args = process(editor, content, internal);
      if (args.cancelled === false) {
        insertContent(editor, args.content, pasteAsText);
      }
    };
    var pasteHtml = function (editor, html, internalFlag) {
      var internal = internalFlag ? internalFlag : isMarked(html);
      doPaste(editor, unmark(html), internal, false);
    };
    var pasteText = function (editor, text) {
      var encodedText = editor.dom.encode(text).replace(/\r\n/g, '\n');
      var normalizedText = normalizeWhitespace(editor, encodedText);
      var html = convert(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
      doPaste(editor, html, false, true);
    };
    var getDataTransferItems = function (dataTransfer) {
      var items = {};
      var mceInternalUrlPrefix = 'data:text/mce-internal,';
      if (dataTransfer) {
        if (dataTransfer.getData) {
          var legacyText = dataTransfer.getData('Text');
          if (legacyText && legacyText.length > 0) {
            if (legacyText.indexOf(mceInternalUrlPrefix) === -1) {
              items['text/plain'] = legacyText;
            }
          }
        }
        if (dataTransfer.types) {
          for (var i = 0; i < dataTransfer.types.length; i++) {
            var contentType = dataTransfer.types[i];
            try {
              items[contentType] = dataTransfer.getData(contentType);
            } catch (ex) {
              items[contentType] = '';
            }
          }
        }
      }
      return items;
    };
    var getClipboardContent = function (editor, clipboardEvent) {
      return getDataTransferItems(clipboardEvent.clipboardData || editor.getDoc().dataTransfer);
    };
    var hasContentType = function (clipboardContent, mimeType) {
      return mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    };
    var hasHtmlOrText = function (content) {
      return hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
    };
    var parseDataUri = function (uri) {
      var matches = /data:([^;]+);base64,([a-z0-9\+\/=]+)/i.exec(uri);
      if (matches) {
        return {
          type: matches[1],
          data: decodeURIComponent(matches[2])
        };
      } else {
        return {
          type: null,
          data: null
        };
      }
    };
    var isValidDataUriImage = function (editor, imgElm) {
      var filter = getImagesDataImgFilter(editor);
      return filter ? filter(imgElm) : true;
    };
    var extractFilename = function (editor, str) {
      var m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return isNonNullable(m) ? editor.dom.encode(m[1]) : null;
    };
    var uniqueId = createIdGenerator('mceclip');
    var pasteImage = function (editor, imageItem) {
      var _a = parseDataUri(imageItem.uri), base64 = _a.data, type = _a.type;
      var id = uniqueId();
      var file = imageItem.blob;
      var img = new Image();
      img.src = imageItem.uri;
      if (isValidDataUriImage(editor, img)) {
        var blobCache = editor.editorUpload.blobCache;
        var blobInfo = void 0;
        var existingBlobInfo = blobCache.getByData(base64, type);
        if (!existingBlobInfo) {
          var useFileName = getImagesReuseFilename(editor) && isNonNullable(file.name);
          var name_1 = useFileName ? extractFilename(editor, file.name) : id;
          var filename = useFileName ? file.name : undefined;
          blobInfo = blobCache.create(id, file, base64, name_1, filename);
          blobCache.add(blobInfo);
        } else {
          blobInfo = existingBlobInfo;
        }
        pasteHtml(editor, '<img src="' + blobInfo.blobUri() + '">', false);
      } else {
        pasteHtml(editor, '<img src="' + imageItem.uri + '">', false);
      }
    };
    var isClipboardEvent = function (event) {
      return event.type === 'paste';
    };
    var isDataTransferItem = function (item) {
      return isNonNullable(item.getAsFile);
    };
    var readFilesAsDataUris = function (items) {
      return global$8.all(map(items, function (item) {
        return new global$8(function (resolve) {
          var blob = isDataTransferItem(item) ? item.getAsFile() : item;
          var reader = new window.FileReader();
          reader.onload = function () {
            resolve({
              blob: blob,
              uri: reader.result
            });
          };
          reader.readAsDataURL(blob);
        });
      }));
    };
    var isImage = function (editor) {
      var allowedExtensions = getAllowedImageFileTypes(editor);
      return function (file) {
        return startsWith(file.type, 'image/') && exists(allowedExtensions, function (extension) {
          return getImageMimeType(extension) === file.type;
        });
      };
    };
    var getImagesFromDataTransfer = function (editor, dataTransfer) {
      var items = dataTransfer.items ? bind(from(dataTransfer.items), function (item) {
        return item.kind === 'file' ? [item.getAsFile()] : [];
      }) : [];
      var files = dataTransfer.files ? from(dataTransfer.files) : [];
      return filter$1(items.length > 0 ? items : files, isImage(editor));
    };
    var pasteImageData = function (editor, e, rng) {
      var dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
      if (getPasteDataImages(editor) && dataTransfer) {
        var images = getImagesFromDataTransfer(editor, dataTransfer);
        if (images.length > 0) {
          e.preventDefault();
          readFilesAsDataUris(images).then(function (fileResults) {
            if (rng) {
              editor.selection.setRng(rng);
            }
            each(fileResults, function (result) {
              pasteImage(editor, result);
            });
          });
          return true;
        }
      }
      return false;
    };
    var isBrokenAndroidClipboardEvent = function (e) {
      var clipboardData = e.clipboardData;
      return navigator.userAgent.indexOf('Android') !== -1 && clipboardData && clipboardData.items && clipboardData.items.length === 0;
    };
    var isKeyboardPasteEvent = function (e) {
      return global$7.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;
    };
    var registerEventHandlers = function (editor, pasteBin, pasteFormat) {
      var keyboardPasteEvent = value();
      var keyboardPastePressed = value();
      var keyboardPastePlainTextState;
      editor.on('keyup', keyboardPastePressed.clear);
      editor.on('keydown', function (e) {
        var removePasteBinOnKeyUp = function (e) {
          if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
            pasteBin.remove();
          }
        };
        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
          if (keyboardPastePlainTextState && global$a.webkit && navigator.userAgent.indexOf('Version/') !== -1) {
            return;
          }
          e.stopImmediatePropagation();
          keyboardPasteEvent.set(e);
          keyboardPastePressed.set(true);
          if (global$a.ie && keyboardPastePlainTextState) {
            e.preventDefault();
            firePaste(editor, true);
            return;
          }
          pasteBin.remove();
          pasteBin.create();
          editor.once('keyup', removePasteBinOnKeyUp);
          editor.once('paste', function () {
            editor.off('keyup', removePasteBinOnKeyUp);
          });
        }
      });
      var insertClipboardContent = function (editor, clipboardContent, isKeyBoardPaste, plainTextMode, internal) {
        var content;
        if (hasContentType(clipboardContent, 'text/html')) {
          content = clipboardContent['text/html'];
        } else {
          content = pasteBin.getHtml();
          internal = internal ? internal : isMarked(content);
          if (pasteBin.isDefaultContent(content)) {
            plainTextMode = true;
          }
        }
        content = trimHtml(content);
        pasteBin.remove();
        var isPlainTextHtml = internal === false && isPlainText(content);
        var isAbsoluteUrl$1 = isAbsoluteUrl(content);
        if (!content.length || isPlainTextHtml && !isAbsoluteUrl$1) {
          plainTextMode = true;
        }
        if (plainTextMode || isAbsoluteUrl$1) {
          if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
            content = clipboardContent['text/plain'];
          } else {
            content = innerText(content);
          }
        }
        if (pasteBin.isDefaultContent(content)) {
          if (!isKeyBoardPaste) {
            editor.windowManager.alert('Please use Ctrl+V/Cmd+V keyboard shortcuts to paste contents.');
          }
          return;
        }
        if (plainTextMode) {
          pasteText(editor, content);
        } else {
          pasteHtml(editor, content, internal);
        }
      };
      var getLastRng = function () {
        return pasteBin.getLastRng() || editor.selection.getRng();
      };
      editor.on('paste', function (e) {
        var isKeyboardPaste = keyboardPasteEvent.isSet() || keyboardPastePressed.isSet();
        if (isKeyboardPaste) {
          keyboardPasteEvent.clear();
        }
        var clipboardContent = getClipboardContent(editor, e);
        var plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;
        var internal = hasContentType(clipboardContent, internalHtmlMime());
        keyboardPastePlainTextState = false;
        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
          pasteBin.remove();
          return;
        }
        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
          pasteBin.remove();
          return;
        }
        if (!isKeyboardPaste) {
          e.preventDefault();
        }
        if (global$a.ie && (!isKeyboardPaste || e.ieFake) && !hasContentType(clipboardContent, 'text/html')) {
          pasteBin.create();
          editor.dom.bind(pasteBin.getEl(), 'paste', function (e) {
            e.stopPropagation();
          });
          editor.getDoc().execCommand('Paste', false, null);
          clipboardContent['text/html'] = pasteBin.getHtml();
        }
        if (hasContentType(clipboardContent, 'text/html')) {
          e.preventDefault();
          if (!internal) {
            internal = isMarked(clipboardContent['text/html']);
          }
          insertClipboardContent(editor, clipboardContent, isKeyboardPaste, plainTextMode, internal);
        } else {
          global$9.setEditorTimeout(editor, function () {
            insertClipboardContent(editor, clipboardContent, isKeyboardPaste, plainTextMode, internal);
          }, 0);
        }
      });
    };
    var registerEventsAndFilters = function (editor, pasteBin, pasteFormat) {
      registerEventHandlers(editor, pasteBin, pasteFormat);
      var src;
      editor.parser.addNodeFilter('img', function (nodes, name, args) {
        var isPasteInsert = function (args) {
          return args.data && args.data.paste === true;
        };
        var remove = function (node) {
          if (!node.attr('data-mce-object') && src !== global$a.transparentSrc) {
            node.remove();
          }
        };
        var isWebKitFakeUrl = function (src) {
          return src.indexOf('webkit-fake-url') === 0;
        };
        var isDataUri = function (src) {
          return src.indexOf('data:') === 0;
        };
        if (!getPasteDataImages(editor) && isPasteInsert(args)) {
          var i = nodes.length;
          while (i--) {
            src = nodes[i].attr('src');
            if (!src) {
              continue;
            }
            if (isWebKitFakeUrl(src)) {
              remove(nodes[i]);
            } else if (!getAllowHtmlDataUrls(editor) && isDataUri(src)) {
              remove(nodes[i]);
            }
          }
        }
      });
    };

    var getPasteBinParent = function (editor) {
      return global$a.ie && editor.inline ? document.body : editor.getBody();
    };
    var isExternalPasteBin = function (editor) {
      return getPasteBinParent(editor) !== editor.getBody();
    };
    var delegatePasteEvents = function (editor, pasteBinElm, pasteBinDefaultContent) {
      if (isExternalPasteBin(editor)) {
        editor.dom.bind(pasteBinElm, 'paste keyup', function (_e) {
          if (!isDefault(editor, pasteBinDefaultContent)) {
            editor.fire('paste');
          }
        });
      }
    };
    var create = function (editor, lastRngCell, pasteBinDefaultContent) {
      var dom = editor.dom, body = editor.getBody();
      lastRngCell.set(editor.selection.getRng());
      var pasteBinElm = editor.dom.add(getPasteBinParent(editor), 'div', {
        'id': 'mcepastebin',
        'class': 'mce-pastebin',
        'contentEditable': true,
        'data-mce-bogus': 'all',
        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'
      }, pasteBinDefaultContent);
      if (global$a.ie || global$a.gecko) {
        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);
      }
      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', function (e) {
        e.stopPropagation();
      });
      delegatePasteEvents(editor, pasteBinElm, pasteBinDefaultContent);
      pasteBinElm.focus();
      editor.selection.select(pasteBinElm, true);
    };
    var remove = function (editor, lastRngCell) {
      if (getEl(editor)) {
        var pasteBinClone = void 0;
        var lastRng = lastRngCell.get();
        while (pasteBinClone = editor.dom.get('mcepastebin')) {
          editor.dom.remove(pasteBinClone);
          editor.dom.unbind(pasteBinClone);
        }
        if (lastRng) {
          editor.selection.setRng(lastRng);
        }
      }
      lastRngCell.set(null);
    };
    var getEl = function (editor) {
      return editor.dom.get('mcepastebin');
    };
    var getHtml = function (editor) {
      var copyAndRemove = function (toElm, fromElm) {
        toElm.appendChild(fromElm);
        editor.dom.remove(fromElm, true);
      };
      var pasteBinClones = global$6.grep(getPasteBinParent(editor).childNodes, function (elm) {
        return elm.id === 'mcepastebin';
      });
      var pasteBinElm = pasteBinClones.shift();
      global$6.each(pasteBinClones, function (pasteBinClone) {
        copyAndRemove(pasteBinElm, pasteBinClone);
      });
      var dirtyWrappers = editor.dom.select('div[id=mcepastebin]', pasteBinElm);
      for (var i = dirtyWrappers.length - 1; i >= 0; i--) {
        var cleanWrapper = editor.dom.create('div');
        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
        copyAndRemove(cleanWrapper, dirtyWrappers[i]);
      }
      return pasteBinElm ? pasteBinElm.innerHTML : '';
    };
    var isDefaultContent = function (pasteBinDefaultContent, content) {
      return content === pasteBinDefaultContent;
    };
    var isPasteBin = function (elm) {
      return elm && elm.id === 'mcepastebin';
    };
    var isDefault = function (editor, pasteBinDefaultContent) {
      var pasteBinElm = getEl(editor);
      return isPasteBin(pasteBinElm) && isDefaultContent(pasteBinDefaultContent, pasteBinElm.innerHTML);
    };
    var PasteBin = function (editor) {
      var lastRng = Cell(null);
      var pasteBinDefaultContent = '%MCEPASTEBIN%';
      return {
        create: function () {
          return create(editor, lastRng, pasteBinDefaultContent);
        },
        remove: function () {
          return remove(editor, lastRng);
        },
        getEl: function () {
          return getEl(editor);
        },
        getHtml: function () {
          return getHtml(editor);
        },
        getLastRng: lastRng.get,
        isDefault: function () {
          return isDefault(editor, pasteBinDefaultContent);
        },
        isDefaultContent: function (content) {
          return isDefaultContent(pasteBinDefaultContent, content);
        }
      };
    };

    var Clipboard = function (editor, pasteFormat) {
      var pasteBin = PasteBin(editor);
      editor.on('PreInit', function () {
        return registerEventsAndFilters(editor, pasteBin, pasteFormat);
      });
      return {
        pasteFormat: pasteFormat,
        pasteHtml: function (html, internalFlag) {
          return pasteHtml(editor, html, internalFlag);
        },
        pasteText: function (text) {
          return pasteText(editor, text);
        },
        pasteImageData: function (e, rng) {
          return pasteImageData(editor, e, rng);
        },
        getDataTransferItems: getDataTransferItems,
        hasHtmlOrText: hasHtmlOrText,
        hasContentType: hasContentType
      };
    };

    var togglePlainTextPaste = function (editor, clipboard) {
      if (clipboard.pasteFormat.get() === 'text') {
        clipboard.pasteFormat.set('html');
        firePastePlainTextToggle(editor, false);
      } else {
        clipboard.pasteFormat.set('text');
        firePastePlainTextToggle(editor, true);
      }
      editor.focus();
    };

    var register$2 = function (editor, clipboard) {
      editor.addCommand('mceTogglePlainTextPaste', function () {
        togglePlainTextPaste(editor, clipboard);
      });
      editor.addCommand('mceInsertClipboardContent', function (ui, value) {
        if (value.content) {
          clipboard.pasteHtml(value.content, value.internal);
        }
        if (value.text) {
          clipboard.pasteText(value.text);
        }
      });
    };

    var hasWorkingClipboardApi = function (clipboardData) {
      return global$a.iOS === false && typeof (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.setData) === 'function';
    };
    var setHtml5Clipboard = function (clipboardData, html, text) {
      if (hasWorkingClipboardApi(clipboardData)) {
        try {
          clipboardData.clearData();
          clipboardData.setData('text/html', html);
          clipboardData.setData('text/plain', text);
          clipboardData.setData(internalHtmlMime(), html);
          return true;
        } catch (e) {
          return false;
        }
      } else {
        return false;
      }
    };
    var setClipboardData = function (evt, data, fallback, done) {
      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
        evt.preventDefault();
        done();
      } else {
        fallback(data.html, done);
      }
    };
    var fallback = function (editor) {
      return function (html, done) {
        var markedHtml = mark(html);
        var outer = editor.dom.create('div', {
          'contenteditable': 'false',
          'data-mce-bogus': 'all'
        });
        var inner = editor.dom.create('div', { contenteditable: 'true' }, markedHtml);
        editor.dom.setStyles(outer, {
          position: 'fixed',
          top: '0',
          left: '-3000px',
          width: '1000px',
          overflow: 'hidden'
        });
        outer.appendChild(inner);
        editor.dom.add(editor.getBody(), outer);
        var range = editor.selection.getRng();
        inner.focus();
        var offscreenRange = editor.dom.createRng();
        offscreenRange.selectNodeContents(inner);
        editor.selection.setRng(offscreenRange);
        global$9.setTimeout(function () {
          editor.selection.setRng(range);
          outer.parentNode.removeChild(outer);
          done();
        }, 0);
      };
    };
    var getData = function (editor) {
      return {
        html: editor.selection.getContent({ contextual: true }),
        text: editor.selection.getContent({ format: 'text' })
      };
    };
    var isTableSelection = function (editor) {
      return !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());
    };
    var hasSelectedContent = function (editor) {
      return !editor.selection.isCollapsed() || isTableSelection(editor);
    };
    var cut = function (editor) {
      return function (evt) {
        if (hasSelectedContent(editor)) {
          setClipboardData(evt, getData(editor), fallback(editor), function () {
            if (global$a.browser.isChrome() || global$a.browser.isFirefox()) {
              var rng_1 = editor.selection.getRng();
              global$9.setEditorTimeout(editor, function () {
                editor.selection.setRng(rng_1);
                editor.execCommand('Delete');
              }, 0);
            } else {
              editor.execCommand('Delete');
            }
          });
        }
      };
    };
    var copy = function (editor) {
      return function (evt) {
        if (hasSelectedContent(editor)) {
          setClipboardData(evt, getData(editor), fallback(editor), noop);
        }
      };
    };
    var register$1 = function (editor) {
      editor.on('cut', cut(editor));
      editor.on('copy', copy(editor));
    };

    var global = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');

    var getCaretRangeFromEvent = function (editor, e) {
      return global.getCaretRangeFromPoint(e.clientX, e.clientY, editor.getDoc());
    };
    var isPlainTextFileUrl = function (content) {
      var plainTextContent = content['text/plain'];
      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
    };
    var setFocusedRange = function (editor, rng) {
      editor.focus();
      editor.selection.setRng(rng);
    };
    var setup$2 = function (editor, clipboard, draggingInternallyState) {
      if (shouldBlockDrop(editor)) {
        editor.on('dragend dragover draggesture dragdrop drop drag', function (e) {
          e.preventDefault();
          e.stopPropagation();
        });
      }
      if (!shouldPasteDataImages(editor)) {
        editor.on('drop', function (e) {
          var dataTransfer = e.dataTransfer;
          if (dataTransfer && dataTransfer.files && dataTransfer.files.length > 0) {
            e.preventDefault();
          }
        });
      }
      editor.on('drop', function (e) {
        var rng = getCaretRangeFromEvent(editor, e);
        if (e.isDefaultPrevented() || draggingInternallyState.get()) {
          return;
        }
        var dropContent = clipboard.getDataTransferItems(e.dataTransfer);
        var internal = clipboard.hasContentType(dropContent, internalHtmlMime());
        if ((!clipboard.hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && clipboard.pasteImageData(e, rng)) {
          return;
        }
        if (rng && shouldFilterDrop(editor)) {
          var content_1 = dropContent['mce-internal'] || dropContent['text/html'] || dropContent['text/plain'];
          if (content_1) {
            e.preventDefault();
            global$9.setEditorTimeout(editor, function () {
              editor.undoManager.transact(function () {
                if (dropContent['mce-internal']) {
                  editor.execCommand('Delete');
                }
                setFocusedRange(editor, rng);
                content_1 = trimHtml(content_1);
                if (!dropContent['text/html']) {
                  clipboard.pasteText(content_1);
                } else {
                  clipboard.pasteHtml(content_1, internal);
                }
              });
            });
          }
        }
      });
      editor.on('dragstart', function (_e) {
        draggingInternallyState.set(true);
      });
      editor.on('dragover dragend', function (e) {
        if (shouldPasteDataImages(editor) && draggingInternallyState.get() === false) {
          e.preventDefault();
          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
        }
        if (e.type === 'dragend') {
          draggingInternallyState.set(false);
        }
      });
    };

    var setup$1 = function (editor) {
      var plugin = editor.plugins.paste;
      var preProcess = getPreProcess(editor);
      if (preProcess) {
        editor.on('PastePreProcess', function (e) {
          preProcess.call(plugin, plugin, e);
        });
      }
      var postProcess = getPostProcess(editor);
      if (postProcess) {
        editor.on('PastePostProcess', function (e) {
          postProcess.call(plugin, plugin, e);
        });
      }
    };

    var addPreProcessFilter = function (editor, filterFunc) {
      editor.on('PastePreProcess', function (e) {
        e.content = filterFunc(editor, e.content, e.internal, e.wordContent);
      });
    };
    var addPostProcessFilter = function (editor, filterFunc) {
      editor.on('PastePostProcess', function (e) {
        filterFunc(editor, e.node);
      });
    };
    var removeExplorerBrElementsAfterBlocks = function (editor, html) {
      if (!isWordContent(html)) {
        return html;
      }
      var blockElements = [];
      global$6.each(editor.schema.getBlockElements(), function (block, blockName) {
        blockElements.push(blockName);
      });
      var explorerBlocksRegExp = new RegExp('(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(' + blockElements.join('|') + ')[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*', 'g');
      html = filter(html, [[
          explorerBlocksRegExp,
          '$1'
        ]]);
      html = filter(html, [
        [
          /<br><br>/g,
          '<BR><BR>'
        ],
        [
          /<br>/g,
          ' '
        ],
        [
          /<BR><BR>/g,
          '<br>'
        ]
      ]);
      return html;
    };
    var removeWebKitStyles = function (editor, content, internal, isWordHtml) {
      if (isWordHtml || internal) {
        return content;
      }
      var webKitStylesSetting = getWebkitStyles(editor);
      var webKitStyles;
      if (shouldRemoveWebKitStyles(editor) === false || webKitStylesSetting === 'all') {
        return content;
      }
      if (webKitStylesSetting) {
        webKitStyles = webKitStylesSetting.split(/[, ]/);
      }
      if (webKitStyles) {
        var dom_1 = editor.dom, node_1 = editor.selection.getNode();
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, function (all, before, value, after) {
          var inputStyles = dom_1.parseStyle(dom_1.decode(value));
          var outputStyles = {};
          if (webKitStyles === 'none') {
            return before + after;
          }
          for (var i = 0; i < webKitStyles.length; i++) {
            var inputValue = inputStyles[webKitStyles[i]], currentValue = dom_1.getStyle(node_1, webKitStyles[i], true);
            if (/color/.test(webKitStyles[i])) {
              inputValue = dom_1.toHex(inputValue);
              currentValue = dom_1.toHex(currentValue);
            }
            if (currentValue !== inputValue) {
              outputStyles[webKitStyles[i]] = inputValue;
            }
          }
          var outputStyle = dom_1.serializeStyle(outputStyles, 'span');
          if (outputStyle) {
            return before + ' style="' + outputStyle + '"' + after;
          }
          return before + after;
        });
      } else {
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
      }
      content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, function (all, before, value, after) {
        return before + ' style="' + value + '"' + after;
      });
      return content;
    };
    var removeUnderlineAndFontInAnchor = function (editor, root) {
      editor.$('a', root).find('font,u').each(function (i, node) {
        editor.dom.remove(node, true);
      });
    };
    var setup = function (editor) {
      if (global$a.webkit) {
        addPreProcessFilter(editor, removeWebKitStyles);
      }
      if (global$a.ie) {
        addPreProcessFilter(editor, removeExplorerBrElementsAfterBlocks);
        addPostProcessFilter(editor, removeUnderlineAndFontInAnchor);
      }
    };

    var makeSetupHandler = function (editor, clipboard) {
      return function (api) {
        api.setActive(clipboard.pasteFormat.get() === 'text');
        var pastePlainTextToggleHandler = function (e) {
          return api.setActive(e.state);
        };
        editor.on('PastePlainTextToggle', pastePlainTextToggleHandler);
        return function () {
          return editor.off('PastePlainTextToggle', pastePlainTextToggleHandler);
        };
      };
    };
    var register = function (editor, clipboard) {
      var onAction = function () {
        return editor.execCommand('mceTogglePlainTextPaste');
      };
      editor.ui.registry.addToggleButton('pastetext', {
        active: false,
        icon: 'paste-text',
        tooltip: 'Paste as text',
        onAction: onAction,
        onSetup: makeSetupHandler(editor, clipboard)
      });
      editor.ui.registry.addToggleMenuItem('pastetext', {
        text: 'Paste as text',
        icon: 'paste-text',
        onAction: onAction,
        onSetup: makeSetupHandler(editor, clipboard)
      });
    };

    function Plugin () {
      global$b.add('paste', function (editor) {
        if (hasProPlugin(editor) === false) {
          var draggingInternallyState = Cell(false);
          var pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');
          var clipboard = Clipboard(editor, pasteFormat);
          setup(editor);
          register(editor, clipboard);
          register$2(editor, clipboard);
          setup$1(editor);
          register$1(editor);
          setup$2(editor, clipboard, draggingInternallyState);
          return get(clipboard);
        }
      });
    }

    Plugin();

}());


/***/ }),

/***/ "1ac6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1d9e":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var getDateFormat = function (editor) {
      return editor.getParam('insertdatetime_dateformat', editor.translate('%Y-%m-%d'));
    };
    var getTimeFormat = function (editor) {
      return editor.getParam('insertdatetime_timeformat', editor.translate('%H:%M:%S'));
    };
    var getFormats = function (editor) {
      return editor.getParam('insertdatetime_formats', [
        '%H:%M:%S',
        '%Y-%m-%d',
        '%I:%M:%S %p',
        '%D'
      ]);
    };
    var getDefaultDateTime = function (editor) {
      var formats = getFormats(editor);
      return formats.length > 0 ? formats[0] : getTimeFormat(editor);
    };
    var shouldInsertTimeElement = function (editor) {
      return editor.getParam('insertdatetime_element', false);
    };

    var daysShort = 'Sun Mon Tue Wed Thu Fri Sat Sun'.split(' ');
    var daysLong = 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday'.split(' ');
    var monthsShort = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' ');
    var monthsLong = 'January February March April May June July August September October November December'.split(' ');
    var addZeros = function (value, len) {
      value = '' + value;
      if (value.length < len) {
        for (var i = 0; i < len - value.length; i++) {
          value = '0' + value;
        }
      }
      return value;
    };
    var getDateTime = function (editor, fmt, date) {
      if (date === void 0) {
        date = new Date();
      }
      fmt = fmt.replace('%D', '%m/%d/%Y');
      fmt = fmt.replace('%r', '%I:%M:%S %p');
      fmt = fmt.replace('%Y', '' + date.getFullYear());
      fmt = fmt.replace('%y', '' + date.getYear());
      fmt = fmt.replace('%m', addZeros(date.getMonth() + 1, 2));
      fmt = fmt.replace('%d', addZeros(date.getDate(), 2));
      fmt = fmt.replace('%H', '' + addZeros(date.getHours(), 2));
      fmt = fmt.replace('%M', '' + addZeros(date.getMinutes(), 2));
      fmt = fmt.replace('%S', '' + addZeros(date.getSeconds(), 2));
      fmt = fmt.replace('%I', '' + ((date.getHours() + 11) % 12 + 1));
      fmt = fmt.replace('%p', '' + (date.getHours() < 12 ? 'AM' : 'PM'));
      fmt = fmt.replace('%B', '' + editor.translate(monthsLong[date.getMonth()]));
      fmt = fmt.replace('%b', '' + editor.translate(monthsShort[date.getMonth()]));
      fmt = fmt.replace('%A', '' + editor.translate(daysLong[date.getDay()]));
      fmt = fmt.replace('%a', '' + editor.translate(daysShort[date.getDay()]));
      fmt = fmt.replace('%%', '%');
      return fmt;
    };
    var updateElement = function (editor, timeElm, computerTime, userTime) {
      var newTimeElm = editor.dom.create('time', { datetime: computerTime }, userTime);
      timeElm.parentNode.insertBefore(newTimeElm, timeElm);
      editor.dom.remove(timeElm);
      editor.selection.select(newTimeElm, true);
      editor.selection.collapse(false);
    };
    var insertDateTime = function (editor, format) {
      if (shouldInsertTimeElement(editor)) {
        var userTime = getDateTime(editor, format);
        var computerTime = void 0;
        if (/%[HMSIp]/.test(format)) {
          computerTime = getDateTime(editor, '%Y-%m-%dT%H:%M');
        } else {
          computerTime = getDateTime(editor, '%Y-%m-%d');
        }
        var timeElm = editor.dom.getParent(editor.selection.getStart(), 'time');
        if (timeElm) {
          updateElement(editor, timeElm, computerTime, userTime);
        } else {
          editor.insertContent('<time datetime="' + computerTime + '">' + userTime + '</time>');
        }
      } else {
        editor.insertContent(getDateTime(editor, format));
      }
    };

    var register$1 = function (editor) {
      editor.addCommand('mceInsertDate', function (_ui, value) {
        insertDateTime(editor, value !== null && value !== void 0 ? value : getDateFormat(editor));
      });
      editor.addCommand('mceInsertTime', function (_ui, value) {
        insertDateTime(editor, value !== null && value !== void 0 ? value : getTimeFormat(editor));
      });
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var register = function (editor) {
      var formats = getFormats(editor);
      var defaultFormat = Cell(getDefaultDateTime(editor));
      var insertDateTime = function (format) {
        return editor.execCommand('mceInsertDate', false, format);
      };
      editor.ui.registry.addSplitButton('insertdatetime', {
        icon: 'insert-time',
        tooltip: 'Insert date/time',
        select: function (value) {
          return value === defaultFormat.get();
        },
        fetch: function (done) {
          done(global.map(formats, function (format) {
            return {
              type: 'choiceitem',
              text: getDateTime(editor, format),
              value: format
            };
          }));
        },
        onAction: function (_api) {
          insertDateTime(defaultFormat.get());
        },
        onItemAction: function (_api, value) {
          defaultFormat.set(value);
          insertDateTime(value);
        }
      });
      var makeMenuItemHandler = function (format) {
        return function () {
          defaultFormat.set(format);
          insertDateTime(format);
        };
      };
      editor.ui.registry.addNestedMenuItem('insertdatetime', {
        icon: 'insert-time',
        text: 'Date/time',
        getSubmenuItems: function () {
          return global.map(formats, function (format) {
            return {
              type: 'menuitem',
              text: getDateTime(editor, format),
              onAction: makeMenuItemHandler(format)
            };
          });
        }
      });
    };

    function Plugin () {
      global$1.add('insertdatetime', function (editor) {
        register$1(editor);
        register(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "209c4":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var global$6 = tinymce.util.Tools.resolve('tinymce.util.VK');

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString = isType('string');
    var isArray = isType('array');
    var isNull = eq(null);
    var isBoolean = isSimpleType('boolean');
    var isFunction = isSimpleType('function');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var tripleEquals = function (a, b) {
      return a === b;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var contains = function (xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var foldl = function (xs, f, acc) {
      each$1(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var is = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lhs.exists(function (left) {
        return comparator(left, rhs);
      });
    };
    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    var someIf = function (b, a) {
      return b ? Optional.some(a) : Optional.none();
    };

    var assumeExternalTargets = function (editor) {
      var externalTargets = editor.getParam('link_assume_external_targets', false);
      if (isBoolean(externalTargets) && externalTargets) {
        return 1;
      } else if (isString(externalTargets) && (externalTargets === 'http' || externalTargets === 'https')) {
        return externalTargets;
      }
      return 0;
    };
    var hasContextToolbar = function (editor) {
      return editor.getParam('link_context_toolbar', false, 'boolean');
    };
    var getLinkList = function (editor) {
      return editor.getParam('link_list');
    };
    var getDefaultLinkTarget = function (editor) {
      return editor.getParam('default_link_target');
    };
    var getTargetList = function (editor) {
      return editor.getParam('target_list', true);
    };
    var getRelList = function (editor) {
      return editor.getParam('rel_list', [], 'array');
    };
    var getLinkClassList = function (editor) {
      return editor.getParam('link_class_list', [], 'array');
    };
    var shouldShowLinkTitle = function (editor) {
      return editor.getParam('link_title', true, 'boolean');
    };
    var allowUnsafeLinkTarget = function (editor) {
      return editor.getParam('allow_unsafe_link_target', false, 'boolean');
    };
    var useQuickLink = function (editor) {
      return editor.getParam('link_quicklink', false, 'boolean');
    };
    var getDefaultLinkProtocol = function (editor) {
      return editor.getParam('link_default_protocol', 'http', 'string');
    };

    var global$5 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getValue = function (item) {
      return isString(item.value) ? item.value : '';
    };
    var getText = function (item) {
      if (isString(item.text)) {
        return item.text;
      } else if (isString(item.title)) {
        return item.title;
      } else {
        return '';
      }
    };
    var sanitizeList = function (list, extractValue) {
      var out = [];
      global$5.each(list, function (item) {
        var text = getText(item);
        if (item.menu !== undefined) {
          var items = sanitizeList(item.menu, extractValue);
          out.push({
            text: text,
            items: items
          });
        } else {
          var value = extractValue(item);
          out.push({
            text: text,
            value: value
          });
        }
      });
      return out;
    };
    var sanitizeWith = function (extracter) {
      if (extracter === void 0) {
        extracter = getValue;
      }
      return function (list) {
        return Optional.from(list).map(function (list) {
          return sanitizeList(list, extracter);
        });
      };
    };
    var sanitize = function (list) {
      return sanitizeWith(getValue)(list);
    };
    var createUi = function (name, label) {
      return function (items) {
        return {
          name: name,
          type: 'listbox',
          label: label,
          items: items
        };
      };
    };
    var ListOptions = {
      sanitize: sanitize,
      sanitizeWith: sanitizeWith,
      createUi: createUi,
      getValue: getValue
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };

    var global$4 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');

    var global$3 = tinymce.util.Tools.resolve('tinymce.util.URI');

    var isAnchor = function (elm) {
      return elm && elm.nodeName.toLowerCase() === 'a';
    };
    var isLink = function (elm) {
      return isAnchor(elm) && !!getHref(elm);
    };
    var collectNodesInRange = function (rng, predicate) {
      if (rng.collapsed) {
        return [];
      } else {
        var contents = rng.cloneContents();
        var walker = new global$4(contents.firstChild, contents);
        var elements = [];
        var current = contents.firstChild;
        do {
          if (predicate(current)) {
            elements.push(current);
          }
        } while (current = walker.next());
        return elements;
      }
    };
    var hasProtocol = function (url) {
      return /^\w+:/i.test(url);
    };
    var getHref = function (elm) {
      var href = elm.getAttribute('data-mce-href');
      return href ? href : elm.getAttribute('href');
    };
    var applyRelTargetRules = function (rel, isUnsafe) {
      var rules = ['noopener'];
      var rels = rel ? rel.split(/\s+/) : [];
      var toString = function (rels) {
        return global$5.trim(rels.sort().join(' '));
      };
      var addTargetRules = function (rels) {
        rels = removeTargetRules(rels);
        return rels.length > 0 ? rels.concat(rules) : rules;
      };
      var removeTargetRules = function (rels) {
        return rels.filter(function (val) {
          return global$5.inArray(rules, val) === -1;
        });
      };
      var newRels = isUnsafe ? addTargetRules(rels) : removeTargetRules(rels);
      return newRels.length > 0 ? toString(newRels) : '';
    };
    var trimCaretContainers = function (text) {
      return text.replace(/\uFEFF/g, '');
    };
    var getAnchorElement = function (editor, selectedElm) {
      selectedElm = selectedElm || editor.selection.getNode();
      if (isImageFigure(selectedElm)) {
        return editor.dom.select('a[href]', selectedElm)[0];
      } else {
        return editor.dom.getParent(selectedElm, 'a[href]');
      }
    };
    var getAnchorText = function (selection, anchorElm) {
      var text = anchorElm ? anchorElm.innerText || anchorElm.textContent : selection.getContent({ format: 'text' });
      return trimCaretContainers(text);
    };
    var hasLinks = function (elements) {
      return global$5.grep(elements, isLink).length > 0;
    };
    var hasLinksInSelection = function (rng) {
      return collectNodesInRange(rng, isLink).length > 0;
    };
    var isOnlyTextSelected = function (editor) {
      var inlineTextElements = editor.schema.getTextInlineElements();
      var isElement = function (elm) {
        return elm.nodeType === 1 && !isAnchor(elm) && !has(inlineTextElements, elm.nodeName.toLowerCase());
      };
      var elements = collectNodesInRange(editor.selection.getRng(), isElement);
      return elements.length === 0;
    };
    var isImageFigure = function (elm) {
      return elm && elm.nodeName === 'FIGURE' && /\bimage\b/i.test(elm.className);
    };
    var getLinkAttrs = function (data) {
      var attrs = [
        'title',
        'rel',
        'class',
        'target'
      ];
      return foldl(attrs, function (acc, key) {
        data[key].each(function (value) {
          acc[key] = value.length > 0 ? value : null;
        });
        return acc;
      }, { href: data.href });
    };
    var handleExternalTargets = function (href, assumeExternalTargets) {
      if ((assumeExternalTargets === 'http' || assumeExternalTargets === 'https') && !hasProtocol(href)) {
        return assumeExternalTargets + '://' + href;
      }
      return href;
    };
    var applyLinkOverrides = function (editor, linkAttrs) {
      var newLinkAttrs = __assign({}, linkAttrs);
      if (!(getRelList(editor).length > 0) && allowUnsafeLinkTarget(editor) === false) {
        var newRel = applyRelTargetRules(newLinkAttrs.rel, newLinkAttrs.target === '_blank');
        newLinkAttrs.rel = newRel ? newRel : null;
      }
      if (Optional.from(newLinkAttrs.target).isNone() && getTargetList(editor) === false) {
        newLinkAttrs.target = getDefaultLinkTarget(editor);
      }
      newLinkAttrs.href = handleExternalTargets(newLinkAttrs.href, assumeExternalTargets(editor));
      return newLinkAttrs;
    };
    var updateLink = function (editor, anchorElm, text, linkAttrs) {
      text.each(function (text) {
        if (has(anchorElm, 'innerText')) {
          anchorElm.innerText = text;
        } else {
          anchorElm.textContent = text;
        }
      });
      editor.dom.setAttribs(anchorElm, linkAttrs);
      editor.selection.select(anchorElm);
    };
    var createLink = function (editor, selectedElm, text, linkAttrs) {
      if (isImageFigure(selectedElm)) {
        linkImageFigure(editor, selectedElm, linkAttrs);
      } else {
        text.fold(function () {
          editor.execCommand('mceInsertLink', false, linkAttrs);
        }, function (text) {
          editor.insertContent(editor.dom.createHTML('a', linkAttrs, editor.dom.encode(text)));
        });
      }
    };
    var linkDomMutation = function (editor, attachState, data) {
      var selectedElm = editor.selection.getNode();
      var anchorElm = getAnchorElement(editor, selectedElm);
      var linkAttrs = applyLinkOverrides(editor, getLinkAttrs(data));
      editor.undoManager.transact(function () {
        if (data.href === attachState.href) {
          attachState.attach();
        }
        if (anchorElm) {
          editor.focus();
          updateLink(editor, anchorElm, data.text, linkAttrs);
        } else {
          createLink(editor, selectedElm, data.text, linkAttrs);
        }
      });
    };
    var unlinkSelection = function (editor) {
      var dom = editor.dom, selection = editor.selection;
      var bookmark = selection.getBookmark();
      var rng = selection.getRng().cloneRange();
      var startAnchorElm = dom.getParent(rng.startContainer, 'a[href]', editor.getBody());
      var endAnchorElm = dom.getParent(rng.endContainer, 'a[href]', editor.getBody());
      if (startAnchorElm) {
        rng.setStartBefore(startAnchorElm);
      }
      if (endAnchorElm) {
        rng.setEndAfter(endAnchorElm);
      }
      selection.setRng(rng);
      editor.execCommand('unlink');
      selection.moveToBookmark(bookmark);
    };
    var unlinkDomMutation = function (editor) {
      editor.undoManager.transact(function () {
        var node = editor.selection.getNode();
        if (isImageFigure(node)) {
          unlinkImageFigure(editor, node);
        } else {
          unlinkSelection(editor);
        }
        editor.focus();
      });
    };
    var unwrapOptions = function (data) {
      var cls = data.class, href = data.href, rel = data.rel, target = data.target, text = data.text, title = data.title;
      return filter({
        class: cls.getOrNull(),
        href: href,
        rel: rel.getOrNull(),
        target: target.getOrNull(),
        text: text.getOrNull(),
        title: title.getOrNull()
      }, function (v, _k) {
        return isNull(v) === false;
      });
    };
    var sanitizeData = function (editor, data) {
      var href = data.href;
      return __assign(__assign({}, data), { href: global$3.isDomSafe(href, 'a', editor.settings) ? href : '' });
    };
    var link = function (editor, attachState, data) {
      var sanitizedData = sanitizeData(editor, data);
      editor.hasPlugin('rtc', true) ? editor.execCommand('createlink', false, unwrapOptions(sanitizedData)) : linkDomMutation(editor, attachState, sanitizedData);
    };
    var unlink = function (editor) {
      editor.hasPlugin('rtc', true) ? editor.execCommand('unlink') : unlinkDomMutation(editor);
    };
    var unlinkImageFigure = function (editor, fig) {
      var img = editor.dom.select('img', fig)[0];
      if (img) {
        var a = editor.dom.getParents(img, 'a[href]', fig)[0];
        if (a) {
          a.parentNode.insertBefore(img, a);
          editor.dom.remove(a);
        }
      }
    };
    var linkImageFigure = function (editor, fig, attrs) {
      var img = editor.dom.select('img', fig)[0];
      if (img) {
        var a = editor.dom.create('a', attrs);
        img.parentNode.insertBefore(a, img);
        a.appendChild(img);
      }
    };

    var isListGroup = function (item) {
      return hasNonNullableKey(item, 'items');
    };
    var findTextByValue = function (value, catalog) {
      return findMap(catalog, function (item) {
        if (isListGroup(item)) {
          return findTextByValue(value, item.items);
        } else {
          return someIf(item.value === value, item);
        }
      });
    };
    var getDelta = function (persistentText, fieldName, catalog, data) {
      var value = data[fieldName];
      var hasPersistentText = persistentText.length > 0;
      return value !== undefined ? findTextByValue(value, catalog).map(function (i) {
        return {
          url: {
            value: i.value,
            meta: {
              text: hasPersistentText ? persistentText : i.text,
              attach: noop
            }
          },
          text: hasPersistentText ? persistentText : i.text
        };
      }) : Optional.none();
    };
    var findCatalog = function (catalogs, fieldName) {
      if (fieldName === 'link') {
        return catalogs.link;
      } else if (fieldName === 'anchor') {
        return catalogs.anchor;
      } else {
        return Optional.none();
      }
    };
    var init = function (initialData, linkCatalog) {
      var persistentData = {
        text: initialData.text,
        title: initialData.title
      };
      var getTitleFromUrlChange = function (url) {
        return someIf(persistentData.title.length <= 0, Optional.from(url.meta.title).getOr(''));
      };
      var getTextFromUrlChange = function (url) {
        return someIf(persistentData.text.length <= 0, Optional.from(url.meta.text).getOr(url.value));
      };
      var onUrlChange = function (data) {
        var text = getTextFromUrlChange(data.url);
        var title = getTitleFromUrlChange(data.url);
        if (text.isSome() || title.isSome()) {
          return Optional.some(__assign(__assign({}, text.map(function (text) {
            return { text: text };
          }).getOr({})), title.map(function (title) {
            return { title: title };
          }).getOr({})));
        } else {
          return Optional.none();
        }
      };
      var onCatalogChange = function (data, change) {
        var catalog = findCatalog(linkCatalog, change.name).getOr([]);
        return getDelta(persistentData.text, change.name, catalog, data);
      };
      var onChange = function (getData, change) {
        var name = change.name;
        if (name === 'url') {
          return onUrlChange(getData());
        } else if (contains([
            'anchor',
            'link'
          ], name)) {
          return onCatalogChange(getData(), change);
        } else if (name === 'text' || name === 'title') {
          persistentData[name] = getData()[name];
          return Optional.none();
        } else {
          return Optional.none();
        }
      };
      return { onChange: onChange };
    };
    var DialogChanges = {
      init: init,
      getDelta: getDelta
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var delayedConfirm = function (editor, message, callback) {
      var rng = editor.selection.getRng();
      global$2.setEditorTimeout(editor, function () {
        editor.windowManager.confirm(message, function (state) {
          editor.selection.setRng(rng);
          callback(state);
        });
      });
    };
    var tryEmailTransform = function (data) {
      var url = data.href;
      var suggestMailTo = url.indexOf('@') > 0 && url.indexOf('/') === -1 && url.indexOf('mailto:') === -1;
      return suggestMailTo ? Optional.some({
        message: 'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?',
        preprocess: function (oldData) {
          return __assign(__assign({}, oldData), { href: 'mailto:' + url });
        }
      }) : Optional.none();
    };
    var tryProtocolTransform = function (assumeExternalTargets, defaultLinkProtocol) {
      return function (data) {
        var url = data.href;
        var suggestProtocol = assumeExternalTargets === 1 && !hasProtocol(url) || assumeExternalTargets === 0 && /^\s*www(\.|\d\.)/i.test(url);
        return suggestProtocol ? Optional.some({
          message: 'The URL you entered seems to be an external link. Do you want to add the required ' + defaultLinkProtocol + ':// prefix?',
          preprocess: function (oldData) {
            return __assign(__assign({}, oldData), { href: defaultLinkProtocol + '://' + url });
          }
        }) : Optional.none();
      };
    };
    var preprocess = function (editor, data) {
      return findMap([
        tryEmailTransform,
        tryProtocolTransform(assumeExternalTargets(editor), getDefaultLinkProtocol(editor))
      ], function (f) {
        return f(data);
      }).fold(function () {
        return global$1.resolve(data);
      }, function (transform) {
        return new global$1(function (callback) {
          delayedConfirm(editor, transform.message, function (state) {
            callback(state ? transform.preprocess(data) : data);
          });
        });
      });
    };
    var DialogConfirms = { preprocess: preprocess };

    var getAnchors = function (editor) {
      var anchorNodes = editor.dom.select('a:not([href])');
      var anchors = bind(anchorNodes, function (anchor) {
        var id = anchor.name || anchor.id;
        return id ? [{
            text: id,
            value: '#' + id
          }] : [];
      });
      return anchors.length > 0 ? Optional.some([{
          text: 'None',
          value: ''
        }].concat(anchors)) : Optional.none();
    };
    var AnchorListOptions = { getAnchors: getAnchors };

    var getClasses = function (editor) {
      var list = getLinkClassList(editor);
      if (list.length > 0) {
        return ListOptions.sanitize(list);
      }
      return Optional.none();
    };
    var ClassListOptions = { getClasses: getClasses };

    var global = tinymce.util.Tools.resolve('tinymce.util.XHR');

    var parseJson = function (text) {
      try {
        return Optional.some(JSON.parse(text));
      } catch (err) {
        return Optional.none();
      }
    };
    var getLinks = function (editor) {
      var extractor = function (item) {
        return editor.convertURL(item.value || item.url, 'href');
      };
      var linkList = getLinkList(editor);
      return new global$1(function (callback) {
        if (isString(linkList)) {
          global.send({
            url: linkList,
            success: function (text) {
              return callback(parseJson(text));
            },
            error: function (_) {
              return callback(Optional.none());
            }
          });
        } else if (isFunction(linkList)) {
          linkList(function (output) {
            return callback(Optional.some(output));
          });
        } else {
          callback(Optional.from(linkList));
        }
      }).then(function (optItems) {
        return optItems.bind(ListOptions.sanitizeWith(extractor)).map(function (items) {
          if (items.length > 0) {
            var noneItem = [{
                text: 'None',
                value: ''
              }];
            return noneItem.concat(items);
          } else {
            return items;
          }
        });
      });
    };
    var LinkListOptions = { getLinks: getLinks };

    var getRels = function (editor, initialTarget) {
      var list = getRelList(editor);
      if (list.length > 0) {
        var isTargetBlank_1 = is(initialTarget, '_blank');
        var enforceSafe = allowUnsafeLinkTarget(editor) === false;
        var safeRelExtractor = function (item) {
          return applyRelTargetRules(ListOptions.getValue(item), isTargetBlank_1);
        };
        var sanitizer = enforceSafe ? ListOptions.sanitizeWith(safeRelExtractor) : ListOptions.sanitize;
        return sanitizer(list);
      }
      return Optional.none();
    };
    var RelOptions = { getRels: getRels };

    var fallbacks = [
      {
        text: 'Current window',
        value: ''
      },
      {
        text: 'New window',
        value: '_blank'
      }
    ];
    var getTargets = function (editor) {
      var list = getTargetList(editor);
      if (isArray(list)) {
        return ListOptions.sanitize(list).orThunk(function () {
          return Optional.some(fallbacks);
        });
      } else if (list === false) {
        return Optional.none();
      }
      return Optional.some(fallbacks);
    };
    var TargetOptions = { getTargets: getTargets };

    var nonEmptyAttr = function (dom, elem, name) {
      var val = dom.getAttrib(elem, name);
      return val !== null && val.length > 0 ? Optional.some(val) : Optional.none();
    };
    var extractFromAnchor = function (editor, anchor) {
      var dom = editor.dom;
      var onlyText = isOnlyTextSelected(editor);
      var text = onlyText ? Optional.some(getAnchorText(editor.selection, anchor)) : Optional.none();
      var url = anchor ? Optional.some(dom.getAttrib(anchor, 'href')) : Optional.none();
      var target = anchor ? Optional.from(dom.getAttrib(anchor, 'target')) : Optional.none();
      var rel = nonEmptyAttr(dom, anchor, 'rel');
      var linkClass = nonEmptyAttr(dom, anchor, 'class');
      var title = nonEmptyAttr(dom, anchor, 'title');
      return {
        url: url,
        text: text,
        title: title,
        target: target,
        rel: rel,
        linkClass: linkClass
      };
    };
    var collect = function (editor, linkNode) {
      return LinkListOptions.getLinks(editor).then(function (links) {
        var anchor = extractFromAnchor(editor, linkNode);
        return {
          anchor: anchor,
          catalogs: {
            targets: TargetOptions.getTargets(editor),
            rels: RelOptions.getRels(editor, anchor.target),
            classes: ClassListOptions.getClasses(editor),
            anchor: AnchorListOptions.getAnchors(editor),
            link: links
          },
          optNode: Optional.from(linkNode),
          flags: { titleEnabled: shouldShowLinkTitle(editor) }
        };
      });
    };
    var DialogInfo = { collect: collect };

    var handleSubmit = function (editor, info) {
      return function (api) {
        var data = api.getData();
        if (!data.url.value) {
          unlink(editor);
          api.close();
          return;
        }
        var getChangedValue = function (key) {
          return Optional.from(data[key]).filter(function (value) {
            return !is(info.anchor[key], value);
          });
        };
        var changedData = {
          href: data.url.value,
          text: getChangedValue('text'),
          target: getChangedValue('target'),
          rel: getChangedValue('rel'),
          class: getChangedValue('linkClass'),
          title: getChangedValue('title')
        };
        var attachState = {
          href: data.url.value,
          attach: data.url.meta !== undefined && data.url.meta.attach ? data.url.meta.attach : noop
        };
        DialogConfirms.preprocess(editor, changedData).then(function (pData) {
          link(editor, attachState, pData);
        });
        api.close();
      };
    };
    var collectData = function (editor) {
      var anchorNode = getAnchorElement(editor);
      return DialogInfo.collect(editor, anchorNode);
    };
    var getInitialData = function (info, defaultTarget) {
      var anchor = info.anchor;
      var url = anchor.url.getOr('');
      return {
        url: {
          value: url,
          meta: { original: { value: url } }
        },
        text: anchor.text.getOr(''),
        title: anchor.title.getOr(''),
        anchor: url,
        link: url,
        rel: anchor.rel.getOr(''),
        target: anchor.target.or(defaultTarget).getOr(''),
        linkClass: anchor.linkClass.getOr('')
      };
    };
    var makeDialog = function (settings, onSubmit, editor) {
      var urlInput = [{
          name: 'url',
          type: 'urlinput',
          filetype: 'file',
          label: 'URL'
        }];
      var displayText = settings.anchor.text.map(function () {
        return {
          name: 'text',
          type: 'input',
          label: 'Text to display'
        };
      }).toArray();
      var titleText = settings.flags.titleEnabled ? [{
          name: 'title',
          type: 'input',
          label: 'Title'
        }] : [];
      var defaultTarget = Optional.from(getDefaultLinkTarget(editor));
      var initialData = getInitialData(settings, defaultTarget);
      var catalogs = settings.catalogs;
      var dialogDelta = DialogChanges.init(initialData, catalogs);
      var body = {
        type: 'panel',
        items: flatten([
          urlInput,
          displayText,
          titleText,
          cat([
            catalogs.anchor.map(ListOptions.createUi('anchor', 'Anchors')),
            catalogs.rels.map(ListOptions.createUi('rel', 'Rel')),
            catalogs.targets.map(ListOptions.createUi('target', 'Open link in...')),
            catalogs.link.map(ListOptions.createUi('link', 'Link list')),
            catalogs.classes.map(ListOptions.createUi('linkClass', 'Class'))
          ])
        ])
      };
      return {
        title: 'Insert/Edit Link',
        size: 'normal',
        body: body,
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: initialData,
        onChange: function (api, _a) {
          var name = _a.name;
          dialogDelta.onChange(api.getData, { name: name }).each(function (newData) {
            api.setData(newData);
          });
        },
        onSubmit: onSubmit
      };
    };
    var open$1 = function (editor) {
      var data = collectData(editor);
      data.then(function (info) {
        var onSubmit = handleSubmit(editor, info);
        return makeDialog(info, onSubmit, editor);
      }).then(function (spec) {
        editor.windowManager.open(spec);
      });
    };

    var appendClickRemove = function (link, evt) {
      document.body.appendChild(link);
      link.dispatchEvent(evt);
      document.body.removeChild(link);
    };
    var open = function (url) {
      var link = document.createElement('a');
      link.target = '_blank';
      link.href = url;
      link.rel = 'noreferrer noopener';
      var evt = document.createEvent('MouseEvents');
      evt.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      appendClickRemove(link, evt);
    };

    var getLink = function (editor, elm) {
      return editor.dom.getParent(elm, 'a[href]');
    };
    var getSelectedLink = function (editor) {
      return getLink(editor, editor.selection.getStart());
    };
    var hasOnlyAltModifier = function (e) {
      return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
    };
    var gotoLink = function (editor, a) {
      if (a) {
        var href = getHref(a);
        if (/^#/.test(href)) {
          var targetEl = editor.$(href);
          if (targetEl.length) {
            editor.selection.scrollIntoView(targetEl[0], true);
          }
        } else {
          open(a.href);
        }
      }
    };
    var openDialog = function (editor) {
      return function () {
        open$1(editor);
      };
    };
    var gotoSelectedLink = function (editor) {
      return function () {
        gotoLink(editor, getSelectedLink(editor));
      };
    };
    var setupGotoLinks = function (editor) {
      editor.on('click', function (e) {
        var link = getLink(editor, e.target);
        if (link && global$6.metaKeyPressed(e)) {
          e.preventDefault();
          gotoLink(editor, link);
        }
      });
      editor.on('keydown', function (e) {
        var link = getSelectedLink(editor);
        if (link && e.keyCode === 13 && hasOnlyAltModifier(e)) {
          e.preventDefault();
          gotoLink(editor, link);
        }
      });
    };
    var toggleState = function (editor, toggler) {
      editor.on('NodeChange', toggler);
      return function () {
        return editor.off('NodeChange', toggler);
      };
    };
    var toggleActiveState = function (editor) {
      return function (api) {
        var updateState = function () {
          return api.setActive(!editor.mode.isReadOnly() && getAnchorElement(editor, editor.selection.getNode()) !== null);
        };
        updateState();
        return toggleState(editor, updateState);
      };
    };
    var toggleEnabledState = function (editor) {
      return function (api) {
        var updateState = function () {
          return api.setDisabled(getAnchorElement(editor, editor.selection.getNode()) === null);
        };
        updateState();
        return toggleState(editor, updateState);
      };
    };
    var toggleUnlinkState = function (editor) {
      return function (api) {
        var hasLinks$1 = function (parents) {
          return hasLinks(parents) || hasLinksInSelection(editor.selection.getRng());
        };
        var parents = editor.dom.getParents(editor.selection.getStart());
        api.setDisabled(!hasLinks$1(parents));
        return toggleState(editor, function (e) {
          return api.setDisabled(!hasLinks$1(e.parents));
        });
      };
    };

    var register = function (editor) {
      editor.addCommand('mceLink', function () {
        if (useQuickLink(editor)) {
          editor.fire('contexttoolbar-show', { toolbarKey: 'quicklink' });
        } else {
          openDialog(editor)();
        }
      });
    };

    var setup = function (editor) {
      editor.addShortcut('Meta+K', '', function () {
        editor.execCommand('mceLink');
      });
    };

    var setupButtons = function (editor) {
      editor.ui.registry.addToggleButton('link', {
        icon: 'link',
        tooltip: 'Insert/edit link',
        onAction: openDialog(editor),
        onSetup: toggleActiveState(editor)
      });
      editor.ui.registry.addButton('openlink', {
        icon: 'new-tab',
        tooltip: 'Open link',
        onAction: gotoSelectedLink(editor),
        onSetup: toggleEnabledState(editor)
      });
      editor.ui.registry.addButton('unlink', {
        icon: 'unlink',
        tooltip: 'Remove link',
        onAction: function () {
          return unlink(editor);
        },
        onSetup: toggleUnlinkState(editor)
      });
    };
    var setupMenuItems = function (editor) {
      editor.ui.registry.addMenuItem('openlink', {
        text: 'Open link',
        icon: 'new-tab',
        onAction: gotoSelectedLink(editor),
        onSetup: toggleEnabledState(editor)
      });
      editor.ui.registry.addMenuItem('link', {
        icon: 'link',
        text: 'Link...',
        shortcut: 'Meta+K',
        onAction: openDialog(editor)
      });
      editor.ui.registry.addMenuItem('unlink', {
        icon: 'unlink',
        text: 'Remove link',
        onAction: function () {
          return unlink(editor);
        },
        onSetup: toggleUnlinkState(editor)
      });
    };
    var setupContextMenu = function (editor) {
      var inLink = 'link unlink openlink';
      var noLink = 'link';
      editor.ui.registry.addContextMenu('link', {
        update: function (element) {
          return hasLinks(editor.dom.getParents(element, 'a')) ? inLink : noLink;
        }
      });
    };
    var setupContextToolbars = function (editor) {
      var collapseSelectionToEnd = function (editor) {
        editor.selection.collapse(false);
      };
      var onSetupLink = function (buttonApi) {
        var node = editor.selection.getNode();
        buttonApi.setDisabled(!getAnchorElement(editor, node));
        return noop;
      };
      var getLinkText = function (value) {
        var anchor = getAnchorElement(editor);
        var onlyText = isOnlyTextSelected(editor);
        if (!anchor && onlyText) {
          var text = getAnchorText(editor.selection, anchor);
          return Optional.some(text.length > 0 ? text : value);
        } else {
          return Optional.none();
        }
      };
      editor.ui.registry.addContextForm('quicklink', {
        launch: {
          type: 'contextformtogglebutton',
          icon: 'link',
          tooltip: 'Link',
          onSetup: toggleActiveState(editor)
        },
        label: 'Link',
        predicate: function (node) {
          return !!getAnchorElement(editor, node) && hasContextToolbar(editor);
        },
        initValue: function () {
          var elm = getAnchorElement(editor);
          return !!elm ? getHref(elm) : '';
        },
        commands: [
          {
            type: 'contextformtogglebutton',
            icon: 'link',
            tooltip: 'Link',
            primary: true,
            onSetup: function (buttonApi) {
              var node = editor.selection.getNode();
              buttonApi.setActive(!!getAnchorElement(editor, node));
              return toggleActiveState(editor)(buttonApi);
            },
            onAction: function (formApi) {
              var value = formApi.getValue();
              var text = getLinkText(value);
              var attachState = {
                href: value,
                attach: noop
              };
              link(editor, attachState, {
                href: value,
                text: text,
                title: Optional.none(),
                rel: Optional.none(),
                target: Optional.none(),
                class: Optional.none()
              });
              collapseSelectionToEnd(editor);
              formApi.hide();
            }
          },
          {
            type: 'contextformbutton',
            icon: 'unlink',
            tooltip: 'Remove link',
            onSetup: onSetupLink,
            onAction: function (formApi) {
              unlink(editor);
              formApi.hide();
            }
          },
          {
            type: 'contextformbutton',
            icon: 'new-tab',
            tooltip: 'Open link',
            onSetup: onSetupLink,
            onAction: function (formApi) {
              gotoSelectedLink(editor)();
              formApi.hide();
            }
          }
        ]
      });
    };

    function Plugin () {
      global$7.add('link', function (editor) {
        setupButtons(editor);
        setupMenuItems(editor);
        setupContextMenu(editor);
        setupContextToolbars(editor);
        setupGotoLinks(editor);
        register(editor);
        setup(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "2292":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "visualchars" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/visualchars')
//   ES2015:
//     import 'tinymce/plugins/visualchars'
__webpack_require__("33b6");

/***/ }),

/***/ "267b":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "table" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/table')
//   ES2015:
//     import 'tinymce/plugins/table'
__webpack_require__("cf92");

/***/ }),

/***/ "2b99":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isString = isType$1('string');
    var isArray = isType$1('array');
    var isBoolean = isSimpleType('boolean');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var punctuationStr = '[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uff3f\uFF5B\uFF5D\uFF5F-\uFF65]';

    var punctuation$1 = constant(punctuationStr);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var punctuation = punctuation$1;

    var global$2 = tinymce.util.Tools.resolve('tinymce.Env');

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var nativeSlice = Array.prototype.slice;
    var nativePush = Array.prototype.push;
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function (xs, f) {
      for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var groupBy = function (xs, f) {
      if (xs.length === 0) {
        return [];
      } else {
        var wasType = f(xs[0]);
        var r = [];
        var group = [];
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          var type = f(x);
          if (type !== wasType) {
            r.push(group);
            group = [];
          }
          wasType = type;
          group.push(x);
        }
        if (group.length !== 0) {
          r.push(group);
        }
        return r;
      }
    };
    var foldl = function (xs, f, acc) {
      each(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };
    var sort = function (xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };

    var hasOwnProperty = Object.hasOwnProperty;
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;

    var type = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isText$1 = isType(TEXT);

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set = function (element, key, value) {
      rawSet(element.dom, key, value);
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) & match) !== 0;
    };
    var documentPositionPreceding = function (a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_PRECEDING);
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    };
    var all = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);
    };

    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var children = function (element) {
      return map(element.dom.childNodes, SugarElement.fromDom);
    };
    var spot = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };
    var leaf = function (element, offset) {
      var cs = children(element);
      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);
    };

    var before = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var append = function (parent, element) {
      parent.dom.appendChild(element.dom);
    };
    var wrap = function (element, wrapper) {
      before(element, wrapper);
      append(wrapper, element);
    };

    var NodeValue = function (is, name) {
      var get = function (element) {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      var getOption = function (element) {
        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      };
      var set = function (element, value) {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get: get,
        getOption: getOption,
        set: set
      };
    };

    var api = NodeValue(isText$1, 'text');
    var get$1 = function (element) {
      return api.get(element);
    };

    var descendants = function (scope, selector) {
      return all(selector, scope);
    };

    var global = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');

    var isSimpleBoundary = function (dom, node) {
      return dom.isBlock(node) || has(dom.schema.getShortEndedElements(), node.nodeName);
    };
    var isContentEditableFalse = function (dom, node) {
      return dom.getContentEditable(node) === 'false';
    };
    var isContentEditableTrueInCef = function (dom, node) {
      return dom.getContentEditable(node) === 'true' && dom.getContentEditableParent(node.parentNode) === 'false';
    };
    var isHidden = function (dom, node) {
      return !dom.isBlock(node) && has(dom.schema.getWhiteSpaceElements(), node.nodeName);
    };
    var isBoundary = function (dom, node) {
      return isSimpleBoundary(dom, node) || isContentEditableFalse(dom, node) || isHidden(dom, node) || isContentEditableTrueInCef(dom, node);
    };
    var isText = function (node) {
      return node.nodeType === 3;
    };
    var nuSection = function () {
      return {
        sOffset: 0,
        fOffset: 0,
        elements: []
      };
    };
    var toLeaf = function (node, offset) {
      return leaf(SugarElement.fromDom(node), offset);
    };
    var walk = function (dom, walkerFn, startNode, callbacks, endNode, skipStart) {
      if (skipStart === void 0) {
        skipStart = true;
      }
      var next = skipStart ? walkerFn(false) : startNode;
      while (next) {
        var isCefNode = isContentEditableFalse(dom, next);
        if (isCefNode || isHidden(dom, next)) {
          var stopWalking = isCefNode ? callbacks.cef(next) : callbacks.boundary(next);
          if (stopWalking) {
            break;
          } else {
            next = walkerFn(true);
            continue;
          }
        } else if (isSimpleBoundary(dom, next)) {
          if (callbacks.boundary(next)) {
            break;
          }
        } else if (isText(next)) {
          callbacks.text(next);
        }
        if (next === endNode) {
          break;
        } else {
          next = walkerFn(false);
        }
      }
    };
    var collectTextToBoundary = function (dom, section, node, rootNode, forwards) {
      if (isBoundary(dom, node)) {
        return;
      }
      var rootBlock = dom.getParent(rootNode, dom.isBlock);
      var walker = new global(node, rootBlock);
      var walkerFn = forwards ? walker.next.bind(walker) : walker.prev.bind(walker);
      walk(dom, walkerFn, node, {
        boundary: always,
        cef: always,
        text: function (next) {
          if (forwards) {
            section.fOffset += next.length;
          } else {
            section.sOffset += next.length;
          }
          section.elements.push(SugarElement.fromDom(next));
        }
      });
    };
    var collect = function (dom, rootNode, startNode, endNode, callbacks, skipStart) {
      if (skipStart === void 0) {
        skipStart = true;
      }
      var walker = new global(startNode, rootNode);
      var sections = [];
      var current = nuSection();
      collectTextToBoundary(dom, current, startNode, rootNode, false);
      var finishSection = function () {
        if (current.elements.length > 0) {
          sections.push(current);
          current = nuSection();
        }
        return false;
      };
      walk(dom, walker.next.bind(walker), startNode, {
        boundary: finishSection,
        cef: function (node) {
          finishSection();
          if (callbacks) {
            sections.push.apply(sections, callbacks.cef(node));
          }
          return false;
        },
        text: function (next) {
          current.elements.push(SugarElement.fromDom(next));
          if (callbacks) {
            callbacks.text(next, current);
          }
        }
      }, endNode, skipStart);
      if (endNode) {
        collectTextToBoundary(dom, current, endNode, rootNode, true);
      }
      finishSection();
      return sections;
    };
    var collectRangeSections = function (dom, rng) {
      var start = toLeaf(rng.startContainer, rng.startOffset);
      var startNode = start.element.dom;
      var end = toLeaf(rng.endContainer, rng.endOffset);
      var endNode = end.element.dom;
      return collect(dom, rng.commonAncestorContainer, startNode, endNode, {
        text: function (node, section) {
          if (node === endNode) {
            section.fOffset += node.length - end.offset;
          } else if (node === startNode) {
            section.sOffset += start.offset;
          }
        },
        cef: function (node) {
          var sections = bind(descendants(SugarElement.fromDom(node), '*[contenteditable=true]'), function (e) {
            var ceTrueNode = e.dom;
            return collect(dom, ceTrueNode, ceTrueNode);
          });
          return sort(sections, function (a, b) {
            return documentPositionPreceding(a.elements[0].dom, b.elements[0].dom) ? 1 : -1;
          });
        }
      }, false);
    };
    var fromRng = function (dom, rng) {
      return rng.collapsed ? [] : collectRangeSections(dom, rng);
    };
    var fromNode = function (dom, node) {
      var rng = dom.createRng();
      rng.selectNode(node);
      return fromRng(dom, rng);
    };
    var fromNodes = function (dom, nodes) {
      return bind(nodes, function (node) {
        return fromNode(dom, node);
      });
    };

    var find$2 = function (text, pattern, start, finish) {
      if (start === void 0) {
        start = 0;
      }
      if (finish === void 0) {
        finish = text.length;
      }
      var regex = pattern.regex;
      regex.lastIndex = start;
      var results = [];
      var match;
      while (match = regex.exec(text)) {
        var matchedText = match[pattern.matchIndex];
        var matchStart = match.index + match[0].indexOf(matchedText);
        var matchFinish = matchStart + matchedText.length;
        if (matchFinish > finish) {
          break;
        }
        results.push({
          start: matchStart,
          finish: matchFinish
        });
        regex.lastIndex = matchFinish;
      }
      return results;
    };
    var extract = function (elements, matches) {
      var nodePositions = foldl(elements, function (acc, element) {
        var content = get$1(element);
        var start = acc.last;
        var finish = start + content.length;
        var positions = bind(matches, function (match, matchIdx) {
          if (match.start < finish && match.finish > start) {
            return [{
                element: element,
                start: Math.max(start, match.start) - start,
                finish: Math.min(finish, match.finish) - start,
                matchId: matchIdx
              }];
          } else {
            return [];
          }
        });
        return {
          results: acc.results.concat(positions),
          last: finish
        };
      }, {
        results: [],
        last: 0
      }).results;
      return groupBy(nodePositions, function (position) {
        return position.matchId;
      });
    };

    var find$1 = function (pattern, sections) {
      return bind(sections, function (section) {
        var elements = section.elements;
        var content = map(elements, get$1).join('');
        var positions = find$2(content, pattern, section.sOffset, content.length - section.fOffset);
        return extract(elements, positions);
      });
    };
    var mark = function (matches, replacementNode) {
      eachr(matches, function (match, idx) {
        eachr(match, function (pos) {
          var wrapper = SugarElement.fromDom(replacementNode.cloneNode(false));
          set(wrapper, 'data-mce-index', idx);
          var textNode = pos.element.dom;
          if (textNode.length === pos.finish && pos.start === 0) {
            wrap(pos.element, wrapper);
          } else {
            if (textNode.length !== pos.finish) {
              textNode.splitText(pos.finish);
            }
            var matchNode = textNode.splitText(pos.start);
            wrap(SugarElement.fromDom(matchNode), wrapper);
          }
        });
      });
    };
    var findAndMark = function (dom, pattern, node, replacementNode) {
      var textSections = fromNode(dom, node);
      var matches = find$1(pattern, textSections);
      mark(matches, replacementNode);
      return matches.length;
    };
    var findAndMarkInSelection = function (dom, pattern, selection, replacementNode) {
      var bookmark = selection.getBookmark();
      var nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');
      var textSections = nodes.length > 0 ? fromNodes(dom, nodes) : fromRng(dom, selection.getRng());
      var matches = find$1(pattern, textSections);
      mark(matches, replacementNode);
      selection.moveToBookmark(bookmark);
      return matches.length;
    };

    var getElmIndex = function (elm) {
      var value = elm.getAttribute('data-mce-index');
      if (typeof value === 'number') {
        return '' + value;
      }
      return value;
    };
    var markAllMatches = function (editor, currentSearchState, pattern, inSelection) {
      var marker = editor.dom.create('span', { 'data-mce-bogus': 1 });
      marker.className = 'mce-match-marker';
      var node = editor.getBody();
      done(editor, currentSearchState, false);
      if (inSelection) {
        return findAndMarkInSelection(editor.dom, pattern, editor.selection, marker);
      } else {
        return findAndMark(editor.dom, pattern, node, marker);
      }
    };
    var unwrap = function (node) {
      var parentNode = node.parentNode;
      if (node.firstChild) {
        parentNode.insertBefore(node.firstChild, node);
      }
      node.parentNode.removeChild(node);
    };
    var findSpansByIndex = function (editor, index) {
      var spans = [];
      var nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));
      if (nodes.length) {
        for (var i = 0; i < nodes.length; i++) {
          var nodeIndex = getElmIndex(nodes[i]);
          if (nodeIndex === null || !nodeIndex.length) {
            continue;
          }
          if (nodeIndex === index.toString()) {
            spans.push(nodes[i]);
          }
        }
      }
      return spans;
    };
    var moveSelection = function (editor, currentSearchState, forward) {
      var searchState = currentSearchState.get();
      var testIndex = searchState.index;
      var dom = editor.dom;
      forward = forward !== false;
      if (forward) {
        if (testIndex + 1 === searchState.count) {
          testIndex = 0;
        } else {
          testIndex++;
        }
      } else {
        if (testIndex - 1 === -1) {
          testIndex = searchState.count - 1;
        } else {
          testIndex--;
        }
      }
      dom.removeClass(findSpansByIndex(editor, searchState.index), 'mce-match-marker-selected');
      var spans = findSpansByIndex(editor, testIndex);
      if (spans.length) {
        dom.addClass(findSpansByIndex(editor, testIndex), 'mce-match-marker-selected');
        editor.selection.scrollIntoView(spans[0]);
        return testIndex;
      }
      return -1;
    };
    var removeNode = function (dom, node) {
      var parent = node.parentNode;
      dom.remove(node);
      if (dom.isEmpty(parent)) {
        dom.remove(parent);
      }
    };
    var escapeSearchText = function (text, wholeWord) {
      var escapedText = text.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&').replace(/\s/g, '[^\\S\\r\\n\\uFEFF]');
      var wordRegex = '(' + escapedText + ')';
      return wholeWord ? '(?:^|\\s|' + punctuation() + ')' + wordRegex + ('(?=$|\\s|' + punctuation() + ')') : wordRegex;
    };
    var find = function (editor, currentSearchState, text, matchCase, wholeWord, inSelection) {
      var selection = editor.selection;
      var escapedText = escapeSearchText(text, wholeWord);
      var isForwardSelection = selection.isForward();
      var pattern = {
        regex: new RegExp(escapedText, matchCase ? 'g' : 'gi'),
        matchIndex: 1
      };
      var count = markAllMatches(editor, currentSearchState, pattern, inSelection);
      if (global$2.browser.isSafari()) {
        selection.setRng(selection.getRng(), isForwardSelection);
      }
      if (count) {
        var newIndex = moveSelection(editor, currentSearchState, true);
        currentSearchState.set({
          index: newIndex,
          count: count,
          text: text,
          matchCase: matchCase,
          wholeWord: wholeWord,
          inSelection: inSelection
        });
      }
      return count;
    };
    var next = function (editor, currentSearchState) {
      var index = moveSelection(editor, currentSearchState, true);
      currentSearchState.set(__assign(__assign({}, currentSearchState.get()), { index: index }));
    };
    var prev = function (editor, currentSearchState) {
      var index = moveSelection(editor, currentSearchState, false);
      currentSearchState.set(__assign(__assign({}, currentSearchState.get()), { index: index }));
    };
    var isMatchSpan = function (node) {
      var matchIndex = getElmIndex(node);
      return matchIndex !== null && matchIndex.length > 0;
    };
    var replace = function (editor, currentSearchState, text, forward, all) {
      var searchState = currentSearchState.get();
      var currentIndex = searchState.index;
      var currentMatchIndex, nextIndex = currentIndex;
      forward = forward !== false;
      var node = editor.getBody();
      var nodes = global$1.grep(global$1.toArray(node.getElementsByTagName('span')), isMatchSpan);
      for (var i = 0; i < nodes.length; i++) {
        var nodeIndex = getElmIndex(nodes[i]);
        var matchIndex = currentMatchIndex = parseInt(nodeIndex, 10);
        if (all || matchIndex === searchState.index) {
          if (text.length) {
            nodes[i].firstChild.nodeValue = text;
            unwrap(nodes[i]);
          } else {
            removeNode(editor.dom, nodes[i]);
          }
          while (nodes[++i]) {
            matchIndex = parseInt(getElmIndex(nodes[i]), 10);
            if (matchIndex === currentMatchIndex) {
              removeNode(editor.dom, nodes[i]);
            } else {
              i--;
              break;
            }
          }
          if (forward) {
            nextIndex--;
          }
        } else if (currentMatchIndex > currentIndex) {
          nodes[i].setAttribute('data-mce-index', String(currentMatchIndex - 1));
        }
      }
      currentSearchState.set(__assign(__assign({}, searchState), {
        count: all ? 0 : searchState.count - 1,
        index: nextIndex
      }));
      if (forward) {
        next(editor, currentSearchState);
      } else {
        prev(editor, currentSearchState);
      }
      return !all && currentSearchState.get().count > 0;
    };
    var done = function (editor, currentSearchState, keepEditorSelection) {
      var startContainer, endContainer;
      var searchState = currentSearchState.get();
      var nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));
      for (var i = 0; i < nodes.length; i++) {
        var nodeIndex = getElmIndex(nodes[i]);
        if (nodeIndex !== null && nodeIndex.length) {
          if (nodeIndex === searchState.index.toString()) {
            if (!startContainer) {
              startContainer = nodes[i].firstChild;
            }
            endContainer = nodes[i].firstChild;
          }
          unwrap(nodes[i]);
        }
      }
      currentSearchState.set(__assign(__assign({}, searchState), {
        index: -1,
        count: 0,
        text: ''
      }));
      if (startContainer && endContainer) {
        var rng = editor.dom.createRng();
        rng.setStart(startContainer, 0);
        rng.setEnd(endContainer, endContainer.data.length);
        if (keepEditorSelection !== false) {
          editor.selection.setRng(rng);
        }
        return rng;
      }
    };
    var hasNext = function (editor, currentSearchState) {
      return currentSearchState.get().count > 1;
    };
    var hasPrev = function (editor, currentSearchState) {
      return currentSearchState.get().count > 1;
    };

    var get = function (editor, currentState) {
      var done$1 = function (keepEditorSelection) {
        return done(editor, currentState, keepEditorSelection);
      };
      var find$1 = function (text, matchCase, wholeWord, inSelection) {
        if (inSelection === void 0) {
          inSelection = false;
        }
        return find(editor, currentState, text, matchCase, wholeWord, inSelection);
      };
      var next$1 = function () {
        return next(editor, currentState);
      };
      var prev$1 = function () {
        return prev(editor, currentState);
      };
      var replace$1 = function (text, forward, all) {
        return replace(editor, currentState, text, forward, all);
      };
      return {
        done: done$1,
        find: find$1,
        next: next$1,
        prev: prev$1,
        replace: replace$1
      };
    };

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var open = function (editor, currentSearchState) {
      var dialogApi = value();
      editor.undoManager.add();
      var selectedText = global$1.trim(editor.selection.getContent({ format: 'text' }));
      var updateButtonStates = function (api) {
        var updateNext = hasNext(editor, currentSearchState) ? api.enable : api.disable;
        updateNext('next');
        var updatePrev = hasPrev(editor, currentSearchState) ? api.enable : api.disable;
        updatePrev('prev');
      };
      var updateSearchState = function (api) {
        var data = api.getData();
        var current = currentSearchState.get();
        currentSearchState.set(__assign(__assign({}, current), {
          matchCase: data.matchcase,
          wholeWord: data.wholewords,
          inSelection: data.inselection
        }));
      };
      var disableAll = function (api, disable) {
        var buttons = [
          'replace',
          'replaceall',
          'prev',
          'next'
        ];
        var toggle = disable ? api.disable : api.enable;
        each(buttons, toggle);
      };
      var notFoundAlert = function (api) {
        editor.windowManager.alert('Could not find the specified string.', function () {
          api.focus('findtext');
        });
      };
      var focusButtonIfRequired = function (api, name) {
        if (global$2.browser.isSafari() && global$2.deviceType.isTouch() && (name === 'find' || name === 'replace' || name === 'replaceall')) {
          api.focus(name);
        }
      };
      var reset = function (api) {
        done(editor, currentSearchState, false);
        disableAll(api, true);
        updateButtonStates(api);
      };
      var doFind = function (api) {
        var data = api.getData();
        var last = currentSearchState.get();
        if (!data.findtext.length) {
          reset(api);
          return;
        }
        if (last.text === data.findtext && last.matchCase === data.matchcase && last.wholeWord === data.wholewords) {
          next(editor, currentSearchState);
        } else {
          var count = find(editor, currentSearchState, data.findtext, data.matchcase, data.wholewords, data.inselection);
          if (count <= 0) {
            notFoundAlert(api);
          }
          disableAll(api, count === 0);
        }
        updateButtonStates(api);
      };
      var initialState = currentSearchState.get();
      var initialData = {
        findtext: selectedText,
        replacetext: '',
        wholewords: initialState.wholeWord,
        matchcase: initialState.matchCase,
        inselection: initialState.inSelection
      };
      var spec = {
        title: 'Find and Replace',
        size: 'normal',
        body: {
          type: 'panel',
          items: [
            {
              type: 'bar',
              items: [
                {
                  type: 'input',
                  name: 'findtext',
                  placeholder: 'Find',
                  maximized: true,
                  inputMode: 'search'
                },
                {
                  type: 'button',
                  name: 'prev',
                  text: 'Previous',
                  icon: 'action-prev',
                  disabled: true,
                  borderless: true
                },
                {
                  type: 'button',
                  name: 'next',
                  text: 'Next',
                  icon: 'action-next',
                  disabled: true,
                  borderless: true
                }
              ]
            },
            {
              type: 'input',
              name: 'replacetext',
              placeholder: 'Replace with',
              inputMode: 'search'
            }
          ]
        },
        buttons: [
          {
            type: 'menu',
            name: 'options',
            icon: 'preferences',
            tooltip: 'Preferences',
            align: 'start',
            items: [
              {
                type: 'togglemenuitem',
                name: 'matchcase',
                text: 'Match case'
              },
              {
                type: 'togglemenuitem',
                name: 'wholewords',
                text: 'Find whole words only'
              },
              {
                type: 'togglemenuitem',
                name: 'inselection',
                text: 'Find in selection'
              }
            ]
          },
          {
            type: 'custom',
            name: 'find',
            text: 'Find',
            primary: true
          },
          {
            type: 'custom',
            name: 'replace',
            text: 'Replace',
            disabled: true
          },
          {
            type: 'custom',
            name: 'replaceall',
            text: 'Replace all',
            disabled: true
          }
        ],
        initialData: initialData,
        onChange: function (api, details) {
          if (details.name === 'findtext' && currentSearchState.get().count > 0) {
            reset(api);
          }
        },
        onAction: function (api, details) {
          var data = api.getData();
          switch (details.name) {
          case 'find':
            doFind(api);
            break;
          case 'replace':
            if (!replace(editor, currentSearchState, data.replacetext)) {
              reset(api);
            } else {
              updateButtonStates(api);
            }
            break;
          case 'replaceall':
            replace(editor, currentSearchState, data.replacetext, true, true);
            reset(api);
            break;
          case 'prev':
            prev(editor, currentSearchState);
            updateButtonStates(api);
            break;
          case 'next':
            next(editor, currentSearchState);
            updateButtonStates(api);
            break;
          case 'matchcase':
          case 'wholewords':
          case 'inselection':
            updateSearchState(api);
            reset(api);
            break;
          }
          focusButtonIfRequired(api, details.name);
        },
        onSubmit: function (api) {
          doFind(api);
          focusButtonIfRequired(api, 'find');
        },
        onClose: function () {
          editor.focus();
          done(editor, currentSearchState);
          editor.undoManager.add();
        }
      };
      dialogApi.set(editor.windowManager.open(spec, { inline: 'toolbar' }));
    };

    var register$1 = function (editor, currentSearchState) {
      editor.addCommand('SearchReplace', function () {
        open(editor, currentSearchState);
      });
    };

    var showDialog = function (editor, currentSearchState) {
      return function () {
        open(editor, currentSearchState);
      };
    };
    var register = function (editor, currentSearchState) {
      editor.ui.registry.addMenuItem('searchreplace', {
        text: 'Find and replace...',
        shortcut: 'Meta+F',
        onAction: showDialog(editor, currentSearchState),
        icon: 'search'
      });
      editor.ui.registry.addButton('searchreplace', {
        tooltip: 'Find and replace',
        onAction: showDialog(editor, currentSearchState),
        icon: 'search'
      });
      editor.shortcuts.add('Meta+F', '', showDialog(editor, currentSearchState));
    };

    function Plugin () {
      global$3.add('searchreplace', function (editor) {
        var currentSearchState = Cell({
          index: -1,
          count: 0,
          text: '',
          matchCase: false,
          wholeWord: false,
          inSelection: false
        });
        register$1(editor, currentSearchState);
        register(editor, currentSearchState);
        return get(editor, currentSearchState);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "2c24":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$9 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isString = isType('string');
    var isObject = isType('object');
    var isArray = isType('array');
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var nativePush = Array.prototype.push;
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var get$1 = function (obj, key) {
      return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    var getScripts = function (editor) {
      return editor.getParam('media_scripts');
    };
    var getAudioTemplateCallback = function (editor) {
      return editor.getParam('audio_template_callback');
    };
    var getVideoTemplateCallback = function (editor) {
      return editor.getParam('video_template_callback');
    };
    var hasLiveEmbeds = function (editor) {
      return editor.getParam('media_live_embeds', true);
    };
    var shouldFilterHtml = function (editor) {
      return editor.getParam('media_filter_html', true);
    };
    var getUrlResolver = function (editor) {
      return editor.getParam('media_url_resolver');
    };
    var hasAltSource = function (editor) {
      return editor.getParam('media_alt_source', true);
    };
    var hasPoster = function (editor) {
      return editor.getParam('media_poster', true);
    };
    var hasDimensions = function (editor) {
      return editor.getParam('media_dimensions', true);
    };

    var global$8 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var global$7 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$6 = tinymce.util.Tools.resolve('tinymce.html.SaxParser');

    var getVideoScriptMatch = function (prefixes, src) {
      if (prefixes) {
        for (var i = 0; i < prefixes.length; i++) {
          if (src.indexOf(prefixes[i].filter) !== -1) {
            return prefixes[i];
          }
        }
      }
    };

    var DOM$1 = global$7.DOM;
    var trimPx = function (value) {
      return value.replace(/px$/, '');
    };
    var getEphoxEmbedData = function (attrs) {
      var style = attrs.map.style;
      var styles = style ? DOM$1.parseStyle(style) : {};
      return {
        type: 'ephox-embed-iri',
        source: attrs.map['data-ephox-embed-iri'],
        altsource: '',
        poster: '',
        width: get$1(styles, 'max-width').map(trimPx).getOr(''),
        height: get$1(styles, 'max-height').map(trimPx).getOr('')
      };
    };
    var htmlToData = function (prefixes, html) {
      var isEphoxEmbed = Cell(false);
      var data = {};
      global$6({
        validate: false,
        allow_conditional_comments: true,
        start: function (name, attrs) {
          if (isEphoxEmbed.get()) ; else if (has(attrs.map, 'data-ephox-embed-iri')) {
            isEphoxEmbed.set(true);
            data = getEphoxEmbedData(attrs);
          } else {
            if (!data.source && name === 'param') {
              data.source = attrs.map.movie;
            }
            if (name === 'iframe' || name === 'object' || name === 'embed' || name === 'video' || name === 'audio') {
              if (!data.type) {
                data.type = name;
              }
              data = global$8.extend(attrs.map, data);
            }
            if (name === 'script') {
              var videoScript = getVideoScriptMatch(prefixes, attrs.map.src);
              if (!videoScript) {
                return;
              }
              data = {
                type: 'script',
                source: attrs.map.src,
                width: String(videoScript.width),
                height: String(videoScript.height)
              };
            }
            if (name === 'source') {
              if (!data.source) {
                data.source = attrs.map.src;
              } else if (!data.altsource) {
                data.altsource = attrs.map.src;
              }
            }
            if (name === 'img' && !data.poster) {
              data.poster = attrs.map.src;
            }
          }
        }
      }).parse(html);
      data.source = data.source || data.src || data.data;
      data.altsource = data.altsource || '';
      data.poster = data.poster || '';
      return data;
    };

    var guess = function (url) {
      var mimes = {
        mp3: 'audio/mpeg',
        m4a: 'audio/x-m4a',
        wav: 'audio/wav',
        mp4: 'video/mp4',
        webm: 'video/webm',
        ogg: 'video/ogg',
        swf: 'application/x-shockwave-flash'
      };
      var fileEnd = url.toLowerCase().split('.').pop();
      var mime = mimes[fileEnd];
      return mime ? mime : '';
    };

    var global$5 = tinymce.util.Tools.resolve('tinymce.html.Schema');

    var global$4 = tinymce.util.Tools.resolve('tinymce.html.Writer');

    var DOM = global$7.DOM;
    var addPx = function (value) {
      return /^[0-9.]+$/.test(value) ? value + 'px' : value;
    };
    var setAttributes = function (attrs, updatedAttrs) {
      each(updatedAttrs, function (val, name) {
        var value = '' + val;
        if (attrs.map[name]) {
          var i = attrs.length;
          while (i--) {
            var attr = attrs[i];
            if (attr.name === name) {
              if (value) {
                attrs.map[name] = value;
                attr.value = value;
              } else {
                delete attrs.map[name];
                attrs.splice(i, 1);
              }
            }
          }
        } else if (value) {
          attrs.push({
            name: name,
            value: value
          });
          attrs.map[name] = value;
        }
      });
    };
    var updateEphoxEmbed = function (data, attrs) {
      var style = attrs.map.style;
      var styleMap = style ? DOM.parseStyle(style) : {};
      styleMap['max-width'] = addPx(data.width);
      styleMap['max-height'] = addPx(data.height);
      setAttributes(attrs, { style: DOM.serializeStyle(styleMap) });
    };
    var sources = [
      'source',
      'altsource'
    ];
    var updateHtml = function (html, data, updateAll) {
      var writer = global$4();
      var isEphoxEmbed = Cell(false);
      var sourceCount = 0;
      var hasImage;
      global$6({
        validate: false,
        allow_conditional_comments: true,
        comment: function (text) {
          writer.comment(text);
        },
        cdata: function (text) {
          writer.cdata(text);
        },
        text: function (text, raw) {
          writer.text(text, raw);
        },
        start: function (name, attrs, empty) {
          if (isEphoxEmbed.get()) ; else if (has(attrs.map, 'data-ephox-embed-iri')) {
            isEphoxEmbed.set(true);
            updateEphoxEmbed(data, attrs);
          } else {
            switch (name) {
            case 'video':
            case 'object':
            case 'embed':
            case 'img':
            case 'iframe':
              if (data.height !== undefined && data.width !== undefined) {
                setAttributes(attrs, {
                  width: data.width,
                  height: data.height
                });
              }
              break;
            }
            if (updateAll) {
              switch (name) {
              case 'video':
                setAttributes(attrs, {
                  poster: data.poster,
                  src: ''
                });
                if (data.altsource) {
                  setAttributes(attrs, { src: '' });
                }
                break;
              case 'iframe':
                setAttributes(attrs, { src: data.source });
                break;
              case 'source':
                if (sourceCount < 2) {
                  setAttributes(attrs, {
                    src: data[sources[sourceCount]],
                    type: data[sources[sourceCount] + 'mime']
                  });
                  if (!data[sources[sourceCount]]) {
                    return;
                  }
                }
                sourceCount++;
                break;
              case 'img':
                if (!data.poster) {
                  return;
                }
                hasImage = true;
                break;
              }
            }
          }
          writer.start(name, attrs, empty);
        },
        end: function (name) {
          if (!isEphoxEmbed.get()) {
            if (name === 'video' && updateAll) {
              for (var index = 0; index < 2; index++) {
                if (data[sources[index]]) {
                  var attrs = [];
                  attrs.map = {};
                  if (sourceCount <= index) {
                    setAttributes(attrs, {
                      src: data[sources[index]],
                      type: data[sources[index] + 'mime']
                    });
                    writer.start('source', attrs, true);
                  }
                }
              }
            }
            if (data.poster && name === 'object' && updateAll && !hasImage) {
              var imgAttrs = [];
              imgAttrs.map = {};
              setAttributes(imgAttrs, {
                src: data.poster,
                width: data.width,
                height: data.height
              });
              writer.start('img', imgAttrs, true);
            }
          }
          writer.end(name);
        }
      }, global$5({})).parse(html);
      return writer.getContent();
    };

    var urlPatterns = [
      {
        regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
        type: 'iframe',
        w: 560,
        h: 314,
        url: 'www.youtube.com/embed/$1',
        allowFullscreen: true
      },
      {
        regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
        type: 'iframe',
        w: 560,
        h: 314,
        url: 'www.youtube.com/embed/$2?$4',
        allowFullscreen: true
      },
      {
        regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
        type: 'iframe',
        w: 560,
        h: 314,
        url: 'www.youtube.com/embed/$1',
        allowFullscreen: true
      },
      {
        regex: /vimeo\.com\/([0-9]+)/,
        type: 'iframe',
        w: 425,
        h: 350,
        url: 'player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc',
        allowFullscreen: true
      },
      {
        regex: /vimeo\.com\/(.*)\/([0-9]+)/,
        type: 'iframe',
        w: 425,
        h: 350,
        url: 'player.vimeo.com/video/$2?title=0&amp;byline=0',
        allowFullscreen: true
      },
      {
        regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
        type: 'iframe',
        w: 425,
        h: 350,
        url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
        allowFullscreen: false
      },
      {
        regex: /dailymotion\.com\/video\/([^_]+)/,
        type: 'iframe',
        w: 480,
        h: 270,
        url: 'www.dailymotion.com/embed/video/$1',
        allowFullscreen: true
      },
      {
        regex: /dai\.ly\/([^_]+)/,
        type: 'iframe',
        w: 480,
        h: 270,
        url: 'www.dailymotion.com/embed/video/$1',
        allowFullscreen: true
      }
    ];
    var getProtocol = function (url) {
      var protocolMatches = url.match(/^(https?:\/\/|www\.)(.+)$/i);
      if (protocolMatches && protocolMatches.length > 1) {
        return protocolMatches[1] === 'www.' ? 'https://' : protocolMatches[1];
      } else {
        return 'https://';
      }
    };
    var getUrl = function (pattern, url) {
      var protocol = getProtocol(url);
      var match = pattern.regex.exec(url);
      var newUrl = protocol + pattern.url;
      var _loop_1 = function (i) {
        newUrl = newUrl.replace('$' + i, function () {
          return match[i] ? match[i] : '';
        });
      };
      for (var i = 0; i < match.length; i++) {
        _loop_1(i);
      }
      return newUrl.replace(/\?$/, '');
    };
    var matchPattern = function (url) {
      var patterns = urlPatterns.filter(function (pattern) {
        return pattern.regex.test(url);
      });
      if (patterns.length > 0) {
        return global$8.extend({}, patterns[0], { url: getUrl(patterns[0], url) });
      } else {
        return null;
      }
    };

    var getIframeHtml = function (data) {
      var allowFullscreen = data.allowfullscreen ? ' allowFullscreen="1"' : '';
      return '<iframe src="' + data.source + '" width="' + data.width + '" height="' + data.height + '"' + allowFullscreen + '></iframe>';
    };
    var getFlashHtml = function (data) {
      var html = '<object data="' + data.source + '" width="' + data.width + '" height="' + data.height + '" type="application/x-shockwave-flash">';
      if (data.poster) {
        html += '<img src="' + data.poster + '" width="' + data.width + '" height="' + data.height + '" />';
      }
      html += '</object>';
      return html;
    };
    var getAudioHtml = function (data, audioTemplateCallback) {
      if (audioTemplateCallback) {
        return audioTemplateCallback(data);
      } else {
        return '<audio controls="controls" src="' + data.source + '">' + (data.altsource ? '\n<source src="' + data.altsource + '"' + (data.altsourcemime ? ' type="' + data.altsourcemime + '"' : '') + ' />\n' : '') + '</audio>';
      }
    };
    var getVideoHtml = function (data, videoTemplateCallback) {
      if (videoTemplateCallback) {
        return videoTemplateCallback(data);
      } else {
        return '<video width="' + data.width + '" height="' + data.height + '"' + (data.poster ? ' poster="' + data.poster + '"' : '') + ' controls="controls">\n' + '<source src="' + data.source + '"' + (data.sourcemime ? ' type="' + data.sourcemime + '"' : '') + ' />\n' + (data.altsource ? '<source src="' + data.altsource + '"' + (data.altsourcemime ? ' type="' + data.altsourcemime + '"' : '') + ' />\n' : '') + '</video>';
      }
    };
    var getScriptHtml = function (data) {
      return '<script src="' + data.source + '"></script>';
    };
    var dataToHtml = function (editor, dataIn) {
      var data = global$8.extend({}, dataIn);
      if (!data.source) {
        global$8.extend(data, htmlToData(getScripts(editor), data.embed));
        if (!data.source) {
          return '';
        }
      }
      if (!data.altsource) {
        data.altsource = '';
      }
      if (!data.poster) {
        data.poster = '';
      }
      data.source = editor.convertURL(data.source, 'source');
      data.altsource = editor.convertURL(data.altsource, 'source');
      data.sourcemime = guess(data.source);
      data.altsourcemime = guess(data.altsource);
      data.poster = editor.convertURL(data.poster, 'poster');
      var pattern = matchPattern(data.source);
      if (pattern) {
        data.source = pattern.url;
        data.type = pattern.type;
        data.allowfullscreen = pattern.allowFullscreen;
        data.width = data.width || String(pattern.w);
        data.height = data.height || String(pattern.h);
      }
      if (data.embed) {
        return updateHtml(data.embed, data, true);
      } else {
        var videoScript = getVideoScriptMatch(getScripts(editor), data.source);
        if (videoScript) {
          data.type = 'script';
          data.width = String(videoScript.width);
          data.height = String(videoScript.height);
        }
        var audioTemplateCallback = getAudioTemplateCallback(editor);
        var videoTemplateCallback = getVideoTemplateCallback(editor);
        data.width = data.width || '300';
        data.height = data.height || '150';
        global$8.each(data, function (value, key) {
          data[key] = editor.dom.encode('' + value);
        });
        if (data.type === 'iframe') {
          return getIframeHtml(data);
        } else if (data.sourcemime === 'application/x-shockwave-flash') {
          return getFlashHtml(data);
        } else if (data.sourcemime.indexOf('audio') !== -1) {
          return getAudioHtml(data, audioTemplateCallback);
        } else if (data.type === 'script') {
          return getScriptHtml(data);
        } else {
          return getVideoHtml(data, videoTemplateCallback);
        }
      }
    };

    var isMediaElement = function (element) {
      return element.hasAttribute('data-mce-object') || element.hasAttribute('data-ephox-embed-iri');
    };
    var setup$2 = function (editor) {
      editor.on('click keyup touchend', function () {
        var selectedNode = editor.selection.getNode();
        if (selectedNode && editor.dom.hasClass(selectedNode, 'mce-preview-object')) {
          if (editor.dom.getAttrib(selectedNode, 'data-mce-selected')) {
            selectedNode.setAttribute('data-mce-selected', '2');
          }
        }
      });
      editor.on('ObjectSelected', function (e) {
        var objectType = e.target.getAttribute('data-mce-object');
        if (objectType === 'script') {
          e.preventDefault();
        }
      });
      editor.on('ObjectResized', function (e) {
        var target = e.target;
        if (target.getAttribute('data-mce-object')) {
          var html = target.getAttribute('data-mce-html');
          if (html) {
            html = unescape(html);
            target.setAttribute('data-mce-html', escape(updateHtml(html, {
              width: String(e.width),
              height: String(e.height)
            })));
          }
        }
      });
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var cache = {};
    var embedPromise = function (data, dataToHtml, handler) {
      return new global$3(function (res, rej) {
        var wrappedResolve = function (response) {
          if (response.html) {
            cache[data.source] = response;
          }
          return res({
            url: data.source,
            html: response.html ? response.html : dataToHtml(data)
          });
        };
        if (cache[data.source]) {
          wrappedResolve(cache[data.source]);
        } else {
          handler({ url: data.source }, wrappedResolve, rej);
        }
      });
    };
    var defaultPromise = function (data, dataToHtml) {
      return global$3.resolve({
        html: dataToHtml(data),
        url: data.source
      });
    };
    var loadedData = function (editor) {
      return function (data) {
        return dataToHtml(editor, data);
      };
    };
    var getEmbedHtml = function (editor, data) {
      var embedHandler = getUrlResolver(editor);
      return embedHandler ? embedPromise(data, loadedData(editor), embedHandler) : defaultPromise(data, loadedData(editor));
    };
    var isCached = function (url) {
      return has(cache, url);
    };

    var extractMeta = function (sourceInput, data) {
      return get$1(data, sourceInput).bind(function (mainData) {
        return get$1(mainData, 'meta');
      });
    };
    var getValue = function (data, metaData, sourceInput) {
      return function (prop) {
        var _a;
        var getFromData = function () {
          return get$1(data, prop);
        };
        var getFromMetaData = function () {
          return get$1(metaData, prop);
        };
        var getNonEmptyValue = function (c) {
          return get$1(c, 'value').bind(function (v) {
            return v.length > 0 ? Optional.some(v) : Optional.none();
          });
        };
        var getFromValueFirst = function () {
          return getFromData().bind(function (child) {
            return isObject(child) ? getNonEmptyValue(child).orThunk(getFromMetaData) : getFromMetaData().orThunk(function () {
              return Optional.from(child);
            });
          });
        };
        var getFromMetaFirst = function () {
          return getFromMetaData().orThunk(function () {
            return getFromData().bind(function (child) {
              return isObject(child) ? getNonEmptyValue(child) : Optional.from(child);
            });
          });
        };
        return _a = {}, _a[prop] = (prop === sourceInput ? getFromValueFirst() : getFromMetaFirst()).getOr(''), _a;
      };
    };
    var getDimensions = function (data, metaData) {
      var dimensions = {};
      get$1(data, 'dimensions').each(function (dims) {
        each$1([
          'width',
          'height'
        ], function (prop) {
          get$1(metaData, prop).orThunk(function () {
            return get$1(dims, prop);
          }).each(function (value) {
            return dimensions[prop] = value;
          });
        });
      });
      return dimensions;
    };
    var unwrap = function (data, sourceInput) {
      var metaData = sourceInput ? extractMeta(sourceInput, data).getOr({}) : {};
      var get = getValue(data, metaData, sourceInput);
      return __assign(__assign(__assign(__assign(__assign({}, get('source')), get('altsource')), get('poster')), get('embed')), getDimensions(data, metaData));
    };
    var wrap = function (data) {
      var wrapped = __assign(__assign({}, data), {
        source: { value: get$1(data, 'source').getOr('') },
        altsource: { value: get$1(data, 'altsource').getOr('') },
        poster: { value: get$1(data, 'poster').getOr('') }
      });
      each$1([
        'width',
        'height'
      ], function (prop) {
        get$1(data, prop).each(function (value) {
          var dimensions = wrapped.dimensions || {};
          dimensions[prop] = value;
          wrapped.dimensions = dimensions;
        });
      });
      return wrapped;
    };
    var handleError = function (editor) {
      return function (error) {
        var errorMessage = error && error.msg ? 'Media embed handler error: ' + error.msg : 'Media embed handler threw unknown error.';
        editor.notificationManager.open({
          type: 'error',
          text: errorMessage
        });
      };
    };
    var snippetToData = function (editor, embedSnippet) {
      return htmlToData(getScripts(editor), embedSnippet);
    };
    var getEditorData = function (editor) {
      var element = editor.selection.getNode();
      var snippet = isMediaElement(element) ? editor.serializer.serialize(element, { selection: true }) : '';
      return __assign({ embed: snippet }, htmlToData(getScripts(editor), snippet));
    };
    var addEmbedHtml = function (api, editor) {
      return function (response) {
        if (isString(response.url) && response.url.trim().length > 0) {
          var html = response.html;
          var snippetData = snippetToData(editor, html);
          var nuData = __assign(__assign({}, snippetData), {
            source: response.url,
            embed: html
          });
          api.setData(wrap(nuData));
        }
      };
    };
    var selectPlaceholder = function (editor, beforeObjects) {
      var afterObjects = editor.dom.select('*[data-mce-object]');
      for (var i = 0; i < beforeObjects.length; i++) {
        for (var y = afterObjects.length - 1; y >= 0; y--) {
          if (beforeObjects[i] === afterObjects[y]) {
            afterObjects.splice(y, 1);
          }
        }
      }
      editor.selection.select(afterObjects[0]);
    };
    var handleInsert = function (editor, html) {
      var beforeObjects = editor.dom.select('*[data-mce-object]');
      editor.insertContent(html);
      selectPlaceholder(editor, beforeObjects);
      editor.nodeChanged();
    };
    var submitForm = function (prevData, newData, editor) {
      newData.embed = updateHtml(newData.embed, newData);
      if (newData.embed && (prevData.source === newData.source || isCached(newData.source))) {
        handleInsert(editor, newData.embed);
      } else {
        getEmbedHtml(editor, newData).then(function (response) {
          handleInsert(editor, response.html);
        }).catch(handleError(editor));
      }
    };
    var showDialog = function (editor) {
      var editorData = getEditorData(editor);
      var currentData = Cell(editorData);
      var initialData = wrap(editorData);
      var handleSource = function (prevData, api) {
        var serviceData = unwrap(api.getData(), 'source');
        if (prevData.source !== serviceData.source) {
          addEmbedHtml(win, editor)({
            url: serviceData.source,
            html: ''
          });
          getEmbedHtml(editor, serviceData).then(addEmbedHtml(win, editor)).catch(handleError(editor));
        }
      };
      var handleEmbed = function (api) {
        var data = unwrap(api.getData());
        var dataFromEmbed = snippetToData(editor, data.embed);
        api.setData(wrap(dataFromEmbed));
      };
      var handleUpdate = function (api, sourceInput) {
        var data = unwrap(api.getData(), sourceInput);
        var embed = dataToHtml(editor, data);
        api.setData(wrap(__assign(__assign({}, data), { embed: embed })));
      };
      var mediaInput = [{
          name: 'source',
          type: 'urlinput',
          filetype: 'media',
          label: 'Source'
        }];
      var sizeInput = !hasDimensions(editor) ? [] : [{
          type: 'sizeinput',
          name: 'dimensions',
          label: 'Constrain proportions',
          constrain: true
        }];
      var generalTab = {
        title: 'General',
        name: 'general',
        items: flatten([
          mediaInput,
          sizeInput
        ])
      };
      var embedTextarea = {
        type: 'textarea',
        name: 'embed',
        label: 'Paste your embed code below:'
      };
      var embedTab = {
        title: 'Embed',
        items: [embedTextarea]
      };
      var advancedFormItems = [];
      if (hasAltSource(editor)) {
        advancedFormItems.push({
          name: 'altsource',
          type: 'urlinput',
          filetype: 'media',
          label: 'Alternative source URL'
        });
      }
      if (hasPoster(editor)) {
        advancedFormItems.push({
          name: 'poster',
          type: 'urlinput',
          filetype: 'image',
          label: 'Media poster (Image URL)'
        });
      }
      var advancedTab = {
        title: 'Advanced',
        name: 'advanced',
        items: advancedFormItems
      };
      var tabs = [
        generalTab,
        embedTab
      ];
      if (advancedFormItems.length > 0) {
        tabs.push(advancedTab);
      }
      var body = {
        type: 'tabpanel',
        tabs: tabs
      };
      var win = editor.windowManager.open({
        title: 'Insert/Edit Media',
        size: 'normal',
        body: body,
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        onSubmit: function (api) {
          var serviceData = unwrap(api.getData());
          submitForm(currentData.get(), serviceData, editor);
          api.close();
        },
        onChange: function (api, detail) {
          switch (detail.name) {
          case 'source':
            handleSource(currentData.get(), api);
            break;
          case 'embed':
            handleEmbed(api);
            break;
          case 'dimensions':
          case 'altsource':
          case 'poster':
            handleUpdate(api, detail.name);
            break;
          }
          currentData.set(unwrap(api.getData()));
        },
        initialData: initialData
      });
    };

    var get = function (editor) {
      var showDialog$1 = function () {
        showDialog(editor);
      };
      return { showDialog: showDialog$1 };
    };

    var register$1 = function (editor) {
      var showDialog$1 = function () {
        showDialog(editor);
      };
      editor.addCommand('mceMedia', showDialog$1);
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.html.Node');

    var global$1 = tinymce.util.Tools.resolve('tinymce.Env');

    var global = tinymce.util.Tools.resolve('tinymce.html.DomParser');

    var sanitize = function (editor, html) {
      if (shouldFilterHtml(editor) === false) {
        return html;
      }
      var writer = global$4();
      var blocked;
      global$6({
        validate: false,
        allow_conditional_comments: false,
        comment: function (text) {
          if (!blocked) {
            writer.comment(text);
          }
        },
        cdata: function (text) {
          if (!blocked) {
            writer.cdata(text);
          }
        },
        text: function (text, raw) {
          if (!blocked) {
            writer.text(text, raw);
          }
        },
        start: function (name, attrs, empty) {
          blocked = true;
          if (name === 'script' || name === 'noscript' || name === 'svg') {
            return;
          }
          for (var i = attrs.length - 1; i >= 0; i--) {
            var attrName = attrs[i].name;
            if (attrName.indexOf('on') === 0) {
              delete attrs.map[attrName];
              attrs.splice(i, 1);
            }
            if (attrName === 'style') {
              attrs[i].value = editor.dom.serializeStyle(editor.dom.parseStyle(attrs[i].value), name);
            }
          }
          writer.start(name, attrs, empty);
          blocked = false;
        },
        end: function (name) {
          if (blocked) {
            return;
          }
          writer.end(name);
        }
      }, global$5({})).parse(html);
      return writer.getContent();
    };

    var isLiveEmbedNode = function (node) {
      var name = node.name;
      return name === 'iframe' || name === 'video' || name === 'audio';
    };
    var getDimension = function (node, styles, dimension, defaultValue) {
      if (defaultValue === void 0) {
        defaultValue = null;
      }
      var value = node.attr(dimension);
      if (isNonNullable(value)) {
        return value;
      } else if (!has(styles, dimension)) {
        return defaultValue;
      } else {
        return null;
      }
    };
    var setDimensions = function (node, previewNode, styles) {
      var useDefaults = previewNode.name === 'img' || node.name === 'video';
      var defaultWidth = useDefaults ? '300' : null;
      var fallbackHeight = node.name === 'audio' ? '30' : '150';
      var defaultHeight = useDefaults ? fallbackHeight : null;
      previewNode.attr({
        width: getDimension(node, styles, 'width', defaultWidth),
        height: getDimension(node, styles, 'height', defaultHeight)
      });
    };
    var appendNodeContent = function (editor, nodeName, previewNode, html) {
      var newNode = global({
        forced_root_block: false,
        validate: false
      }, editor.schema).parse(html, { context: nodeName });
      while (newNode.firstChild) {
        previewNode.append(newNode.firstChild);
      }
    };
    var createPlaceholderNode = function (editor, node) {
      var name = node.name;
      var placeHolder = new global$2('img', 1);
      placeHolder.shortEnded = true;
      retainAttributesAndInnerHtml(editor, node, placeHolder);
      setDimensions(node, placeHolder, {});
      placeHolder.attr({
        'style': node.attr('style'),
        'src': global$1.transparentSrc,
        'data-mce-object': name,
        'class': 'mce-object mce-object-' + name
      });
      return placeHolder;
    };
    var createPreviewNode = function (editor, node) {
      var name = node.name;
      var previewWrapper = new global$2('span', 1);
      previewWrapper.attr({
        'contentEditable': 'false',
        'style': node.attr('style'),
        'data-mce-object': name,
        'class': 'mce-preview-object mce-object-' + name
      });
      retainAttributesAndInnerHtml(editor, node, previewWrapper);
      var styles = editor.dom.parseStyle(node.attr('style'));
      var previewNode = new global$2(name, 1);
      setDimensions(node, previewNode, styles);
      previewNode.attr({
        src: node.attr('src'),
        style: node.attr('style'),
        class: node.attr('class')
      });
      if (name === 'iframe') {
        previewNode.attr({
          allowfullscreen: node.attr('allowfullscreen'),
          frameborder: '0'
        });
      } else {
        var attrs = [
          'controls',
          'crossorigin',
          'currentTime',
          'loop',
          'muted',
          'poster',
          'preload'
        ];
        each$1(attrs, function (attrName) {
          previewNode.attr(attrName, node.attr(attrName));
        });
        var sanitizedHtml = previewWrapper.attr('data-mce-html');
        if (isNonNullable(sanitizedHtml)) {
          appendNodeContent(editor, name, previewNode, unescape(sanitizedHtml));
        }
      }
      var shimNode = new global$2('span', 1);
      shimNode.attr('class', 'mce-shim');
      previewWrapper.append(previewNode);
      previewWrapper.append(shimNode);
      return previewWrapper;
    };
    var retainAttributesAndInnerHtml = function (editor, sourceNode, targetNode) {
      var attribs = sourceNode.attributes;
      var ai = attribs.length;
      while (ai--) {
        var attrName = attribs[ai].name;
        var attrValue = attribs[ai].value;
        if (attrName !== 'width' && attrName !== 'height' && attrName !== 'style') {
          if (attrName === 'data' || attrName === 'src') {
            attrValue = editor.convertURL(attrValue, attrName);
          }
          targetNode.attr('data-mce-p-' + attrName, attrValue);
        }
      }
      var innerHtml = sourceNode.firstChild && sourceNode.firstChild.value;
      if (innerHtml) {
        targetNode.attr('data-mce-html', escape(sanitize(editor, innerHtml)));
        targetNode.firstChild = null;
      }
    };
    var isPageEmbedWrapper = function (node) {
      var nodeClass = node.attr('class');
      return nodeClass && /\btiny-pageembed\b/.test(nodeClass);
    };
    var isWithinEmbedWrapper = function (node) {
      while (node = node.parent) {
        if (node.attr('data-ephox-embed-iri') || isPageEmbedWrapper(node)) {
          return true;
        }
      }
      return false;
    };
    var placeHolderConverter = function (editor) {
      return function (nodes) {
        var i = nodes.length;
        var node;
        var videoScript;
        while (i--) {
          node = nodes[i];
          if (!node.parent) {
            continue;
          }
          if (node.parent.attr('data-mce-object')) {
            continue;
          }
          if (node.name === 'script') {
            videoScript = getVideoScriptMatch(getScripts(editor), node.attr('src'));
            if (!videoScript) {
              continue;
            }
          }
          if (videoScript) {
            if (videoScript.width) {
              node.attr('width', videoScript.width.toString());
            }
            if (videoScript.height) {
              node.attr('height', videoScript.height.toString());
            }
          }
          if (isLiveEmbedNode(node) && hasLiveEmbeds(editor) && global$1.ceFalse) {
            if (!isWithinEmbedWrapper(node)) {
              node.replace(createPreviewNode(editor, node));
            }
          } else {
            if (!isWithinEmbedWrapper(node)) {
              node.replace(createPlaceholderNode(editor, node));
            }
          }
        }
      };
    };

    var setup$1 = function (editor) {
      editor.on('preInit', function () {
        var specialElements = editor.schema.getSpecialElements();
        global$8.each('video audio iframe object'.split(' '), function (name) {
          specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
        });
        var boolAttrs = editor.schema.getBoolAttrs();
        global$8.each('webkitallowfullscreen mozallowfullscreen allowfullscreen'.split(' '), function (name) {
          boolAttrs[name] = {};
        });
        editor.parser.addNodeFilter('iframe,video,audio,object,embed,script', placeHolderConverter(editor));
        editor.serializer.addAttributeFilter('data-mce-object', function (nodes, name) {
          var i = nodes.length;
          var node;
          var realElm;
          var ai;
          var attribs;
          var innerHtml;
          var innerNode;
          var realElmName;
          var className;
          while (i--) {
            node = nodes[i];
            if (!node.parent) {
              continue;
            }
            realElmName = node.attr(name);
            realElm = new global$2(realElmName, 1);
            if (realElmName !== 'audio' && realElmName !== 'script') {
              className = node.attr('class');
              if (className && className.indexOf('mce-preview-object') !== -1) {
                realElm.attr({
                  width: node.firstChild.attr('width'),
                  height: node.firstChild.attr('height')
                });
              } else {
                realElm.attr({
                  width: node.attr('width'),
                  height: node.attr('height')
                });
              }
            }
            realElm.attr({ style: node.attr('style') });
            attribs = node.attributes;
            ai = attribs.length;
            while (ai--) {
              var attrName = attribs[ai].name;
              if (attrName.indexOf('data-mce-p-') === 0) {
                realElm.attr(attrName.substr(11), attribs[ai].value);
              }
            }
            if (realElmName === 'script') {
              realElm.attr('type', 'text/javascript');
            }
            innerHtml = node.attr('data-mce-html');
            if (innerHtml) {
              innerNode = new global$2('#text', 3);
              innerNode.raw = true;
              innerNode.value = sanitize(editor, unescape(innerHtml));
              realElm.append(innerNode);
            }
            node.replace(realElm);
          }
        });
      });
      editor.on('SetContent', function () {
        editor.$('span.mce-preview-object').each(function (index, elm) {
          var $elm = editor.$(elm);
          if ($elm.find('span.mce-shim').length === 0) {
            $elm.append('<span class="mce-shim"></span>');
          }
        });
      });
    };

    var setup = function (editor) {
      editor.on('ResolveName', function (e) {
        var name;
        if (e.target.nodeType === 1 && (name = e.target.getAttribute('data-mce-object'))) {
          e.name = name;
        }
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceMedia');
      };
      editor.ui.registry.addToggleButton('media', {
        tooltip: 'Insert/edit media',
        icon: 'embed',
        onAction: onAction,
        onSetup: function (buttonApi) {
          var selection = editor.selection;
          buttonApi.setActive(isMediaElement(selection.getNode()));
          return selection.selectorChangedWithUnbind('img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]', buttonApi.setActive).unbind;
        }
      });
      editor.ui.registry.addMenuItem('media', {
        icon: 'embed',
        text: 'Media...',
        onAction: onAction
      });
    };

    function Plugin () {
      global$9.add('media', function (editor) {
        register$1(editor);
        register(editor);
        setup(editor);
        setup$1(editor);
        setup$2(editor);
        return get(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "2cf9":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "link" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/link')
//   ES2015:
//     import 'tinymce/plugins/link'
__webpack_require__("209c4");

/***/ }),

/***/ "2eae":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "emoticons" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/emoticons')
//   ES2015:
//     import 'tinymce/plugins/emoticons'
__webpack_require__("a7fd");

/***/ }),

/***/ "30df":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "hr" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/hr')
//   ES2015:
//     import 'tinymce/plugins/hr'
__webpack_require__("9005");

/***/ }),

/***/ "3205":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var getKeyboardSpaces = function (editor) {
      var spaces = editor.getParam('nonbreaking_force_tab', 0);
      if (typeof spaces === 'boolean') {
        return spaces === true ? 3 : 0;
      } else {
        return spaces;
      }
    };
    var wrapNbsps = function (editor) {
      return editor.getParam('nonbreaking_wrap', true, 'boolean');
    };

    var stringRepeat = function (string, repeats) {
      var str = '';
      for (var index = 0; index < repeats; index++) {
        str += string;
      }
      return str;
    };
    var isVisualCharsEnabled = function (editor) {
      return editor.plugins.visualchars ? editor.plugins.visualchars.isEnabled() : false;
    };
    var insertNbsp = function (editor, times) {
      var classes = function () {
        return isVisualCharsEnabled(editor) ? 'mce-nbsp-wrap mce-nbsp' : 'mce-nbsp-wrap';
      };
      var nbspSpan = function () {
        return '<span class="' + classes() + '" contenteditable="false">' + stringRepeat('&nbsp;', times) + '</span>';
      };
      var shouldWrap = wrapNbsps(editor);
      var html = shouldWrap || editor.plugins.visualchars ? nbspSpan() : stringRepeat('&nbsp;', times);
      editor.undoManager.transact(function () {
        return editor.insertContent(html);
      });
    };

    var register$1 = function (editor) {
      editor.addCommand('mceNonBreaking', function () {
        insertNbsp(editor, 1);
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.VK');

    var setup = function (editor) {
      var spaces = getKeyboardSpaces(editor);
      if (spaces > 0) {
        editor.on('keydown', function (e) {
          if (e.keyCode === global.TAB && !e.isDefaultPrevented()) {
            if (e.shiftKey) {
              return;
            }
            e.preventDefault();
            e.stopImmediatePropagation();
            insertNbsp(editor, spaces);
          }
        });
      }
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceNonBreaking');
      };
      editor.ui.registry.addButton('nonbreaking', {
        icon: 'non-breaking',
        tooltip: 'Nonbreaking space',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('nonbreaking', {
        icon: 'non-breaking',
        text: 'Nonbreaking space',
        onAction: onAction
      });
    };

    function Plugin () {
      global$1.add('nonbreaking', function (editor) {
        register$1(editor);
        register(editor);
        setup(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "33b6":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var get$2 = function (toggleState) {
      var isEnabled = function () {
        return toggleState.get();
      };
      return { isEnabled: isEnabled };
    };

    var fireVisualChars = function (editor, state) {
      return editor.fire('VisualChars', { state: state });
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isString = isType$1('string');
    var isBoolean = isSimpleType('boolean');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var filter = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };

    var keys = Object.keys;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var TEXT = 3;

    var type = function (element) {
      return element.dom.nodeType;
    };
    var value = function (element) {
      return element.dom.nodeValue;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isText = isType(TEXT);

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var get$1 = function (element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    var remove$3 = function (element, key) {
      element.dom.removeAttribute(key);
    };

    var read = function (element, attr) {
      var value = get$1(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    var add$2 = function (element, attr, id) {
      var old = read(element, attr);
      var nu = old.concat([id]);
      set(element, attr, nu.join(' '));
      return true;
    };
    var remove$2 = function (element, attr, id) {
      var nu = filter(read(element, attr), function (v) {
        return v !== id;
      });
      if (nu.length > 0) {
        set(element, attr, nu.join(' '));
      } else {
        remove$3(element, attr);
      }
      return false;
    };

    var supports = function (element) {
      return element.dom.classList !== undefined;
    };
    var get = function (element) {
      return read(element, 'class');
    };
    var add$1 = function (element, clazz) {
      return add$2(element, 'class', clazz);
    };
    var remove$1 = function (element, clazz) {
      return remove$2(element, 'class', clazz);
    };

    var add = function (element, clazz) {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$1(element, clazz);
      }
    };
    var cleanClass = function (element) {
      var classList = supports(element) ? element.dom.classList : get(element);
      if (classList.length === 0) {
        remove$3(element, 'class');
      }
    };
    var remove = function (element, clazz) {
      if (supports(element)) {
        var classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$1(element, clazz);
      }
      cleanClass(element);
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    var charMap = {
      '\xA0': 'nbsp',
      '\xAD': 'shy'
    };
    var charMapToRegExp = function (charMap, global) {
      var regExp = '';
      each(charMap, function (_value, key) {
        regExp += key;
      });
      return new RegExp('[' + regExp + ']', global ? 'g' : '');
    };
    var charMapToSelector = function (charMap) {
      var selector = '';
      each(charMap, function (value) {
        if (selector) {
          selector += ',';
        }
        selector += 'span.mce-' + value;
      });
      return selector;
    };
    var regExp = charMapToRegExp(charMap);
    var regExpGlobal = charMapToRegExp(charMap, true);
    var selector = charMapToSelector(charMap);
    var nbspClass = 'mce-nbsp';

    var wrapCharWithSpan = function (value) {
      return '<span data-mce-bogus="1" class="mce-' + charMap[value] + '">' + value + '</span>';
    };

    var isMatch = function (n) {
      var value$1 = value(n);
      return isText(n) && value$1 !== undefined && regExp.test(value$1);
    };
    var filterDescendants = function (scope, predicate) {
      var result = [];
      var dom = scope.dom;
      var children = map(dom.childNodes, SugarElement.fromDom);
      each$1(children, function (x) {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(filterDescendants(x, predicate));
      });
      return result;
    };
    var findParentElm = function (elm, rootElm) {
      while (elm.parentNode) {
        if (elm.parentNode === rootElm) {
          return elm;
        }
        elm = elm.parentNode;
      }
    };
    var replaceWithSpans = function (text) {
      return text.replace(regExpGlobal, wrapCharWithSpan);
    };

    var isWrappedNbsp = function (node) {
      return node.nodeName.toLowerCase() === 'span' && node.classList.contains('mce-nbsp-wrap');
    };
    var show = function (editor, rootElm) {
      var nodeList = filterDescendants(SugarElement.fromDom(rootElm), isMatch);
      each$1(nodeList, function (n) {
        var parent = n.dom.parentNode;
        if (isWrappedNbsp(parent)) {
          add(SugarElement.fromDom(parent), nbspClass);
        } else {
          var withSpans = replaceWithSpans(editor.dom.encode(value(n)));
          var div = editor.dom.create('div', null, withSpans);
          var node = void 0;
          while (node = div.lastChild) {
            editor.dom.insertAfter(node, n.dom);
          }
          editor.dom.remove(n.dom);
        }
      });
    };
    var hide = function (editor, rootElm) {
      var nodeList = editor.dom.select(selector, rootElm);
      each$1(nodeList, function (node) {
        if (isWrappedNbsp(node)) {
          remove(SugarElement.fromDom(node), nbspClass);
        } else {
          editor.dom.remove(node, true);
        }
      });
    };
    var toggle = function (editor) {
      var body = editor.getBody();
      var bookmark = editor.selection.getBookmark();
      var parentNode = findParentElm(editor.selection.getNode(), body);
      parentNode = parentNode !== undefined ? parentNode : body;
      hide(editor, parentNode);
      show(editor, parentNode);
      editor.selection.moveToBookmark(bookmark);
    };

    var applyVisualChars = function (editor, toggleState) {
      fireVisualChars(editor, toggleState.get());
      var body = editor.getBody();
      if (toggleState.get() === true) {
        show(editor, body);
      } else {
        hide(editor, body);
      }
    };
    var toggleVisualChars = function (editor, toggleState) {
      toggleState.set(!toggleState.get());
      var bookmark = editor.selection.getBookmark();
      applyVisualChars(editor, toggleState);
      editor.selection.moveToBookmark(bookmark);
    };

    var register$1 = function (editor, toggleState) {
      editor.addCommand('mceVisualChars', function () {
        toggleVisualChars(editor, toggleState);
      });
    };

    var isEnabledByDefault = function (editor) {
      return editor.getParam('visualchars_default_state', false);
    };
    var hasForcedRootBlock = function (editor) {
      return editor.getParam('forced_root_block') !== false;
    };

    var setup$1 = function (editor, toggleState) {
      editor.on('init', function () {
        applyVisualChars(editor, toggleState);
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var setup = function (editor, toggleState) {
      var debouncedToggle = global.debounce(function () {
        toggle(editor);
      }, 300);
      if (hasForcedRootBlock(editor)) {
        editor.on('keydown', function (e) {
          if (toggleState.get() === true) {
            e.keyCode === 13 ? toggle(editor) : debouncedToggle();
          }
        });
      }
      editor.on('remove', debouncedToggle.stop);
    };

    var toggleActiveState = function (editor, enabledStated) {
      return function (api) {
        api.setActive(enabledStated.get());
        var editorEventCallback = function (e) {
          return api.setActive(e.state);
        };
        editor.on('VisualChars', editorEventCallback);
        return function () {
          return editor.off('VisualChars', editorEventCallback);
        };
      };
    };
    var register = function (editor, toggleState) {
      var onAction = function () {
        return editor.execCommand('mceVisualChars');
      };
      editor.ui.registry.addToggleButton('visualchars', {
        tooltip: 'Show invisible characters',
        icon: 'visualchars',
        onAction: onAction,
        onSetup: toggleActiveState(editor, toggleState)
      });
      editor.ui.registry.addToggleMenuItem('visualchars', {
        text: 'Show invisible characters',
        icon: 'visualchars',
        onAction: onAction,
        onSetup: toggleActiveState(editor, toggleState)
      });
    };

    function Plugin () {
      global$1.add('visualchars', function (editor) {
        var toggleState = Cell(isEnabledByDefault(editor));
        register$1(editor, toggleState);
        register(editor, toggleState);
        setup(editor, toggleState);
        setup$1(editor, toggleState);
        return get$2(toggleState);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "3753":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "visualblocks" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/visualblocks')
//   ES2015:
//     import 'tinymce/plugins/visualblocks'
__webpack_require__("38a4");

/***/ }),

/***/ "38a4":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var fireVisualBlocks = function (editor, state) {
      editor.fire('VisualBlocks', { state: state });
    };

    var toggleVisualBlocks = function (editor, pluginUrl, enabledState) {
      var dom = editor.dom;
      dom.toggleClass(editor.getBody(), 'mce-visualblocks');
      enabledState.set(!enabledState.get());
      fireVisualBlocks(editor, enabledState.get());
    };

    var register$1 = function (editor, pluginUrl, enabledState) {
      editor.addCommand('mceVisualBlocks', function () {
        toggleVisualBlocks(editor, pluginUrl, enabledState);
      });
    };

    var isEnabledByDefault = function (editor) {
      return editor.getParam('visualblocks_default_state', false, 'boolean');
    };

    var setup = function (editor, pluginUrl, enabledState) {
      editor.on('PreviewFormats AfterPreviewFormats', function (e) {
        if (enabledState.get()) {
          editor.dom.toggleClass(editor.getBody(), 'mce-visualblocks', e.type === 'afterpreviewformats');
        }
      });
      editor.on('init', function () {
        if (isEnabledByDefault(editor)) {
          toggleVisualBlocks(editor, pluginUrl, enabledState);
        }
      });
    };

    var toggleActiveState = function (editor, enabledState) {
      return function (api) {
        api.setActive(enabledState.get());
        var editorEventCallback = function (e) {
          return api.setActive(e.state);
        };
        editor.on('VisualBlocks', editorEventCallback);
        return function () {
          return editor.off('VisualBlocks', editorEventCallback);
        };
      };
    };
    var register = function (editor, enabledState) {
      var onAction = function () {
        return editor.execCommand('mceVisualBlocks');
      };
      editor.ui.registry.addToggleButton('visualblocks', {
        icon: 'visualblocks',
        tooltip: 'Show blocks',
        onAction: onAction,
        onSetup: toggleActiveState(editor, enabledState)
      });
      editor.ui.registry.addToggleMenuItem('visualblocks', {
        text: 'Show blocks',
        icon: 'visualblocks',
        onAction: onAction,
        onSetup: toggleActiveState(editor, enabledState)
      });
    };

    function Plugin () {
      global.add('visualblocks', function (editor, pluginUrl) {
        var enabledState = Cell(false);
        register$1(editor, pluginUrl, enabledState);
        register(editor, enabledState);
        setup(editor, pluginUrl, enabledState);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "3979":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "charmap" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/charmap')
//   ES2015:
//     import 'tinymce/plugins/charmap'
__webpack_require__("8d66");

/***/ }),

/***/ "4948":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$2 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var global$1 = tinymce.util.Tools.resolve('tinymce.Env');

    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getContentStyle = function (editor) {
      return editor.getParam('content_style', '', 'string');
    };
    var shouldUseContentCssCors = function (editor) {
      return editor.getParam('content_css_cors', false, 'boolean');
    };
    var getBodyClassByHash = function (editor) {
      var bodyClass = editor.getParam('body_class', '', 'hash');
      return bodyClass[editor.id] || '';
    };
    var getBodyClass = function (editor) {
      var bodyClass = editor.getParam('body_class', '', 'string');
      if (bodyClass.indexOf('=') === -1) {
        return bodyClass;
      } else {
        return getBodyClassByHash(editor);
      }
    };
    var getBodyIdByHash = function (editor) {
      var bodyId = editor.getParam('body_id', '', 'hash');
      return bodyId[editor.id] || bodyId;
    };
    var getBodyId = function (editor) {
      var bodyId = editor.getParam('body_id', 'tinymce', 'string');
      if (bodyId.indexOf('=') === -1) {
        return bodyId;
      } else {
        return getBodyIdByHash(editor);
      }
    };

    var getPreviewHtml = function (editor) {
      var headHtml = '';
      var encode = editor.dom.encode;
      var contentStyle = getContentStyle(editor);
      headHtml += '<base href="' + encode(editor.documentBaseURI.getURI()) + '">';
      var cors = shouldUseContentCssCors(editor) ? ' crossorigin="anonymous"' : '';
      global.each(editor.contentCSS, function (url) {
        headHtml += '<link type="text/css" rel="stylesheet" href="' + encode(editor.documentBaseURI.toAbsolute(url)) + '"' + cors + '>';
      });
      if (contentStyle) {
        headHtml += '<style type="text/css">' + contentStyle + '</style>';
      }
      var bodyId = getBodyId(editor);
      var bodyClass = getBodyClass(editor);
      var isMetaKeyPressed = global$1.mac ? 'e.metaKey' : 'e.ctrlKey && !e.altKey';
      var preventClicksOnLinksScript = '<script>' + 'document.addEventListener && document.addEventListener("click", function(e) {' + 'for (var elm = e.target; elm; elm = elm.parentNode) {' + 'if (elm.nodeName === "A" && !(' + isMetaKeyPressed + ')) {' + 'e.preventDefault();' + '}' + '}' + '}, false);' + '</script> ';
      var directionality = editor.getBody().dir;
      var dirAttr = directionality ? ' dir="' + encode(directionality) + '"' : '';
      var previewHtml = '<!DOCTYPE html>' + '<html>' + '<head>' + headHtml + '</head>' + '<body id="' + encode(bodyId) + '" class="mce-content-body ' + encode(bodyClass) + '"' + dirAttr + '>' + editor.getContent() + preventClicksOnLinksScript + '</body>' + '</html>';
      return previewHtml;
    };

    var open = function (editor) {
      var content = getPreviewHtml(editor);
      var dataApi = editor.windowManager.open({
        title: 'Preview',
        size: 'large',
        body: {
          type: 'panel',
          items: [{
              name: 'preview',
              type: 'iframe',
              sandboxed: true
            }]
        },
        buttons: [{
            type: 'cancel',
            name: 'close',
            text: 'Close',
            primary: true
          }],
        initialData: { preview: content }
      });
      dataApi.focus('close');
    };

    var register$1 = function (editor) {
      editor.addCommand('mcePreview', function () {
        open(editor);
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mcePreview');
      };
      editor.ui.registry.addButton('preview', {
        icon: 'preview',
        tooltip: 'Preview',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('preview', {
        icon: 'preview',
        text: 'Preview',
        onAction: onAction
      });
    };

    function Plugin () {
      global$2.add('preview', function (editor) {
        register$1(editor);
        register(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "4a84":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "autolink" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/autolink')
//   ES2015:
//     import 'tinymce/plugins/autolink'
__webpack_require__("b9b0");

/***/ }),

/***/ "4b10":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "anchor" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/anchor')
//   ES2015:
//     import 'tinymce/plugins/anchor'
__webpack_require__("c34e");

/***/ }),

/***/ "4b46":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("6b14");
var react_1 = (0, tslib_1.__importDefault)(__webpack_require__("9cd5"));
// Import TinyMCE
// @ts-ignore
var tinymce_1 = (0, tslib_1.__importDefault)(__webpack_require__("bc75"));
// A theme is also required
__webpack_require__("6230");
__webpack_require__("4efa");
__webpack_require__("1ac6");
// Any plugins you want to use has to be imported
__webpack_require__("ebd6");
__webpack_require__("4a84");
__webpack_require__("75b5");
__webpack_require__("2cf9");
__webpack_require__("8e0d");
__webpack_require__("3979");
__webpack_require__("daed");
__webpack_require__("f016");
__webpack_require__("4b10");
__webpack_require__("8e2c");
__webpack_require__("3753");
__webpack_require__("51cc");
__webpack_require__("e2b6");
__webpack_require__("0269");
__webpack_require__("9156");
__webpack_require__("267b");
__webpack_require__("9c16");
__webpack_require__("d85a");
__webpack_require__("58e6");
__webpack_require__("30df");
__webpack_require__("550c");
__webpack_require__("2292");
__webpack_require__("75d5");
__webpack_require__("9153");
__webpack_require__("2eae");
__webpack_require__("eac6");
var TinymceEditor = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(TinymceEditor, _super);
    function TinymceEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.elementRef = react_1.default.createRef();
        return _this;
    }
    TinymceEditor.prototype.componentDidMount = function () {
        var _this = this;
        var locale = this.props.locale;
        this.config = (0, tslib_1.__assign)((0, tslib_1.__assign)({ inline: false, skin: false, content_css: false, height: 400, language: !locale || locale === 'zh-CN' ? 'zh_CN' : 'en', plugins: [
                'advlist autolink link image lists charmap print preview hr anchor pagebreak',
                'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking',
                'table emoticons template paste help'
            ], toolbar: 'undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | ' +
                'bullist numlist outdent indent | link image | print preview media fullpage | ' +
                'forecolor backcolor emoticons | help', menu: {
                file: {
                    title: 'File',
                    items: 'newdocument restoredraft | preview | print '
                },
                edit: {
                    title: 'Edit',
                    items: 'undo redo | cut copy paste | selectall | searchreplace'
                },
                view: {
                    title: 'View',
                    items: 'code | visualaid visualchars visualblocks | preview fullscreen'
                },
                insert: {
                    title: 'Insert',
                    items: 'image link media template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime'
                },
                format: {
                    title: 'Format',
                    items: 'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align | forecolor backcolor | removeformat'
                },
                tools: {
                    title: 'Tools',
                    items: 'code wordcount'
                },
                table: {
                    title: 'Table',
                    items: 'inserttable | cell row column | tableprops deletetable'
                },
                help: { title: 'Help', items: 'help' }
            }, paste_data_images: true }, this.props.config), { target: this.elementRef.current, readOnly: this.props.disabled, setup: function (editor) {
                _this.editor = editor;
                editor.on('init', function (e) {
                    _this.initEditor(e, editor);
                });
            } });
        tinymce_1.default.init(this.config);
    };
    TinymceEditor.prototype.componentDidUpdate = function (prevProps) {
        var _a;
        var props = this.props;
        if (props.model !== prevProps.model &&
            props.model !== this.currentContent) {
            (_a = this.editor) === null || _a === void 0 ? void 0 : _a.setContent(props.model || '');
        }
    };
    TinymceEditor.prototype.componentWillUnmount = function () {
        tinymce_1.default.remove(this.editor);
    };
    TinymceEditor.prototype.initEditor = function (e, editor) {
        var _this = this;
        var _a = this.props, model = _a.model, onModelChange = _a.onModelChange, outputFormat = _a.outputFormat, onFocus = _a.onFocus, onBlur = _a.onBlur;
        var value = model || '';
        editor.setContent(value);
        if (onModelChange) {
            editor.on('change keyup setcontent', function (e) {
                var newContent = editor.getContent({ format: outputFormat });
                if (newContent !== _this.currentContent) {
                    _this.currentContent = newContent;
                    onModelChange(newContent);
                }
            });
        }
        onFocus && editor.on('focus', onFocus);
        onBlur && editor.on('blur', onBlur);
    };
    TinymceEditor.prototype.render = function () {
        return react_1.default.createElement("textarea", { ref: this.elementRef });
    };
    TinymceEditor.defaultProps = {
        outputFormat: 'html'
    };
    return TinymceEditor;
}(react_1.default.Component));
exports.default = TinymceEditor;
tinymce_1.default.addI18n('zh_CN', {
    'Redo': '\u91cd\u505a',
    'Undo': '\u64a4\u9500',
    'Cut': '\u526a\u5207',
    'Copy': '\u590d\u5236',
    'Paste': '\u7c98\u8d34',
    'Select all': '\u5168\u9009',
    'New document': '\u65b0\u6587\u4ef6',
    'Ok': '\u786e\u5b9a',
    'Cancel': '\u53d6\u6d88',
    'Visual aids': '\u7f51\u683c\u7ebf',
    'Bold': '\u7c97\u4f53',
    'Italic': '\u659c\u4f53',
    'Underline': '\u4e0b\u5212\u7ebf',
    'Strikethrough': '\u5220\u9664\u7ebf',
    'Superscript': '\u4e0a\u6807',
    'Subscript': '\u4e0b\u6807',
    'Clear formatting': '\u6e05\u9664\u683c\u5f0f',
    'Align left': '\u5de6\u8fb9\u5bf9\u9f50',
    'Align center': '\u4e2d\u95f4\u5bf9\u9f50',
    'Align right': '\u53f3\u8fb9\u5bf9\u9f50',
    'Justify': '\u4e24\u7aef\u5bf9\u9f50',
    'Bullet list': '\u9879\u76ee\u7b26\u53f7',
    'Numbered list': '\u7f16\u53f7\u5217\u8868',
    'Decrease indent': '\u51cf\u5c11\u7f29\u8fdb',
    'Increase indent': '\u589e\u52a0\u7f29\u8fdb',
    'Close': '\u5173\u95ed',
    'Formats': '\u683c\u5f0f',
    "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": '\u4f60\u7684\u6d4f\u89c8\u5668\u4e0d\u652f\u6301\u6253\u5f00\u526a\u8d34\u677f\uff0c\u8bf7\u4f7f\u7528Ctrl+X/C/V\u7b49\u5feb\u6377\u952e\u3002',
    'Headers': '\u6807\u9898',
    'Header 1': '\u6807\u98981',
    'Header 2': '\u6807\u98982',
    'Header 3': '\u6807\u98983',
    'Header 4': '\u6807\u98984',
    'Header 5': '\u6807\u98985',
    'Header 6': '\u6807\u98986',
    'Headings': '\u6807\u9898',
    'Heading 1': '\u6807\u98981',
    'Heading 2': '\u6807\u98982',
    'Heading 3': '\u6807\u98983',
    'Heading 4': '\u6807\u98984',
    'Heading 5': '\u6807\u98985',
    'Heading 6': '\u6807\u98986',
    'Preformatted': '\u9884\u5148\u683c\u5f0f\u5316\u7684',
    'Div': 'Div',
    'Pre': 'Pre',
    'Code': '\u4ee3\u7801',
    'Paragraph': '\u6bb5\u843d',
    'Blockquote': '\u5f15\u6587\u533a\u5757',
    'Inline': '\u6587\u672c',
    'Blocks': '\u57fa\u5757',
    'Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.': '\u5f53\u524d\u4e3a\u7eaf\u6587\u672c\u7c98\u8d34\u6a21\u5f0f\uff0c\u518d\u6b21\u70b9\u51fb\u53ef\u4ee5\u56de\u5230\u666e\u901a\u7c98\u8d34\u6a21\u5f0f\u3002',
    'Fonts': '\u5b57\u4f53',
    'Font Sizes': '\u5b57\u53f7',
    'Class': '\u7c7b\u578b',
    'Browse for an image': '\u6d4f\u89c8\u56fe\u50cf',
    'OR': '\u6216',
    'Drop an image here': '\u62d6\u653e\u4e00\u5f20\u56fe\u50cf\u81f3\u6b64',
    'Upload': '\u4e0a\u4f20',
    'Block': '\u5757',
    'Align': '\u5bf9\u9f50',
    'Default': '\u9ed8\u8ba4',
    'Circle': '\u7a7a\u5fc3\u5706',
    'Disc': '\u5b9e\u5fc3\u5706',
    'Square': '\u65b9\u5757',
    'Lower Alpha': '\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd',
    'Lower Greek': '\u5c0f\u5199\u5e0c\u814a\u5b57\u6bcd',
    'Lower Roman': '\u5c0f\u5199\u7f57\u9a6c\u5b57\u6bcd',
    'Upper Alpha': '\u5927\u5199\u82f1\u6587\u5b57\u6bcd',
    'Upper Roman': '\u5927\u5199\u7f57\u9a6c\u5b57\u6bcd',
    'Anchor...': '\u951a\u70b9...',
    'Name': '\u540d\u79f0',
    'Id': '\u6807\u8bc6\u7b26',
    'Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.': '\u6807\u8bc6\u7b26\u5e94\u8be5\u4ee5\u5b57\u6bcd\u5f00\u5934\uff0c\u540e\u8ddf\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u7834\u6298\u53f7\u3001\u70b9\u3001\u5192\u53f7\u6216\u4e0b\u5212\u7ebf\u3002',
    'You have unsaved changes are you sure you want to navigate away?': '\u4f60\u8fd8\u6709\u6587\u6863\u5c1a\u672a\u4fdd\u5b58\uff0c\u786e\u5b9a\u8981\u79bb\u5f00\uff1f',
    'Restore last draft': '\u6062\u590d\u4e0a\u6b21\u7684\u8349\u7a3f',
    'Special character...': '\u7279\u6b8a\u5b57\u7b26...',
    'Source code': '\u6e90\u4ee3\u7801',
    'Insert/Edit code sample': '\u63d2\u5165/\u7f16\u8f91\u4ee3\u7801\u793a\u4f8b',
    'Language': '\u8bed\u8a00',
    'Code sample...': '\u793a\u4f8b\u4ee3\u7801...',
    'Color Picker': '\u9009\u8272\u5668',
    'R': 'R',
    'G': 'G',
    'B': 'B',
    'Left to right': '\u4ece\u5de6\u5230\u53f3',
    'Right to left': '\u4ece\u53f3\u5230\u5de6',
    'Emoticons...': '\u8868\u60c5\u7b26\u53f7...',
    'Metadata and Document Properties': '\u5143\u6570\u636e\u548c\u6587\u6863\u5c5e\u6027',
    'Title': '\u6807\u9898',
    'Keywords': '\u5173\u952e\u8bcd',
    'Description': '\u63cf\u8ff0',
    'Robots': '\u673a\u5668\u4eba',
    'Author': '\u4f5c\u8005',
    'Encoding': '\u7f16\u7801',
    'Fullscreen': '\u5168\u5c4f',
    'Action': '\u64cd\u4f5c',
    'Shortcut': '\u5feb\u6377\u952e',
    'Help': '\u5e2e\u52a9',
    'Address': '\u5730\u5740',
    'Focus to menubar': '\u79fb\u52a8\u7126\u70b9\u5230\u83dc\u5355\u680f',
    'Focus to toolbar': '\u79fb\u52a8\u7126\u70b9\u5230\u5de5\u5177\u680f',
    'Focus to element path': '\u79fb\u52a8\u7126\u70b9\u5230\u5143\u7d20\u8def\u5f84',
    'Focus to contextual toolbar': '\u79fb\u52a8\u7126\u70b9\u5230\u4e0a\u4e0b\u6587\u83dc\u5355',
    'Insert link (if link plugin activated)': '\u63d2\u5165\u94fe\u63a5 (\u5982\u679c\u94fe\u63a5\u63d2\u4ef6\u5df2\u6fc0\u6d3b)',
    'Save (if save plugin activated)': '\u4fdd\u5b58(\u5982\u679c\u4fdd\u5b58\u63d2\u4ef6\u5df2\u6fc0\u6d3b)',
    'Find (if searchreplace plugin activated)': '\u67e5\u627e(\u5982\u679c\u67e5\u627e\u66ff\u6362\u63d2\u4ef6\u5df2\u6fc0\u6d3b)',
    'Plugins installed ({0}):': '\u5df2\u5b89\u88c5\u63d2\u4ef6 ({0}):',
    'Premium plugins:': '\u4f18\u79c0\u63d2\u4ef6\uff1a',
    'Learn more...': '\u4e86\u89e3\u66f4\u591a...',
    'You are using {0}': '\u4f60\u6b63\u5728\u4f7f\u7528 {0}',
    'Plugins': '\u63d2\u4ef6',
    'Handy Shortcuts': '\u5feb\u6377\u952e',
    'Horizontal line': '\u6c34\u5e73\u5206\u5272\u7ebf',
    'Insert/edit image': '\u63d2\u5165/\u7f16\u8f91\u56fe\u7247',
    'Image description': '\u56fe\u7247\u63cf\u8ff0',
    'Source': '\u5730\u5740',
    'Dimensions': '\u5927\u5c0f',
    'Constrain proportions': '\u4fdd\u6301\u7eb5\u6a2a\u6bd4',
    'General': '\u666e\u901a',
    'Advanced': '\u9ad8\u7ea7',
    'Style': '\u6837\u5f0f',
    'Vertical space': '\u5782\u76f4\u8fb9\u8ddd',
    'Horizontal space': '\u6c34\u5e73\u8fb9\u8ddd',
    'Border': '\u8fb9\u6846',
    'Insert image': '\u63d2\u5165\u56fe\u7247',
    'Image...': '\u56fe\u7247...',
    'Image list': '\u56fe\u7247\u5217\u8868',
    'Rotate counterclockwise': '\u9006\u65f6\u9488\u65cb\u8f6c',
    'Rotate clockwise': '\u987a\u65f6\u9488\u65cb\u8f6c',
    'Flip vertically': '\u5782\u76f4\u7ffb\u8f6c',
    'Flip horizontally': '\u6c34\u5e73\u7ffb\u8f6c',
    'Edit image': '\u7f16\u8f91\u56fe\u7247',
    'Image options': '\u56fe\u7247\u9009\u9879',
    'Zoom in': '\u653e\u5927',
    'Zoom out': '\u7f29\u5c0f',
    'Crop': '\u88c1\u526a',
    'Resize': '\u8c03\u6574\u5927\u5c0f',
    'Orientation': '\u65b9\u5411',
    'Brightness': '\u4eae\u5ea6',
    'Sharpen': '\u9510\u5316',
    'Contrast': '\u5bf9\u6bd4\u5ea6',
    'Color levels': '\u989c\u8272\u5c42\u6b21',
    'Gamma': '\u4f3d\u9a6c\u503c',
    'Invert': '\u53cd\u8f6c',
    'Apply': '\u5e94\u7528',
    'Back': '\u540e\u9000',
    'Insert date/time': '\u63d2\u5165\u65e5\u671f/\u65f6\u95f4',
    'Date/time': '\u65e5\u671f/\u65f6\u95f4',
    'Insert/Edit Link': '\u63d2\u5165/\u7f16\u8f91\u94fe\u63a5',
    'Insert/edit link': '\u63d2\u5165/\u7f16\u8f91\u94fe\u63a5',
    'Text to display': '\u663e\u793a\u6587\u5b57',
    'Url': '\u5730\u5740',
    'Open link in...': '\u94fe\u63a5\u6253\u5f00\u4f4d\u7f6e...',
    'Current window': '\u5f53\u524d\u7a97\u53e3',
    'None': '\u65e0',
    'New window': '\u5728\u65b0\u7a97\u53e3\u6253\u5f00',
    'Remove link': '\u5220\u9664\u94fe\u63a5',
    'Anchors': '\u951a\u70b9',
    'Link...': '\u94fe\u63a5...',
    'Paste or type a link': '\u7c98\u8d34\u6216\u8f93\u5165\u94fe\u63a5',
    'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?': '\u4f60\u6240\u586b\u5199\u7684URL\u5730\u5740\u4e3a\u90ae\u4ef6\u5730\u5740\uff0c\u9700\u8981\u52a0\u4e0amailto:\u524d\u7f00\u5417\uff1f',
    'The URL you entered seems to be an external link. Do you want to add the required http:// prefix?': '\u4f60\u6240\u586b\u5199\u7684URL\u5730\u5740\u5c5e\u4e8e\u5916\u90e8\u94fe\u63a5\uff0c\u9700\u8981\u52a0\u4e0ahttp://:\u524d\u7f00\u5417\uff1f',
    'Link list': '\u94fe\u63a5\u5217\u8868',
    'Insert video': '\u63d2\u5165\u89c6\u9891',
    'Insert/edit video': '\u63d2\u5165/\u7f16\u8f91\u89c6\u9891',
    'Insert/edit media': '\u63d2\u5165/\u7f16\u8f91\u5a92\u4f53',
    'Alternative source': '\u955c\u50cf',
    'Alternative source URL': '\u66ff\u4ee3\u6765\u6e90\u7f51\u5740',
    'Media poster (Image URL)': '\u5c01\u9762(\u56fe\u7247\u5730\u5740)',
    'Paste your embed code below:': '\u5c06\u5185\u5d4c\u4ee3\u7801\u7c98\u8d34\u5728\u4e0b\u9762:',
    'Embed': '\u5185\u5d4c',
    'Media...': '\u591a\u5a92\u4f53...',
    'Nonbreaking space': '\u4e0d\u95f4\u65ad\u7a7a\u683c',
    'Page break': '\u5206\u9875\u7b26',
    'Paste as text': '\u7c98\u8d34\u4e3a\u6587\u672c',
    'Preview': '\u9884\u89c8',
    'Print...': '\u6253\u5370...',
    'Save': '\u4fdd\u5b58',
    'Find': '\u67e5\u627e',
    'Replace with': '\u66ff\u6362\u4e3a',
    'Replace': '\u66ff\u6362',
    'Replace all': '\u5168\u90e8\u66ff\u6362',
    'Previous': '\u4e0a\u4e00\u4e2a',
    'Next': '\u4e0b\u4e00\u4e2a',
    'Find and replace...': '\u67e5\u627e\u5e76\u66ff\u6362...',
    'Could not find the specified string.': '\u672a\u627e\u5230\u641c\u7d22\u5185\u5bb9.',
    'Match case': '\u533a\u5206\u5927\u5c0f\u5199',
    'Find whole words only': '\u5168\u5b57\u5339\u914d',
    'Spell check': '\u62fc\u5199\u68c0\u67e5',
    'Ignore': '\u5ffd\u7565',
    'Ignore all': '\u5168\u90e8\u5ffd\u7565',
    'Finish': '\u5b8c\u6210',
    'Add to Dictionary': '\u6dfb\u52a0\u5230\u5b57\u5178',
    'Insert table': '\u63d2\u5165\u8868\u683c',
    'Table properties': '\u8868\u683c\u5c5e\u6027',
    'Delete table': '\u5220\u9664\u8868\u683c',
    'Cell': '\u5355\u5143\u683c',
    'Row': '\u884c',
    'Column': '\u5217',
    'Cell properties': '\u5355\u5143\u683c\u5c5e\u6027',
    'Merge cells': '\u5408\u5e76\u5355\u5143\u683c',
    'Split cell': '\u62c6\u5206\u5355\u5143\u683c',
    'Insert row before': '\u5728\u4e0a\u65b9\u63d2\u5165',
    'Insert row after': '\u5728\u4e0b\u65b9\u63d2\u5165',
    'Delete row': '\u5220\u9664\u884c',
    'Row properties': '\u884c\u5c5e\u6027',
    'Cut row': '\u526a\u5207\u884c',
    'Copy row': '\u590d\u5236\u884c',
    'Paste row before': '\u7c98\u8d34\u5230\u4e0a\u65b9',
    'Paste row after': '\u7c98\u8d34\u5230\u4e0b\u65b9',
    'Insert column before': '\u5728\u5de6\u4fa7\u63d2\u5165',
    'Insert column after': '\u5728\u53f3\u4fa7\u63d2\u5165',
    'Delete column': '\u5220\u9664\u5217',
    'Cols': '\u5217',
    'Rows': '\u884c',
    'Width': '\u5bbd',
    'Height': '\u9ad8',
    'Cell spacing': '\u5355\u5143\u683c\u5916\u95f4\u8ddd',
    'Cell padding': '\u5355\u5143\u683c\u5185\u8fb9\u8ddd',
    'Show caption': '\u663e\u793a\u6807\u9898',
    'Left': '\u5de6\u5bf9\u9f50',
    'Center': '\u5c45\u4e2d',
    'Right': '\u53f3\u5bf9\u9f50',
    'Cell type': '\u5355\u5143\u683c\u7c7b\u578b',
    'Scope': '\u8303\u56f4',
    'Alignment': '\u5bf9\u9f50\u65b9\u5f0f',
    'H Align': '\u6c34\u5e73\u5bf9\u9f50',
    'V Align': '\u5782\u76f4\u5bf9\u9f50',
    'Top': '\u9876\u90e8\u5bf9\u9f50',
    'Middle': '\u5782\u76f4\u5c45\u4e2d',
    'Bottom': '\u5e95\u90e8\u5bf9\u9f50',
    'Header cell': '\u8868\u5934\u5355\u5143\u683c',
    'Row group': '\u884c\u7ec4',
    'Column group': '\u5217\u7ec4',
    'Row type': '\u884c\u7c7b\u578b',
    'Header': '\u8868\u5934',
    'Body': '\u8868\u4f53',
    'Footer': '\u8868\u5c3e',
    'Border color': '\u8fb9\u6846\u989c\u8272',
    'Insert template...': '\u63d2\u5165\u6a21\u677f...',
    'Templates': '\u6a21\u677f',
    'Template': '\u6a21\u677f',
    'Text color': '\u6587\u5b57\u989c\u8272',
    'Background color': '\u80cc\u666f\u8272',
    'Custom...': '\u81ea\u5b9a\u4e49...',
    'Custom color': '\u81ea\u5b9a\u4e49\u989c\u8272',
    'No color': '\u65e0',
    'Remove color': '\u79fb\u9664\u989c\u8272',
    'Table of Contents': '\u5185\u5bb9\u5217\u8868',
    'Show blocks': '\u663e\u793a\u533a\u5757\u8fb9\u6846',
    'Show invisible characters': '\u663e\u793a\u4e0d\u53ef\u89c1\u5b57\u7b26',
    'Word count': '\u5b57\u6570',
    'Count': '\u8ba1\u6570',
    'Document': '\u6587\u6863',
    'Selection': '\u9009\u62e9',
    'Words': '\u5355\u8bcd',
    'Words: {0}': '\u5b57\u6570\uff1a{0}',
    '{0} words': '{0} \u5b57',
    'File': '\u6587\u4ef6',
    'Edit': '\u7f16\u8f91',
    'Insert': '\u63d2\u5165',
    'View': '\u89c6\u56fe',
    'Format': '\u683c\u5f0f',
    'Table': '\u8868\u683c',
    'Tools': '\u5de5\u5177',
    'Powered by {0}': '\u7531{0}\u9a71\u52a8',
    'Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help': '\u5728\u7f16\u8f91\u533a\u6309ALT-F9\u6253\u5f00\u83dc\u5355\uff0c\u6309ALT-F10\u6253\u5f00\u5de5\u5177\u680f\uff0c\u6309ALT-0\u67e5\u770b\u5e2e\u52a9',
    'Image title': '\u56fe\u7247\u6807\u9898',
    'Border width': '\u8fb9\u6846\u5bbd\u5ea6',
    'Border style': '\u8fb9\u6846\u6837\u5f0f',
    'Error': '\u9519\u8bef',
    'Warn': '\u8b66\u544a',
    'Valid': '\u6709\u6548',
    'To open the popup, press Shift+Enter': '\u6309Shitf+Enter\u952e\u6253\u5f00\u5bf9\u8bdd\u6846',
    'Rich Text Area. Press ALT-0 for help.': '\u7f16\u8f91\u533a\u3002\u6309Alt+0\u952e\u6253\u5f00\u5e2e\u52a9\u3002',
    'System Font': '\u7cfb\u7edf\u5b57\u4f53',
    'Failed to upload image: {0}': '\u56fe\u7247\u4e0a\u4f20\u5931\u8d25: {0}',
    'Failed to load plugin: {0} from url {1}': '\u63d2\u4ef6\u52a0\u8f7d\u5931\u8d25: {0} \u6765\u81ea\u94fe\u63a5 {1}',
    'Failed to load plugin url: {0}': '\u63d2\u4ef6\u52a0\u8f7d\u5931\u8d25 \u94fe\u63a5: {0}',
    'Failed to initialize plugin: {0}': '\u63d2\u4ef6\u521d\u59cb\u5316\u5931\u8d25: {0}',
    'example': '\u793a\u4f8b',
    'Search': '\u641c\u7d22',
    'All': '\u5168\u90e8',
    'Currency': '\u8d27\u5e01',
    'Text': '\u6587\u5b57',
    'Quotations': '\u5f15\u7528',
    'Mathematical': '\u6570\u5b66',
    'Extended Latin': '\u62c9\u4e01\u8bed\u6269\u5145',
    'Symbols': '\u7b26\u53f7',
    'Arrows': '\u7bad\u5934',
    'User Defined': '\u81ea\u5b9a\u4e49',
    'dollar sign': '\u7f8e\u5143\u7b26\u53f7',
    'currency sign': '\u8d27\u5e01\u7b26\u53f7',
    'euro-currency sign': '\u6b27\u5143\u7b26\u53f7',
    'colon sign': '\u5192\u53f7',
    'cruzeiro sign': '\u514b\u9c81\u8d5b\u7f57\u5e01\u7b26\u53f7',
    'french franc sign': '\u6cd5\u90ce\u7b26\u53f7',
    'lira sign': '\u91cc\u62c9\u7b26\u53f7',
    'mill sign': '\u5bc6\u5c14\u7b26\u53f7',
    'naira sign': '\u5948\u62c9\u7b26\u53f7',
    'peseta sign': '\u6bd4\u585e\u5854\u7b26\u53f7',
    'rupee sign': '\u5362\u6bd4\u7b26\u53f7',
    'won sign': '\u97e9\u5143\u7b26\u53f7',
    'new sheqel sign': '\u65b0\u8c22\u514b\u5c14\u7b26\u53f7',
    'dong sign': '\u8d8a\u5357\u76fe\u7b26\u53f7',
    'kip sign': '\u8001\u631d\u57fa\u666e\u7b26\u53f7',
    'tugrik sign': '\u56fe\u683c\u91cc\u514b\u7b26\u53f7',
    'drachma sign': '\u5fb7\u62c9\u514b\u9a6c\u7b26\u53f7',
    'german penny symbol': '\u5fb7\u56fd\u4fbf\u58eb\u7b26\u53f7',
    'peso sign': '\u6bd4\u7d22\u7b26\u53f7',
    'guarani sign': '\u74dc\u62c9\u5c3c\u7b26\u53f7',
    'austral sign': '\u6fb3\u5143\u7b26\u53f7',
    'hryvnia sign': '\u683c\u91cc\u592b\u5c3c\u4e9a\u7b26\u53f7',
    'cedi sign': '\u585e\u5730\u7b26\u53f7',
    'livre tournois sign': '\u91cc\u5f17\u5f17\u5c14\u7b26\u53f7',
    'spesmilo sign': 'spesmilo\u7b26\u53f7',
    'tenge sign': '\u575a\u6208\u7b26\u53f7',
    'indian rupee sign': '\u5370\u5ea6\u5362\u6bd4',
    'turkish lira sign': '\u571f\u8033\u5176\u91cc\u62c9',
    'nordic mark sign': '\u5317\u6b27\u9a6c\u514b',
    'manat sign': '\u9a6c\u7eb3\u7279\u7b26\u53f7',
    'ruble sign': '\u5362\u5e03\u7b26\u53f7',
    'yen character': '\u65e5\u5143\u5b57\u6837',
    'yuan character': '\u4eba\u6c11\u5e01\u5143\u5b57\u6837',
    'yuan character, in hong kong and taiwan': '\u5143\u5b57\u6837\uff08\u6e2f\u53f0\u5730\u533a\uff09',
    'yen/yuan character variant one': '\u5143\u5b57\u6837\uff08\u5927\u5199\uff09',
    'Loading emoticons...': '\u52a0\u8f7d\u8868\u60c5\u7b26\u53f7...',
    'Could not load emoticons': '\u4e0d\u80fd\u52a0\u8f7d\u8868\u60c5\u7b26\u53f7',
    'People': '\u4eba\u7c7b',
    'Animals and Nature': '\u52a8\u7269\u548c\u81ea\u7136',
    'Food and Drink': '\u98df\u7269\u548c\u996e\u54c1',
    'Activity': '\u6d3b\u52a8',
    'Travel and Places': '\u65c5\u6e38\u548c\u5730\u70b9',
    'Objects': '\u7269\u4ef6',
    'Flags': '\u65d7\u5e1c',
    'Characters': '\u5b57\u7b26',
    'Characters (no spaces)': '\u5b57\u7b26(\u65e0\u7a7a\u683c)',
    '{0} characters': '{0} \u4e2a\u5b57\u7b26',
    'Error: Form submit field collision.': '\u9519\u8bef: \u8868\u5355\u63d0\u4ea4\u5b57\u6bb5\u51b2\u7a81\u3002',
    'Error: No form element found.': '\u9519\u8bef: \u6ca1\u6709\u8868\u5355\u63a7\u4ef6\u3002',
    'Update': '\u66f4\u65b0',
    'Color swatch': '\u989c\u8272\u6837\u672c',
    'Turquoise': '\u9752\u7eff\u8272',
    'Green': '\u7eff\u8272',
    'Blue': '\u84dd\u8272',
    'Purple': '\u7d2b\u8272',
    'Navy Blue': '\u6d77\u519b\u84dd',
    'Dark Turquoise': '\u6df1\u84dd\u7eff\u8272',
    'Dark Green': '\u6df1\u7eff\u8272',
    'Medium Blue': '\u4e2d\u84dd\u8272',
    'Medium Purple': '\u4e2d\u7d2b\u8272',
    'Midnight Blue': '\u6df1\u84dd\u8272',
    'Yellow': '\u9ec4\u8272',
    'Orange': '\u6a59\u8272',
    'Red': '\u7ea2\u8272',
    'Light Gray': '\u6d45\u7070\u8272',
    'Gray': '\u7070\u8272',
    'Dark Yellow': '\u6697\u9ec4\u8272',
    'Dark Orange': '\u6df1\u6a59\u8272',
    'Dark Red': '\u6df1\u7ea2\u8272',
    'Medium Gray': '\u4e2d\u7070\u8272',
    'Dark Gray': '\u6df1\u7070\u8272',
    'Light Green': '\u6d45\u7eff\u8272',
    'Light Yellow': '\u6d45\u9ec4\u8272',
    'Light Red': '\u6d45\u7ea2\u8272',
    'Light Purple': '\u6d45\u7d2b\u8272',
    'Light Blue': '\u6d45\u84dd\u8272',
    'Dark Purple': '\u6df1\u7d2b\u8272',
    'Dark Blue': '\u6df1\u84dd\u8272',
    'Black': '\u9ed1\u8272',
    'White': '\u767d\u8272',
    'Switch to or from fullscreen mode': '\u5207\u6362\u5168\u5c4f\u6a21\u5f0f',
    'Open help dialog': '\u6253\u5f00\u5e2e\u52a9\u5bf9\u8bdd\u6846',
    'history': '\u5386\u53f2',
    'styles': '\u6837\u5f0f',
    'formatting': '\u683c\u5f0f\u5316',
    'alignment': '\u5bf9\u9f50',
    'indentation': '\u7f29\u8fdb',
    'permanent pen': '\u8bb0\u53f7\u7b14',
    'comments': '\u5907\u6ce8',
    'Format Painter': '\u683c\u5f0f\u5237',
    'Insert/edit iframe': '\u63d2\u5165/\u7f16\u8f91\u6846\u67b6',
    'Capitalization': '\u5927\u5199',
    'lowercase': '\u5c0f\u5199',
    'UPPERCASE': '\u5927\u5199',
    'Title Case': '\u9996\u5b57\u6bcd\u5927\u5199',
    'Permanent Pen Properties': '\u6c38\u4e45\u7b14\u5c5e\u6027',
    'Permanent pen properties...': '\u6c38\u4e45\u7b14\u5c5e\u6027...',
    'Font': '\u5b57\u4f53',
    'Size': '\u5b57\u53f7',
    'More...': '\u66f4\u591a...',
    'Spellcheck Language': '\u62fc\u5199\u68c0\u67e5\u8bed\u8a00',
    'Select...': '\u9009\u62e9...',
    'Preferences': '\u9996\u9009\u9879',
    'Yes': '\u662f',
    'No': '\u5426',
    'Keyboard Navigation': '\u952e\u76d8\u6307\u5f15',
    'Version': '\u7248\u672c',
    'Anchor': '\u951a\u70b9',
    'Special character': '\u7279\u6b8a\u7b26\u53f7',
    'Code sample': '\u4ee3\u7801\u793a\u4f8b',
    'Color': '\u989c\u8272',
    'Emoticons': '\u8868\u60c5',
    'Document properties': '\u6587\u6863\u5c5e\u6027',
    'Image': '\u56fe\u7247',
    'Insert link': '\u63d2\u5165\u94fe\u63a5',
    'Target': '\u6253\u5f00\u65b9\u5f0f',
    'Link': '\u94fe\u63a5',
    'Poster': '\u5c01\u9762',
    'Media': '\u5a92\u4f53',
    'Print': '\u6253\u5370',
    'Prev': '\u4e0a\u4e00\u4e2a',
    'Find and replace': '\u67e5\u627e\u548c\u66ff\u6362',
    'Whole words': '\u5168\u5b57\u5339\u914d',
    'Spellcheck': '\u62fc\u5199\u68c0\u67e5',
    'Caption': '\u6807\u9898',
    'Insert template': '\u63d2\u5165\u6a21\u677f'
});
//# sourceMappingURL=./components/Tinymce.js.map


/***/ }),

/***/ "4efa":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "silver" theme for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/themes/silver')
//   ES2015:
//     import 'tinymce/themes/silver'
__webpack_require__("705c");

/***/ }),

/***/ "51cc":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "code" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/code')
//   ES2015:
//     import 'tinymce/plugins/code'
__webpack_require__("0537");

/***/ }),

/***/ "550c":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "pagebreak" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/pagebreak')
//   ES2015:
//     import 'tinymce/plugins/pagebreak'
__webpack_require__("fb04");

/***/ }),

/***/ "58e6":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "wordcount" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/wordcount')
//   ES2015:
//     import 'tinymce/plugins/wordcount'
__webpack_require__("9acd");

/***/ }),

/***/ "5e1c":
/***/ (function(module, exports) {

tinymce.IconManager.add('default', {
  icons: {
    'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 01-1-1v-5c0-.6-.4-1-1-1a1 1 0 00-1 1v5c0 .6-.4 1-1 1a1 1 0 01-1-1V9H4a1 1 0 110-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>',
    'action-next': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 00-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 10-1.4-1.4L12 13.6 5.7 7.3z"/></svg>',
    'action-prev': '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 001.4-1.4L12 6.6l-7.7 7.7a1 1 0 001.4 1.4L12 9.4l6.3 6.3z"/></svg>',
    'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'align-none': '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 110-2h9.2zm4 0h.8a1 1 0 010 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h6.8zm4 0H19a1 1 0 010 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h4.4zm4 0H19a1 1 0 010 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 010-2h2zm4 0h8a1 1 0 010 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>',
    'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'arrow-left': '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 001.4-1V6a1 1 0 00-1.4-.9l-12 6a1 1 0 000 1.8z" fill-rule="evenodd"/></svg>',
    'arrow-right': '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 015 18V6a1 1 0 011.4-.9l12 6a1 1 0 010 1.8z" fill-rule="evenodd"/></svg>',
    'bold': '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 01-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>',
    'bookmark': '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 00-1 1z" fill-rule="nonzero"/></svg>',
    'border-style': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    'border-width': '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    'brightness': '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 01-.7-.3A1 1 0 0111 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3h-1a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 01-.7.3H5a1 1 0 01-.7-.3A1 1 0 014 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 01-.8.3 1 1 0 01-.6-.3l-.8-.7a1 1 0 01-.3-.8c0-.2.1-.5.3-.7a1 1 0 011.4 0zm-10-7l-.7-.8a1 1 0 01-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.8-.3zm10 0a1 1 0 01-.8.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 010 1.4l-.8.8a1 1 0 01-.6.3 1 1 0 01-.8-.3 1 1 0 01-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 013.7 2.4 4 4 0 010 3.2A4 4 0 0112 16a4 4 0 01-3.7-2.4 4 4 0 010-3.2A4 4 0 0112 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>',
    'browse': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 11-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 01-1.4 1.4L13 13.4V20a1 1 0 01-2 0v-6.6z" fill-rule="nonzero"/></svg>',
    'cancel': '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 110 14.8 7.4 7.4 0 010-14.8zM12 3a9 9 0 100 18 9 9 0 000-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>',
    'cell-background-color': '<svg width="24" height="24"><path d="M15.7 2l1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 01-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2zM18 12l-4.5-4L9 12h9zM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16z"/></svg>',
    'cell-border-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 01-2-2v-5h2zm8-7V4h6a2 2 0 012 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1l.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="M13 11l-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="M18.4 8l1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 01-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8zm1.6 7l-3-3-3 3h6z"/></g></svg>',
    'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 01-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 01-1 .7h-.2a.7.7 0 01-.7-1l4-12a1 1 0 012 0l4 12a.7.7 0 01-.8 1h-.2a1 1 0 01-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 01-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 00-.5-.1 1 1 0 00-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 00-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 001.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 00-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 00-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 01-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 01-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>',
    'checklist-rtl': '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    'checklist': '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8a1 1 0 010 2h-8a1 1 0 010-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    'checkmark': '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 011.6 1.2l-8 12a1 1 0 01-1.5.1l-5-5a1 1 0 111.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>',
    'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 010-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>',
    'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 010-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>',
    'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 010-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 010-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>',
    'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 010-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>',
    'close': '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 01-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 01-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 011.5-1.5l3.8 3.9 3.8-3.9a1 1 0 011.5 1.5z" fill-rule="evenodd"/></svg>',
    'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 01-.8 2 2.8 2.8 0 01.8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 01-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 01.8-2 2.8 2.8 0 01-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 01-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 01-.5-.5V17a3 3 0 001-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>',
    'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0118 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 01-3.7 3 5.7 5.7 0 01-3.2 0A5.9 5.9 0 017.6 18a6.2 6.2 0 01-1.4-2.6 6.7 6.7 0 010-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 012.3-4A20 20 0 0112 4a26.4 26.4 0 013.2 3.4 18.2 18.2 0 012.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 00-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 01-1.3 3 5.3 5.3 0 01-2.3 1.5 4.9 4.9 0 01-2 .1 4.3 4.3 0 002.4.8 4 4 0 002-.6 4 4 0 001.5-1.5z" fill-rule="evenodd"/></svg>',
    'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 000 18 1.5 1.5 0 001.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 005-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3-4a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3 4a1.5 1.5 0 110-3 1.5 1.5 0 010 3z" fill-rule="nonzero"/></svg>',
    'color-swatch-remove-color': '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>',
    'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    'comment-add': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/><path d="M13 10h2a1 1 0 010 2h-2v2a1 1 0 01-2 0v-2H9a1 1 0 010-2h2V8a1 1 0 012 0v2z"/></g></svg>',
    'comment': '<svg width="24" height="24"><path fill-rule="nonzero" d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/></svg>',
    'contrast': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-6 8a6 6 0 006 6V6a6 6 0 00-6 6z" fill-rule="evenodd"/></svg>',
    'copy': '<svg width="24" height="24"><path d="M16 3H6a2 2 0 00-2 2v11h2V5h10V3zm1 4a2 2 0 012 2v10a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>',
    'crop': '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 01-1-1v-2H7V9H5a1 1 0 110-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>',
    'cut-column': '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0110.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 012 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 017 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7zm12.3 5h-3v10h3v-10zM8 13.8h-.3l-.4.2a2.8 2.8 0 00-.7.4v.1a2.8 2.8 0 00-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 00.8-.3 2.4 2.4 0 00.7-.7 2.5 2.5 0 00.3-.8 1.5 1.5 0 000-.8 1 1 0 00-.2-.4 1 1 0 00-.5-.2H8zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zM7 5.8h-.4a1 1 0 00-.5.3 1 1 0 00-.2.5v.7a2.5 2.5 0 00.3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 000-.8 2.6 2.6 0 00-.3-.8A2.5 2.5 0 007.7 6l-.4-.1H7z"/></svg>',
    'cut-row': '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l2 2V3h14zM8.5 15.3h-.3a2.6 2.6 0 00-.8.4 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3L9 18V18l.4-.4.2-.4.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2h-.5zm7 0H15a1 1 0 00-.4.3 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4a2.8 2.8 0 00.5.7h.1a2.8 2.8 0 00.8.6l.4.1h.7l.5-.2.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3h-.3zM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zm8.5-7.1h-11v2h11v-2z"/></svg>',
    'cut': '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 010 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2 1.6 1.6 0 00-.8 0 2.6 2.6 0 00-.8.3 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3 2.8 2.8 0 001-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3 1.5 1.5 0 00-.8 0 1 1 0 00-.4.2 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4l.3.4.3.4a2.8 2.8 0 00.8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>',
    'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
    'drag': '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>',
    'duplicate-column': '<svg width="24" height="24"><path d="M17 6v16h-7V6h7zm-2 2h-3v12h3V8zm-2-6v2H8v15H6V2h7z"/></svg>',
    'duplicate-row': '<svg width="24" height="24"><path d="M22 11v7H6v-7h16zm-2 2H8v3h12v-3zm-1-6v2H4v5H2V7h17z"/></svg>',
    'duplicate': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7a2 2 0 012 2v2z"/><path d="M17 14h1a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1h-1a1 1 0 010-2h1v-1a1 1 0 012 0v1z"/></g></svg>',
    'edit-block': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 00-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z"/></svg>',
    'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 00-2-2H7v2h11v9zM6 17h15a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1H6a2 2 0 01-2-2V7H3a1 1 0 110-2h1V4a1 1 0 112 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>',
    'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0119 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 008 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 00-4 4.5h2.2zm-3.4 0a12 12 0 012.8-4 12 12 0 00-5 4h2.2z" fill-rule="nonzero"/></svg>',
    'embed': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 010 .8l-5.6 4A.5.5 0 019 16V8a.5.5 0 01.8-.4z" fill-rule="nonzero"/></svg>',
    'emoji': '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 100 16 8 8 0 000-16zm0 14.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z" fill-rule="nonzero"/></svg>',
    'export': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3L18 7v1h-5V5H7v14h9a1 1 0 012 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3z"/><path d="M16.4 9.2a1 1 0 011.4.2l2.4 3.6-2.4 3.6a1 1 0 01-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 01.2-1.4z"/></g></svg>',
    'fill': '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 002.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 002-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>',
    'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 00-2 2zm14-2v2h2a2 2 0 00-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 002-2h-2v2z" fill-rule="nonzero"/></svg>',
    'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 00-2 2v3h2V6h10v3h2V6a2 2 0 00-2-2zm2 14h-2v2a2 2 0 002-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>',
    'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 00-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>',
    'format': '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 010 2h-4v11a1 1 0 01-2 0V7H7a1 1 0 110-2h10z"/></svg>',
    'fullscreen': '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 110-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 11-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 111.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 110-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 110 1.7H5a.9.9 0 01-.9-.9v-4.4a.9.9 0 111.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 01-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 010 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>',
    'gallery': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 01-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 110-4 2 2 0 010 4zM4.5 4h15a.5.5 0 110 1h-15a.5.5 0 010-1zm2-2h11a.5.5 0 110 1h-11a.5.5 0 010-1z"/></svg>',
    'gamma': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 00-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 01.6.5l.1.3a8.5 8.5 0 01.3.6l1.9 4.6 2-5.2a1 1 0 011-.6.5.5 0 01.5.6L13 14v2.8a.7.7 0 01-1.4 0z" fill-rule="nonzero"/></svg>',
    'help': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 00-6 9 6.3 6.3 0 001.4 2l1 1a6.3 6.3 0 003.6 1 6.5 6.5 0 006-9 6.3 6.3 0 00-1.4-2l-1-1a6.3 6.3 0 00-3.6-1zM12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4z"/><path d="M9.6 9.7a.7.7 0 01-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 00-.8.8.8.8 0 01-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 012.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    'home': '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
    'image': '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 100-4 2 2 0 000 4z" fill-rule="nonzero"/></svg>',
    'indent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
    'info': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>',
    'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 001.8-2.9 6.3 6.3 0 00-.1-4.1 5.8 5.8 0 00-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 00-3.9 1.8 6.3 6.3 0 00-1.3 6 6.2 6.2 0 001.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 014 11c0-1 .2-1.9.6-2.7A7 7 0 016.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 015.7 2 7 7 0 011.7 2.3 6 6 0 01.2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 01-3.6 2.5v.5z" fill-rule="evenodd"/></svg>',
    'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 100-14 7 7 0 000 14zm0 2a9 9 0 110-18 9 9 0 010 18z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 00-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z"/></g></svg>',
    'invert': '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 01-3.1 1.9 6.1 6.1 0 01-5.5-1.6A5.8 5.8 0 016 14v-.3l.1-1.2A13.9 13.9 0 017.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 00.2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 00-3-4.2L12 6a26.1 26.1 0 00-2.2 2.5l-1-1a20.9 20.9 0 012.9-3.3L12 4l1 .8a22.2 22.2 0 014 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>',
    'italic': '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>',
    'language': '<svg width="24" height="24"><path d="M12 3a9 9 0 110 18 9 9 0 010-18zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 003.2-2.1l-.2-.2a6 6 0 00-1-.6zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 01-2-2.8zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 01-.3-2zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1zm3-1.4l-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 00-1.3-3.5zm-9 0l2 .2V5.5a9 9 0 00-2 2.2zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 00-2-2.3zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 011.9-2.5zm4.4 0l.1.1a10 10 0 011.8 2.4l1.1-.7a7.5 7.5 0 00-3-1.8z"/></svg>',
    'line-height': '<svg width="24" height="24"><path d="M21 5a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zM7 3.6l3.7 3.7a1 1 0 01-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 011.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 011.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 01-1.3 0h-.1a1 1 0 010-1.3v-.1L7 3.6z"/></svg>',
    'line': '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>',
    'link': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2.1 2a2 2 0 102.7 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2-2a2 2 0 10-2.6-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2z" fill-rule="nonzero"/></svg>',
    'list-bull-circle': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 26a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 36a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    'list-bull-default': '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    'list-bull-square': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    'list-num-default-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    'list-num-lower-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-lower-greek-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-lower-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    'list-num-upper-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    'list-num-upper-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    'lock': '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 00-.3-.7A1 1 0 0013 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7z" fill-rule="evenodd"/></svg>',
    'ltr': '<svg width="24" height="24"><path d="M11 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 017.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
    'more-drawer': '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
    'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
    'new-tab': '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>',
    'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 110-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 01-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>',
    'notice': '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>',
    'ordered-list-rtl': '<svg width="24" height="24"><path d="M6 17h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 110-2zm13-1v3.5a.5.5 0 11-1 0V5h-.5a.5.5 0 110-1H19zm-1 8.8l.2.2h1.3a.5.5 0 110 1h-1.6a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2h-1.3a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 010-1h1.2a.3.3 0 100-.6h-1.3a.4.4 0 110-.8h1.3a.3.3 0 000-.6h-1.2a.5.5 0 110-1H19c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
    'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 110-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 01-.5-.5V5h-.5a.5.5 0 010-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2H4.5a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 010-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 110-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 110-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
    'orientation': '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 010-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 11-4.3 16.9l1.5-1.5A7 7 0 1013 6h-1z" fill-rule="nonzero"/></svg>',
    'outdent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm1.6-3.8a1 1 0 01-1.2 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 011.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>',
    'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 01-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 01-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>',
    'paragraph': '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z"/></svg>',
    'paste-column-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm8 7v12h-6V8h6zm-1.5 1.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
    'paste-column-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm-2 7v12H4V8h6zM8.5 9.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
    'paste-row-after': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 11v5H8v-5h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
    'paste-row-before': '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 7v5H8V8h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
    'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>',
    'paste': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>',
    'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 010-3L14 3l1 1-7.3 7.3a1 1 0 000 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 01-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>',
    'plus': '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 01.1 2H13v6a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H11V5c0-.6.4-1 1-1z"/></svg>',
    'preferences': '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 01-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 01-1.4 0l-1.5-1.2a6.2 6.2 0 01-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 01-1-.9l-.2-1.9a5.8 5.8 0 01-1.5-.6l-1.5 1.2a1 1 0 01-1.4 0l-.7-.7a1 1 0 010-1.4l1.2-1.5a6.2 6.2 0 01-.6-1.5l-1.9-.2a1 1 0 01-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 01.6-1.5L5.2 7.3a1 1 0 010-1.4l.7-.7a1 1 0 011.4 0l1.5 1.2a6.2 6.2 0 011.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 011.5.6l1.5-1.2a1 1 0 011.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 01.6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 100-6 3 3 0 000 6z" fill-rule="evenodd"/></svg>',
    'preview': '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 002.1-2.8 15.7 15.7 0 00-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 00-6.7 3.2A16.2 16.2 0 003.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 012.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 01-2.8-3.7 1 1 0 010-1zm12-3.3a2 2 0 102.7 2.6 4 4 0 11-2.6-2.6z" fill-rule="nonzero"/></svg>',
    'print': '<svg width="24" height="24"><path d="M18 8H6a3 3 0 00-3 3v6h2v3h14v-3h2v-6a3 3 0 00-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>',
    'quote': '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3z" fill-rule="nonzero"/></svg>',
    'redo': '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 11-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 111.4-1.4l5 5a1 1 0 010 1.4l-5 5a1 1 0 01-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>',
    'reload': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 011-1l5 .4a1 1 0 11-.2 2l-2.2-.2a7.8 7.8 0 008.4.2 7.5 7.5 0 003.5-6.4 1 1 0 112 0 9.5 9.5 0 01-4.5 8 9.9 9.9 0 01-10.2 0l.4 1.4a1 1 0 11-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 00-9.5-1 7.5 7.5 0 00-3.6 7 1 1 0 01-2 0 9.5 9.5 0 014.5-8.6 10 10 0 0110.9.3l-.3-1a1 1 0 012-.5l1.1 4.8a1 1 0 01-1 1.2l-5-.4a1 1 0 01-.9-1z"/></g></svg>',
    'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 010 .2l-2.6 10a1 1 0 01-1 .8h-.2a.8.8 0 01-.8-1l2.6-10H8a1 1 0 110-2h9a1 1 0 010 2h-3.8zM5 18h7a1 1 0 010 2H5a1 1 0 010-2zm13 1.5L16.5 18 15 19.5a.7.7 0 01-1-1l1.5-1.5-1.5-1.5a.7.7 0 011-1l1.5 1.5 1.5-1.5a.7.7 0 011 1L17.5 17l1.5 1.5a.7.7 0 01-1 1z" fill-rule="evenodd"/></svg>',
    'remove': '<svg width="24" height="24"><path d="M16 7h3a1 1 0 010 2h-1v9a3 3 0 01-3 3H9a3 3 0 01-3-3V9H5a1 1 0 110-2h3V6a3 3 0 013-3h2a3 3 0 013 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 00-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 012 0v4a1 1 0 01-2 0v-4zm4 0a1 1 0 012 0v4a1 1 0 01-2 0v-4z" fill-rule="nonzero"/></svg>',
    'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 119 2l-7 7A.5.5 0 111 8l7-7zM8.1 5.1A.5.5 0 119 6l-3 3A.5.5 0 115 8l3-3z"/></g></svg>',
    'resize': '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-6a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3A1 1 0 014 11V5z" fill-rule="evenodd"/></svg>',
    'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></g></svg>',
    'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></svg>',
    'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 012 0v6c0 .6-.4 1-1 1h-6a1 1 0 010-2h4.3L16 7A7.2 7.2 0 007.7 6a7 7 0 003 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 011.4 1.5A9.2 9.2 0 012.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>',
    'rtl': '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 014.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L8 5zm12 11.2a1 1 0 11-1 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 111 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>',
    'save': '<svg width="24" height="24"><path d="M5 16h14a2 2 0 012 2v2a2 2 0 01-2 2H5a2 2 0 01-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 10-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 10-1.4-1.4L13 11.6V4a1 1 0 00-2 0v7.6z" fill-rule="nonzero"/></svg>',
    'search': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12z" fill-rule="nonzero"/></svg>',
    'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 00-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 00-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 002-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>',
    'selected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 00-1 1L9.6 17 18 8.6a.7.7 0 000-1 .7.7 0 00-1 0l-7.4 7.3z"/></svg>',
    'settings': '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V8H5a1 1 0 110-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V13H5a1 1 0 010-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V18H5a1 1 0 010-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>',
    'sharpen': '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>',
    'sourcecode': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 010-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 00-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>',
    'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 01-.7-.3 1 1 0 01-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>',
    'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 017 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 010 2H5a1 1 0 010-2z" fill-rule="nonzero"/></g></svg>',
    'subscript': '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 00-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 01-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>',
    'superscript': '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>',
    'table-caption': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></g></svg>',
    'table-cell-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8zm-2 2H5v5h6V6z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 012 2v7h-8v-2h6V6h-6V4z" opacity=".2"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3z" opacity=".2"/></g></svg>',
    'table-cell-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z"/></svg>',
    'table-cell-select-all': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z" opacity=".2"/></g></svg>',
    'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z"/></g></svg>',
    'table-classes': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v7h-8v7H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8-7h-6v5h6V6zm-8 0H5v5h6V6z"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/></g></svg>',
    'table-delete-column': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z"/></svg>',
    'table-delete-row': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z"/></svg>',
    'table-delete-table': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z"/><path d="M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    'table-insert-column-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 01-2 0V6h-8v12h8v-1a1 1 0 012 0v2c0 .5-.4 1-.9 1H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H17v2a1 1 0 01-2 .1V13h-2a1 1 0 01-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z"/></svg>',
    'table-insert-column-before': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H4a1 1 0 01-1-1v-2a1 1 0 012 0v1h8V6H5v1a1 1 0 11-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H9v2a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z"/></svg>',
    'table-insert-row-above': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 110 2H5v6h14V6h-1a1 1 0 010-2h2c.6 0 1 .4 1 1v13a2 2 0 01-2 2H5a2 2 0 01-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 010 2h-2v2a1 1 0 01-2 .1V8H9a1 1 0 010-2h2V4c0-.6.4-1 1-1z"/></svg>',
    'table-insert-row-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 01.1 2H13v2a1 1 0 01-2 .1V18H9a1 1 0 01-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 010-2h1v-6H5v6h1a1 1 0 010 2H4a1 1 0 01-1-1V6c0-1.1.9-2 2-2h14a2 2 0 012 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z"/></svg>',
    'table-left-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z"/></svg>',
    'table-merge-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z"/></svg>',
    'table-row-numbering-rtl': '<svg width="24" height="24"><path d="M6 4a2 2 0 00-2 2v13c0 1.1.9 2 2 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6zm0 12h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 11h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 6h8v3H6V6zm11 0c.6 0 1 .4 1 1v1a1 1 0 11-2 0V7c0-.6.4-1 1-1z"/></svg>',
    'table-row-numbering': '<svg width="24" height="24"><path d="M18 4a2 2 0 012 2v13a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2h12zm0 12h-8v3h8v-3zM7 16a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8v-3zM7 11a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8V6zM7 6a1 1 0 00-1 1v1a1 1 0 102 0V7c0-.6-.4-1-1-1z"/></svg>',
    'table-row-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z"/></svg>',
    'table-split-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z"/></svg>',
    'table-top-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></svg>',
    'table': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z"/></svg>',
    'template': '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 116 0v4h4a2 2 0 012 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 10-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>',
    'temporary-placeholder': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 111 0V6H15v1.6a8 8 0 11-6 0zm-2.6 5.3a.5.5 0 00.3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 013.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 00-4.1 3.7z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 01-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 01-.5.6h-.8a.5.5 0 01-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 00.5.6h1.6a.5.5 0 00.5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>',
    'toc': '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'translate': '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 010-1l3.1-3A12.4 12.4 0 016.7 9H8a10.1 10.1 0 001.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 110-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 01-1 2.4 13.5 13.5 0 01-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 01-.4.7 1 1 0 01-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 01-1 .7.5.5 0 01-.4-.7l2.7-7.4a1 1 0 012 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>',
    'underline': '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 01-.4 1.8l-1 1.4a5.3 5.3 0 01-5.5 1 5 5 0 01-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 01-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 002.2.8 3.4 3.4 0 002.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
    'undo': '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 01-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 11-1.4 1.4l-5-5a1 1 0 010-1.4l5-5a1 1 0 011.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>',
    'unlink': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2 2a2 2 0 102.6 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2.1-2a2 2 0 10-2.7-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2zM7.6 6.3a.8.8 0 01-1 1.1L3.3 4.2a.7.7 0 111-1l3.2 3.1zM5.1 8.6a.8.8 0 010 1.5H3a.8.8 0 010-1.5H5zm5-3.5a.8.8 0 01-1.5 0V3a.8.8 0 011.5 0V5zm6 11.8a.8.8 0 011-1l3.2 3.2a.8.8 0 01-1 1L16 17zm-2.2 2a.8.8 0 011.5 0V21a.8.8 0 01-1.5 0V19zm5-3.5a.7.7 0 110-1.5H21a.8.8 0 010 1.5H19z" fill-rule="nonzero"/></svg>',
    'unlock': '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 00-.3-.7A1 1 0 0016 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>',
    'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>',
    'unselected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 00-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z"/></svg>',
    'upload': '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 012 0v3c0 .6-.4 1-1 1H5a1 1 0 01-1-1v-3a1 1 0 012 0v2h12zM11 6.4L8.7 8.7a1 1 0 01-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 11-1.4 1.4L13 6.4V16a1 1 0 01-2 0V6.4z" fill-rule="nonzero"/></svg>',
    'user': '<svg width="24" height="24"><path d="M12 24a12 12 0 110-24 12 12 0 010 24zm-8.7-5.3a11 11 0 0017.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>',
    'vertical-align': '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 011.2 1.5l-.1.1-4.1 3-4-3a1 1 0 011-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8l4 2.9a1 1 0 01-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 01-1-1v-4l-2 1.3a1 1 0 01-1.2-.1l-.1-.1a1 1 0 01.1-1.3l.1-.1 4.1-3z"/></g></svg>',
    'visualblocks': '<svg width="24" height="24"><path d="M9 19v2H7v-2h2zm-4 0v2a2 2 0 01-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 01-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 010 2v7a1 1 0 01-2 0V9h-1v7a1 1 0 01-2 0v-4a2.5 2.5 0 01-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 012 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z" fill-rule="evenodd"/></svg>',
    'visualchars': '<svg width="24" height="24"><path d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z" fill-rule="evenodd"/></svg>',
    'warning': '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>',
    'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-1-9a1 1 0 012 0v6a1 1 0 01-2 0V8zm-2 4a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>',
    'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-3-5a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>',
  }
});

/***/ }),

/***/ "6230":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "default" icons for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/icons/default')
//   ES2015:
//     import 'tinymce/icons/default'
__webpack_require__("5e1c");

/***/ }),

/***/ "705c":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq$1 = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString = isType$1('string');
    var isObject = isType$1('object');
    var isArray = isType$1('array');
    var isNull = eq$1(null);
    var isBoolean = isSimpleType('boolean');
    var isUndefined = eq$1(undefined);
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');
    var isArrayOf = function (value, pred) {
      if (isArray(value)) {
        for (var i = 0, len = value.length; i < len; ++i) {
          if (!pred(value[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    var noop = function () {
    };
    var noarg = function (f) {
      return function () {
        return f();
      };
    };
    var compose = function (fa, fb) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var compose1 = function (fbc, fab) {
      return function (a) {
        return fbc(fab(a));
      };
    };
    var constant$1 = function (value) {
      return function () {
        return value;
      };
    };
    var identity$1 = function (x) {
      return x;
    };
    var tripleEquals = function (a, b) {
      return a === b;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var not = function (f) {
      return function (t) {
        return !f(t);
      };
    };
    var die = function (msg) {
      return function () {
        throw new Error(msg);
      };
    };
    var never = constant$1(false);
    var always = constant$1(true);

    var global$g = tinymce.util.Tools.resolve('tinymce.ThemeManager');

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity$1;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant$1(null),
        getOrUndefined: constant$1(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant$1('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant$1(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from$1 = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from$1
    };

    var nativeSlice = Array.prototype.slice;
    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var indexOf = function (xs, x) {
      var r = rawIndexOf(xs, x);
      return r === -1 ? Optional.none() : Optional.some(r);
    };
    var contains$2 = function (xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var range$2 = function (num, f) {
      var r = [];
      for (var i = 0; i < num; i++) {
        r.push(f(i));
      }
      return r;
    };
    var chunk$1 = function (array, size) {
      var r = [];
      for (var i = 0; i < array.length; i += size) {
        var s = nativeSlice.call(array, i, i + size);
        r.push(s);
      }
      return r;
    };
    var map$2 = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function (xs, f) {
      for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var partition$3 = function (xs, pred) {
      var pass = [];
      var fail = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        var arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass: pass,
        fail: fail
      };
    };
    var filter$2 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var foldr = function (xs, f, acc) {
      eachr(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var foldl = function (xs, f, acc) {
      each$1(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find$5 = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var findIndex$1 = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind$3 = function (xs, f) {
      return flatten(map$2(xs, f));
    };
    var forall = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    var reverse = function (xs) {
      var r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    var difference = function (a1, a2) {
      return filter$2(a1, function (x) {
        return !contains$2(a2, x);
      });
    };
    var mapToObject = function (xs, f) {
      var r = {};
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    var pure$2 = function (x) {
      return [x];
    };
    var sort = function (xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    var get$f = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get$f(xs, 0);
    };
    var last$2 = function (xs) {
      return get$f(xs, xs.length - 1);
    };
    var from = isFunction(Array.from) ? Array.from : function (x) {
      return nativeSlice.call(x);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map$1 = function (obj, f) {
      return tupleMap(obj, function (x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function (obj, f) {
      var r = {};
      each(obj, function (x, i) {
        var tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter$1 = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var mapToArray = function (obj, f) {
      var r = [];
      each(obj, function (value, name) {
        r.push(f(value, name));
      });
      return r;
    };
    var find$4 = function (obj, pred) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        if (pred(x, i, obj)) {
          return Optional.some(x);
        }
      }
      return Optional.none();
    };
    var values = function (obj) {
      return mapToArray(obj, identity$1);
    };
    var get$e = function (obj, key) {
      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has$2 = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };

    var is$1 = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lhs.exists(function (left) {
        return comparator(left, rhs);
      });
    };
    var equals = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
    };
    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    var sequence = function (arr) {
      var r = [];
      for (var i = 0; i < arr.length; i++) {
        var x = arr[i];
        if (x.isSome()) {
          r.push(x.getOrDie());
        } else {
          return Optional.none();
        }
      }
      return Optional.some(r);
    };
    var lift2 = function (oa, ob, f) {
      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    };
    var lift3 = function (oa, ob, oc, f) {
      return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    };
    var mapFrom = function (a, f) {
      return a !== undefined && a !== null ? Optional.some(f(a)) : Optional.none();
    };
    var someIf = function (b, a) {
      return b ? Optional.some(a) : Optional.none();
    };

    var addToEnd = function (str, suffix) {
      return str + suffix;
    };
    var removeFromStart = function (str, numChars) {
      return str.substring(numChars);
    };

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var removeLeading = function (str, prefix) {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    var ensureTrailing = function (str, suffix) {
      return endsWith(str, suffix) ? str : addToEnd(str, suffix);
    };
    var contains$1 = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };
    var endsWith = function (str, suffix) {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    var blank = function (r) {
      return function (s) {
        return s.replace(r, '');
      };
    };
    var trim$1 = blank(/^\s+|\s+$/g);
    var isNotEmpty = function (s) {
      return s.length > 0;
    };
    var isEmpty = function (s) {
      return !isNotEmpty(s);
    };

    var isSupported$1 = function (dom) {
      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
    };

    var fromHtml$2 = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml$2,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;

    var name$2 = function (element) {
      var r = element.dom.nodeName;
      return r.toLowerCase();
    };
    var type = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isElement$2 = isType(ELEMENT);
    var isText$1 = isType(TEXT);
    var isDocument = isType(DOCUMENT);
    var isDocumentFragment = isType(DOCUMENT_FRAGMENT);

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() && !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      var isPhone = isiPhone || isMobile && !isTablet;
      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant$1(isiPad),
        isiPhone: constant$1(isiPhone),
        isTablet: constant$1(isTablet),
        isPhone: constant$1(isPhone),
        isTouch: constant$1(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant$1(iOSwebview),
        isDesktop: constant$1(isDesktop)
      };
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find$3 = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$d(group(1), group(2));
    };
    var detect$4 = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$3();
      }
      return find$3(versionRegexes, cleanedAgent);
    };
    var unknown$3 = function () {
      return nu$d(0, 0);
    };
    var nu$d = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$d,
      detect: detect$4,
      unknown: unknown$3
    };

    var detectBrowser$1 = function (browsers, userAgentData) {
      return findMap(userAgentData.brands, function (uaBrand) {
        var lcBrand = uaBrand.brand.toLowerCase();
        return find$5(browsers, function (browser) {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(function (info) {
          return {
            current: info.name,
            version: Version.nu(parseInt(uaBrand.version, 10), 0)
          };
        });
      });
    };

    var detect$3 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find$5(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$3(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$3(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains$1(uastring, target);
      };
    };
    var browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chrome',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
        }
      }
    ];
    var oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: function (uastring) {
          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'OSX',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant$1(browsers),
      oses: constant$1(oses)
    };

    var edge = 'Edge';
    var chrome = 'Chrome';
    var ie = 'IE';
    var opera = 'Opera';
    var firefox = 'Firefox';
    var safari = 'Safari';
    var unknown$2 = function () {
      return nu$c({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$c = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$2,
      nu: nu$c,
      edge: constant$1(edge),
      chrome: constant$1(chrome),
      ie: constant$1(ie),
      opera: constant$1(opera),
      firefox: constant$1(firefox),
      safari: constant$1(safari)
    };

    var windows = 'Windows';
    var ios = 'iOS';
    var android = 'Android';
    var linux = 'Linux';
    var osx = 'OSX';
    var solaris = 'Solaris';
    var freebsd = 'FreeBSD';
    var chromeos = 'ChromeOS';
    var unknown$1 = function () {
      return nu$b({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$b = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown$1,
      nu: nu$b,
      windows: constant$1(windows),
      ios: constant$1(ios),
      android: constant$1(android),
      linux: constant$1(linux),
      osx: constant$1(osx),
      solaris: constant$1(solaris),
      freebsd: constant$1(freebsd),
      chromeos: constant$1(chromeos)
    };

    var detect$2 = function (userAgent, userAgentDataOpt, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = userAgentDataOpt.bind(function (userAgentData) {
        return detectBrowser$1(browsers, userAgentData);
      }).orThunk(function () {
        return detectBrowser(browsers, userAgent);
      }).fold(Browser.unknown, Browser.nu);
      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$2 };

    var mediaMatch = function (query) {
      return window.matchMedia(query).matches;
    };
    var platform = cached(function () {
      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);
    });
    var detect$1 = function () {
      return platform();
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) & match) !== 0;
    };
    var documentPositionContainedBy = function (a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
    };

    var is = function (element, selector) {
      var dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    };
    var all$3 = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    var one = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    var eq = function (e1, e2) {
      return e1.dom === e2.dom;
    };
    var regularContains = function (e1, e2) {
      var d1 = e1.dom;
      var d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function (e1, e2) {
      return documentPositionContainedBy(e1.dom, e2.dom);
    };
    var contains = function (e1, e2) {
      return detect$1().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };

    var owner$4 = function (element) {
      return SugarElement.fromDom(element.dom.ownerDocument);
    };
    var documentOrOwner = function (dos) {
      return isDocument(dos) ? dos : owner$4(dos);
    };
    var documentElement = function (element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    };
    var defaultView = function (element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    };
    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var parentNode = function (element) {
      return parent(element);
    };
    var offsetParent = function (element) {
      return Optional.from(element.dom.offsetParent).map(SugarElement.fromDom);
    };
    var nextSibling = function (element) {
      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    };
    var children = function (element) {
      return map$2(element.dom.childNodes, SugarElement.fromDom);
    };
    var child$2 = function (element, index) {
      var cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    var firstChild = function (element) {
      return child$2(element, 0);
    };
    var spot = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };
    var leaf = function (element, offset) {
      var cs = children(element);
      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);
    };

    var isShadowRoot = function (dos) {
      return isDocumentFragment(dos) && isNonNullable(dos.dom.host);
    };
    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    var isSupported = constant$1(supported);
    var getRootNode = supported ? function (e) {
      return SugarElement.fromDom(e.dom.getRootNode());
    } : documentOrOwner;
    var getContentContainer = function (dos) {
      return isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    };
    var isInShadowRoot = function (e) {
      return getShadowRoot(e).isSome();
    };
    var getShadowRoot = function (e) {
      var r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    var getShadowHost = function (e) {
      return SugarElement.fromDom(e.dom.host);
    };
    var getOriginalEventTarget = function (event) {
      if (isSupported() && isNonNullable(event.target)) {
        var el = SugarElement.fromDom(event.target);
        if (isElement$2(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    var isOpenShadowHost = function (element) {
      return isNonNullable(element.dom.shadowRoot);
    };

    var inBody = function (element) {
      var dom = isText$1(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      var doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {
        return doc.body.contains(dom);
      }, compose1(inBody, getShadowHost));
    };
    var body = function () {
      return getBody(SugarElement.fromDom(document));
    };
    var getBody = function (doc) {
      var b = doc.dom.body;
      if (b === null || b === undefined) {
        throw new Error('Body is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set$8 = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var setAll$1 = function (element, attrs) {
      var dom = element.dom;
      each(attrs, function (v, k) {
        rawSet(dom, k, v);
      });
    };
    var get$d = function (element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    var getOpt = function (element, key) {
      return Optional.from(get$d(element, key));
    };
    var has$1 = function (element, key) {
      var dom = element.dom;
      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    var remove$7 = function (element, key) {
      element.dom.removeAttribute(key);
    };

    var internalSet = function (dom, property, value) {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported$1(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var internalRemove = function (dom, property) {
      if (isSupported$1(dom)) {
        dom.style.removeProperty(property);
      }
    };
    var set$7 = function (element, property, value) {
      var dom = element.dom;
      internalSet(dom, property, value);
    };
    var setAll = function (element, css) {
      var dom = element.dom;
      each(css, function (v, k) {
        internalSet(dom, k, v);
      });
    };
    var setOptions = function (element, css) {
      var dom = element.dom;
      each(css, function (v, k) {
        v.fold(function () {
          internalRemove(dom, k);
        }, function (value) {
          internalSet(dom, k, value);
        });
      });
    };
    var get$c = function (element, property) {
      var dom = element.dom;
      var styles = window.getComputedStyle(dom);
      var r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    var getUnsafeProperty = function (dom, property) {
      return isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';
    };
    var getRaw = function (element, property) {
      var dom = element.dom;
      var raw = getUnsafeProperty(dom, property);
      return Optional.from(raw).filter(function (r) {
        return r.length > 0;
      });
    };
    var getAllRaw = function (element) {
      var css = {};
      var dom = element.dom;
      if (isSupported$1(dom)) {
        for (var i = 0; i < dom.style.length; i++) {
          var ruleName = dom.style.item(i);
          css[ruleName] = dom.style[ruleName];
        }
      }
      return css;
    };
    var isValidValue = function (tag, property, value) {
      var element = SugarElement.fromTag(tag);
      set$7(element, property, value);
      var style = getRaw(element, property);
      return style.isSome();
    };
    var remove$6 = function (element, property) {
      var dom = element.dom;
      internalRemove(dom, property);
      if (is$1(getOpt(element, 'style').map(trim$1), '')) {
        remove$7(element, 'style');
      }
    };
    var reflow = function (e) {
      return e.dom.offsetWidth;
    };

    var Dimension = function (name, getOffset) {
      var set = function (element, h) {
        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
        }
        var dom = element.dom;
        if (isSupported$1(dom)) {
          dom.style[name] = h + 'px';
        }
      };
      var get = function (element) {
        var r = getOffset(element);
        if (r <= 0 || r === null) {
          var css = get$c(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      var getOuter = get;
      var aggregate = function (element, properties) {
        return foldl(properties, function (acc, property) {
          var val = get$c(element, property);
          var value = val === undefined ? 0 : parseInt(val, 10);
          return isNaN(value) ? acc : acc + value;
        }, 0);
      };
      var max = function (element, value, properties) {
        var cumulativeInclusions = aggregate(element, properties);
        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set,
        get: get,
        getOuter: getOuter,
        aggregate: aggregate,
        max: max
      };
    };

    var api$3 = Dimension('height', function (element) {
      var dom = element.dom;
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    var get$b = function (element) {
      return api$3.get(element);
    };
    var getOuter$2 = function (element) {
      return api$3.getOuter(element);
    };
    var setMax$1 = function (element, value) {
      var inclusions = [
        'margin-top',
        'border-top-width',
        'padding-top',
        'padding-bottom',
        'border-bottom-width',
        'margin-bottom'
      ];
      var absMax = api$3.max(element, value, inclusions);
      set$7(element, 'max-height', absMax + 'px');
    };

    var r$1 = function (left, top) {
      var translate = function (x, y) {
        return r$1(left + x, top + y);
      };
      return {
        left: left,
        top: top,
        translate: translate
      };
    };
    var SugarPosition = r$1;

    var boxPosition = function (dom) {
      var box = dom.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    var firstDefinedOrZero = function (a, b) {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    var absolute$3 = function (element) {
      var doc = element.dom.ownerDocument;
      var body = doc.body;
      var win = doc.defaultView;
      var html = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    var viewport$1 = function (element) {
      var dom = element.dom;
      var doc = dom.ownerDocument;
      var body = doc.body;
      if (body === dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom);
    };

    var api$2 = Dimension('width', function (element) {
      return element.dom.offsetWidth;
    });
    var set$6 = function (element, h) {
      return api$2.set(element, h);
    };
    var get$a = function (element) {
      return api$2.get(element);
    };
    var getOuter$1 = function (element) {
      return api$2.getOuter(element);
    };
    var setMax = function (element, value) {
      var inclusions = [
        'margin-left',
        'border-left-width',
        'padding-left',
        'padding-right',
        'border-right-width',
        'margin-right'
      ];
      var absMax = api$2.max(element, value, inclusions);
      set$7(element, 'max-width', absMax + 'px');
    };

    var mkEvent = function (target, x, y, stop, prevent, kill, raw) {
      return {
        target: target,
        x: x,
        y: y,
        stop: stop,
        prevent: prevent,
        kill: kill,
        raw: raw
      };
    };
    var fromRawEvent$1 = function (rawEvent) {
      var target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      var stop = function () {
        return rawEvent.stopPropagation();
      };
      var prevent = function () {
        return rawEvent.preventDefault();
      };
      var kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    var handle = function (filter, handler) {
      return function (rawEvent) {
        if (filter(rawEvent)) {
          handler(fromRawEvent$1(rawEvent));
        }
      };
    };
    var binder = function (element, event, filter, handler, useCapture) {
      var wrapped = handle(filter, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    var bind$2 = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, false);
    };
    var capture$1 = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, true);
    };
    var unbind = function (element, event, handler, useCapture) {
      element.dom.removeEventListener(event, handler, useCapture);
    };

    var before$2 = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var after$2 = function (marker, element) {
      var sibling = nextSibling(marker);
      sibling.fold(function () {
        var parent$1 = parent(marker);
        parent$1.each(function (v) {
          append$2(v, element);
        });
      }, function (v) {
        before$2(v, element);
      });
    };
    var prepend$1 = function (parent, element) {
      var firstChild$1 = firstChild(parent);
      firstChild$1.fold(function () {
        append$2(parent, element);
      }, function (v) {
        parent.dom.insertBefore(element.dom, v.dom);
      });
    };
    var append$2 = function (parent, element) {
      parent.dom.appendChild(element.dom);
    };
    var appendAt = function (parent, element, index) {
      child$2(parent, index).fold(function () {
        append$2(parent, element);
      }, function (v) {
        before$2(v, element);
      });
    };

    var before$1 = function (marker, elements) {
      each$1(elements, function (x) {
        before$2(marker, x);
      });
    };
    var append$1 = function (parent, elements) {
      each$1(elements, function (x) {
        append$2(parent, x);
      });
    };

    var empty = function (element) {
      element.dom.textContent = '';
      each$1(children(element), function (rogue) {
        remove$5(rogue);
      });
    };
    var remove$5 = function (element) {
      var dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    var unwrap = function (wrapper) {
      var children$1 = children(wrapper);
      if (children$1.length > 0) {
        before$1(wrapper, children$1);
      }
      remove$5(wrapper);
    };

    var get$9 = function (_DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    var to = function (x, y, _DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var win = doc.defaultView;
      if (win) {
        win.scrollTo(x, y);
      }
    };

    var get$8 = function (_win) {
      var win = _win === undefined ? window : _win;
      if (detect$1().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win['visualViewport']);
      }
    };
    var bounds$1 = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var getBounds$3 = function (_win) {
      var win = _win === undefined ? window : _win;
      var doc = win.document;
      var scroll = get$9(SugarElement.fromDom(doc));
      return get$8(win).fold(function () {
        var html = win.document.documentElement;
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds$1(scroll.left, scroll.top, width, height);
      }, function (visualViewport) {
        return bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);
      });
    };

    var walkUp = function (navigation, doc) {
      var frame = navigation.view(doc);
      return frame.fold(constant$1([]), function (f) {
        var parent = navigation.owner(f);
        var rest = walkUp(navigation, parent);
        return [f].concat(rest);
      });
    };
    var pathTo = function (element, navigation) {
      var d = navigation.owner(element);
      var paths = walkUp(navigation, d);
      return Optional.some(paths);
    };

    var view = function (doc) {
      var _a;
      var element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    var owner$3 = function (element) {
      return owner$4(element);
    };

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner$3
    });

    var find$2 = function (element) {
      var doc = SugarElement.fromDom(document);
      var scroll = get$9(doc);
      var path = pathTo(element, Navigation);
      return path.fold(curry(absolute$3, element), function (frames) {
        var offset = viewport$1(element);
        var r = foldr(frames, function (b, a) {
          var loc = viewport$1(a);
          return {
            left: b.left + loc.left,
            top: b.top + loc.top
          };
        }, {
          left: 0,
          top: 0
        });
        return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
      });
    };

    var pointed = function (point, width, height) {
      return {
        point: point,
        width: width,
        height: height
      };
    };
    var rect = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };
    var bounds = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var box$1 = function (element) {
      var xy = absolute$3(element);
      var w = getOuter$1(element);
      var h = getOuter$2(element);
      return bounds(xy.left, xy.top, w, h);
    };
    var absolute$2 = function (element) {
      var position = find$2(element);
      var width = getOuter$1(element);
      var height = getOuter$2(element);
      return bounds(position.left, position.top, width, height);
    };
    var win = function () {
      return getBounds$3(window);
    };

    var value$3 = function (o) {
      var or = function (_opt) {
        return value$3(o);
      };
      var orThunk = function (_f) {
        return value$3(o);
      };
      var map = function (f) {
        return value$3(f(o));
      };
      var mapError = function (_f) {
        return value$3(o);
      };
      var each = function (f) {
        f(o);
      };
      var bind = function (f) {
        return f(o);
      };
      var fold = function (_, onValue) {
        return onValue(o);
      };
      var exists = function (f) {
        return f(o);
      };
      var forall = function (f) {
        return f(o);
      };
      var toOptional = function () {
        return Optional.some(o);
      };
      return {
        isValue: always,
        isError: never,
        getOr: constant$1(o),
        getOrThunk: constant$1(o),
        getOrDie: constant$1(o),
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: each,
        bind: bind,
        exists: exists,
        forall: forall,
        toOptional: toOptional
      };
    };
    var error$1 = function (message) {
      var getOrThunk = function (f) {
        return f();
      };
      var getOrDie = function () {
        return die(String(message))();
      };
      var or = identity$1;
      var orThunk = function (f) {
        return f();
      };
      var map = function (_f) {
        return error$1(message);
      };
      var mapError = function (f) {
        return error$1(f(message));
      };
      var bind = function (_f) {
        return error$1(message);
      };
      var fold = function (onError, _) {
        return onError(message);
      };
      return {
        isValue: never,
        isError: always,
        getOr: identity$1,
        getOrThunk: getOrThunk,
        getOrDie: getOrDie,
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: noop,
        bind: bind,
        exists: never,
        forall: always,
        toOptional: Optional.none
      };
    };
    var fromOption = function (opt, err) {
      return opt.fold(function () {
        return error$1(err);
      }, value$3);
    };
    var Result = {
      value: value$3,
      error: error$1,
      fromOption: fromOption
    };

    var SimpleResultType;
    (function (SimpleResultType) {
      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';
      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';
    }(SimpleResultType || (SimpleResultType = {})));
    var fold$1 = function (res, onError, onValue) {
      return res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    };
    var partition$2 = function (results) {
      var values = [];
      var errors = [];
      each$1(results, function (obj) {
        fold$1(obj, function (err) {
          return errors.push(err);
        }, function (val) {
          return values.push(val);
        });
      });
      return {
        values: values,
        errors: errors
      };
    };
    var mapError = function (res, f) {
      if (res.stype === SimpleResultType.Error) {
        return {
          stype: SimpleResultType.Error,
          serror: f(res.serror)
        };
      } else {
        return res;
      }
    };
    var map = function (res, f) {
      if (res.stype === SimpleResultType.Value) {
        return {
          stype: SimpleResultType.Value,
          svalue: f(res.svalue)
        };
      } else {
        return res;
      }
    };
    var bind$1 = function (res, f) {
      if (res.stype === SimpleResultType.Value) {
        return f(res.svalue);
      } else {
        return res;
      }
    };
    var bindError = function (res, f) {
      if (res.stype === SimpleResultType.Error) {
        return f(res.serror);
      } else {
        return res;
      }
    };
    var svalue = function (v) {
      return {
        stype: SimpleResultType.Value,
        svalue: v
      };
    };
    var serror = function (e) {
      return {
        stype: SimpleResultType.Error,
        serror: e
      };
    };
    var toResult$1 = function (res) {
      return fold$1(res, Result.error, Result.value);
    };
    var fromResult$1 = function (res) {
      return res.fold(serror, svalue);
    };
    var SimpleResult = {
      fromResult: fromResult$1,
      toResult: toResult$1,
      svalue: svalue,
      partition: partition$2,
      serror: serror,
      bind: bind$1,
      bindError: bindError,
      map: map,
      mapError: mapError,
      fold: fold$1
    };

    var field$2 = function (key, newKey, presence, prop) {
      return {
        tag: 'field',
        key: key,
        newKey: newKey,
        presence: presence,
        prop: prop
      };
    };
    var customField$1 = function (newKey, instantiator) {
      return {
        tag: 'custom',
        newKey: newKey,
        instantiator: instantiator
      };
    };
    var fold = function (value, ifField, ifCustom) {
      switch (value.tag) {
      case 'field':
        return ifField(value.key, value.newKey, value.presence, value.prop);
      case 'custom':
        return ifCustom(value.newKey, value.instantiator);
      }
    };

    var shallow$1 = function (old, nu) {
      return nu;
    };
    var deep = function (old, nu) {
      var bothObjects = isObject(old) && isObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    var baseMerge = function (merger) {
      return function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        if (objects.length === 0) {
          throw new Error('Can\'t merge zero objects');
        }
        var ret = {};
        for (var j = 0; j < objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (has$2(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var deepMerge = baseMerge(deep);
    var merge$1 = baseMerge(shallow$1);

    var required$2 = function () {
      return {
        tag: 'required',
        process: {}
      };
    };
    var defaultedThunk = function (fallbackThunk) {
      return {
        tag: 'defaultedThunk',
        process: fallbackThunk
      };
    };
    var defaulted$1 = function (fallback) {
      return defaultedThunk(constant$1(fallback));
    };
    var asOption = function () {
      return {
        tag: 'option',
        process: {}
      };
    };
    var mergeWithThunk = function (baseThunk) {
      return {
        tag: 'mergeWithThunk',
        process: baseThunk
      };
    };
    var mergeWith = function (base) {
      return mergeWithThunk(constant$1(base));
    };

    var mergeValues$1 = function (values, base) {
      return values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base);
    };
    var mergeErrors$1 = function (errors) {
      return compose(SimpleResult.serror, flatten)(errors);
    };
    var consolidateObj = function (objects, base) {
      var partition = SimpleResult.partition(objects);
      return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);
    };
    var consolidateArr = function (objects) {
      var partitions = SimpleResult.partition(objects);
      return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    var ResultCombine = {
      consolidateObj: consolidateObj,
      consolidateArr: consolidateArr
    };

    var formatObj = function (input) {
      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    var formatErrors = function (errors) {
      var es = errors.length > 10 ? errors.slice(0, 10).concat([{
          path: [],
          getErrorInfo: constant$1('... (only showing first ten failures)')
        }]) : errors;
      return map$2(es, function (e) {
        return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
      });
    };

    var nu$a = function (path, getErrorInfo) {
      return SimpleResult.serror([{
          path: path,
          getErrorInfo: getErrorInfo
        }]);
    };
    var missingRequired = function (path, key, obj) {
      return nu$a(path, function () {
        return 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj);
      });
    };
    var missingKey = function (path, key) {
      return nu$a(path, function () {
        return 'Choice schema did not contain choice key: "' + key + '"';
      });
    };
    var missingBranch = function (path, branches, branch) {
      return nu$a(path, function () {
        return 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches);
      });
    };
    var unsupportedFields = function (path, unsupported) {
      return nu$a(path, function () {
        return 'There are unsupported fields: [' + unsupported.join(', ') + '] specified';
      });
    };
    var custom = function (path, err) {
      return nu$a(path, constant$1(err));
    };

    var value$2 = function (validator) {
      var extract = function (path, val) {
        return SimpleResult.bindError(validator(val), function (err) {
          return custom(path, err);
        });
      };
      var toString = constant$1('val');
      return {
        extract: extract,
        toString: toString
      };
    };
    var anyValue$1 = value$2(SimpleResult.svalue);

    var requiredAccess = function (path, obj, key, bundle) {
      return get$e(obj, key).fold(function () {
        return missingRequired(path, key, obj);
      }, bundle);
    };
    var fallbackAccess = function (obj, key, fallback, bundle) {
      var v = get$e(obj, key).getOrThunk(function () {
        return fallback(obj);
      });
      return bundle(v);
    };
    var optionAccess = function (obj, key, bundle) {
      return bundle(get$e(obj, key));
    };
    var optionDefaultedAccess = function (obj, key, fallback, bundle) {
      var opt = get$e(obj, key).map(function (val) {
        return val === true ? fallback(obj) : val;
      });
      return bundle(opt);
    };
    var extractField = function (field, path, obj, key, prop) {
      var bundle = function (av) {
        return prop.extract(path.concat([key]), av);
      };
      var bundleAsOption = function (optValue) {
        return optValue.fold(function () {
          return SimpleResult.svalue(Optional.none());
        }, function (ov) {
          var result = prop.extract(path.concat([key]), ov);
          return SimpleResult.map(result, Optional.some);
        });
      };
      switch (field.tag) {
      case 'required':
        return requiredAccess(path, obj, key, bundle);
      case 'defaultedThunk':
        return fallbackAccess(obj, key, field.process, bundle);
      case 'option':
        return optionAccess(obj, key, bundleAsOption);
      case 'defaultedOptionThunk':
        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
      case 'mergeWithThunk': {
          return fallbackAccess(obj, key, constant$1({}), function (v) {
            var result = deepMerge(field.process(obj), v);
            return bundle(result);
          });
        }
      }
    };
    var extractFields = function (path, obj, fields) {
      var success = {};
      var errors = [];
      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var field = fields_1[_i];
        fold(field, function (key, newKey, presence, prop) {
          var result = extractField(presence, path, obj, key, prop);
          SimpleResult.fold(result, function (err) {
            errors.push.apply(errors, err);
          }, function (res) {
            success[newKey] = res;
          });
        }, function (newKey, instantiator) {
          success[newKey] = instantiator(obj);
        });
      }
      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    var valueThunk = function (getDelegate) {
      var extract = function (path, val) {
        return getDelegate().extract(path, val);
      };
      var toString = function () {
        return getDelegate().toString();
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var getSetKeys = function (obj) {
      return keys(filter$1(obj, isNonNullable));
    };
    var objOfOnly = function (fields) {
      var delegate = objOf(fields);
      var fieldNames = foldr(fields, function (acc, value) {
        return fold(value, function (key) {
          var _a;
          return deepMerge(acc, (_a = {}, _a[key] = true, _a));
        }, constant$1(acc));
      }, {});
      var extract = function (path, o) {
        var keys = isBoolean(o) ? [] : getSetKeys(o);
        var extra = filter$2(keys, function (k) {
          return !hasNonNullableKey(fieldNames, k);
        });
        return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);
      };
      return {
        extract: extract,
        toString: delegate.toString
      };
    };
    var objOf = function (values) {
      var extract = function (path, o) {
        return extractFields(path, o, values);
      };
      var toString = function () {
        var fieldStrings = map$2(values, function (value) {
          return fold(value, function (key, _okey, _presence, prop) {
            return key + ' -> ' + prop.toString();
          }, function (newKey, _instantiator) {
            return 'state(' + newKey + ')';
          });
        });
        return 'obj{\n' + fieldStrings.join('\n') + '}';
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var arrOf = function (prop) {
      var extract = function (path, array) {
        var results = map$2(array, function (a, i) {
          return prop.extract(path.concat(['[' + i + ']']), a);
        });
        return ResultCombine.consolidateArr(results);
      };
      var toString = function () {
        return 'array(' + prop.toString() + ')';
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var oneOf = function (props) {
      var extract = function (path, val) {
        var errors = [];
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
          var prop = props_1[_i];
          var res = prop.extract(path, val);
          if (res.stype === SimpleResultType.Value) {
            return res;
          }
          errors.push(res);
        }
        return ResultCombine.consolidateArr(errors);
      };
      var toString = function () {
        return 'oneOf(' + map$2(props, function (prop) {
          return prop.toString();
        }).join(', ') + ')';
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var setOf$1 = function (validator, prop) {
      var validateKeys = function (path, keys) {
        return arrOf(value$2(validator)).extract(path, keys);
      };
      var extract = function (path, o) {
        var keys$1 = keys(o);
        var validatedKeys = validateKeys(path, keys$1);
        return SimpleResult.bind(validatedKeys, function (validKeys) {
          var schema = map$2(validKeys, function (vk) {
            return field$2(vk, vk, required$2(), prop);
          });
          return objOf(schema).extract(path, o);
        });
      };
      var toString = function () {
        return 'setOf(' + prop.toString() + ')';
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var thunk = function (_desc, processor) {
      var getP = cached(processor);
      var extract = function (path, val) {
        return getP().extract(path, val);
      };
      var toString = function () {
        return getP().toString();
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var arrOfObj = compose(arrOf, objOf);

    var anyValue = constant$1(anyValue$1);
    var typedValue = function (validator, expectedType) {
      return value$2(function (a) {
        var actualType = typeof a;
        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror('Expected type: ' + expectedType + ' but got: ' + actualType);
      });
    };
    var number = typedValue(isNumber, 'number');
    var string = typedValue(isString, 'string');
    var boolean = typedValue(isBoolean, 'boolean');
    var functionProcessor = typedValue(isFunction, 'function');
    var isPostMessageable = function (val) {
      if (Object(val) !== val) {
        return true;
      }
      switch ({}.toString.call(val).slice(8, -1)) {
      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Date':
      case 'RegExp':
      case 'Blob':
      case 'FileList':
      case 'ImageData':
      case 'ImageBitmap':
      case 'ArrayBuffer':
        return true;
      case 'Array':
      case 'Object':
        return Object.keys(val).every(function (prop) {
          return isPostMessageable(val[prop]);
        });
      default:
        return false;
      }
    };
    var postMessageable = value$2(function (a) {
      if (isPostMessageable(a)) {
        return SimpleResult.svalue(a);
      } else {
        return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');
      }
    });

    var chooseFrom = function (path, input, branches, ch) {
      var fields = get$e(branches, ch);
      return fields.fold(function () {
        return missingBranch(path, branches, ch);
      }, function (vp) {
        return vp.extract(path.concat(['branch: ' + ch]), input);
      });
    };
    var choose$2 = function (key, branches) {
      var extract = function (path, input) {
        var choice = get$e(input, key);
        return choice.fold(function () {
          return missingKey(path, key);
        }, function (chosen) {
          return chooseFrom(path, input, branches, chosen);
        });
      };
      var toString = function () {
        return 'chooseOn(' + key + '). Possible values: ' + keys(branches);
      };
      return {
        extract: extract,
        toString: toString
      };
    };

    var arrOfVal = function () {
      return arrOf(anyValue$1);
    };
    var valueOf = function (validator) {
      return value$2(function (v) {
        return validator(v).fold(SimpleResult.serror, SimpleResult.svalue);
      });
    };
    var setOf = function (validator, prop) {
      return setOf$1(function (v) {
        return SimpleResult.fromResult(validator(v));
      }, prop);
    };
    var extractValue = function (label, prop, obj) {
      var res = prop.extract([label], obj);
      return SimpleResult.mapError(res, function (errs) {
        return {
          input: obj,
          errors: errs
        };
      });
    };
    var asRaw = function (label, prop, obj) {
      return SimpleResult.toResult(extractValue(label, prop, obj));
    };
    var getOrDie = function (extraction) {
      return extraction.fold(function (errInfo) {
        throw new Error(formatError(errInfo));
      }, identity$1);
    };
    var asRawOrDie$1 = function (label, prop, obj) {
      return getOrDie(asRaw(label, prop, obj));
    };
    var formatError = function (errInfo) {
      return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') + '\n\nInput object: ' + formatObj(errInfo.input);
    };
    var choose$1 = function (key, branches) {
      return choose$2(key, map$1(branches, objOf));
    };
    var thunkOf = function (desc, schema) {
      return thunk(desc, schema);
    };

    var field$1 = field$2;
    var customField = customField$1;
    var validateEnum = function (values) {
      return valueOf(function (value) {
        return contains$2(values, value) ? Result.value(value) : Result.error('Unsupported value: "' + value + '", choose one of "' + values.join(', ') + '".');
      });
    };
    var required$1 = function (key) {
      return field$1(key, key, required$2(), anyValue());
    };
    var requiredOf = function (key, schema) {
      return field$1(key, key, required$2(), schema);
    };
    var requiredNumber = function (key) {
      return requiredOf(key, number);
    };
    var requiredString = function (key) {
      return requiredOf(key, string);
    };
    var requiredStringEnum = function (key, values) {
      return field$1(key, key, required$2(), validateEnum(values));
    };
    var requiredBoolean = function (key) {
      return requiredOf(key, boolean);
    };
    var requiredFunction = function (key) {
      return requiredOf(key, functionProcessor);
    };
    var forbid = function (key, message) {
      return field$1(key, key, asOption(), value$2(function (_v) {
        return SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message);
      }));
    };
    var requiredObjOf = function (key, objSchema) {
      return field$1(key, key, required$2(), objOf(objSchema));
    };
    var requiredArrayOfObj = function (key, objFields) {
      return field$1(key, key, required$2(), arrOfObj(objFields));
    };
    var requiredArrayOf = function (key, schema) {
      return field$1(key, key, required$2(), arrOf(schema));
    };
    var option = function (key) {
      return field$1(key, key, asOption(), anyValue());
    };
    var optionOf = function (key, schema) {
      return field$1(key, key, asOption(), schema);
    };
    var optionNumber = function (key) {
      return optionOf(key, number);
    };
    var optionString = function (key) {
      return optionOf(key, string);
    };
    var optionFunction = function (key) {
      return optionOf(key, functionProcessor);
    };
    var optionArrayOf = function (key, schema) {
      return optionOf(key, arrOf(schema));
    };
    var optionObjOf = function (key, objSchema) {
      return optionOf(key, objOf(objSchema));
    };
    var optionObjOfOnly = function (key, objSchema) {
      return optionOf(key, objOfOnly(objSchema));
    };
    var defaulted = function (key, fallback) {
      return field$1(key, key, defaulted$1(fallback), anyValue());
    };
    var defaultedOf = function (key, fallback, schema) {
      return field$1(key, key, defaulted$1(fallback), schema);
    };
    var defaultedNumber = function (key, fallback) {
      return defaultedOf(key, fallback, number);
    };
    var defaultedString = function (key, fallback) {
      return defaultedOf(key, fallback, string);
    };
    var defaultedStringEnum = function (key, fallback, values) {
      return defaultedOf(key, fallback, validateEnum(values));
    };
    var defaultedBoolean = function (key, fallback) {
      return defaultedOf(key, fallback, boolean);
    };
    var defaultedFunction = function (key, fallback) {
      return defaultedOf(key, fallback, functionProcessor);
    };
    var defaultedPostMsg = function (key, fallback) {
      return defaultedOf(key, fallback, postMessageable);
    };
    var defaultedArrayOf = function (key, fallback, schema) {
      return defaultedOf(key, fallback, arrOf(schema));
    };
    var defaultedObjOf = function (key, fallback, objSchema) {
      return defaultedOf(key, fallback, objOf(objSchema));
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var generate$7 = function (cases) {
      if (!isArray(cases)) {
        throw new Error('cases must be an array');
      }
      if (cases.length === 0) {
        throw new Error('there must be at least one case');
      }
      var constructors = [];
      var adt = {};
      each$1(cases, function (acase, count) {
        var keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error('one and only one name per case');
        }
        var key = keys$1[0];
        var value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error('duplicate key detected:' + key);
        } else if (key === 'cata') {
          throw new Error('cannot have a case named cata (sorry)');
        } else if (!isArray(value)) {
          throw new Error('case arguments must be an array');
        }
        constructors.push(key);
        adt[key] = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var argLength = args.length;
          if (argLength !== value.length) {
            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
          }
          var match = function (branches) {
            var branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
            }
            var allReqd = forall(constructors, function (reqKey) {
              return contains$2(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: function () {
              var foldArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                foldArgs[_i] = arguments[_i];
              }
              if (foldArgs.length !== cases.length) {
                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
              }
              var target = foldArgs[count];
              return target.apply(null, args);
            },
            match: match,
            log: function (label) {
              console.log(label, {
                constructors: constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    var Adt = { generate: generate$7 };

    Adt.generate([
      {
        bothErrors: [
          'error1',
          'error2'
        ]
      },
      {
        firstError: [
          'error1',
          'value2'
        ]
      },
      {
        secondError: [
          'value1',
          'error2'
        ]
      },
      {
        bothValues: [
          'value1',
          'value2'
        ]
      }
    ]);
    var partition$1 = function (results) {
      var errors = [];
      var values = [];
      each$1(results, function (result) {
        result.fold(function (err) {
          errors.push(err);
        }, function (value) {
          values.push(value);
        });
      });
      return {
        errors: errors,
        values: values
      };
    };

    var exclude$1 = function (obj, fields) {
      var r = {};
      each(obj, function (v, k) {
        if (!contains$2(fields, k)) {
          r[k] = v;
        }
      });
      return r;
    };

    var wrap$2 = function (key, value) {
      var _a;
      return _a = {}, _a[key] = value, _a;
    };
    var wrapAll$1 = function (keyvalues) {
      var r = {};
      each$1(keyvalues, function (kv) {
        r[kv.key] = kv.value;
      });
      return r;
    };

    var exclude = function (obj, fields) {
      return exclude$1(obj, fields);
    };
    var wrap$1 = function (key, value) {
      return wrap$2(key, value);
    };
    var wrapAll = function (keyvalues) {
      return wrapAll$1(keyvalues);
    };
    var mergeValues = function (values, base) {
      return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values)));
    };
    var mergeErrors = function (errors) {
      return Result.error(flatten(errors));
    };
    var consolidate = function (objs, base) {
      var partitions = partition$1(objs);
      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);
    };

    var ensureIsRoot = function (isRoot) {
      return isFunction(isRoot) ? isRoot : never;
    };
    var ancestor$2 = function (scope, transform, isRoot) {
      var element = scope.dom;
      var stop = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        var transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$4 = function (scope, transform, isRoot) {
      var current = transform(scope);
      var stop = ensureIsRoot(isRoot);
      return current.orThunk(function () {
        return stop(scope) ? Optional.none() : ancestor$2(scope, transform, stop);
      });
    };

    var isSource = function (component, simulatedEvent) {
      return eq(component.element, simulatedEvent.event.target);
    };

    var defaultEventHandler = {
      can: always,
      abort: never,
      run: noop
    };
    var nu$9 = function (parts) {
      if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) {
        throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');
      }
      return __assign(__assign({}, defaultEventHandler), parts);
    };
    var all$2 = function (handlers, f) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return foldl(handlers, function (acc, handler) {
          return acc && f(handler).apply(undefined, args);
        }, true);
      };
    };
    var any = function (handlers, f) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return foldl(handlers, function (acc, handler) {
          return acc || f(handler).apply(undefined, args);
        }, false);
      };
    };
    var read$2 = function (handler) {
      return isFunction(handler) ? {
        can: always,
        abort: never,
        run: handler
      } : handler;
    };
    var fuse$1 = function (handlers) {
      var can = all$2(handlers, function (handler) {
        return handler.can;
      });
      var abort = any(handlers, function (handler) {
        return handler.abort;
      });
      var run = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        each$1(handlers, function (handler) {
          handler.run.apply(undefined, args);
        });
      };
      return {
        can: can,
        abort: abort,
        run: run
      };
    };

    var constant = constant$1;
    var touchstart = constant('touchstart');
    var touchmove = constant('touchmove');
    var touchend = constant('touchend');
    var touchcancel = constant('touchcancel');
    var mousedown = constant('mousedown');
    var mousemove = constant('mousemove');
    var mouseout = constant('mouseout');
    var mouseup = constant('mouseup');
    var mouseover = constant('mouseover');
    var focusin = constant('focusin');
    var focusout = constant('focusout');
    var keydown = constant('keydown');
    var keyup = constant('keyup');
    var input = constant('input');
    var change = constant('change');
    var click = constant('click');
    var transitioncancel = constant('transitioncancel');
    var transitionend = constant('transitionend');
    var transitionstart = constant('transitionstart');
    var selectstart = constant('selectstart');

    var prefixName = function (name) {
      return constant$1('alloy.' + name);
    };
    var alloy = { tap: prefixName('tap') };
    var focus$4 = prefixName('focus');
    var postBlur = prefixName('blur.post');
    var postPaste = prefixName('paste.post');
    var receive = prefixName('receive');
    var execute$5 = prefixName('execute');
    var focusItem = prefixName('focus.item');
    var tap = alloy.tap;
    var longpress = prefixName('longpress');
    var sandboxClose = prefixName('sandbox.close');
    var typeaheadCancel = prefixName('typeahead.cancel');
    var systemInit = prefixName('system.init');
    var documentTouchmove = prefixName('system.touchmove');
    var documentTouchend = prefixName('system.touchend');
    var windowScroll = prefixName('system.scroll');
    var windowResize = prefixName('system.resize');
    var attachedToDom = prefixName('system.attached');
    var detachedFromDom = prefixName('system.detached');
    var dismissRequested = prefixName('system.dismissRequested');
    var repositionRequested = prefixName('system.repositionRequested');
    var focusShifted = prefixName('focusmanager.shifted');
    var slotVisibility = prefixName('slotcontainer.visibility');
    var changeTab = prefixName('change.tab');
    var dismissTab = prefixName('dismiss.tab');
    var highlight$1 = prefixName('highlight');
    var dehighlight$1 = prefixName('dehighlight');

    var emit = function (component, event) {
      dispatchWith(component, component.element, event, {});
    };
    var emitWith = function (component, event, properties) {
      dispatchWith(component, component.element, event, properties);
    };
    var emitExecute = function (component) {
      emit(component, execute$5());
    };
    var dispatch = function (component, target, event) {
      dispatchWith(component, target, event, {});
    };
    var dispatchWith = function (component, target, event, properties) {
      var data = __assign({ target: target }, properties);
      component.getSystem().triggerEvent(event, target, data);
    };
    var dispatchEvent = function (component, target, event, simulatedEvent) {
      component.getSystem().triggerEvent(event, target, simulatedEvent.event);
    };

    var derive$2 = function (configs) {
      return wrapAll(configs);
    };
    var abort = function (name, predicate) {
      return {
        key: name,
        value: nu$9({ abort: predicate })
      };
    };
    var can = function (name, predicate) {
      return {
        key: name,
        value: nu$9({ can: predicate })
      };
    };
    var preventDefault = function (name) {
      return {
        key: name,
        value: nu$9({
          run: function (component, simulatedEvent) {
            simulatedEvent.event.prevent();
          }
        })
      };
    };
    var run$1 = function (name, handler) {
      return {
        key: name,
        value: nu$9({ run: handler })
      };
    };
    var runActionExtra = function (name, action, extra) {
      return {
        key: name,
        value: nu$9({
          run: function (component, simulatedEvent) {
            action.apply(undefined, [
              component,
              simulatedEvent
            ].concat(extra));
          }
        })
      };
    };
    var runOnName = function (name) {
      return function (handler) {
        return run$1(name, handler);
      };
    };
    var runOnSourceName = function (name) {
      return function (handler) {
        return {
          key: name,
          value: nu$9({
            run: function (component, simulatedEvent) {
              if (isSource(component, simulatedEvent)) {
                handler(component, simulatedEvent);
              }
            }
          })
        };
      };
    };
    var redirectToUid = function (name, uid) {
      return run$1(name, function (component, simulatedEvent) {
        component.getSystem().getByUid(uid).each(function (redirectee) {
          dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);
        });
      });
    };
    var redirectToPart = function (name, detail, partName) {
      var uid = detail.partUids[partName];
      return redirectToUid(name, uid);
    };
    var runWithTarget = function (name, f) {
      return run$1(name, function (component, simulatedEvent) {
        var ev = simulatedEvent.event;
        var target = component.getSystem().getByDom(ev.target).getOrThunk(function () {
          var closest = closest$4(ev.target, function (el) {
            return component.getSystem().getByDom(el).toOptional();
          }, never);
          return closest.getOr(component);
        });
        f(component, target, simulatedEvent);
      });
    };
    var cutter = function (name) {
      return run$1(name, function (component, simulatedEvent) {
        simulatedEvent.cut();
      });
    };
    var stopper = function (name) {
      return run$1(name, function (component, simulatedEvent) {
        simulatedEvent.stop();
      });
    };
    var runOnSource = function (name, f) {
      return runOnSourceName(name)(f);
    };
    var runOnAttached = runOnSourceName(attachedToDom());
    var runOnDetached = runOnSourceName(detachedFromDom());
    var runOnInit = runOnSourceName(systemInit());
    var runOnExecute$1 = runOnName(execute$5());

    var fromHtml$1 = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      return children(SugarElement.fromDom(div));
    };

    var get$7 = function (element) {
      return element.dom.innerHTML;
    };
    var set$5 = function (element, content) {
      var owner = owner$4(element);
      var docDom = owner.dom;
      var fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      var contentElements = fromHtml$1(content, docDom);
      append$1(fragment, contentElements);
      empty(element);
      append$2(element, fragment);
    };
    var getOuter = function (element) {
      var container = SugarElement.fromTag('div');
      var clone = SugarElement.fromDom(element.dom.cloneNode(true));
      append$2(container, clone);
      return get$7(container);
    };

    var clone$1 = function (original, isDeep) {
      return SugarElement.fromDom(original.dom.cloneNode(isDeep));
    };
    var shallow = function (original) {
      return clone$1(original, false);
    };

    var getHtml = function (element) {
      if (isShadowRoot(element)) {
        return '#shadow-root';
      } else {
        var clone = shallow(element);
        return getOuter(clone);
      }
    };

    var element = function (elem) {
      return getHtml(elem);
    };

    var isRecursive = function (component, originator, target) {
      return eq(originator, component.element) && !eq(originator, target);
    };
    var events$i = derive$2([can(focus$4(), function (component, simulatedEvent) {
        var event = simulatedEvent.event;
        var originator = event.originator;
        var target = event.target;
        if (isRecursive(component, originator, target)) {
          console.warn(focus$4() + ' did not get interpreted by the desired target. ' + '\nOriginator: ' + element(originator) + '\nTarget: ' + element(target) + '\nCheck the ' + focus$4() + ' event handlers');
          return false;
        } else {
          return true;
        }
      })]);

    var DefaultEvents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$i
    });

    var unique = 0;
    var generate$6 = function (prefix) {
      var date = new Date();
      var time = date.getTime();
      var random = Math.floor(Math.random() * 1000000000);
      unique++;
      return prefix + '_' + random + unique + String(time);
    };

    var prefix$1 = constant$1('alloy-id-');
    var idAttr$1 = constant$1('data-alloy-id');

    var prefix = prefix$1();
    var idAttr = idAttr$1();
    var write = function (label, elem) {
      var id = generate$6(prefix + label);
      writeOnly(elem, id);
      return id;
    };
    var writeOnly = function (elem, uid) {
      Object.defineProperty(elem.dom, idAttr, {
        value: uid,
        writable: true
      });
    };
    var read$1 = function (elem) {
      var id = isElement$2(elem) ? elem.dom[idAttr] : null;
      return Optional.from(id);
    };
    var generate$5 = function (prefix) {
      return generate$6(prefix);
    };

    var make$8 = identity$1;

    var NoContextApi = function (getComp) {
      var getMessage = function (event) {
        return 'The component must be in a context to execute: ' + event + (getComp ? '\n' + element(getComp().element) + ' is not in context.' : '');
      };
      var fail = function (event) {
        return function () {
          throw new Error(getMessage(event));
        };
      };
      var warn = function (event) {
        return function () {
          console.warn(getMessage(event));
        };
      };
      return {
        debugInfo: constant$1('fake'),
        triggerEvent: warn('triggerEvent'),
        triggerFocus: warn('triggerFocus'),
        triggerEscape: warn('triggerEscape'),
        broadcast: warn('broadcast'),
        broadcastOn: warn('broadcastOn'),
        broadcastEvent: warn('broadcastEvent'),
        build: fail('build'),
        addToWorld: fail('addToWorld'),
        removeFromWorld: fail('removeFromWorld'),
        addToGui: fail('addToGui'),
        removeFromGui: fail('removeFromGui'),
        getByUid: fail('getByUid'),
        getByDom: fail('getByDom'),
        isConnected: never
      };
    };
    var singleton$1 = NoContextApi();

    var markAsBehaviourApi = function (f, apiName, apiFunction) {
      var delegate = apiFunction.toString();
      var endIndex = delegate.indexOf(')') + 1;
      var openBracketIndex = delegate.indexOf('(');
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: apiName,
          parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
        };
      };
      return f;
    };
    var cleanParameters = function (parameters) {
      return map$2(parameters, function (p) {
        return endsWith(p, '/*') ? p.substring(0, p.length - '/*'.length) : p;
      });
    };
    var markAsExtraApi = function (f, extraName) {
      var delegate = f.toString();
      var endIndex = delegate.indexOf(')') + 1;
      var openBracketIndex = delegate.indexOf('(');
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: extraName,
          parameters: cleanParameters(parameters)
        };
      };
      return f;
    };
    var markAsSketchApi = function (f, apiFunction) {
      var delegate = apiFunction.toString();
      var endIndex = delegate.indexOf(')') + 1;
      var openBracketIndex = delegate.indexOf('(');
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: 'OVERRIDE',
          parameters: cleanParameters(parameters.slice(1))
        };
      };
      return f;
    };

    var premadeTag = generate$6('alloy-premade');
    var premade$1 = function (comp) {
      return wrap$1(premadeTag, comp);
    };
    var getPremade = function (spec) {
      return get$e(spec, premadeTag);
    };
    var makeApi = function (f) {
      return markAsSketchApi(function (component) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        return f.apply(void 0, __spreadArray([
          component.getApis(),
          component
        ], rest, false));
      }, f);
    };

    var NoState = {
      init: function () {
        return nu$8({ readState: constant$1('No State required') });
      }
    };
    var nu$8 = function (spec) {
      return spec;
    };

    var generateFrom$1 = function (spec, all) {
      var schema = map$2(all, function (a) {
        return optionObjOf(a.name(), [
          required$1('config'),
          defaulted('state', NoState)
        ]);
      });
      var validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold(function (errInfo) {
        throw new Error(formatError(errInfo) + '\nComplete spec:\n' + JSON.stringify(spec, null, 2));
      }, identity$1);
      return {
        list: all,
        data: map$1(validated, function (optBlobThunk) {
          var output = optBlobThunk.map(function (blob) {
            return {
              config: blob.config,
              state: blob.state.init(blob.config)
            };
          });
          return constant$1(output);
        })
      };
    };
    var getBehaviours$3 = function (bData) {
      return bData.list;
    };
    var getData$2 = function (bData) {
      return bData.data;
    };

    var byInnerKey = function (data, tuple) {
      var r = {};
      each(data, function (detail, key) {
        each(detail, function (value, indexKey) {
          var chain = get$e(r, indexKey).getOr([]);
          r[indexKey] = chain.concat([tuple(key, value)]);
        });
      });
      return r;
    };

    var nu$7 = function (s) {
      return {
        classes: isUndefined(s.classes) ? [] : s.classes,
        attributes: isUndefined(s.attributes) ? {} : s.attributes,
        styles: isUndefined(s.styles) ? {} : s.styles
      };
    };
    var merge = function (defnA, mod) {
      return __assign(__assign({}, defnA), {
        attributes: __assign(__assign({}, defnA.attributes), mod.attributes),
        styles: __assign(__assign({}, defnA.styles), mod.styles),
        classes: defnA.classes.concat(mod.classes)
      });
    };

    var combine$2 = function (info, baseMod, behaviours, base) {
      var modsByBehaviour = __assign({}, baseMod);
      each$1(behaviours, function (behaviour) {
        modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);
      });
      var byAspect = byInnerKey(modsByBehaviour, function (name, modification) {
        return {
          name: name,
          modification: modification
        };
      });
      var combineObjects = function (objects) {
        return foldr(objects, function (b, a) {
          return __assign(__assign({}, a.modification), b);
        }, {});
      };
      var combinedClasses = foldr(byAspect.classes, function (b, a) {
        return a.modification.concat(b);
      }, []);
      var combinedAttributes = combineObjects(byAspect.attributes);
      var combinedStyles = combineObjects(byAspect.styles);
      return nu$7({
        classes: combinedClasses,
        attributes: combinedAttributes,
        styles: combinedStyles
      });
    };

    var sortKeys = function (label, keyName, array, order) {
      try {
        var sorted = sort(array, function (a, b) {
          var aKey = a[keyName];
          var bKey = b[keyName];
          var aIndex = order.indexOf(aKey);
          var bIndex = order.indexOf(bKey);
          if (aIndex === -1) {
            throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey + '.\nOrder specified: ' + JSON.stringify(order, null, 2));
          }
          if (bIndex === -1) {
            throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey + '.\nOrder specified: ' + JSON.stringify(order, null, 2));
          }
          if (aIndex < bIndex) {
            return -1;
          } else if (bIndex < aIndex) {
            return 1;
          } else {
            return 0;
          }
        });
        return Result.value(sorted);
      } catch (err) {
        return Result.error([err]);
      }
    };

    var uncurried = function (handler, purpose) {
      return {
        handler: handler,
        purpose: purpose
      };
    };
    var curried = function (handler, purpose) {
      return {
        cHandler: handler,
        purpose: purpose
      };
    };
    var curryArgs = function (descHandler, extraArgs) {
      return curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose);
    };
    var getCurried = function (descHandler) {
      return descHandler.cHandler;
    };

    var behaviourTuple = function (name, handler) {
      return {
        name: name,
        handler: handler
      };
    };
    var nameToHandlers = function (behaviours, info) {
      var r = {};
      each$1(behaviours, function (behaviour) {
        r[behaviour.name()] = behaviour.handlers(info);
      });
      return r;
    };
    var groupByEvents = function (info, behaviours, base) {
      var behaviourEvents = __assign(__assign({}, base), nameToHandlers(behaviours, info));
      return byInnerKey(behaviourEvents, behaviourTuple);
    };
    var combine$1 = function (info, eventOrder, behaviours, base) {
      var byEventName = groupByEvents(info, behaviours, base);
      return combineGroups(byEventName, eventOrder);
    };
    var assemble = function (rawHandler) {
      var handler = read$2(rawHandler);
      return function (component, simulatedEvent) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          rest[_i - 2] = arguments[_i];
        }
        var args = [
          component,
          simulatedEvent
        ].concat(rest);
        if (handler.abort.apply(undefined, args)) {
          simulatedEvent.stop();
        } else if (handler.can.apply(undefined, args)) {
          handler.run.apply(undefined, args);
        }
      };
    };
    var missingOrderError = function (eventName, tuples) {
      return Result.error(['The event (' + eventName + ') has more than one behaviour that listens to it.\nWhen this occurs, you must ' + 'specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that ' + 'can trigger it are: ' + JSON.stringify(map$2(tuples, function (c) {
          return c.name;
        }), null, 2)]);
    };
    var fuse = function (tuples, eventOrder, eventName) {
      var order = eventOrder[eventName];
      if (!order) {
        return missingOrderError(eventName, tuples);
      } else {
        return sortKeys('Event: ' + eventName, 'name', tuples, order).map(function (sortedTuples) {
          var handlers = map$2(sortedTuples, function (tuple) {
            return tuple.handler;
          });
          return fuse$1(handlers);
        });
      }
    };
    var combineGroups = function (byEventName, eventOrder) {
      var r = mapToArray(byEventName, function (tuples, eventName) {
        var combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);
        return combined.map(function (handler) {
          var assembled = assemble(handler);
          var purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], function (o) {
            return exists(tuples, function (t) {
              return t.name === o;
            });
          }).join(' > ') : tuples[0].name;
          return wrap$1(eventName, uncurried(assembled, purpose));
        });
      });
      return consolidate(r, {});
    };

    var _a$2;
    var baseBehaviour = 'alloy.base.behaviour';
    var schema$z = objOf([
      field$1('dom', 'dom', required$2(), objOf([
        required$1('tag'),
        defaulted('styles', {}),
        defaulted('classes', []),
        defaulted('attributes', {}),
        option('value'),
        option('innerHtml')
      ])),
      required$1('components'),
      required$1('uid'),
      defaulted('events', {}),
      defaulted('apis', {}),
      field$1('eventOrder', 'eventOrder', mergeWith((_a$2 = {}, _a$2[execute$5()] = [
        'disabling',
        baseBehaviour,
        'toggling',
        'typeaheadevents'
      ], _a$2[focus$4()] = [
        baseBehaviour,
        'focusing',
        'keying'
      ], _a$2[systemInit()] = [
        baseBehaviour,
        'disabling',
        'toggling',
        'representing'
      ], _a$2[input()] = [
        baseBehaviour,
        'representing',
        'streaming',
        'invalidating'
      ], _a$2[detachedFromDom()] = [
        baseBehaviour,
        'representing',
        'item-events',
        'tooltipping'
      ], _a$2[mousedown()] = [
        'focusing',
        baseBehaviour,
        'item-type-events'
      ], _a$2[touchstart()] = [
        'focusing',
        baseBehaviour,
        'item-type-events'
      ], _a$2[mouseover()] = [
        'item-type-events',
        'tooltipping'
      ], _a$2[receive()] = [
        'receiving',
        'reflecting',
        'tooltipping'
      ], _a$2)), anyValue()),
      option('domModification')
    ]);
    var toInfo = function (spec) {
      return asRaw('custom.definition', schema$z, spec);
    };
    var toDefinition = function (detail) {
      return __assign(__assign({}, detail.dom), {
        uid: detail.uid,
        domChildren: map$2(detail.components, function (comp) {
          return comp.element;
        })
      });
    };
    var toModification = function (detail) {
      return detail.domModification.fold(function () {
        return nu$7({});
      }, nu$7);
    };
    var toEvents = function (info) {
      return info.events;
    };

    var read = function (element, attr) {
      var value = get$d(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    var add$4 = function (element, attr, id) {
      var old = read(element, attr);
      var nu = old.concat([id]);
      set$8(element, attr, nu.join(' '));
      return true;
    };
    var remove$4 = function (element, attr, id) {
      var nu = filter$2(read(element, attr), function (v) {
        return v !== id;
      });
      if (nu.length > 0) {
        set$8(element, attr, nu.join(' '));
      } else {
        remove$7(element, attr);
      }
      return false;
    };

    var supports = function (element) {
      return element.dom.classList !== undefined;
    };
    var get$6 = function (element) {
      return read(element, 'class');
    };
    var add$3 = function (element, clazz) {
      return add$4(element, 'class', clazz);
    };
    var remove$3 = function (element, clazz) {
      return remove$4(element, 'class', clazz);
    };

    var add$2 = function (element, clazz) {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$3(element, clazz);
      }
    };
    var cleanClass = function (element) {
      var classList = supports(element) ? element.dom.classList : get$6(element);
      if (classList.length === 0) {
        remove$7(element, 'class');
      }
    };
    var remove$2 = function (element, clazz) {
      if (supports(element)) {
        var classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$3(element, clazz);
      }
      cleanClass(element);
    };
    var has = function (element, clazz) {
      return supports(element) && element.dom.classList.contains(clazz);
    };

    var add$1 = function (element, classes) {
      each$1(classes, function (x) {
        add$2(element, x);
      });
    };
    var remove$1 = function (element, classes) {
      each$1(classes, function (x) {
        remove$2(element, x);
      });
    };
    var hasAll = function (element, classes) {
      return forall(classes, function (clazz) {
        return has(element, clazz);
      });
    };

    var get$5 = function (element) {
      return element.dom.value;
    };
    var set$4 = function (element, value) {
      if (value === undefined) {
        throw new Error('Value.set was undefined');
      }
      element.dom.value = value;
    };

    var renderToDom = function (definition) {
      var subject = SugarElement.fromTag(definition.tag);
      setAll$1(subject, definition.attributes);
      add$1(subject, definition.classes);
      setAll(subject, definition.styles);
      definition.innerHtml.each(function (html) {
        return set$5(subject, html);
      });
      var children = definition.domChildren;
      append$1(subject, children);
      definition.value.each(function (value) {
        set$4(subject, value);
      });
      if (!definition.uid) {
        debugger;
      }
      writeOnly(subject, definition.uid);
      return subject;
    };

    var getBehaviours$2 = function (spec) {
      var behaviours = get$e(spec, 'behaviours').getOr({});
      return bind$3(keys(behaviours), function (name) {
        var behaviour = behaviours[name];
        return isNonNullable(behaviour) ? [behaviour.me] : [];
      });
    };
    var generateFrom = function (spec, all) {
      return generateFrom$1(spec, all);
    };
    var generate$4 = function (spec) {
      var all = getBehaviours$2(spec);
      return generateFrom(spec, all);
    };

    var getDomDefinition = function (info, bList, bData) {
      var definition = toDefinition(info);
      var infoModification = toModification(info);
      var baseModification = { 'alloy.base.modification': infoModification };
      var modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;
      return merge(definition, modification);
    };
    var getEvents = function (info, bList, bData) {
      var baseEvents = { 'alloy.base.behaviour': toEvents(info) };
      return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
    };
    var build$2 = function (spec) {
      var getMe = function () {
        return me;
      };
      var systemApi = Cell(singleton$1);
      var info = getOrDie(toInfo(spec));
      var bBlob = generate$4(spec);
      var bList = getBehaviours$3(bBlob);
      var bData = getData$2(bBlob);
      var modDefinition = getDomDefinition(info, bList, bData);
      var item = renderToDom(modDefinition);
      var events = getEvents(info, bList, bData);
      var subcomponents = Cell(info.components);
      var connect = function (newApi) {
        systemApi.set(newApi);
      };
      var disconnect = function () {
        systemApi.set(NoContextApi(getMe));
      };
      var syncComponents = function () {
        var children$1 = children(item);
        var subs = bind$3(children$1, function (child) {
          return systemApi.get().getByDom(child).fold(function () {
            return [];
          }, pure$2);
        });
        subcomponents.set(subs);
      };
      var config = function (behaviour) {
        var b = bData;
        var f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : function () {
          throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));
        };
        return f();
      };
      var hasConfigured = function (behaviour) {
        return isFunction(bData[behaviour.name()]);
      };
      var getApis = function () {
        return info.apis;
      };
      var readState = function (behaviourName) {
        return bData[behaviourName]().map(function (b) {
          return b.state.readState();
        }).getOr('not enabled');
      };
      var me = {
        uid: spec.uid,
        getSystem: systemApi.get,
        config: config,
        hasConfigured: hasConfigured,
        spec: spec,
        readState: readState,
        getApis: getApis,
        connect: connect,
        disconnect: disconnect,
        element: item,
        syncComponents: syncComponents,
        components: subcomponents.get,
        events: events
      };
      return me;
    };

    var buildSubcomponents = function (spec) {
      var components = get$e(spec, 'components').getOr([]);
      return map$2(components, build$1);
    };
    var buildFromSpec = function (userSpec) {
      var _a = make$8(userSpec), specEvents = _a.events, spec = __rest(_a, ['events']);
      var components = buildSubcomponents(spec);
      var completeSpec = __assign(__assign({}, spec), {
        events: __assign(__assign({}, DefaultEvents), specEvents),
        components: components
      });
      return Result.value(build$2(completeSpec));
    };
    var text = function (textContent) {
      var element = SugarElement.fromText(textContent);
      return external$2({ element: element });
    };
    var external$2 = function (spec) {
      var extSpec = asRawOrDie$1('external.component', objOfOnly([
        required$1('element'),
        option('uid')
      ]), spec);
      var systemApi = Cell(NoContextApi());
      var connect = function (newApi) {
        systemApi.set(newApi);
      };
      var disconnect = function () {
        systemApi.set(NoContextApi(function () {
          return me;
        }));
      };
      var uid = extSpec.uid.getOrThunk(function () {
        return generate$5('external');
      });
      writeOnly(extSpec.element, uid);
      var me = {
        uid: uid,
        getSystem: systemApi.get,
        config: Optional.none,
        hasConfigured: never,
        connect: connect,
        disconnect: disconnect,
        getApis: function () {
          return {};
        },
        element: extSpec.element,
        spec: spec,
        readState: constant$1('No state'),
        syncComponents: noop,
        components: constant$1([]),
        events: {}
      };
      return premade$1(me);
    };
    var uids = generate$5;
    var isSketchSpec$1 = function (spec) {
      return has$2(spec, 'uid');
    };
    var build$1 = function (spec) {
      return getPremade(spec).getOrThunk(function () {
        var userSpecWithUid = isSketchSpec$1(spec) ? spec : __assign({ uid: uids('') }, spec);
        return buildFromSpec(userSpecWithUid).getOrDie();
      });
    };
    var premade = premade$1;

    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
      if (is(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor(scope, a, isRoot);
      }
    }

    var ancestor$1 = function (scope, predicate, isRoot) {
      var element = scope.dom;
      var stop = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$3 = function (scope, predicate, isRoot) {
      var is = function (s, test) {
        return test(s);
      };
      return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);
    };
    var child$1 = function (scope, predicate) {
      var pred = function (node) {
        return predicate(SugarElement.fromDom(node));
      };
      var result = find$5(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    var descendant$1 = function (scope, predicate) {
      var descend = function (node) {
        for (var i = 0; i < node.childNodes.length; i++) {
          var child_1 = SugarElement.fromDom(node.childNodes[i]);
          if (predicate(child_1)) {
            return Optional.some(child_1);
          }
          var res = descend(node.childNodes[i]);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope.dom);
    };

    var closest$2 = function (scope, predicate, isRoot) {
      return closest$3(scope, predicate, isRoot).isSome();
    };

    var ancestor = function (scope, selector, isRoot) {
      return ancestor$1(scope, function (e) {
        return is(e, selector);
      }, isRoot);
    };
    var child = function (scope, selector) {
      return child$1(scope, function (e) {
        return is(e, selector);
      });
    };
    var descendant = function (scope, selector) {
      return one(selector, scope);
    };
    var closest$1 = function (scope, selector, isRoot) {
      var is$1 = function (element, selector) {
        return is(element, selector);
      };
      return ClosestOrAncestor(is$1, ancestor, scope, selector, isRoot);
    };

    var find$1 = function (queryElem) {
      var dependent = closest$3(queryElem, function (elem) {
        if (!isElement$2(elem)) {
          return false;
        }
        var id = get$d(elem, 'id');
        return id !== undefined && id.indexOf('aria-owns') > -1;
      });
      return dependent.bind(function (dep) {
        var id = get$d(dep, 'id');
        var dos = getRootNode(dep);
        return descendant(dos, '[aria-owns="' + id + '"]');
      });
    };
    var manager = function () {
      var ariaId = generate$6('aria-owns');
      var link = function (elem) {
        set$8(elem, 'aria-owns', ariaId);
      };
      var unlink = function (elem) {
        remove$7(elem, 'aria-owns');
      };
      return {
        id: ariaId,
        link: link,
        unlink: unlink
      };
    };

    var isAriaPartOf = function (component, queryElem) {
      return find$1(queryElem).exists(function (owner) {
        return isPartOf$1(component, owner);
      });
    };
    var isPartOf$1 = function (component, queryElem) {
      return closest$2(queryElem, function (el) {
        return eq(el, component.element);
      }, never) || isAriaPartOf(component, queryElem);
    };

    var unknown = 'unknown';
    var EventConfiguration;
    (function (EventConfiguration) {
      EventConfiguration[EventConfiguration['STOP'] = 0] = 'STOP';
      EventConfiguration[EventConfiguration['NORMAL'] = 1] = 'NORMAL';
      EventConfiguration[EventConfiguration['LOGGING'] = 2] = 'LOGGING';
    }(EventConfiguration || (EventConfiguration = {})));
    var eventConfig = Cell({});
    var makeEventLogger = function (eventName, initialTarget) {
      var sequence = [];
      var startTime = new Date().getTime();
      return {
        logEventCut: function (_name, target, purpose) {
          sequence.push({
            outcome: 'cut',
            target: target,
            purpose: purpose
          });
        },
        logEventStopped: function (_name, target, purpose) {
          sequence.push({
            outcome: 'stopped',
            target: target,
            purpose: purpose
          });
        },
        logNoParent: function (_name, target, purpose) {
          sequence.push({
            outcome: 'no-parent',
            target: target,
            purpose: purpose
          });
        },
        logEventNoHandlers: function (_name, target) {
          sequence.push({
            outcome: 'no-handlers-left',
            target: target
          });
        },
        logEventResponse: function (_name, target, purpose) {
          sequence.push({
            outcome: 'response',
            purpose: purpose,
            target: target
          });
        },
        write: function () {
          var finishTime = new Date().getTime();
          if (contains$2([
              'mousemove',
              'mouseover',
              'mouseout',
              systemInit()
            ], eventName)) {
            return;
          }
          console.log(eventName, {
            event: eventName,
            time: finishTime - startTime,
            target: initialTarget.dom,
            sequence: map$2(sequence, function (s) {
              if (!contains$2([
                  'cut',
                  'stopped',
                  'response'
                ], s.outcome)) {
                return s.outcome;
              } else {
                return '{' + s.purpose + '} ' + s.outcome + ' at (' + element(s.target) + ')';
              }
            })
          });
        }
      };
    };
    var processEvent = function (eventName, initialTarget, f) {
      var status = get$e(eventConfig.get(), eventName).orThunk(function () {
        var patterns = keys(eventConfig.get());
        return findMap(patterns, function (p) {
          return eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none();
        });
      }).getOr(EventConfiguration.NORMAL);
      switch (status) {
      case EventConfiguration.NORMAL:
        return f(noLogger());
      case EventConfiguration.LOGGING: {
          var logger = makeEventLogger(eventName, initialTarget);
          var output = f(logger);
          logger.write();
          return output;
        }
      case EventConfiguration.STOP:
        return true;
      }
    };
    var path = [
      'alloy/data/Fields',
      'alloy/debugging/Debugging'
    ];
    var getTrace = function () {
      var err = new Error();
      if (err.stack !== undefined) {
        var lines = err.stack.split('\n');
        return find$5(lines, function (line) {
          return line.indexOf('alloy') > 0 && !exists(path, function (p) {
            return line.indexOf(p) > -1;
          });
        }).getOr(unknown);
      } else {
        return unknown;
      }
    };
    var ignoreEvent = {
      logEventCut: noop,
      logEventStopped: noop,
      logNoParent: noop,
      logEventNoHandlers: noop,
      logEventResponse: noop,
      write: noop
    };
    var monitorEvent = function (eventName, initialTarget, f) {
      return processEvent(eventName, initialTarget, f);
    };
    var noLogger = constant$1(ignoreEvent);

    var menuFields = constant$1([
      required$1('menu'),
      required$1('selectedMenu')
    ]);
    var itemFields = constant$1([
      required$1('item'),
      required$1('selectedItem')
    ]);
    constant$1(objOf(itemFields().concat(menuFields())));
    var itemSchema$3 = constant$1(objOf(itemFields()));

    var _initSize = requiredObjOf('initSize', [
      required$1('numColumns'),
      required$1('numRows')
    ]);
    var itemMarkers = function () {
      return requiredOf('markers', itemSchema$3());
    };
    var tieredMenuMarkers = function () {
      return requiredObjOf('markers', [required$1('backgroundMenu')].concat(menuFields()).concat(itemFields()));
    };
    var markers$1 = function (required) {
      return requiredObjOf('markers', map$2(required, required$1));
    };
    var onPresenceHandler = function (label, fieldName, presence) {
      getTrace();
      return field$1(fieldName, fieldName, presence, valueOf(function (f) {
        return Result.value(function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return f.apply(undefined, args);
        });
      }));
    };
    var onHandler = function (fieldName) {
      return onPresenceHandler('onHandler', fieldName, defaulted$1(noop));
    };
    var onKeyboardHandler = function (fieldName) {
      return onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none));
    };
    var onStrictHandler = function (fieldName) {
      return onPresenceHandler('onHandler', fieldName, required$2());
    };
    var onStrictKeyboardHandler = function (fieldName) {
      return onPresenceHandler('onKeyboardHandler', fieldName, required$2());
    };
    var output$1 = function (name, value) {
      return customField(name, constant$1(value));
    };
    var snapshot = function (name) {
      return customField(name, identity$1);
    };
    var initSize = constant$1(_initSize);

    var nu$6 = function (x, y, bubble, direction, placement, boundsRestriction, labelPrefix, alwaysFit) {
      if (alwaysFit === void 0) {
        alwaysFit = false;
      }
      return {
        x: x,
        y: y,
        bubble: bubble,
        direction: direction,
        placement: placement,
        restriction: boundsRestriction,
        label: labelPrefix + '-' + placement,
        alwaysFit: alwaysFit
      };
    };

    var adt$a = Adt.generate([
      { southeast: [] },
      { southwest: [] },
      { northeast: [] },
      { northwest: [] },
      { south: [] },
      { north: [] },
      { east: [] },
      { west: [] }
    ]);
    var cata$2 = function (subject, southeast, southwest, northeast, northwest, south, north, east, west) {
      return subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);
    };
    var cataVertical = function (subject, south, middle, north) {
      return subject.fold(south, south, north, north, south, north, middle, middle);
    };
    var cataHorizontal = function (subject, east, middle, west) {
      return subject.fold(east, west, east, west, middle, middle, east, west);
    };
    var southeast$3 = adt$a.southeast;
    var southwest$3 = adt$a.southwest;
    var northeast$3 = adt$a.northeast;
    var northwest$3 = adt$a.northwest;
    var south$3 = adt$a.south;
    var north$3 = adt$a.north;
    var east$3 = adt$a.east;
    var west$3 = adt$a.west;

    var cycleBy = function (value, delta, min, max) {
      var r = value + delta;
      if (r > max) {
        return min;
      } else if (r < min) {
        return max;
      } else {
        return r;
      }
    };
    var clamp$1 = function (value, min, max) {
      return Math.min(Math.max(value, min), max);
    };

    var getRestriction = function (anchor, restriction) {
      switch (restriction) {
      case 1:
        return anchor.x;
      case 0:
        return anchor.x + anchor.width;
      case 2:
        return anchor.y;
      case 3:
        return anchor.y + anchor.height;
      }
    };
    var boundsRestriction = function (anchor, restrictions) {
      return mapToObject([
        'left',
        'right',
        'top',
        'bottom'
      ], function (dir) {
        return get$e(restrictions, dir).map(function (restriction) {
          return getRestriction(anchor, restriction);
        });
      });
    };
    var adjustBounds = function (bounds$1, restriction, bubbleOffset) {
      var applyRestriction = function (dir, current) {
        return restriction[dir].map(function (pos) {
          var isVerticalAxis = dir === 'top' || dir === 'bottom';
          var offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;
          var comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;
          var newPos = comparator(pos, current) + offset;
          return isVerticalAxis ? clamp$1(newPos, bounds$1.y, bounds$1.bottom) : clamp$1(newPos, bounds$1.x, bounds$1.right);
        }).getOr(current);
      };
      var adjustedLeft = applyRestriction('left', bounds$1.x);
      var adjustedTop = applyRestriction('top', bounds$1.y);
      var adjustedRight = applyRestriction('right', bounds$1.right);
      var adjustedBottom = applyRestriction('bottom', bounds$1.bottom);
      return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
    };

    var labelPrefix$2 = 'layout';
    var eastX$1 = function (anchor) {
      return anchor.x;
    };
    var middleX$1 = function (anchor, element) {
      return anchor.x + anchor.width / 2 - element.width / 2;
    };
    var westX$1 = function (anchor, element) {
      return anchor.x + anchor.width - element.width;
    };
    var northY$2 = function (anchor, element) {
      return anchor.y - element.height;
    };
    var southY$2 = function (anchor) {
      return anchor.y + anchor.height;
    };
    var centreY$1 = function (anchor, element) {
      return anchor.y + anchor.height / 2 - element.height / 2;
    };
    var eastEdgeX$1 = function (anchor) {
      return anchor.x + anchor.width;
    };
    var westEdgeX$1 = function (anchor, element) {
      return anchor.x - element.width;
    };
    var southeast$2 = function (anchor, element, bubbles) {
      return nu$6(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {
        left: 1,
        top: 3
      }), labelPrefix$2);
    };
    var southwest$2 = function (anchor, element, bubbles) {
      return nu$6(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {
        right: 0,
        top: 3
      }), labelPrefix$2);
    };
    var northeast$2 = function (anchor, element, bubbles) {
      return nu$6(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {
        left: 1,
        bottom: 2
      }), labelPrefix$2);
    };
    var northwest$2 = function (anchor, element, bubbles) {
      return nu$6(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {
        right: 0,
        bottom: 2
      }), labelPrefix$2);
    };
    var north$2 = function (anchor, element, bubbles) {
      return nu$6(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), 'north', boundsRestriction(anchor, { bottom: 2 }), labelPrefix$2);
    };
    var south$2 = function (anchor, element, bubbles) {
      return nu$6(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), 'south', boundsRestriction(anchor, { top: 3 }), labelPrefix$2);
    };
    var east$2 = function (anchor, element, bubbles) {
      return nu$6(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), 'east', boundsRestriction(anchor, { left: 0 }), labelPrefix$2);
    };
    var west$2 = function (anchor, element, bubbles) {
      return nu$6(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), 'west', boundsRestriction(anchor, { right: 1 }), labelPrefix$2);
    };
    var all$1 = function () {
      return [
        southeast$2,
        southwest$2,
        northeast$2,
        northwest$2,
        south$2,
        north$2,
        east$2,
        west$2
      ];
    };
    var allRtl$1 = function () {
      return [
        southwest$2,
        southeast$2,
        northwest$2,
        northeast$2,
        south$2,
        north$2,
        east$2,
        west$2
      ];
    };
    var aboveOrBelow = function () {
      return [
        northeast$2,
        northwest$2,
        southeast$2,
        southwest$2,
        north$2,
        south$2
      ];
    };
    var aboveOrBelowRtl = function () {
      return [
        northwest$2,
        northeast$2,
        southwest$2,
        southeast$2,
        north$2,
        south$2
      ];
    };
    var belowOrAbove = function () {
      return [
        southeast$2,
        southwest$2,
        northeast$2,
        northwest$2,
        south$2,
        north$2
      ];
    };
    var belowOrAboveRtl = function () {
      return [
        southwest$2,
        southeast$2,
        northwest$2,
        northeast$2,
        south$2,
        north$2
      ];
    };

    var chooseChannels = function (channels, message) {
      return message.universal ? channels : filter$2(channels, function (ch) {
        return contains$2(message.channels, ch);
      });
    };
    var events$h = function (receiveConfig) {
      return derive$2([run$1(receive(), function (component, message) {
          var channelMap = receiveConfig.channels;
          var channels = keys(channelMap);
          var receivingData = message;
          var targetChannels = chooseChannels(channels, receivingData);
          each$1(targetChannels, function (ch) {
            var channelInfo = channelMap[ch];
            var channelSchema = channelInfo.schema;
            var data = asRawOrDie$1('channel[' + ch + '] data\nReceiver: ' + element(component.element), channelSchema, receivingData.data);
            channelInfo.onReceive(component, data);
          });
        })]);
    };

    var ActiveReceiving = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$h
    });

    var ReceivingSchema = [requiredOf('channels', setOf(Result.value, objOfOnly([
        onStrictHandler('onReceive'),
        defaulted('schema', anyValue())
      ])))];

    var executeEvent = function (bConfig, bState, executor) {
      return runOnExecute$1(function (component) {
        executor(component, bConfig, bState);
      });
    };
    var loadEvent = function (bConfig, bState, f) {
      return runOnInit(function (component, _simulatedEvent) {
        f(component, bConfig, bState);
      });
    };
    var create$8 = function (schema, name, active, apis, extra, state) {
      var configSchema = objOfOnly(schema);
      var schemaSchema = optionObjOf(name, [optionObjOfOnly('config', schema)]);
      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    var createModes$1 = function (modes, name, active, apis, extra, state) {
      var configSchema = modes;
      var schemaSchema = optionObjOf(name, [optionOf('config', modes)]);
      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    var wrapApi = function (bName, apiFunction, apiName) {
      var f = function (component) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        var args = [component].concat(rest);
        return component.config({ name: constant$1(bName) }).fold(function () {
          throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);
        }, function (info) {
          var rest = Array.prototype.slice.call(args, 1);
          return apiFunction.apply(undefined, [
            component,
            info.config,
            info.state
          ].concat(rest));
        });
      };
      return markAsBehaviourApi(f, apiName, apiFunction);
    };
    var revokeBehaviour = function (name) {
      return {
        key: name,
        value: undefined
      };
    };
    var doCreate = function (configSchema, schemaSchema, name, active, apis, extra, state) {
      var getConfig = function (info) {
        return hasNonNullableKey(info, name) ? info[name]() : Optional.none();
      };
      var wrappedApis = map$1(apis, function (apiF, apiName) {
        return wrapApi(name, apiF, apiName);
      });
      var wrappedExtra = map$1(extra, function (extraF, extraName) {
        return markAsExtraApi(extraF, extraName);
      });
      var me = __assign(__assign(__assign({}, wrappedExtra), wrappedApis), {
        revoke: curry(revokeBehaviour, name),
        config: function (spec) {
          var prepared = asRawOrDie$1(name + '-config', configSchema, spec);
          return {
            key: name,
            value: {
              config: prepared,
              me: me,
              configAsRaw: cached(function () {
                return asRawOrDie$1(name + '-config', configSchema, spec);
              }),
              initialConfig: spec,
              state: state
            }
          };
        },
        schema: constant$1(schemaSchema),
        exhibit: function (info, base) {
          return lift2(getConfig(info), get$e(active, 'exhibit'), function (behaviourInfo, exhibitor) {
            return exhibitor(base, behaviourInfo.config, behaviourInfo.state);
          }).getOrThunk(function () {
            return nu$7({});
          });
        },
        name: constant$1(name),
        handlers: function (info) {
          return getConfig(info).map(function (behaviourInfo) {
            var getEvents = get$e(active, 'events').getOr(function () {
              return {};
            });
            return getEvents(behaviourInfo.config, behaviourInfo.state);
          }).getOr({});
        }
      });
      return me;
    };

    var derive$1 = function (capabilities) {
      return wrapAll(capabilities);
    };
    var simpleSchema = objOfOnly([
      required$1('fields'),
      required$1('name'),
      defaulted('active', {}),
      defaulted('apis', {}),
      defaulted('state', NoState),
      defaulted('extra', {})
    ]);
    var create$7 = function (data) {
      var value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);
      return create$8(value.fields, value.name, value.active, value.apis, value.extra, value.state);
    };
    var modeSchema = objOfOnly([
      required$1('branchKey'),
      required$1('branches'),
      required$1('name'),
      defaulted('active', {}),
      defaulted('apis', {}),
      defaulted('state', NoState),
      defaulted('extra', {})
    ]);
    var createModes = function (data) {
      var value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);
      return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);
    };
    var revoke = constant$1(undefined);

    var Receiving = create$7({
      fields: ReceivingSchema,
      name: 'receiving',
      active: ActiveReceiving
    });

    var exhibit$6 = function (base, posConfig) {
      return nu$7({
        classes: [],
        styles: posConfig.useFixed() ? {} : { position: 'relative' }
      });
    };

    var ActivePosition = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$6
    });

    var getDocument = function () {
      return SugarElement.fromDom(document);
    };

    var focus$3 = function (element) {
      return element.dom.focus();
    };
    var blur$1 = function (element) {
      return element.dom.blur();
    };
    var hasFocus = function (element) {
      var root = getRootNode(element).dom;
      return element.dom === root.activeElement;
    };
    var active = function (root) {
      if (root === void 0) {
        root = getDocument();
      }
      return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    };
    var search = function (element) {
      return active(getRootNode(element)).filter(function (e) {
        return element.dom.contains(e.dom);
      });
    };

    var preserve$1 = function (f, container) {
      var dos = getRootNode(container);
      var refocus = active(dos).bind(function (focused) {
        var hasFocus = function (elem) {
          return eq(focused, elem);
        };
        return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);
      });
      var result = f(container);
      refocus.each(function (oldFocus) {
        active(dos).filter(function (newFocus) {
          return eq(newFocus, oldFocus);
        }).fold(function () {
          focus$3(oldFocus);
        }, noop);
      });
      return result;
    };

    var NuPositionCss = function (position, left, top, right, bottom) {
      var toPx = function (num) {
        return num + 'px';
      };
      return {
        position: position,
        left: left.map(toPx),
        top: top.map(toPx),
        right: right.map(toPx),
        bottom: bottom.map(toPx)
      };
    };
    var toOptions = function (position) {
      return __assign(__assign({}, position), { position: Optional.some(position.position) });
    };
    var applyPositionCss = function (element, position) {
      setOptions(element, toOptions(position));
    };

    var adt$9 = Adt.generate([
      { none: [] },
      {
        relative: [
          'x',
          'y',
          'width',
          'height'
        ]
      },
      {
        fixed: [
          'x',
          'y',
          'width',
          'height'
        ]
      }
    ]);
    var positionWithDirection = function (posName, decision, x, y, width, height) {
      var decisionRect = decision.rect;
      var decisionX = decisionRect.x - x;
      var decisionY = decisionRect.y - y;
      var decisionWidth = decisionRect.width;
      var decisionHeight = decisionRect.height;
      var decisionRight = width - (decisionX + decisionWidth);
      var decisionBottom = height - (decisionY + decisionHeight);
      var left = Optional.some(decisionX);
      var top = Optional.some(decisionY);
      var right = Optional.some(decisionRight);
      var bottom = Optional.some(decisionBottom);
      var none = Optional.none();
      return cata$2(decision.direction, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, none, top, right, none);
      }, function () {
        return NuPositionCss(posName, left, none, none, bottom);
      }, function () {
        return NuPositionCss(posName, none, none, right, bottom);
      }, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, left, none, none, bottom);
      }, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, none, top, right, none);
      });
    };
    var reposition = function (origin, decision) {
      return origin.fold(function () {
        var decisionRect = decision.rect;
        return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
      }, function (x, y, width, height) {
        return positionWithDirection('absolute', decision, x, y, width, height);
      }, function (x, y, width, height) {
        return positionWithDirection('fixed', decision, x, y, width, height);
      });
    };
    var toBox = function (origin, element) {
      var rel = curry(find$2, element);
      var position = origin.fold(rel, rel, function () {
        var scroll = get$9();
        return find$2(element).translate(-scroll.left, -scroll.top);
      });
      var width = getOuter$1(element);
      var height = getOuter$2(element);
      return bounds(position.left, position.top, width, height);
    };
    var viewport = function (origin, getBounds) {
      return getBounds.fold(function () {
        return origin.fold(win, win, bounds);
      }, function (b) {
        return origin.fold(b, b, function () {
          var bounds$1 = b();
          var pos = translate$2(origin, bounds$1.x, bounds$1.y);
          return bounds(pos.left, pos.top, bounds$1.width, bounds$1.height);
        });
      });
    };
    var translate$2 = function (origin, x, y) {
      var pos = SugarPosition(x, y);
      var removeScroll = function () {
        var outerScroll = get$9();
        return pos.translate(-outerScroll.left, -outerScroll.top);
      };
      return origin.fold(constant$1(pos), constant$1(pos), removeScroll);
    };
    var cata$1 = function (subject, onNone, onRelative, onFixed) {
      return subject.fold(onNone, onRelative, onFixed);
    };
    adt$9.none;
    var relative$1 = adt$9.relative;
    var fixed$1 = adt$9.fixed;

    var anchor = function (anchorBox, origin) {
      return {
        anchorBox: anchorBox,
        origin: origin
      };
    };
    var box = function (anchorBox, origin) {
      return anchor(anchorBox, origin);
    };

    var placementAttribute = 'data-alloy-placement';
    var setPlacement$1 = function (element, placement) {
      set$8(element, placementAttribute, placement);
    };
    var getPlacement = function (element) {
      return getOpt(element, placementAttribute);
    };
    var reset$2 = function (element) {
      return remove$7(element, placementAttribute);
    };

    var adt$8 = Adt.generate([
      { fit: ['reposition'] },
      {
        nofit: [
          'reposition',
          'visibleW',
          'visibleH',
          'isVisible'
        ]
      }
    ]);
    var determinePosition = function (box, bounds) {
      var boundsX = bounds.x, boundsY = bounds.y, boundsRight = bounds.right, boundsBottom = bounds.bottom;
      var x = box.x, y = box.y, right = box.right, bottom = box.bottom, width = box.width, height = box.height;
      var xInBounds = x >= boundsX && x <= boundsRight;
      var yInBounds = y >= boundsY && y <= boundsBottom;
      var originInBounds = xInBounds && yInBounds;
      var rightInBounds = right <= boundsRight && right >= boundsX;
      var bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;
      var sizeInBounds = rightInBounds && bottomInBounds;
      var visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);
      var visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);
      return {
        originInBounds: originInBounds,
        sizeInBounds: sizeInBounds,
        visibleW: visibleW,
        visibleH: visibleH
      };
    };
    var calcReposition = function (box, bounds$1) {
      var boundsX = bounds$1.x, boundsY = bounds$1.y, boundsRight = bounds$1.right, boundsBottom = bounds$1.bottom;
      var x = box.x, y = box.y, width = box.width, height = box.height;
      var maxX = Math.max(boundsX, boundsRight - width);
      var maxY = Math.max(boundsY, boundsBottom - height);
      var restrictedX = clamp$1(x, boundsX, maxX);
      var restrictedY = clamp$1(y, boundsY, maxY);
      var restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;
      var restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;
      return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);
    };
    var calcMaxSizes = function (direction, box, bounds) {
      var upAvailable = constant$1(box.bottom - bounds.y);
      var downAvailable = constant$1(bounds.bottom - box.y);
      var maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);
      var westAvailable = constant$1(box.right - bounds.x);
      var eastAvailable = constant$1(bounds.right - box.x);
      var maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);
      return {
        maxWidth: maxWidth,
        maxHeight: maxHeight
      };
    };
    var attempt = function (candidate, width, height, bounds$1) {
      var bubble = candidate.bubble;
      var bubbleOffset = bubble.offset;
      var adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);
      var newX = candidate.x + bubbleOffset.left;
      var newY = candidate.y + bubbleOffset.top;
      var box = bounds(newX, newY, width, height);
      var _a = determinePosition(box, adjustedBounds), originInBounds = _a.originInBounds, sizeInBounds = _a.sizeInBounds, visibleW = _a.visibleW, visibleH = _a.visibleH;
      var fits = originInBounds && sizeInBounds;
      var fittedBox = fits ? box : calcReposition(box, adjustedBounds);
      var isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;
      var _b = calcMaxSizes(candidate.direction, fittedBox, bounds$1), maxWidth = _b.maxWidth, maxHeight = _b.maxHeight;
      var reposition = {
        rect: fittedBox,
        maxHeight: maxHeight,
        maxWidth: maxWidth,
        direction: candidate.direction,
        placement: candidate.placement,
        classes: {
          on: bubble.classesOn,
          off: bubble.classesOff
        },
        layout: candidate.label,
        testY: newY
      };
      return fits || candidate.alwaysFit ? adt$8.fit(reposition) : adt$8.nofit(reposition, visibleW, visibleH, isPartlyVisible);
    };
    var attempts = function (element, candidates, anchorBox, elementBox, bubbles, bounds) {
      var panelWidth = elementBox.width;
      var panelHeight = elementBox.height;
      var attemptBestFit = function (layout, reposition, visibleW, visibleH, isVisible) {
        var next = layout(anchorBox, elementBox, bubbles, element, bounds);
        var attemptLayout = attempt(next, panelWidth, panelHeight, bounds);
        return attemptLayout.fold(constant$1(attemptLayout), function (newReposition, newVisibleW, newVisibleH, newIsVisible) {
          var improved = isVisible === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible && newIsVisible;
          return improved ? attemptLayout : adt$8.nofit(reposition, visibleW, visibleH, isVisible);
        });
      };
      var abc = foldl(candidates, function (b, a) {
        var bestNext = curry(attemptBestFit, a);
        return b.fold(constant$1(b), bestNext);
      }, adt$8.nofit({
        rect: anchorBox,
        maxHeight: elementBox.height,
        maxWidth: elementBox.width,
        direction: southeast$3(),
        placement: 'southeast',
        classes: {
          on: [],
          off: []
        },
        layout: 'none',
        testY: anchorBox.y
      }, -1, -1, false));
      return abc.fold(identity$1, identity$1);
    };

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var destroyable = function () {
      return singleton(function (s) {
        return s.destroy();
      });
    };
    var unbindable = function () {
      return singleton(function (s) {
        return s.unbind();
      });
    };
    var api$1 = function () {
      var subject = destroyable();
      var run = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { run: run });
    };
    var value$1 = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var filter = always;
    var bind = function (element, event, handler) {
      return bind$2(element, event, filter, handler);
    };
    var capture = function (element, event, handler) {
      return capture$1(element, event, filter, handler);
    };
    var fromRawEvent = fromRawEvent$1;

    var properties = [
      'top',
      'bottom',
      'right',
      'left'
    ];
    var timerAttr = 'data-alloy-transition-timer';
    var isTransitioning$1 = function (element, transition) {
      return hasAll(element, transition.classes);
    };
    var shouldApplyTransitionCss = function (transition, decision, lastPlacement) {
      return lastPlacement.exists(function (placer) {
        var mode = transition.mode;
        return mode === 'all' ? true : placer[mode] !== decision[mode];
      });
    };
    var hasChanges = function (position, intermediate) {
      var round = function (value) {
        return parseFloat(value).toFixed(3);
      };
      return find$4(intermediate, function (value, key) {
        var newValue = position[key].map(round);
        var val = value.map(round);
        return !equals(newValue, val);
      }).isSome();
    };
    var getTransitionDuration = function (element) {
      var get = function (name) {
        var style = get$c(element, name);
        var times = isString(style) ? style.split(/\s*,\s*/) : [];
        return filter$2(times, isNotEmpty);
      };
      var parse = function (value) {
        if (isString(value) && /^[\d.]+/.test(value)) {
          var num = parseFloat(value);
          return endsWith(value, 'ms') ? num : num * 1000;
        } else {
          return 0;
        }
      };
      var delay = get('transition-delay');
      var duration = get('transition-duration');
      return foldl(duration, function (acc, dur, i) {
        var time = parse(delay[i]) + parse(dur);
        return Math.max(acc, time);
      }, 0);
    };
    var setupTransitionListeners = function (element, transition) {
      var transitionEnd = unbindable();
      var transitionCancel = unbindable();
      var timer;
      var isSourceTransition = function (e) {
        var _a;
        var pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';
        return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);
      };
      var transitionDone = function (e) {
        if (isNullable(e) || isSourceTransition(e)) {
          transitionEnd.clear();
          transitionCancel.clear();
          var type = e === null || e === void 0 ? void 0 : e.raw.type;
          if (isNullable(type) || type === transitionend()) {
            clearTimeout(timer);
            remove$7(element, timerAttr);
            remove$1(element, transition.classes);
          }
        }
      };
      var transitionStarted = function () {
        transitionEnd.set(bind(element, transitionend(), transitionDone));
        transitionCancel.set(bind(element, transitioncancel(), transitionDone));
      };
      if ('ontransitionstart' in element.dom) {
        var transitionStart_1 = bind(element, transitionstart(), function (e) {
          if (isSourceTransition(e)) {
            transitionStart_1.unbind();
            transitionStarted();
          }
        });
      } else {
        transitionStarted();
      }
      var duration = getTransitionDuration(element);
      requestAnimationFrame(function () {
        timer = setTimeout(transitionDone, duration + 17);
        set$8(element, timerAttr, timer);
      });
    };
    var startTransitioning = function (element, transition) {
      add$1(element, transition.classes);
      getOpt(element, timerAttr).each(function (timerId) {
        clearTimeout(parseInt(timerId, 10));
        remove$7(element, timerAttr);
      });
      setupTransitionListeners(element, transition);
    };
    var applyTransitionCss = function (element, origin, position, transition, decision, lastPlacement) {
      var shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
      if (shouldTransition || isTransitioning$1(element, transition)) {
        set$7(element, 'position', position.position);
        var rect = toBox(origin, element);
        var intermediatePosition_1 = reposition(origin, __assign(__assign({}, decision), { rect: rect }));
        var intermediateCssOptions = mapToObject(properties, function (prop) {
          return intermediatePosition_1[prop];
        });
        if (hasChanges(position, intermediateCssOptions)) {
          setOptions(element, intermediateCssOptions);
          if (shouldTransition) {
            startTransitioning(element, transition);
          }
          reflow(element);
        }
      } else {
        remove$1(element, transition.classes);
      }
    };

    var elementSize = function (p) {
      return {
        width: getOuter$1(p),
        height: getOuter$2(p)
      };
    };
    var layout = function (anchorBox, element, bubbles, options) {
      remove$6(element, 'max-height');
      remove$6(element, 'max-width');
      var elementBox = elementSize(element);
      return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);
    };
    var setClasses = function (element, decision) {
      var classInfo = decision.classes;
      remove$1(element, classInfo.off);
      add$1(element, classInfo.on);
    };
    var setHeight = function (element, decision, options) {
      var maxHeightFunction = options.maxHeightFunction;
      maxHeightFunction(element, decision.maxHeight);
    };
    var setWidth = function (element, decision, options) {
      var maxWidthFunction = options.maxWidthFunction;
      maxWidthFunction(element, decision.maxWidth);
    };
    var position$2 = function (element, decision, options) {
      var positionCss = reposition(options.origin, decision);
      options.transition.each(function (transition) {
        applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);
      });
      applyPositionCss(element, positionCss);
    };
    var setPlacement = function (element, decision) {
      setPlacement$1(element, decision.placement);
    };

    var setMaxHeight = function (element, maxHeight) {
      setMax$1(element, Math.floor(maxHeight));
    };
    var anchored = constant$1(function (element, available) {
      setMaxHeight(element, available);
      setAll(element, {
        'overflow-x': 'hidden',
        'overflow-y': 'auto'
      });
    });
    var expandable$1 = constant$1(function (element, available) {
      setMaxHeight(element, available);
    });

    var defaultOr = function (options, key, dephault) {
      return options[key] === undefined ? dephault : options[key];
    };
    var simple = function (anchor, element, bubble, layouts, lastPlacement, getBounds, overrideOptions, transition) {
      var maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());
      var maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);
      var anchorBox = anchor.anchorBox;
      var origin = anchor.origin;
      var options = {
        bounds: viewport(origin, getBounds),
        origin: origin,
        preference: layouts,
        maxHeightFunction: maxHeightFunction,
        maxWidthFunction: maxWidthFunction,
        lastPlacement: lastPlacement,
        transition: transition
      };
      return go(anchorBox, element, bubble, options);
    };
    var go = function (anchorBox, element, bubble, options) {
      var decision = layout(anchorBox, element, bubble, options);
      position$2(element, decision, options);
      setPlacement(element, decision);
      setClasses(element, decision);
      setHeight(element, decision, options);
      setWidth(element, decision, options);
      return {
        layout: decision.layout,
        placement: decision.placement
      };
    };

    var allAlignments = [
      'valignCentre',
      'alignLeft',
      'alignRight',
      'alignCentre',
      'top',
      'bottom',
      'left',
      'right',
      'inset'
    ];
    var nu$5 = function (xOffset, yOffset, classes, insetModifier) {
      if (insetModifier === void 0) {
        insetModifier = 1;
      }
      var insetXOffset = xOffset * insetModifier;
      var insetYOffset = yOffset * insetModifier;
      var getClasses = function (prop) {
        return get$e(classes, prop).getOr([]);
      };
      var make = function (xDelta, yDelta, alignmentsOn) {
        var alignmentsOff = difference(allAlignments, alignmentsOn);
        return {
          offset: SugarPosition(xDelta, yDelta),
          classesOn: bind$3(alignmentsOn, getClasses),
          classesOff: bind$3(alignmentsOff, getClasses)
        };
      };
      return {
        southeast: function () {
          return make(-xOffset, yOffset, [
            'top',
            'alignLeft'
          ]);
        },
        southwest: function () {
          return make(xOffset, yOffset, [
            'top',
            'alignRight'
          ]);
        },
        south: function () {
          return make(-xOffset / 2, yOffset, [
            'top',
            'alignCentre'
          ]);
        },
        northeast: function () {
          return make(-xOffset, -yOffset, [
            'bottom',
            'alignLeft'
          ]);
        },
        northwest: function () {
          return make(xOffset, -yOffset, [
            'bottom',
            'alignRight'
          ]);
        },
        north: function () {
          return make(-xOffset / 2, -yOffset, [
            'bottom',
            'alignCentre'
          ]);
        },
        east: function () {
          return make(xOffset, -yOffset / 2, [
            'valignCentre',
            'left'
          ]);
        },
        west: function () {
          return make(-xOffset, -yOffset / 2, [
            'valignCentre',
            'right'
          ]);
        },
        insetNortheast: function () {
          return make(insetXOffset, insetYOffset, [
            'top',
            'alignLeft',
            'inset'
          ]);
        },
        insetNorthwest: function () {
          return make(-insetXOffset, insetYOffset, [
            'top',
            'alignRight',
            'inset'
          ]);
        },
        insetNorth: function () {
          return make(-insetXOffset / 2, insetYOffset, [
            'top',
            'alignCentre',
            'inset'
          ]);
        },
        insetSoutheast: function () {
          return make(insetXOffset, -insetYOffset, [
            'bottom',
            'alignLeft',
            'inset'
          ]);
        },
        insetSouthwest: function () {
          return make(-insetXOffset, -insetYOffset, [
            'bottom',
            'alignRight',
            'inset'
          ]);
        },
        insetSouth: function () {
          return make(-insetXOffset / 2, -insetYOffset, [
            'bottom',
            'alignCentre',
            'inset'
          ]);
        },
        insetEast: function () {
          return make(-insetXOffset, -insetYOffset / 2, [
            'valignCentre',
            'right',
            'inset'
          ]);
        },
        insetWest: function () {
          return make(insetXOffset, -insetYOffset / 2, [
            'valignCentre',
            'left',
            'inset'
          ]);
        }
      };
    };
    var fallback = function () {
      return nu$5(0, 0, {});
    };

    var nu$4 = identity$1;

    var onDirection = function (isLtr, isRtl) {
      return function (element) {
        return getDirection(element) === 'rtl' ? isRtl : isLtr;
      };
    };
    var getDirection = function (element) {
      return get$c(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';
    };

    var AttributeValue;
    (function (AttributeValue) {
      AttributeValue['TopToBottom'] = 'toptobottom';
      AttributeValue['BottomToTop'] = 'bottomtotop';
    }(AttributeValue || (AttributeValue = {})));
    var Attribute = 'data-alloy-vertical-dir';
    var isBottomToTopDir = function (el) {
      return closest$2(el, function (current) {
        return isElement$2(current) && get$d(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop;
      });
    };

    var schema$y = function () {
      return optionObjOf('layouts', [
        required$1('onLtr'),
        required$1('onRtl'),
        option('onBottomLtr'),
        option('onBottomRtl')
      ]);
    };
    var get$4 = function (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) {
      var isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
      var customLtr = info.layouts.map(function (ls) {
        return ls.onLtr(elem);
      });
      var customRtl = info.layouts.map(function (ls) {
        return ls.onRtl(elem);
      });
      var ltr = isBottomToTop ? info.layouts.bind(function (ls) {
        return ls.onBottomLtr.map(function (f) {
          return f(elem);
        });
      }).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);
      var rtl = isBottomToTop ? info.layouts.bind(function (ls) {
        return ls.onBottomRtl.map(function (f) {
          return f(elem);
        });
      }).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);
      var f = onDirection(ltr, rtl);
      return f(elem);
    };

    var placement$4 = function (component, anchorInfo, origin) {
      var hotspot = anchorInfo.hotspot;
      var anchorBox = toBox(origin, hotspot.element);
      var layouts = get$4(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));
      return Optional.some(nu$4({
        anchorBox: anchorBox,
        bubble: anchorInfo.bubble.getOr(fallback()),
        overrides: anchorInfo.overrides,
        layouts: layouts,
        placer: Optional.none()
      }));
    };
    var HotspotAnchor = [
      required$1('hotspot'),
      option('bubble'),
      defaulted('overrides', {}),
      schema$y(),
      output$1('placement', placement$4)
    ];

    var placement$3 = function (component, anchorInfo, origin) {
      var pos = translate$2(origin, anchorInfo.x, anchorInfo.y);
      var anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);
      var layouts = get$4(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());
      return Optional.some(nu$4({
        anchorBox: anchorBox,
        bubble: anchorInfo.bubble,
        overrides: anchorInfo.overrides,
        layouts: layouts,
        placer: Optional.none()
      }));
    };
    var MakeshiftAnchor = [
      required$1('x'),
      required$1('y'),
      defaulted('height', 0),
      defaulted('width', 0),
      defaulted('bubble', fallback()),
      defaulted('overrides', {}),
      schema$y(),
      output$1('placement', placement$3)
    ];

    var adt$7 = Adt.generate([
      { screen: ['point'] },
      {
        absolute: [
          'point',
          'scrollLeft',
          'scrollTop'
        ]
      }
    ]);
    var toFixed = function (pos) {
      return pos.fold(identity$1, function (point, scrollLeft, scrollTop) {
        return point.translate(-scrollLeft, -scrollTop);
      });
    };
    var toAbsolute = function (pos) {
      return pos.fold(identity$1, identity$1);
    };
    var sum = function (points) {
      return foldl(points, function (b, a) {
        return b.translate(a.left, a.top);
      }, SugarPosition(0, 0));
    };
    var sumAsFixed = function (positions) {
      var points = map$2(positions, toFixed);
      return sum(points);
    };
    var sumAsAbsolute = function (positions) {
      var points = map$2(positions, toAbsolute);
      return sum(points);
    };
    var screen = adt$7.screen;
    var absolute$1 = adt$7.absolute;

    var getOffset = function (component, origin, anchorInfo) {
      var win = defaultView(anchorInfo.root).dom;
      var hasSameOwner = function (frame) {
        var frameOwner = owner$4(frame);
        var compOwner = owner$4(component.element);
        return eq(frameOwner, compOwner);
      };
      return Optional.from(win.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);
    };
    var getRootPoint = function (component, origin, anchorInfo) {
      var doc = owner$4(component.element);
      var outerScroll = get$9(doc);
      var offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);
      return absolute$1(offset, outerScroll.left, outerScroll.top);
    };

    var getBox = function (left, top, width, height) {
      var point = screen(SugarPosition(left, top));
      return Optional.some(pointed(point, width, height));
    };
    var calcNewAnchor = function (optBox, rootPoint, anchorInfo, origin, elem) {
      return optBox.map(function (box) {
        var points = [
          rootPoint,
          box.point
        ];
        var topLeft = cata$1(origin, function () {
          return sumAsAbsolute(points);
        }, function () {
          return sumAsAbsolute(points);
        }, function () {
          return sumAsFixed(points);
        });
        var anchorBox = rect(topLeft.left, topLeft.top, box.width, box.height);
        var layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();
        var layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();
        var layouts = get$4(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());
        return nu$4({
          anchorBox: anchorBox,
          bubble: anchorInfo.bubble.getOr(fallback()),
          overrides: anchorInfo.overrides,
          layouts: layouts,
          placer: Optional.none()
        });
      });
    };

    var placement$2 = function (component, anchorInfo, origin) {
      var rootPoint = getRootPoint(component, origin, anchorInfo);
      return anchorInfo.node.filter(inBody).bind(function (target) {
        var rect = target.dom.getBoundingClientRect();
        var nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);
        var elem = anchorInfo.node.getOr(component.element);
        return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);
      });
    };
    var NodeAnchor = [
      required$1('node'),
      required$1('root'),
      option('bubble'),
      schema$y(),
      defaulted('overrides', {}),
      defaulted('showAbove', false),
      output$1('placement', placement$2)
    ];

    var zeroWidth = '\uFEFF';
    var nbsp = '\xA0';

    var create$6 = function (start, soffset, finish, foffset) {
      return {
        start: start,
        soffset: soffset,
        finish: finish,
        foffset: foffset
      };
    };
    var SimRange = { create: create$6 };

    var adt$6 = Adt.generate([
      { before: ['element'] },
      {
        on: [
          'element',
          'offset'
        ]
      },
      { after: ['element'] }
    ]);
    var cata = function (subject, onBefore, onOn, onAfter) {
      return subject.fold(onBefore, onOn, onAfter);
    };
    var getStart$1 = function (situ) {
      return situ.fold(identity$1, identity$1, identity$1);
    };
    var before = adt$6.before;
    var on$1 = adt$6.on;
    var after$1 = adt$6.after;
    var Situ = {
      before: before,
      on: on$1,
      after: after$1,
      cata: cata,
      getStart: getStart$1
    };

    var adt$5 = Adt.generate([
      { domRange: ['rng'] },
      {
        relative: [
          'startSitu',
          'finishSitu'
        ]
      },
      {
        exact: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    var exactFromRange = function (simRange) {
      return adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    };
    var getStart = function (selection) {
      return selection.match({
        domRange: function (rng) {
          return SugarElement.fromDom(rng.startContainer);
        },
        relative: function (startSitu, _finishSitu) {
          return Situ.getStart(startSitu);
        },
        exact: function (start, _soffset, _finish, _foffset) {
          return start;
        }
      });
    };
    var domRange = adt$5.domRange;
    var relative = adt$5.relative;
    var exact = adt$5.exact;
    var getWin = function (selection) {
      var start = getStart(selection);
      return defaultView(start);
    };
    var range$1 = SimRange.create;
    var SimSelection = {
      domRange: domRange,
      relative: relative,
      exact: exact,
      exactFromRange: exactFromRange,
      getWin: getWin,
      range: range$1
    };

    var setStart = function (rng, situ) {
      situ.fold(function (e) {
        rng.setStartBefore(e.dom);
      }, function (e, o) {
        rng.setStart(e.dom, o);
      }, function (e) {
        rng.setStartAfter(e.dom);
      });
    };
    var setFinish = function (rng, situ) {
      situ.fold(function (e) {
        rng.setEndBefore(e.dom);
      }, function (e, o) {
        rng.setEnd(e.dom, o);
      }, function (e) {
        rng.setEndAfter(e.dom);
      });
    };
    var relativeToNative = function (win, startSitu, finishSitu) {
      var range = win.document.createRange();
      setStart(range, startSitu);
      setFinish(range, finishSitu);
      return range;
    };
    var exactToNative = function (win, start, soffset, finish, foffset) {
      var rng = win.document.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };
    var toRect = function (rect) {
      return {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height
      };
    };
    var getFirstRect$1 = function (rng) {
      var rects = rng.getClientRects();
      var rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };
    var getBounds$2 = function (rng) {
      var rect = rng.getBoundingClientRect();
      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };

    var adt$4 = Adt.generate([
      {
        ltr: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      },
      {
        rtl: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    var fromRange = function (win, type, range) {
      return type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    };
    var getRanges = function (win, selection) {
      return selection.match({
        domRange: function (rng) {
          return {
            ltr: constant$1(rng),
            rtl: Optional.none
          };
        },
        relative: function (startSitu, finishSitu) {
          return {
            ltr: cached(function () {
              return relativeToNative(win, startSitu, finishSitu);
            }),
            rtl: cached(function () {
              return Optional.some(relativeToNative(win, finishSitu, startSitu));
            })
          };
        },
        exact: function (start, soffset, finish, foffset) {
          return {
            ltr: cached(function () {
              return exactToNative(win, start, soffset, finish, foffset);
            }),
            rtl: cached(function () {
              return Optional.some(exactToNative(win, finish, foffset, start, soffset));
            })
          };
        }
      });
    };
    var doDiagnose = function (win, ranges) {
      var rng = ranges.ltr();
      if (rng.collapsed) {
        var reversed = ranges.rtl().filter(function (rev) {
          return rev.collapsed === false;
        });
        return reversed.map(function (rev) {
          return adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset);
        }).getOrThunk(function () {
          return fromRange(win, adt$4.ltr, rng);
        });
      } else {
        return fromRange(win, adt$4.ltr, rng);
      }
    };
    var diagnose = function (win, selection) {
      var ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    var asLtrRange = function (win, selection) {
      var diagnosis = diagnose(win, selection);
      return diagnosis.match({
        ltr: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(start.dom, soffset);
          rng.setEnd(finish.dom, foffset);
          return rng;
        },
        rtl: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(finish.dom, foffset);
          rng.setEnd(start.dom, soffset);
          return rng;
        }
      });
    };
    adt$4.ltr;
    adt$4.rtl;

    var NodeValue = function (is, name) {
      var get = function (element) {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      var getOption = function (element) {
        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      };
      var set = function (element, value) {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get: get,
        getOption: getOption,
        set: set
      };
    };

    var api = NodeValue(isText$1, 'text');
    var get$3 = function (element) {
      return api.get(element);
    };
    var getOption = function (element) {
      return api.getOption(element);
    };

    var getEnd = function (element) {
      return name$2(element) === 'img' ? 1 : getOption(element).fold(function () {
        return children(element).length;
      }, function (v) {
        return v.length;
      });
    };
    var isTextNodeWithCursorPosition = function (el) {
      return getOption(el).filter(function (text) {
        return text.trim().length !== 0 || text.indexOf(nbsp) > -1;
      }).isSome();
    };
    var elementsWithCursorPosition = [
      'img',
      'br'
    ];
    var isCursorPosition = function (elem) {
      var hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains$2(elementsWithCursorPosition, name$2(elem));
    };

    var last$1 = function (element) {
      return descendantRtl(element, isCursorPosition);
    };
    var descendantRtl = function (scope, predicate) {
      var descend = function (element) {
        var children$1 = children(element);
        for (var i = children$1.length - 1; i >= 0; i--) {
          var child = children$1[i];
          if (predicate(child)) {
            return Optional.some(child);
          }
          var res = descend(child);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope);
    };

    var descendants = function (scope, selector) {
      return all$3(selector, scope);
    };

    var makeRange = function (start, soffset, finish, foffset) {
      var doc = owner$4(start);
      var rng = doc.dom.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };
    var after = function (start, soffset, finish, foffset) {
      var r = makeRange(start, soffset, finish, foffset);
      var same = eq(start, finish) && soffset === foffset;
      return r.collapsed && !same;
    };

    var getNativeSelection = function (win) {
      return Optional.from(win.getSelection());
    };
    var readRange = function (selection) {
      if (selection.rangeCount > 0) {
        var firstRng = selection.getRangeAt(0);
        var lastRng = selection.getRangeAt(selection.rangeCount - 1);
        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
      } else {
        return Optional.none();
      }
    };
    var doGetExact = function (selection) {
      if (selection.anchorNode === null || selection.focusNode === null) {
        return readRange(selection);
      } else {
        var anchor = SugarElement.fromDom(selection.anchorNode);
        var focus_1 = SugarElement.fromDom(selection.focusNode);
        return after(anchor, selection.anchorOffset, focus_1, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus_1, selection.focusOffset)) : readRange(selection);
      }
    };
    var getExact = function (win) {
      return getNativeSelection(win).filter(function (sel) {
        return sel.rangeCount > 0;
      }).bind(doGetExact);
    };
    var getFirstRect = function (win, selection) {
      var rng = asLtrRange(win, selection);
      return getFirstRect$1(rng);
    };
    var getBounds$1 = function (win, selection) {
      var rng = asLtrRange(win, selection);
      return getBounds$2(rng);
    };

    var point$1 = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };
    var descendOnce$1 = function (element, offset) {
      var children$1 = children(element);
      if (children$1.length === 0) {
        return point$1(element, offset);
      } else if (offset < children$1.length) {
        return point$1(children$1[offset], 0);
      } else {
        var last = children$1[children$1.length - 1];
        var len = isText$1(last) ? get$3(last).length : children(last).length;
        return point$1(last, len);
      }
    };

    var descendOnce = function (element, offset) {
      return isText$1(element) ? point$1(element, offset) : descendOnce$1(element, offset);
    };
    var getAnchorSelection = function (win, anchorInfo) {
      var getSelection = anchorInfo.getSelection.getOrThunk(function () {
        return function () {
          return getExact(win);
        };
      });
      return getSelection().map(function (sel) {
        var modStart = descendOnce(sel.start, sel.soffset);
        var modFinish = descendOnce(sel.finish, sel.foffset);
        return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
      });
    };
    var placement$1 = function (component, anchorInfo, origin) {
      var win = defaultView(anchorInfo.root).dom;
      var rootPoint = getRootPoint(component, origin, anchorInfo);
      var selectionBox = getAnchorSelection(win, anchorInfo).bind(function (sel) {
        var optRect = getBounds$1(win, SimSelection.exactFromRange(sel)).orThunk(function () {
          var x = SugarElement.fromText(zeroWidth);
          before$2(sel.start, x);
          var rect = getFirstRect(win, SimSelection.exact(x, 0, x, 1));
          remove$5(x);
          return rect;
        });
        return optRect.bind(function (rawRect) {
          return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);
        });
      });
      var targetElement = getAnchorSelection(win, anchorInfo).bind(function (sel) {
        return isElement$2(sel.start) ? Optional.some(sel.start) : parentNode(sel.start);
      });
      var elem = targetElement.getOr(component.element);
      return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
    };
    var SelectionAnchor = [
      option('getSelection'),
      required$1('root'),
      option('bubble'),
      schema$y(),
      defaulted('overrides', {}),
      defaulted('showAbove', false),
      output$1('placement', placement$1)
    ];

    var labelPrefix$1 = 'link-layout';
    var eastX = function (anchor) {
      return anchor.x + anchor.width;
    };
    var westX = function (anchor, element) {
      return anchor.x - element.width;
    };
    var northY$1 = function (anchor, element) {
      return anchor.y - element.height + anchor.height;
    };
    var southY$1 = function (anchor) {
      return anchor.y;
    };
    var southeast$1 = function (anchor, element, bubbles) {
      return nu$6(eastX(anchor), southY$1(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {
        left: 0,
        top: 2
      }), labelPrefix$1);
    };
    var southwest$1 = function (anchor, element, bubbles) {
      return nu$6(westX(anchor, element), southY$1(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {
        right: 1,
        top: 2
      }), labelPrefix$1);
    };
    var northeast$1 = function (anchor, element, bubbles) {
      return nu$6(eastX(anchor), northY$1(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {
        left: 0,
        bottom: 3
      }), labelPrefix$1);
    };
    var northwest$1 = function (anchor, element, bubbles) {
      return nu$6(westX(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {
        right: 1,
        bottom: 3
      }), labelPrefix$1);
    };
    var all = function () {
      return [
        southeast$1,
        southwest$1,
        northeast$1,
        northwest$1
      ];
    };
    var allRtl = function () {
      return [
        southwest$1,
        southeast$1,
        northwest$1,
        northeast$1
      ];
    };

    var placement = function (component, submenuInfo, origin) {
      var anchorBox = toBox(origin, submenuInfo.item.element);
      var layouts = get$4(component.element, submenuInfo, all(), allRtl(), all(), allRtl(), Optional.none());
      return Optional.some(nu$4({
        anchorBox: anchorBox,
        bubble: fallback(),
        overrides: submenuInfo.overrides,
        layouts: layouts,
        placer: Optional.none()
      }));
    };
    var SubmenuAnchor = [
      required$1('item'),
      schema$y(),
      defaulted('overrides', {}),
      output$1('placement', placement)
    ];

    var AnchorSchema = choose$1('type', {
      selection: SelectionAnchor,
      node: NodeAnchor,
      hotspot: HotspotAnchor,
      submenu: SubmenuAnchor,
      makeshift: MakeshiftAnchor
    });

    var TransitionSchema = [
      requiredArrayOf('classes', string),
      defaultedStringEnum('mode', 'all', [
        'all',
        'layout',
        'placement'
      ])
    ];
    var PositionSchema = [
      defaulted('useFixed', never),
      option('getBounds')
    ];
    var PlacementSchema = [
      requiredOf('anchor', AnchorSchema),
      optionObjOf('transition', TransitionSchema)
    ];

    var getFixedOrigin = function () {
      var html = document.documentElement;
      return fixed$1(0, 0, html.clientWidth, html.clientHeight);
    };
    var getRelativeOrigin = function (component) {
      var position = absolute$3(component.element);
      var bounds = component.element.dom.getBoundingClientRect();
      return relative$1(position.left, position.top, bounds.width, bounds.height);
    };
    var place = function (component, origin, anchoring, getBounds, placee, lastPlace, transition) {
      var anchor = box(anchoring.anchorBox, origin);
      return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, getBounds, anchoring.overrides, transition);
    };
    var position$1 = function (component, posConfig, posState, placee, placementSpec) {
      positionWithin(component, posConfig, posState, placee, placementSpec, Optional.none());
    };
    var positionWithin = function (component, posConfig, posState, placee, placementSpec, boxElement) {
      var boundsBox = boxElement.map(box$1);
      return positionWithinBounds(component, posConfig, posState, placee, placementSpec, boundsBox);
    };
    var positionWithinBounds = function (component, posConfig, posState, placee, placementSpec, bounds) {
      var placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);
      var anchorage = placeeDetail.anchor;
      var element = placee.element;
      var placeeState = posState.get(placee.uid);
      preserve$1(function () {
        set$7(element, 'position', 'fixed');
        var oldVisibility = getRaw(element, 'visibility');
        set$7(element, 'visibility', 'hidden');
        var origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
        var placer = anchorage.placement;
        var getBounds = bounds.map(constant$1).or(posConfig.getBounds);
        placer(component, anchorage, origin).each(function (anchoring) {
          var doPlace = anchoring.placer.getOr(place);
          var newState = doPlace(component, origin, anchoring, getBounds, placee, placeeState, placeeDetail.transition);
          posState.set(placee.uid, newState);
        });
        oldVisibility.fold(function () {
          remove$6(element, 'visibility');
        }, function (vis) {
          set$7(element, 'visibility', vis);
        });
        if (getRaw(element, 'left').isNone() && getRaw(element, 'top').isNone() && getRaw(element, 'right').isNone() && getRaw(element, 'bottom').isNone() && is$1(getRaw(element, 'position'), 'fixed')) {
          remove$6(element, 'position');
        }
      }, element);
    };
    var getMode = function (component, pConfig, _pState) {
      return pConfig.useFixed() ? 'fixed' : 'absolute';
    };
    var reset$1 = function (component, pConfig, posState, placee) {
      var element = placee.element;
      each$1([
        'position',
        'left',
        'right',
        'top',
        'bottom'
      ], function (prop) {
        return remove$6(element, prop);
      });
      reset$2(element);
      posState.clear(placee.uid);
    };

    var PositionApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        position: position$1,
        positionWithin: positionWithin,
        positionWithinBounds: positionWithinBounds,
        getMode: getMode,
        reset: reset$1
    });

    var init$g = function () {
      var state = {};
      var set = function (id, data) {
        state[id] = data;
      };
      var get = function (id) {
        return get$e(state, id);
      };
      var clear = function (id) {
        if (isNonNullable(id)) {
          delete state[id];
        } else {
          state = {};
        }
      };
      return nu$8({
        readState: function () {
          return state;
        },
        clear: clear,
        set: set,
        get: get
      });
    };

    var PositioningState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$g
    });

    var Positioning = create$7({
      fields: PositionSchema,
      name: 'positioning',
      active: ActivePosition,
      apis: PositionApis,
      state: PositioningState
    });

    var fireDetaching = function (component) {
      emit(component, detachedFromDom());
      var children = component.components();
      each$1(children, fireDetaching);
    };
    var fireAttaching = function (component) {
      var children = component.components();
      each$1(children, fireAttaching);
      emit(component, attachedToDom());
    };
    var attach$1 = function (parent, child) {
      append$2(parent.element, child.element);
    };
    var detachChildren$1 = function (component) {
      each$1(component.components(), function (childComp) {
        return remove$5(childComp.element);
      });
      empty(component.element);
      component.syncComponents();
    };
    var replaceChildren = function (component, newChildren) {
      var subs = component.components();
      detachChildren$1(component);
      var deleted = difference(subs, newChildren);
      each$1(deleted, function (comp) {
        fireDetaching(comp);
        component.getSystem().removeFromWorld(comp);
      });
      each$1(newChildren, function (childComp) {
        if (!childComp.getSystem().isConnected()) {
          component.getSystem().addToWorld(childComp);
          attach$1(component, childComp);
          if (inBody(component.element)) {
            fireAttaching(childComp);
          }
        } else {
          attach$1(component, childComp);
        }
        component.syncComponents();
      });
    };

    var attach = function (parent, child) {
      attachWith(parent, child, append$2);
    };
    var attachWith = function (parent, child, insertion) {
      parent.getSystem().addToWorld(child);
      insertion(parent.element, child.element);
      if (inBody(parent.element)) {
        fireAttaching(child);
      }
      parent.syncComponents();
    };
    var doDetach = function (component) {
      fireDetaching(component);
      remove$5(component.element);
      component.getSystem().removeFromWorld(component);
    };
    var detach = function (component) {
      var parent$1 = parent(component.element).bind(function (p) {
        return component.getSystem().getByDom(p).toOptional();
      });
      doDetach(component);
      parent$1.each(function (p) {
        p.syncComponents();
      });
    };
    var detachChildren = function (component) {
      var subs = component.components();
      each$1(subs, doDetach);
      empty(component.element);
      component.syncComponents();
    };
    var attachSystem = function (element, guiSystem) {
      attachSystemWith(element, guiSystem, append$2);
    };
    var attachSystemAfter = function (element, guiSystem) {
      attachSystemWith(element, guiSystem, after$2);
    };
    var attachSystemWith = function (element, guiSystem, inserter) {
      inserter(element, guiSystem.element);
      var children$1 = children(guiSystem.element);
      each$1(children$1, function (child) {
        guiSystem.getByDom(child).each(fireAttaching);
      });
    };
    var detachSystem = function (guiSystem) {
      var children$1 = children(guiSystem.element);
      each$1(children$1, function (child) {
        guiSystem.getByDom(child).each(fireDetaching);
      });
      remove$5(guiSystem.element);
    };

    var rebuild = function (sandbox, sConfig, sState, data) {
      sState.get().each(function (_data) {
        detachChildren(sandbox);
      });
      var point = sConfig.getAttachPoint(sandbox);
      attach(point, sandbox);
      var built = sandbox.getSystem().build(data);
      attach(sandbox, built);
      sState.set(built);
      return built;
    };
    var open$1 = function (sandbox, sConfig, sState, data) {
      var newState = rebuild(sandbox, sConfig, sState, data);
      sConfig.onOpen(sandbox, newState);
      return newState;
    };
    var setContent = function (sandbox, sConfig, sState, data) {
      return sState.get().map(function () {
        return rebuild(sandbox, sConfig, sState, data);
      });
    };
    var openWhileCloaked = function (sandbox, sConfig, sState, data, transaction) {
      cloak(sandbox, sConfig);
      open$1(sandbox, sConfig, sState, data);
      transaction();
      decloak(sandbox, sConfig);
    };
    var close$1 = function (sandbox, sConfig, sState) {
      sState.get().each(function (data) {
        detachChildren(sandbox);
        detach(sandbox);
        sConfig.onClose(sandbox, data);
        sState.clear();
      });
    };
    var isOpen$1 = function (_sandbox, _sConfig, sState) {
      return sState.isOpen();
    };
    var isPartOf = function (sandbox, sConfig, sState, queryElem) {
      return isOpen$1(sandbox, sConfig, sState) && sState.get().exists(function (data) {
        return sConfig.isPartOf(sandbox, data, queryElem);
      });
    };
    var getState$2 = function (_sandbox, _sConfig, sState) {
      return sState.get();
    };
    var store = function (sandbox, cssKey, attr, newValue) {
      getRaw(sandbox.element, cssKey).fold(function () {
        remove$7(sandbox.element, attr);
      }, function (v) {
        set$8(sandbox.element, attr, v);
      });
      set$7(sandbox.element, cssKey, newValue);
    };
    var restore = function (sandbox, cssKey, attr) {
      getOpt(sandbox.element, attr).fold(function () {
        return remove$6(sandbox.element, cssKey);
      }, function (oldValue) {
        return set$7(sandbox.element, cssKey, oldValue);
      });
    };
    var cloak = function (sandbox, sConfig, _sState) {
      var sink = sConfig.getAttachPoint(sandbox);
      set$7(sandbox.element, 'position', Positioning.getMode(sink));
      store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
    };
    var hasPosition = function (element) {
      return exists([
        'top',
        'left',
        'right',
        'bottom'
      ], function (pos) {
        return getRaw(element, pos).isSome();
      });
    };
    var decloak = function (sandbox, sConfig, _sState) {
      if (!hasPosition(sandbox.element)) {
        remove$6(sandbox.element, 'position');
      }
      restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
    };

    var SandboxApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        cloak: cloak,
        decloak: decloak,
        open: open$1,
        openWhileCloaked: openWhileCloaked,
        close: close$1,
        isOpen: isOpen$1,
        isPartOf: isPartOf,
        getState: getState$2,
        setContent: setContent
    });

    var events$g = function (sandboxConfig, sandboxState) {
      return derive$2([run$1(sandboxClose(), function (sandbox, _simulatedEvent) {
          close$1(sandbox, sandboxConfig, sandboxState);
        })]);
    };

    var ActiveSandbox = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$g
    });

    var SandboxSchema = [
      onHandler('onOpen'),
      onHandler('onClose'),
      required$1('isPartOf'),
      required$1('getAttachPoint'),
      defaulted('cloakVisibilityAttr', 'data-precloak-visibility')
    ];

    var init$f = function () {
      var contents = value$1();
      var readState = constant$1('not-implemented');
      return nu$8({
        readState: readState,
        isOpen: contents.isSet,
        clear: contents.clear,
        set: contents.set,
        get: contents.get
      });
    };

    var SandboxState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$f
    });

    var Sandboxing = create$7({
      fields: SandboxSchema,
      name: 'sandboxing',
      active: ActiveSandbox,
      apis: SandboxApis,
      state: SandboxState
    });

    var dismissPopups = constant$1('dismiss.popups');
    var repositionPopups = constant$1('reposition.popups');
    var mouseReleased = constant$1('mouse.released');

    var schema$x = objOfOnly([
      defaulted('isExtraPart', never),
      optionObjOf('fireEventInstead', [defaulted('event', dismissRequested())])
    ]);
    var receivingChannel$1 = function (rawSpec) {
      var _a;
      var detail = asRawOrDie$1('Dismissal', schema$x, rawSpec);
      return _a = {}, _a[dismissPopups()] = {
        schema: objOfOnly([required$1('target')]),
        onReceive: function (sandbox, data) {
          if (Sandboxing.isOpen(sandbox)) {
            var isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
            if (!isPart) {
              detail.fireEventInstead.fold(function () {
                return Sandboxing.close(sandbox);
              }, function (fe) {
                return emit(sandbox, fe.event);
              });
            }
          }
        }
      }, _a;
    };

    var schema$w = objOfOnly([
      optionObjOf('fireEventInstead', [defaulted('event', repositionRequested())]),
      requiredFunction('doReposition')
    ]);
    var receivingChannel = function (rawSpec) {
      var _a;
      var detail = asRawOrDie$1('Reposition', schema$w, rawSpec);
      return _a = {}, _a[repositionPopups()] = {
        onReceive: function (sandbox) {
          if (Sandboxing.isOpen(sandbox)) {
            detail.fireEventInstead.fold(function () {
              return detail.doReposition(sandbox);
            }, function (fe) {
              return emit(sandbox, fe.event);
            });
          }
        }
      }, _a;
    };

    var onLoad$5 = function (component, repConfig, repState) {
      repConfig.store.manager.onLoad(component, repConfig, repState);
    };
    var onUnload$2 = function (component, repConfig, repState) {
      repConfig.store.manager.onUnload(component, repConfig, repState);
    };
    var setValue$3 = function (component, repConfig, repState, data) {
      repConfig.store.manager.setValue(component, repConfig, repState, data);
    };
    var getValue$3 = function (component, repConfig, repState) {
      return repConfig.store.manager.getValue(component, repConfig, repState);
    };
    var getState$1 = function (component, repConfig, repState) {
      return repState;
    };

    var RepresentApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad$5,
        onUnload: onUnload$2,
        setValue: setValue$3,
        getValue: getValue$3,
        getState: getState$1
    });

    var events$f = function (repConfig, repState) {
      var es = repConfig.resetOnDom ? [
        runOnAttached(function (comp, _se) {
          onLoad$5(comp, repConfig, repState);
        }),
        runOnDetached(function (comp, _se) {
          onUnload$2(comp, repConfig, repState);
        })
      ] : [loadEvent(repConfig, repState, onLoad$5)];
      return derive$2(es);
    };

    var ActiveRepresenting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$f
    });

    var memory$1 = function () {
      var data = Cell(null);
      var readState = function () {
        return {
          mode: 'memory',
          value: data.get()
        };
      };
      var isNotSet = function () {
        return data.get() === null;
      };
      var clear = function () {
        data.set(null);
      };
      return nu$8({
        set: data.set,
        get: data.get,
        isNotSet: isNotSet,
        clear: clear,
        readState: readState
      });
    };
    var manual = function () {
      var readState = noop;
      return nu$8({ readState: readState });
    };
    var dataset = function () {
      var dataByValue = Cell({});
      var dataByText = Cell({});
      var readState = function () {
        return {
          mode: 'dataset',
          dataByValue: dataByValue.get(),
          dataByText: dataByText.get()
        };
      };
      var clear = function () {
        dataByValue.set({});
        dataByText.set({});
      };
      var lookup = function (itemString) {
        return get$e(dataByValue.get(), itemString).orThunk(function () {
          return get$e(dataByText.get(), itemString);
        });
      };
      var update = function (items) {
        var currentDataByValue = dataByValue.get();
        var currentDataByText = dataByText.get();
        var newDataByValue = {};
        var newDataByText = {};
        each$1(items, function (item) {
          newDataByValue[item.value] = item;
          get$e(item, 'meta').each(function (meta) {
            get$e(meta, 'text').each(function (text) {
              newDataByText[text] = item;
            });
          });
        });
        dataByValue.set(__assign(__assign({}, currentDataByValue), newDataByValue));
        dataByText.set(__assign(__assign({}, currentDataByText), newDataByText));
      };
      return nu$8({
        readState: readState,
        lookup: lookup,
        update: update,
        clear: clear
      });
    };
    var init$e = function (spec) {
      return spec.store.manager.state(spec);
    };

    var RepresentState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        memory: memory$1,
        dataset: dataset,
        manual: manual,
        init: init$e
    });

    var setValue$2 = function (component, repConfig, repState, data) {
      var store = repConfig.store;
      repState.update([data]);
      store.setValue(component, data);
      repConfig.onSetValue(component, data);
    };
    var getValue$2 = function (component, repConfig, repState) {
      var store = repConfig.store;
      var key = store.getDataKey(component);
      return repState.lookup(key).getOrThunk(function () {
        return store.getFallbackEntry(key);
      });
    };
    var onLoad$4 = function (component, repConfig, repState) {
      var store = repConfig.store;
      store.initialValue.each(function (data) {
        setValue$2(component, repConfig, repState, data);
      });
    };
    var onUnload$1 = function (component, repConfig, repState) {
      repState.clear();
    };
    var DatasetStore = [
      option('initialValue'),
      required$1('getFallbackEntry'),
      required$1('getDataKey'),
      required$1('setValue'),
      output$1('manager', {
        setValue: setValue$2,
        getValue: getValue$2,
        onLoad: onLoad$4,
        onUnload: onUnload$1,
        state: dataset
      })
    ];

    var getValue$1 = function (component, repConfig, _repState) {
      return repConfig.store.getValue(component);
    };
    var setValue$1 = function (component, repConfig, _repState, data) {
      repConfig.store.setValue(component, data);
      repConfig.onSetValue(component, data);
    };
    var onLoad$3 = function (component, repConfig, _repState) {
      repConfig.store.initialValue.each(function (data) {
        repConfig.store.setValue(component, data);
      });
    };
    var ManualStore = [
      required$1('getValue'),
      defaulted('setValue', noop),
      option('initialValue'),
      output$1('manager', {
        setValue: setValue$1,
        getValue: getValue$1,
        onLoad: onLoad$3,
        onUnload: noop,
        state: NoState.init
      })
    ];

    var setValue = function (component, repConfig, repState, data) {
      repState.set(data);
      repConfig.onSetValue(component, data);
    };
    var getValue = function (component, repConfig, repState) {
      return repState.get();
    };
    var onLoad$2 = function (component, repConfig, repState) {
      repConfig.store.initialValue.each(function (initVal) {
        if (repState.isNotSet()) {
          repState.set(initVal);
        }
      });
    };
    var onUnload = function (component, repConfig, repState) {
      repState.clear();
    };
    var MemoryStore = [
      option('initialValue'),
      output$1('manager', {
        setValue: setValue,
        getValue: getValue,
        onLoad: onLoad$2,
        onUnload: onUnload,
        state: memory$1
      })
    ];

    var RepresentSchema = [
      defaultedOf('store', { mode: 'memory' }, choose$1('mode', {
        memory: MemoryStore,
        manual: ManualStore,
        dataset: DatasetStore
      })),
      onHandler('onSetValue'),
      defaulted('resetOnDom', false)
    ];

    var Representing = create$7({
      fields: RepresentSchema,
      name: 'representing',
      active: ActiveRepresenting,
      apis: RepresentApis,
      extra: {
        setValueFrom: function (component, source) {
          var value = Representing.getValue(source);
          Representing.setValue(component, value);
        }
      },
      state: RepresentState
    });

    var field = function (name, forbidden) {
      return defaultedObjOf(name, {}, map$2(forbidden, function (f) {
        return forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name);
      }).concat([customField('dump', identity$1)]));
    };
    var get$2 = function (data) {
      return data.dump;
    };
    var augment = function (data, original) {
      return __assign(__assign({}, derive$1(original)), data.dump);
    };
    var SketchBehaviours = {
      field: field,
      augment: augment,
      get: get$2
    };

    var _placeholder = 'placeholder';
    var adt$3 = Adt.generate([
      {
        single: [
          'required',
          'valueThunk'
        ]
      },
      {
        multiple: [
          'required',
          'valueThunks'
        ]
      }
    ]);
    var isSubstituted = function (spec) {
      return has$2(spec, 'uiType');
    };
    var subPlaceholder = function (owner, detail, compSpec, placeholders) {
      if (owner.exists(function (o) {
          return o !== compSpec.owner;
        })) {
        return adt$3.single(true, constant$1(compSpec));
      }
      return get$e(placeholders, compSpec.name).fold(function () {
        throw new Error('Unknown placeholder component: ' + compSpec.name + '\nKnown: [' + keys(placeholders) + ']\nNamespace: ' + owner.getOr('none') + '\nSpec: ' + JSON.stringify(compSpec, null, 2));
      }, function (newSpec) {
        return newSpec.replace();
      });
    };
    var scan = function (owner, detail, compSpec, placeholders) {
      if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {
        return subPlaceholder(owner, detail, compSpec, placeholders);
      } else {
        return adt$3.single(false, constant$1(compSpec));
      }
    };
    var substitute = function (owner, detail, compSpec, placeholders) {
      var base = scan(owner, detail, compSpec, placeholders);
      return base.fold(function (req, valueThunk) {
        var value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);
        var childSpecs = get$e(value, 'components').getOr([]);
        var substituted = bind$3(childSpecs, function (c) {
          return substitute(owner, detail, c, placeholders);
        });
        return [__assign(__assign({}, value), { components: substituted })];
      }, function (req, valuesThunk) {
        if (isSubstituted(compSpec)) {
          var values = valuesThunk(detail, compSpec.config, compSpec.validated);
          var preprocessor = compSpec.validated.preprocess.getOr(identity$1);
          return preprocessor(values);
        } else {
          return valuesThunk(detail);
        }
      });
    };
    var substituteAll = function (owner, detail, components, placeholders) {
      return bind$3(components, function (c) {
        return substitute(owner, detail, c, placeholders);
      });
    };
    var oneReplace = function (label, replacements) {
      var called = false;
      var used = function () {
        return called;
      };
      var replace = function () {
        if (called) {
          throw new Error('Trying to use the same placeholder more than once: ' + label);
        }
        called = true;
        return replacements;
      };
      var required = function () {
        return replacements.fold(function (req, _) {
          return req;
        }, function (req, _) {
          return req;
        });
      };
      return {
        name: constant$1(label),
        required: required,
        used: used,
        replace: replace
      };
    };
    var substitutePlaces = function (owner, detail, components, placeholders) {
      var ps = map$1(placeholders, function (ph, name) {
        return oneReplace(name, ph);
      });
      var outcome = substituteAll(owner, detail, components, ps);
      each(ps, function (p) {
        if (p.used() === false && p.required()) {
          throw new Error('Placeholder: ' + p.name() + ' was not found in components list\nNamespace: ' + owner.getOr('none') + '\nComponents: ' + JSON.stringify(detail.components, null, 2));
        }
      });
      return outcome;
    };
    var single$2 = adt$3.single;
    var multiple = adt$3.multiple;
    var placeholder = constant$1(_placeholder);

    var adt$2 = Adt.generate([
      { required: ['data'] },
      { external: ['data'] },
      { optional: ['data'] },
      { group: ['data'] }
    ]);
    var fFactory = defaulted('factory', { sketch: identity$1 });
    var fSchema = defaulted('schema', []);
    var fName = required$1('name');
    var fPname = field$1('pname', 'pname', defaultedThunk(function (typeSpec) {
      return '<alloy.' + generate$6(typeSpec.name) + '>';
    }), anyValue());
    var fGroupSchema = customField('schema', function () {
      return [option('preprocess')];
    });
    var fDefaults = defaulted('defaults', constant$1({}));
    var fOverrides = defaulted('overrides', constant$1({}));
    var requiredSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fPname,
      fDefaults,
      fOverrides
    ]);
    var externalSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fDefaults,
      fOverrides
    ]);
    var optionalSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fPname,
      fDefaults,
      fOverrides
    ]);
    var groupSpec = objOf([
      fFactory,
      fGroupSchema,
      fName,
      required$1('unit'),
      fPname,
      fDefaults,
      fOverrides
    ]);
    var asNamedPart = function (part) {
      return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);
    };
    var name$1 = function (part) {
      var get = function (data) {
        return data.name;
      };
      return part.fold(get, get, get, get);
    };
    var asCommon = function (part) {
      return part.fold(identity$1, identity$1, identity$1, identity$1);
    };
    var convert = function (adtConstructor, partSchema) {
      return function (spec) {
        var data = asRawOrDie$1('Converting part type', partSchema, spec);
        return adtConstructor(data);
      };
    };
    var required = convert(adt$2.required, requiredSpec);
    var external$1 = convert(adt$2.external, externalSpec);
    var optional = convert(adt$2.optional, optionalSpec);
    var group = convert(adt$2.group, groupSpec);
    var original = constant$1('entirety');

    var PartType = /*#__PURE__*/Object.freeze({
        __proto__: null,
        required: required,
        external: external$1,
        optional: optional,
        group: group,
        asNamedPart: asNamedPart,
        name: name$1,
        asCommon: asCommon,
        original: original
    });

    var combine = function (detail, data, partSpec, partValidated) {
      return deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));
    };
    var subs = function (owner, detail, parts) {
      var internals = {};
      var externals = {};
      each$1(parts, function (part) {
        part.fold(function (data) {
          internals[data.pname] = single$2(true, function (detail, partSpec, partValidated) {
            return data.factory.sketch(combine(detail, data, partSpec, partValidated));
          });
        }, function (data) {
          var partSpec = detail.parts[data.name];
          externals[data.name] = constant$1(data.factory.sketch(combine(detail, data, partSpec[original()]), partSpec));
        }, function (data) {
          internals[data.pname] = single$2(false, function (detail, partSpec, partValidated) {
            return data.factory.sketch(combine(detail, data, partSpec, partValidated));
          });
        }, function (data) {
          internals[data.pname] = multiple(true, function (detail, _partSpec, _partValidated) {
            var units = detail[data.name];
            return map$2(units, function (u) {
              return data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u)));
            });
          });
        });
      });
      return {
        internals: constant$1(internals),
        externals: constant$1(externals)
      };
    };

    var generate$3 = function (owner, parts) {
      var r = {};
      each$1(parts, function (part) {
        asNamedPart(part).each(function (np) {
          var g = doGenerateOne(owner, np.pname);
          r[np.name] = function (config) {
            var validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);
            return __assign(__assign({}, g), {
              config: config,
              validated: validated
            });
          };
        });
      });
      return r;
    };
    var doGenerateOne = function (owner, pname) {
      return {
        uiType: placeholder(),
        owner: owner,
        name: pname
      };
    };
    var generateOne$1 = function (owner, pname, config) {
      return {
        uiType: placeholder(),
        owner: owner,
        name: pname,
        config: config,
        validated: {}
      };
    };
    var schemas = function (parts) {
      return bind$3(parts, function (part) {
        return part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map(function (data) {
          return requiredObjOf(data.name, data.schema.concat([snapshot(original())]));
        }).toArray();
      });
    };
    var names = function (parts) {
      return map$2(parts, name$1);
    };
    var substitutes = function (owner, detail, parts) {
      return subs(owner, detail, parts);
    };
    var components$1 = function (owner, detail, internals) {
      return substitutePlaces(Optional.some(owner), detail, detail.components, internals);
    };
    var getPart = function (component, detail, partKey) {
      var uid = detail.partUids[partKey];
      return component.getSystem().getByUid(uid).toOptional();
    };
    var getPartOrDie = function (component, detail, partKey) {
      return getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey);
    };
    var getParts = function (component, detail, partKeys) {
      var r = {};
      var uids = detail.partUids;
      var system = component.getSystem();
      each$1(partKeys, function (pk) {
        r[pk] = constant$1(system.getByUid(uids[pk]));
      });
      return r;
    };
    var getAllParts = function (component, detail) {
      var system = component.getSystem();
      return map$1(detail.partUids, function (pUid, _k) {
        return constant$1(system.getByUid(pUid));
      });
    };
    var getAllPartNames = function (detail) {
      return keys(detail.partUids);
    };
    var getPartsOrDie = function (component, detail, partKeys) {
      var r = {};
      var uids = detail.partUids;
      var system = component.getSystem();
      each$1(partKeys, function (pk) {
        r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());
      });
      return r;
    };
    var defaultUids = function (baseUid, partTypes) {
      var partNames = names(partTypes);
      return wrapAll(map$2(partNames, function (pn) {
        return {
          key: pn,
          value: baseUid + '-' + pn
        };
      }));
    };
    var defaultUidsSchema = function (partTypes) {
      return field$1('partUids', 'partUids', mergeWithThunk(function (spec) {
        return defaultUids(spec.uid, partTypes);
      }), anyValue());
    };

    var AlloyParts = /*#__PURE__*/Object.freeze({
        __proto__: null,
        generate: generate$3,
        generateOne: generateOne$1,
        schemas: schemas,
        names: names,
        substitutes: substitutes,
        components: components$1,
        defaultUids: defaultUids,
        defaultUidsSchema: defaultUidsSchema,
        getAllParts: getAllParts,
        getAllPartNames: getAllPartNames,
        getPart: getPart,
        getPartOrDie: getPartOrDie,
        getParts: getParts,
        getPartsOrDie: getPartsOrDie
    });

    var base = function (partSchemas, partUidsSchemas) {
      var ps = partSchemas.length > 0 ? [requiredObjOf('parts', partSchemas)] : [];
      return ps.concat([
        required$1('uid'),
        defaulted('dom', {}),
        defaulted('components', []),
        snapshot('originalSpec'),
        defaulted('debug.sketcher', {})
      ]).concat(partUidsSchemas);
    };
    var asRawOrDie = function (label, schema, spec, partSchemas, partUidsSchemas) {
      var baseS = base(partSchemas, partUidsSchemas);
      return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);
    };

    var single$1 = function (owner, schema, factory, spec) {
      var specWithUid = supplyUid(spec);
      var detail = asRawOrDie(owner, schema, specWithUid, [], []);
      return factory(detail, specWithUid);
    };
    var composite$1 = function (owner, schema, partTypes, factory, spec) {
      var specWithUid = supplyUid(spec);
      var partSchemas = schemas(partTypes);
      var partUidsSchema = defaultUidsSchema(partTypes);
      var detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [partUidsSchema]);
      var subs = substitutes(owner, detail, partTypes);
      var components = components$1(owner, detail, subs.internals());
      return factory(detail, components, specWithUid, subs.externals());
    };
    var hasUid = function (spec) {
      return has$2(spec, 'uid');
    };
    var supplyUid = function (spec) {
      return hasUid(spec) ? spec : __assign(__assign({}, spec), { uid: generate$5('uid') });
    };

    var isSketchSpec = function (spec) {
      return spec.uid !== undefined;
    };
    var singleSchema = objOfOnly([
      required$1('name'),
      required$1('factory'),
      required$1('configFields'),
      defaulted('apis', {}),
      defaulted('extraApis', {})
    ]);
    var compositeSchema = objOfOnly([
      required$1('name'),
      required$1('factory'),
      required$1('configFields'),
      required$1('partFields'),
      defaulted('apis', {}),
      defaulted('extraApis', {})
    ]);
    var single = function (rawConfig) {
      var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);
      var sketch = function (spec) {
        return single$1(config.name, config.configFields, config.factory, spec);
      };
      var apis = map$1(config.apis, makeApi);
      var extraApis = map$1(config.extraApis, function (f, k) {
        return markAsExtraApi(f, k);
      });
      return __assign(__assign({
        name: config.name,
        configFields: config.configFields,
        sketch: sketch
      }, apis), extraApis);
    };
    var composite = function (rawConfig) {
      var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);
      var sketch = function (spec) {
        return composite$1(config.name, config.configFields, config.partFields, config.factory, spec);
      };
      var parts = generate$3(config.name, config.partFields);
      var apis = map$1(config.apis, makeApi);
      var extraApis = map$1(config.extraApis, function (f, k) {
        return markAsExtraApi(f, k);
      });
      return __assign(__assign({
        name: config.name,
        partFields: config.partFields,
        configFields: config.configFields,
        sketch: sketch,
        parts: parts
      }, apis), extraApis);
    };

    var inside = function (target) {
      return name$2(target) === 'input' && get$d(target, 'type') !== 'radio' || name$2(target) === 'textarea';
    };

    var getCurrent = function (component, composeConfig, _composeState) {
      return composeConfig.find(component);
    };

    var ComposeApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCurrent: getCurrent
    });

    var ComposeSchema = [required$1('find')];

    var Composing = create$7({
      fields: ComposeSchema,
      name: 'composing',
      apis: ComposeApis
    });

    var nativeDisabled = [
      'input',
      'button',
      'textarea',
      'select'
    ];
    var onLoad$1 = function (component, disableConfig, disableState) {
      var f = disableConfig.disabled() ? disable$1 : enable$1;
      f(component, disableConfig);
    };
    var hasNative = function (component, config) {
      return config.useNative === true && contains$2(nativeDisabled, name$2(component.element));
    };
    var nativeIsDisabled = function (component) {
      return has$1(component.element, 'disabled');
    };
    var nativeDisable = function (component) {
      set$8(component.element, 'disabled', 'disabled');
    };
    var nativeEnable = function (component) {
      remove$7(component.element, 'disabled');
    };
    var ariaIsDisabled = function (component) {
      return get$d(component.element, 'aria-disabled') === 'true';
    };
    var ariaDisable = function (component) {
      set$8(component.element, 'aria-disabled', 'true');
    };
    var ariaEnable = function (component) {
      set$8(component.element, 'aria-disabled', 'false');
    };
    var disable$1 = function (component, disableConfig, _disableState) {
      disableConfig.disableClass.each(function (disableClass) {
        add$2(component.element, disableClass);
      });
      var f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;
      f(component);
      disableConfig.onDisabled(component);
    };
    var enable$1 = function (component, disableConfig, _disableState) {
      disableConfig.disableClass.each(function (disableClass) {
        remove$2(component.element, disableClass);
      });
      var f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;
      f(component);
      disableConfig.onEnabled(component);
    };
    var isDisabled = function (component, disableConfig) {
      return hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);
    };
    var set$3 = function (component, disableConfig, disableState, disabled) {
      var f = disabled ? disable$1 : enable$1;
      f(component, disableConfig);
    };

    var DisableApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        enable: enable$1,
        disable: disable$1,
        isDisabled: isDisabled,
        onLoad: onLoad$1,
        set: set$3
    });

    var exhibit$5 = function (base, disableConfig) {
      return nu$7({ classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : [] });
    };
    var events$e = function (disableConfig, disableState) {
      return derive$2([
        abort(execute$5(), function (component, _simulatedEvent) {
          return isDisabled(component, disableConfig);
        }),
        loadEvent(disableConfig, disableState, onLoad$1)
      ]);
    };

    var ActiveDisable = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$5,
        events: events$e
    });

    var DisableSchema = [
      defaultedFunction('disabled', never),
      defaulted('useNative', true),
      option('disableClass'),
      onHandler('onDisabled'),
      onHandler('onEnabled')
    ];

    var Disabling = create$7({
      fields: DisableSchema,
      name: 'disabling',
      active: ActiveDisable,
      apis: DisableApis
    });

    var dehighlightAllExcept = function (component, hConfig, hState, skip) {
      var highlighted = descendants(component.element, '.' + hConfig.highlightClass);
      each$1(highlighted, function (h) {
        if (!exists(skip, function (skipComp) {
            return skipComp.element === h;
          })) {
          remove$2(h, hConfig.highlightClass);
          component.getSystem().getByDom(h).each(function (target) {
            hConfig.onDehighlight(component, target);
            emit(target, dehighlight$1());
          });
        }
      });
    };
    var dehighlightAll = function (component, hConfig, hState) {
      return dehighlightAllExcept(component, hConfig, hState, []);
    };
    var dehighlight = function (component, hConfig, hState, target) {
      if (isHighlighted(component, hConfig, hState, target)) {
        remove$2(target.element, hConfig.highlightClass);
        hConfig.onDehighlight(component, target);
        emit(target, dehighlight$1());
      }
    };
    var highlight = function (component, hConfig, hState, target) {
      dehighlightAllExcept(component, hConfig, hState, [target]);
      if (!isHighlighted(component, hConfig, hState, target)) {
        add$2(target.element, hConfig.highlightClass);
        hConfig.onHighlight(component, target);
        emit(target, highlight$1());
      }
    };
    var highlightFirst = function (component, hConfig, hState) {
      getFirst(component, hConfig).each(function (firstComp) {
        highlight(component, hConfig, hState, firstComp);
      });
    };
    var highlightLast = function (component, hConfig, hState) {
      getLast(component, hConfig).each(function (lastComp) {
        highlight(component, hConfig, hState, lastComp);
      });
    };
    var highlightAt = function (component, hConfig, hState, index) {
      getByIndex(component, hConfig, hState, index).fold(function (err) {
        throw err;
      }, function (firstComp) {
        highlight(component, hConfig, hState, firstComp);
      });
    };
    var highlightBy = function (component, hConfig, hState, predicate) {
      var candidates = getCandidates(component, hConfig);
      var targetComp = find$5(candidates, predicate);
      targetComp.each(function (c) {
        highlight(component, hConfig, hState, c);
      });
    };
    var isHighlighted = function (component, hConfig, hState, queryTarget) {
      return has(queryTarget.element, hConfig.highlightClass);
    };
    var getHighlighted = function (component, hConfig, _hState) {
      return descendant(component.element, '.' + hConfig.highlightClass).bind(function (e) {
        return component.getSystem().getByDom(e).toOptional();
      });
    };
    var getByIndex = function (component, hConfig, hState, index) {
      var items = descendants(component.element, '.' + hConfig.itemClass);
      return Optional.from(items[index]).fold(function () {
        return Result.error(new Error('No element found with index ' + index));
      }, component.getSystem().getByDom);
    };
    var getFirst = function (component, hConfig, _hState) {
      return descendant(component.element, '.' + hConfig.itemClass).bind(function (e) {
        return component.getSystem().getByDom(e).toOptional();
      });
    };
    var getLast = function (component, hConfig, _hState) {
      var items = descendants(component.element, '.' + hConfig.itemClass);
      var last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
      return last.bind(function (c) {
        return component.getSystem().getByDom(c).toOptional();
      });
    };
    var getDelta$2 = function (component, hConfig, hState, delta) {
      var items = descendants(component.element, '.' + hConfig.itemClass);
      var current = findIndex$1(items, function (item) {
        return has(item, hConfig.highlightClass);
      });
      return current.bind(function (selected) {
        var dest = cycleBy(selected, delta, 0, items.length - 1);
        return component.getSystem().getByDom(items[dest]).toOptional();
      });
    };
    var getPrevious = function (component, hConfig, hState) {
      return getDelta$2(component, hConfig, hState, -1);
    };
    var getNext = function (component, hConfig, hState) {
      return getDelta$2(component, hConfig, hState, +1);
    };
    var getCandidates = function (component, hConfig, _hState) {
      var items = descendants(component.element, '.' + hConfig.itemClass);
      return cat(map$2(items, function (i) {
        return component.getSystem().getByDom(i).toOptional();
      }));
    };

    var HighlightApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        dehighlightAll: dehighlightAll,
        dehighlight: dehighlight,
        highlight: highlight,
        highlightFirst: highlightFirst,
        highlightLast: highlightLast,
        highlightAt: highlightAt,
        highlightBy: highlightBy,
        isHighlighted: isHighlighted,
        getHighlighted: getHighlighted,
        getFirst: getFirst,
        getLast: getLast,
        getPrevious: getPrevious,
        getNext: getNext,
        getCandidates: getCandidates
    });

    var HighlightSchema = [
      required$1('highlightClass'),
      required$1('itemClass'),
      onHandler('onHighlight'),
      onHandler('onDehighlight')
    ];

    var Highlighting = create$7({
      fields: HighlightSchema,
      name: 'highlighting',
      apis: HighlightApis
    });

    var BACKSPACE = [8];
    var TAB = [9];
    var ENTER = [13];
    var ESCAPE = [27];
    var SPACE = [32];
    var LEFT = [37];
    var UP = [38];
    var RIGHT = [39];
    var DOWN = [40];

    var cyclePrev = function (values, index, predicate) {
      var before = reverse(values.slice(0, index));
      var after = reverse(values.slice(index + 1));
      return find$5(before.concat(after), predicate);
    };
    var tryPrev = function (values, index, predicate) {
      var before = reverse(values.slice(0, index));
      return find$5(before, predicate);
    };
    var cycleNext = function (values, index, predicate) {
      var before = values.slice(0, index);
      var after = values.slice(index + 1);
      return find$5(after.concat(before), predicate);
    };
    var tryNext = function (values, index, predicate) {
      var after = values.slice(index + 1);
      return find$5(after, predicate);
    };

    var inSet = function (keys) {
      return function (event) {
        var raw = event.raw;
        return contains$2(keys, raw.which);
      };
    };
    var and = function (preds) {
      return function (event) {
        return forall(preds, function (pred) {
          return pred(event);
        });
      };
    };
    var isShift = function (event) {
      var raw = event.raw;
      return raw.shiftKey === true;
    };
    var isControl = function (event) {
      var raw = event.raw;
      return raw.ctrlKey === true;
    };
    var isNotShift = not(isShift);

    var rule = function (matches, action) {
      return {
        matches: matches,
        classification: action
      };
    };
    var choose = function (transitions, event) {
      var transition = find$5(transitions, function (t) {
        return t.matches(event);
      });
      return transition.map(function (t) {
        return t.classification;
      });
    };

    var reportFocusShifting = function (component, prevFocus, newFocus) {
      var noChange = prevFocus.exists(function (p) {
        return newFocus.exists(function (n) {
          return eq(n, p);
        });
      });
      if (!noChange) {
        emitWith(component, focusShifted(), {
          prevFocus: prevFocus,
          newFocus: newFocus
        });
      }
    };
    var dom$2 = function () {
      var get = function (component) {
        return search(component.element);
      };
      var set = function (component, focusee) {
        var prevFocus = get(component);
        component.getSystem().triggerFocus(focusee, component.element);
        var newFocus = get(component);
        reportFocusShifting(component, prevFocus, newFocus);
      };
      return {
        get: get,
        set: set
      };
    };
    var highlights = function () {
      var get = function (component) {
        return Highlighting.getHighlighted(component).map(function (item) {
          return item.element;
        });
      };
      var set = function (component, element) {
        var prevFocus = get(component);
        component.getSystem().getByDom(element).fold(noop, function (item) {
          Highlighting.highlight(component, item);
        });
        var newFocus = get(component);
        reportFocusShifting(component, prevFocus, newFocus);
      };
      return {
        get: get,
        set: set
      };
    };

    var FocusInsideModes;
    (function (FocusInsideModes) {
      FocusInsideModes['OnFocusMode'] = 'onFocus';
      FocusInsideModes['OnEnterOrSpaceMode'] = 'onEnterOrSpace';
      FocusInsideModes['OnApiMode'] = 'onApi';
    }(FocusInsideModes || (FocusInsideModes = {})));

    var typical = function (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) {
      var schema = function () {
        return infoSchema.concat([
          defaulted('focusManager', dom$2()),
          defaultedOf('focusInside', 'onFocus', valueOf(function (val) {
            return contains$2([
              'onFocus',
              'onEnterOrSpace',
              'onApi'
            ], val) ? Result.value(val) : Result.error('Invalid value for focusInside');
          })),
          output$1('handler', me),
          output$1('state', stateInit),
          output$1('sendFocusIn', optFocusIn)
        ]);
      };
      var processKey = function (component, simulatedEvent, getRules, keyingConfig, keyingState) {
        var rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
        return choose(rules, simulatedEvent.event).bind(function (rule) {
          return rule(component, simulatedEvent, keyingConfig, keyingState);
        });
      };
      var toEvents = function (keyingConfig, keyingState) {
        var onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map(function (focusIn) {
          return run$1(focus$4(), function (component, simulatedEvent) {
            focusIn(component, keyingConfig, keyingState);
            simulatedEvent.stop();
          });
        });
        var tryGoInsideComponent = function (component, simulatedEvent) {
          var isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);
          if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {
            optFocusIn(keyingConfig).each(function (focusIn) {
              focusIn(component, keyingConfig, keyingState);
              simulatedEvent.stop();
            });
          }
        };
        var keyboardEvents = [
          run$1(keydown(), function (component, simulatedEvent) {
            processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(function () {
              tryGoInsideComponent(component, simulatedEvent);
            }, function (_) {
              simulatedEvent.stop();
            });
          }),
          run$1(keyup(), function (component, simulatedEvent) {
            processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each(function (_) {
              simulatedEvent.stop();
            });
          })
        ];
        return derive$2(onFocusHandler.toArray().concat(keyboardEvents));
      };
      var me = {
        schema: schema,
        processKey: processKey,
        toEvents: toEvents
      };
      return me;
    };

    var create$5 = function (cyclicField) {
      var schema = [
        option('onEscape'),
        option('onEnter'),
        defaulted('selector', '[data-alloy-tabstop="true"]:not(:disabled)'),
        defaulted('firstTabstop', 0),
        defaulted('useTabstopAt', always),
        option('visibilitySelector')
      ].concat([cyclicField]);
      var isVisible = function (tabbingConfig, element) {
        var target = tabbingConfig.visibilitySelector.bind(function (sel) {
          return closest$1(element, sel);
        }).getOr(element);
        return get$b(target) > 0;
      };
      var findInitial = function (component, tabbingConfig) {
        var tabstops = descendants(component.element, tabbingConfig.selector);
        var visibles = filter$2(tabstops, function (elem) {
          return isVisible(tabbingConfig, elem);
        });
        return Optional.from(visibles[tabbingConfig.firstTabstop]);
      };
      var findCurrent = function (component, tabbingConfig) {
        return tabbingConfig.focusManager.get(component).bind(function (elem) {
          return closest$1(elem, tabbingConfig.selector);
        });
      };
      var isTabstop = function (tabbingConfig, element) {
        return isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);
      };
      var focusIn = function (component, tabbingConfig, _tabbingState) {
        findInitial(component, tabbingConfig).each(function (target) {
          tabbingConfig.focusManager.set(component, target);
        });
      };
      var goFromTabstop = function (component, tabstops, stopIndex, tabbingConfig, cycle) {
        return cycle(tabstops, stopIndex, function (elem) {
          return isTabstop(tabbingConfig, elem);
        }).fold(function () {
          return tabbingConfig.cyclic ? Optional.some(true) : Optional.none();
        }, function (target) {
          tabbingConfig.focusManager.set(component, target);
          return Optional.some(true);
        });
      };
      var go = function (component, _simulatedEvent, tabbingConfig, cycle) {
        var tabstops = descendants(component.element, tabbingConfig.selector);
        return findCurrent(component, tabbingConfig).bind(function (tabstop) {
          var optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));
          return optStopIndex.bind(function (stopIndex) {
            return goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle);
          });
        });
      };
      var goBackwards = function (component, simulatedEvent, tabbingConfig) {
        var navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
        return go(component, simulatedEvent, tabbingConfig, navigate);
      };
      var goForwards = function (component, simulatedEvent, tabbingConfig) {
        var navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
        return go(component, simulatedEvent, tabbingConfig, navigate);
      };
      var execute = function (component, simulatedEvent, tabbingConfig) {
        return tabbingConfig.onEnter.bind(function (f) {
          return f(component, simulatedEvent);
        });
      };
      var exit = function (component, simulatedEvent, tabbingConfig) {
        return tabbingConfig.onEscape.bind(function (f) {
          return f(component, simulatedEvent);
        });
      };
      var getKeydownRules = constant$1([
        rule(and([
          isShift,
          inSet(TAB)
        ]), goBackwards),
        rule(inSet(TAB), goForwards),
        rule(inSet(ESCAPE), exit),
        rule(and([
          isNotShift,
          inSet(ENTER)
        ]), execute)
      ]);
      var getKeyupRules = constant$1([]);
      return typical(schema, NoState.init, getKeydownRules, getKeyupRules, function () {
        return Optional.some(focusIn);
      });
    };

    var AcyclicType = create$5(customField('cyclic', never));

    var CyclicType = create$5(customField('cyclic', always));

    var doDefaultExecute = function (component, _simulatedEvent, focused) {
      dispatch(component, focused, execute$5());
      return Optional.some(true);
    };
    var defaultExecute = function (component, simulatedEvent, focused) {
      var isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);
      return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
    };
    var stopEventForFirefox = function (_component, _simulatedEvent) {
      return Optional.some(true);
    };

    var schema$v = [
      defaulted('execute', defaultExecute),
      defaulted('useSpace', false),
      defaulted('useEnter', true),
      defaulted('useControlEnter', false),
      defaulted('useDown', false)
    ];
    var execute$4 = function (component, simulatedEvent, executeConfig) {
      return executeConfig.execute(component, simulatedEvent, component.element);
    };
    var getKeydownRules$5 = function (component, _simulatedEvent, executeConfig, _executeState) {
      var spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];
      var enterExec = executeConfig.useEnter ? ENTER : [];
      var downExec = executeConfig.useDown ? DOWN : [];
      var execKeys = spaceExec.concat(enterExec).concat(downExec);
      return [rule(inSet(execKeys), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([
          isControl,
          inSet(ENTER)
        ]), execute$4)] : []);
    };
    var getKeyupRules$5 = function (component, _simulatedEvent, executeConfig, _executeState) {
      return executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];
    };
    var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, function () {
      return Optional.none();
    });

    var flatgrid$1 = function () {
      var dimensions = value$1();
      var setGridSize = function (numRows, numColumns) {
        dimensions.set({
          numRows: numRows,
          numColumns: numColumns
        });
      };
      var getNumRows = function () {
        return dimensions.get().map(function (d) {
          return d.numRows;
        });
      };
      var getNumColumns = function () {
        return dimensions.get().map(function (d) {
          return d.numColumns;
        });
      };
      return nu$8({
        readState: function () {
          return dimensions.get().map(function (d) {
            return {
              numRows: String(d.numRows),
              numColumns: String(d.numColumns)
            };
          }).getOr({
            numRows: '?',
            numColumns: '?'
          });
        },
        setGridSize: setGridSize,
        getNumRows: getNumRows,
        getNumColumns: getNumColumns
      });
    };
    var init$d = function (spec) {
      return spec.state(spec);
    };

    var KeyingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        flatgrid: flatgrid$1,
        init: init$d
    });

    var useH = function (movement) {
      return function (component, simulatedEvent, config, state) {
        var move = movement(component.element);
        return use(move, component, simulatedEvent, config, state);
      };
    };
    var west$1 = function (moveLeft, moveRight) {
      var movement = onDirection(moveLeft, moveRight);
      return useH(movement);
    };
    var east$1 = function (moveLeft, moveRight) {
      var movement = onDirection(moveRight, moveLeft);
      return useH(movement);
    };
    var useV = function (move) {
      return function (component, simulatedEvent, config, state) {
        return use(move, component, simulatedEvent, config, state);
      };
    };
    var use = function (move, component, simulatedEvent, config, state) {
      var outcome = config.focusManager.get(component).bind(function (focused) {
        return move(component.element, focused, config, state);
      });
      return outcome.map(function (newFocus) {
        config.focusManager.set(component, newFocus);
        return true;
      });
    };
    var north$1 = useV;
    var south$1 = useV;
    var move$1 = useV;

    var isHidden$1 = function (dom) {
      return dom.offsetWidth <= 0 && dom.offsetHeight <= 0;
    };
    var isVisible = function (element) {
      return !isHidden$1(element.dom);
    };

    var locate = function (candidates, predicate) {
      return findIndex$1(candidates, predicate).map(function (index) {
        return {
          index: index,
          candidates: candidates
        };
      });
    };

    var locateVisible = function (container, current, selector) {
      var predicate = function (x) {
        return eq(x, current);
      };
      var candidates = descendants(container, selector);
      var visible = filter$2(candidates, isVisible);
      return locate(visible, predicate);
    };
    var findIndex = function (elements, target) {
      return findIndex$1(elements, function (elem) {
        return eq(target, elem);
      });
    };

    var withGrid = function (values, index, numCols, f) {
      var oldRow = Math.floor(index / numCols);
      var oldColumn = index % numCols;
      return f(oldRow, oldColumn).bind(function (address) {
        var newIndex = address.row * numCols + address.column;
        return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();
      });
    };
    var cycleHorizontal$1 = function (values, index, numRows, numCols, delta) {
      return withGrid(values, index, numCols, function (oldRow, oldColumn) {
        var onLastRow = oldRow === numRows - 1;
        var colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;
        var newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
        return Optional.some({
          row: oldRow,
          column: newColumn
        });
      });
    };
    var cycleVertical$1 = function (values, index, numRows, numCols, delta) {
      return withGrid(values, index, numCols, function (oldRow, oldColumn) {
        var newRow = cycleBy(oldRow, delta, 0, numRows - 1);
        var onLastRow = newRow === numRows - 1;
        var colsInRow = onLastRow ? values.length - newRow * numCols : numCols;
        var newCol = clamp$1(oldColumn, 0, colsInRow - 1);
        return Optional.some({
          row: newRow,
          column: newCol
        });
      });
    };
    var cycleRight$1 = function (values, index, numRows, numCols) {
      return cycleHorizontal$1(values, index, numRows, numCols, +1);
    };
    var cycleLeft$1 = function (values, index, numRows, numCols) {
      return cycleHorizontal$1(values, index, numRows, numCols, -1);
    };
    var cycleUp$1 = function (values, index, numRows, numCols) {
      return cycleVertical$1(values, index, numRows, numCols, -1);
    };
    var cycleDown$1 = function (values, index, numRows, numCols) {
      return cycleVertical$1(values, index, numRows, numCols, +1);
    };

    var schema$u = [
      required$1('selector'),
      defaulted('execute', defaultExecute),
      onKeyboardHandler('onEscape'),
      defaulted('captureTab', false),
      initSize()
    ];
    var focusIn$3 = function (component, gridConfig, _gridState) {
      descendant(component.element, gridConfig.selector).each(function (first) {
        gridConfig.focusManager.set(component, first);
      });
    };
    var findCurrent$1 = function (component, gridConfig) {
      return gridConfig.focusManager.get(component).bind(function (elem) {
        return closest$1(elem, gridConfig.selector);
      });
    };
    var execute$3 = function (component, simulatedEvent, gridConfig, _gridState) {
      return findCurrent$1(component, gridConfig).bind(function (focused) {
        return gridConfig.execute(component, simulatedEvent, focused);
      });
    };
    var doMove$2 = function (cycle) {
      return function (element, focused, gridConfig, gridState) {
        return locateVisible(element, focused, gridConfig.selector).bind(function (identified) {
          return cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns));
        });
      };
    };
    var handleTab = function (_component, _simulatedEvent, gridConfig) {
      return gridConfig.captureTab ? Optional.some(true) : Optional.none();
    };
    var doEscape$1 = function (component, simulatedEvent, gridConfig) {
      return gridConfig.onEscape(component, simulatedEvent);
    };
    var moveLeft$3 = doMove$2(cycleLeft$1);
    var moveRight$3 = doMove$2(cycleRight$1);
    var moveNorth$1 = doMove$2(cycleUp$1);
    var moveSouth$1 = doMove$2(cycleDown$1);
    var getKeydownRules$4 = constant$1([
      rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),
      rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),
      rule(inSet(UP), north$1(moveNorth$1)),
      rule(inSet(DOWN), south$1(moveSouth$1)),
      rule(and([
        isShift,
        inSet(TAB)
      ]), handleTab),
      rule(and([
        isNotShift,
        inSet(TAB)
      ]), handleTab),
      rule(inSet(ESCAPE), doEscape$1),
      rule(inSet(SPACE.concat(ENTER)), execute$3)
    ]);
    var getKeyupRules$4 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
    var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, function () {
      return Optional.some(focusIn$3);
    });

    var horizontal = function (container, selector, current, delta) {
      var isDisabledButton = function (candidate) {
        return name$2(candidate) === 'button' && get$d(candidate, 'disabled') === 'disabled';
      };
      var tryCycle = function (initial, index, candidates) {
        var newIndex = cycleBy(index, delta, 0, candidates.length - 1);
        if (newIndex === initial) {
          return Optional.none();
        } else {
          return isDisabledButton(candidates[newIndex]) ? tryCycle(initial, newIndex, candidates) : Optional.from(candidates[newIndex]);
        }
      };
      return locateVisible(container, current, selector).bind(function (identified) {
        var index = identified.index;
        var candidates = identified.candidates;
        return tryCycle(index, index, candidates);
      });
    };

    var schema$t = [
      required$1('selector'),
      defaulted('getInitial', Optional.none),
      defaulted('execute', defaultExecute),
      onKeyboardHandler('onEscape'),
      defaulted('executeOnMove', false),
      defaulted('allowVertical', true)
    ];
    var findCurrent = function (component, flowConfig) {
      return flowConfig.focusManager.get(component).bind(function (elem) {
        return closest$1(elem, flowConfig.selector);
      });
    };
    var execute$2 = function (component, simulatedEvent, flowConfig) {
      return findCurrent(component, flowConfig).bind(function (focused) {
        return flowConfig.execute(component, simulatedEvent, focused);
      });
    };
    var focusIn$2 = function (component, flowConfig, _state) {
      flowConfig.getInitial(component).orThunk(function () {
        return descendant(component.element, flowConfig.selector);
      }).each(function (first) {
        flowConfig.focusManager.set(component, first);
      });
    };
    var moveLeft$2 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, -1);
    };
    var moveRight$2 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, +1);
    };
    var doMove$1 = function (movement) {
      return function (component, simulatedEvent, flowConfig, flowState) {
        return movement(component, simulatedEvent, flowConfig, flowState).bind(function () {
          return flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true);
        });
      };
    };
    var doEscape = function (component, simulatedEvent, flowConfig) {
      return flowConfig.onEscape(component, simulatedEvent);
    };
    var getKeydownRules$3 = function (_component, _se, flowConfig, _flowState) {
      var westMovers = LEFT.concat(flowConfig.allowVertical ? UP : []);
      var eastMovers = RIGHT.concat(flowConfig.allowVertical ? DOWN : []);
      return [
        rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),
        rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),
        rule(inSet(ENTER), execute$2),
        rule(inSet(SPACE), execute$2),
        rule(inSet(ESCAPE), doEscape)
      ];
    };
    var getKeyupRules$3 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
    var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, function () {
      return Optional.some(focusIn$2);
    });

    var toCell = function (matrix, rowIndex, columnIndex) {
      return Optional.from(matrix[rowIndex]).bind(function (row) {
        return Optional.from(row[columnIndex]).map(function (cell) {
          return {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            cell: cell
          };
        });
      });
    };
    var cycleHorizontal = function (matrix, rowIndex, startCol, deltaCol) {
      var row = matrix[rowIndex];
      var colsInRow = row.length;
      var newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
      return toCell(matrix, rowIndex, newColIndex);
    };
    var cycleVertical = function (matrix, colIndex, startRow, deltaRow) {
      var nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);
      var colsInNextRow = matrix[nextRowIndex].length;
      var nextColIndex = clamp$1(colIndex, 0, colsInNextRow - 1);
      return toCell(matrix, nextRowIndex, nextColIndex);
    };
    var moveHorizontal = function (matrix, rowIndex, startCol, deltaCol) {
      var row = matrix[rowIndex];
      var colsInRow = row.length;
      var newColIndex = clamp$1(startCol + deltaCol, 0, colsInRow - 1);
      return toCell(matrix, rowIndex, newColIndex);
    };
    var moveVertical = function (matrix, colIndex, startRow, deltaRow) {
      var nextRowIndex = clamp$1(startRow + deltaRow, 0, matrix.length - 1);
      var colsInNextRow = matrix[nextRowIndex].length;
      var nextColIndex = clamp$1(colIndex, 0, colsInNextRow - 1);
      return toCell(matrix, nextRowIndex, nextColIndex);
    };
    var cycleRight = function (matrix, startRow, startCol) {
      return cycleHorizontal(matrix, startRow, startCol, +1);
    };
    var cycleLeft = function (matrix, startRow, startCol) {
      return cycleHorizontal(matrix, startRow, startCol, -1);
    };
    var cycleUp = function (matrix, startRow, startCol) {
      return cycleVertical(matrix, startCol, startRow, -1);
    };
    var cycleDown = function (matrix, startRow, startCol) {
      return cycleVertical(matrix, startCol, startRow, +1);
    };
    var moveLeft$1 = function (matrix, startRow, startCol) {
      return moveHorizontal(matrix, startRow, startCol, -1);
    };
    var moveRight$1 = function (matrix, startRow, startCol) {
      return moveHorizontal(matrix, startRow, startCol, +1);
    };
    var moveUp$1 = function (matrix, startRow, startCol) {
      return moveVertical(matrix, startCol, startRow, -1);
    };
    var moveDown$1 = function (matrix, startRow, startCol) {
      return moveVertical(matrix, startCol, startRow, +1);
    };

    var schema$s = [
      requiredObjOf('selectors', [
        required$1('row'),
        required$1('cell')
      ]),
      defaulted('cycles', true),
      defaulted('previousSelector', Optional.none),
      defaulted('execute', defaultExecute)
    ];
    var focusIn$1 = function (component, matrixConfig, _state) {
      var focused = matrixConfig.previousSelector(component).orThunk(function () {
        var selectors = matrixConfig.selectors;
        return descendant(component.element, selectors.cell);
      });
      focused.each(function (cell) {
        matrixConfig.focusManager.set(component, cell);
      });
    };
    var execute$1 = function (component, simulatedEvent, matrixConfig) {
      return search(component.element).bind(function (focused) {
        return matrixConfig.execute(component, simulatedEvent, focused);
      });
    };
    var toMatrix = function (rows, matrixConfig) {
      return map$2(rows, function (row) {
        return descendants(row, matrixConfig.selectors.cell);
      });
    };
    var doMove = function (ifCycle, ifMove) {
      return function (element, focused, matrixConfig) {
        var move = matrixConfig.cycles ? ifCycle : ifMove;
        return closest$1(focused, matrixConfig.selectors.row).bind(function (inRow) {
          var cellsInRow = descendants(inRow, matrixConfig.selectors.cell);
          return findIndex(cellsInRow, focused).bind(function (colIndex) {
            var allRows = descendants(element, matrixConfig.selectors.row);
            return findIndex(allRows, inRow).bind(function (rowIndex) {
              var matrix = toMatrix(allRows, matrixConfig);
              return move(matrix, rowIndex, colIndex).map(function (next) {
                return next.cell;
              });
            });
          });
        });
      };
    };
    var moveLeft = doMove(cycleLeft, moveLeft$1);
    var moveRight = doMove(cycleRight, moveRight$1);
    var moveNorth = doMove(cycleUp, moveUp$1);
    var moveSouth = doMove(cycleDown, moveDown$1);
    var getKeydownRules$2 = constant$1([
      rule(inSet(LEFT), west$1(moveLeft, moveRight)),
      rule(inSet(RIGHT), east$1(moveLeft, moveRight)),
      rule(inSet(UP), north$1(moveNorth)),
      rule(inSet(DOWN), south$1(moveSouth)),
      rule(inSet(SPACE.concat(ENTER)), execute$1)
    ]);
    var getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
    var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, function () {
      return Optional.some(focusIn$1);
    });

    var schema$r = [
      required$1('selector'),
      defaulted('execute', defaultExecute),
      defaulted('moveOnTab', false)
    ];
    var execute = function (component, simulatedEvent, menuConfig) {
      return menuConfig.focusManager.get(component).bind(function (focused) {
        return menuConfig.execute(component, simulatedEvent, focused);
      });
    };
    var focusIn = function (component, menuConfig, _state) {
      descendant(component.element, menuConfig.selector).each(function (first) {
        menuConfig.focusManager.set(component, first);
      });
    };
    var moveUp = function (element, focused, info) {
      return horizontal(element, info.selector, focused, -1);
    };
    var moveDown = function (element, focused, info) {
      return horizontal(element, info.selector, focused, +1);
    };
    var fireShiftTab = function (component, simulatedEvent, menuConfig, menuState) {
      return menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    };
    var fireTab = function (component, simulatedEvent, menuConfig, menuState) {
      return menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    };
    var getKeydownRules$1 = constant$1([
      rule(inSet(UP), move$1(moveUp)),
      rule(inSet(DOWN), move$1(moveDown)),
      rule(and([
        isShift,
        inSet(TAB)
      ]), fireShiftTab),
      rule(and([
        isNotShift,
        inSet(TAB)
      ]), fireTab),
      rule(inSet(ENTER), execute),
      rule(inSet(SPACE), execute)
    ]);
    var getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
    var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, function () {
      return Optional.some(focusIn);
    });

    var schema$q = [
      onKeyboardHandler('onSpace'),
      onKeyboardHandler('onEnter'),
      onKeyboardHandler('onShiftEnter'),
      onKeyboardHandler('onLeft'),
      onKeyboardHandler('onRight'),
      onKeyboardHandler('onTab'),
      onKeyboardHandler('onShiftTab'),
      onKeyboardHandler('onUp'),
      onKeyboardHandler('onDown'),
      onKeyboardHandler('onEscape'),
      defaulted('stopSpaceKeyup', false),
      option('focusIn')
    ];
    var getKeydownRules = function (component, simulatedEvent, specialInfo) {
      return [
        rule(inSet(SPACE), specialInfo.onSpace),
        rule(and([
          isNotShift,
          inSet(ENTER)
        ]), specialInfo.onEnter),
        rule(and([
          isShift,
          inSet(ENTER)
        ]), specialInfo.onShiftEnter),
        rule(and([
          isShift,
          inSet(TAB)
        ]), specialInfo.onShiftTab),
        rule(and([
          isNotShift,
          inSet(TAB)
        ]), specialInfo.onTab),
        rule(inSet(UP), specialInfo.onUp),
        rule(inSet(DOWN), specialInfo.onDown),
        rule(inSet(LEFT), specialInfo.onLeft),
        rule(inSet(RIGHT), specialInfo.onRight),
        rule(inSet(SPACE), specialInfo.onSpace),
        rule(inSet(ESCAPE), specialInfo.onEscape)
      ];
    };
    var getKeyupRules = function (component, simulatedEvent, specialInfo) {
      return specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : [];
    };
    var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, function (specialInfo) {
      return specialInfo.focusIn;
    });

    var acyclic = AcyclicType.schema();
    var cyclic = CyclicType.schema();
    var flow = FlowType.schema();
    var flatgrid = FlatgridType.schema();
    var matrix = MatrixType.schema();
    var execution = ExecutionType.schema();
    var menu = MenuType.schema();
    var special = SpecialType.schema();

    var KeyboardBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        acyclic: acyclic,
        cyclic: cyclic,
        flow: flow,
        flatgrid: flatgrid,
        matrix: matrix,
        execution: execution,
        menu: menu,
        special: special
    });

    var isFlatgridState = function (keyState) {
      return hasNonNullableKey(keyState, 'setGridSize');
    };
    var Keying = createModes({
      branchKey: 'mode',
      branches: KeyboardBranches,
      name: 'keying',
      active: {
        events: function (keyingConfig, keyingState) {
          var handler = keyingConfig.handler;
          return handler.toEvents(keyingConfig, keyingState);
        }
      },
      apis: {
        focusIn: function (component, keyConfig, keyState) {
          keyConfig.sendFocusIn(keyConfig).fold(function () {
            component.getSystem().triggerFocus(component.element, component.element);
          }, function (sendFocusIn) {
            sendFocusIn(component, keyConfig, keyState);
          });
        },
        setGridSize: function (component, keyConfig, keyState, numRows, numColumns) {
          if (!isFlatgridState(keyState)) {
            console.error('Layout does not support setGridSize');
          } else {
            keyState.setGridSize(numRows, numColumns);
          }
        }
      },
      state: KeyingState
    });

    var set$2 = function (component, replaceConfig, replaceState, data) {
      preserve$1(function () {
        var newChildren = map$2(data, component.getSystem().build);
        replaceChildren(component, newChildren);
      }, component.element);
    };
    var insert = function (component, replaceConfig, insertion, childSpec) {
      var child = component.getSystem().build(childSpec);
      attachWith(component, child, insertion);
    };
    var append = function (component, replaceConfig, replaceState, appendee) {
      insert(component, replaceConfig, append$2, appendee);
    };
    var prepend = function (component, replaceConfig, replaceState, prependee) {
      insert(component, replaceConfig, prepend$1, prependee);
    };
    var remove = function (component, replaceConfig, replaceState, removee) {
      var children = contents(component);
      var foundChild = find$5(children, function (child) {
        return eq(removee.element, child.element);
      });
      foundChild.each(detach);
    };
    var contents = function (component, _replaceConfig) {
      return component.components();
    };
    var replaceAt = function (component, replaceConfig, replaceState, replaceeIndex, replacer) {
      var children = contents(component);
      return Optional.from(children[replaceeIndex]).map(function (replacee) {
        remove(component, replaceConfig, replaceState, replacee);
        replacer.each(function (r) {
          insert(component, replaceConfig, function (p, c) {
            appendAt(p, c, replaceeIndex);
          }, r);
        });
        return replacee;
      });
    };
    var replaceBy = function (component, replaceConfig, replaceState, replaceePred, replacer) {
      var children = contents(component);
      return findIndex$1(children, replaceePred).bind(function (replaceeIndex) {
        return replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer);
      });
    };

    var ReplaceApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        append: append,
        prepend: prepend,
        remove: remove,
        replaceAt: replaceAt,
        replaceBy: replaceBy,
        set: set$2,
        contents: contents
    });

    var Replacing = create$7({
      fields: [],
      name: 'replacing',
      apis: ReplaceApis
    });

    var events$d = function (name, eventHandlers) {
      var events = derive$2(eventHandlers);
      return create$7({
        fields: [required$1('enabled')],
        name: name,
        active: { events: constant$1(events) }
      });
    };
    var config = function (name, eventHandlers) {
      var me = events$d(name, eventHandlers);
      return {
        key: name,
        value: {
          config: {},
          me: me,
          configAsRaw: constant$1({}),
          initialConfig: {},
          state: NoState
        }
      };
    };

    var focus$2 = function (component, focusConfig) {
      if (!focusConfig.ignore) {
        focus$3(component.element);
        focusConfig.onFocus(component);
      }
    };
    var blur = function (component, focusConfig) {
      if (!focusConfig.ignore) {
        blur$1(component.element);
      }
    };
    var isFocused = function (component) {
      return hasFocus(component.element);
    };

    var FocusApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        focus: focus$2,
        blur: blur,
        isFocused: isFocused
    });

    var exhibit$4 = function (base, focusConfig) {
      var mod = focusConfig.ignore ? {} : { attributes: { tabindex: '-1' } };
      return nu$7(mod);
    };
    var events$c = function (focusConfig) {
      return derive$2([run$1(focus$4(), function (component, simulatedEvent) {
          focus$2(component, focusConfig);
          simulatedEvent.stop();
        })].concat(focusConfig.stopMousedown ? [run$1(mousedown(), function (_, simulatedEvent) {
          simulatedEvent.event.prevent();
        })] : []));
    };

    var ActiveFocus = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$4,
        events: events$c
    });

    var FocusSchema = [
      onHandler('onFocus'),
      defaulted('stopMousedown', false),
      defaulted('ignore', false)
    ];

    var Focusing = create$7({
      fields: FocusSchema,
      name: 'focusing',
      active: ActiveFocus,
      apis: FocusApis
    });

    var SetupBehaviourCellState = function (initialState) {
      var init = function () {
        var cell = Cell(initialState);
        var get = function () {
          return cell.get();
        };
        var set = function (newState) {
          return cell.set(newState);
        };
        var clear = function () {
          return cell.set(initialState);
        };
        var readState = function () {
          return cell.get();
        };
        return {
          get: get,
          set: set,
          clear: clear,
          readState: readState
        };
      };
      return { init: init };
    };

    var updateAriaState = function (component, toggleConfig, toggleState) {
      var ariaInfo = toggleConfig.aria;
      ariaInfo.update(component, ariaInfo, toggleState.get());
    };
    var updateClass = function (component, toggleConfig, toggleState) {
      toggleConfig.toggleClass.each(function (toggleClass) {
        if (toggleState.get()) {
          add$2(component.element, toggleClass);
        } else {
          remove$2(component.element, toggleClass);
        }
      });
    };
    var toggle$2 = function (component, toggleConfig, toggleState) {
      set$1(component, toggleConfig, toggleState, !toggleState.get());
    };
    var on = function (component, toggleConfig, toggleState) {
      toggleState.set(true);
      updateClass(component, toggleConfig, toggleState);
      updateAriaState(component, toggleConfig, toggleState);
    };
    var off = function (component, toggleConfig, toggleState) {
      toggleState.set(false);
      updateClass(component, toggleConfig, toggleState);
      updateAriaState(component, toggleConfig, toggleState);
    };
    var set$1 = function (component, toggleConfig, toggleState, state) {
      var action = state ? on : off;
      action(component, toggleConfig, toggleState);
    };
    var isOn = function (component, toggleConfig, toggleState) {
      return toggleState.get();
    };
    var onLoad = function (component, toggleConfig, toggleState) {
      set$1(component, toggleConfig, toggleState, toggleConfig.selected);
    };

    var ToggleApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad,
        toggle: toggle$2,
        isOn: isOn,
        on: on,
        off: off,
        set: set$1
    });

    var exhibit$3 = function () {
      return nu$7({});
    };
    var events$b = function (toggleConfig, toggleState) {
      var execute = executeEvent(toggleConfig, toggleState, toggle$2);
      var load = loadEvent(toggleConfig, toggleState, onLoad);
      return derive$2(flatten([
        toggleConfig.toggleOnExecute ? [execute] : [],
        [load]
      ]));
    };

    var ActiveToggle = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$3,
        events: events$b
    });

    var updatePressed = function (component, ariaInfo, status) {
      set$8(component.element, 'aria-pressed', status);
      if (ariaInfo.syncWithExpanded) {
        updateExpanded(component, ariaInfo, status);
      }
    };
    var updateSelected = function (component, ariaInfo, status) {
      set$8(component.element, 'aria-selected', status);
    };
    var updateChecked = function (component, ariaInfo, status) {
      set$8(component.element, 'aria-checked', status);
    };
    var updateExpanded = function (component, ariaInfo, status) {
      set$8(component.element, 'aria-expanded', status);
    };

    var ToggleSchema = [
      defaulted('selected', false),
      option('toggleClass'),
      defaulted('toggleOnExecute', true),
      defaultedOf('aria', { mode: 'none' }, choose$1('mode', {
        pressed: [
          defaulted('syncWithExpanded', false),
          output$1('update', updatePressed)
        ],
        checked: [output$1('update', updateChecked)],
        expanded: [output$1('update', updateExpanded)],
        selected: [output$1('update', updateSelected)],
        none: [output$1('update', noop)]
      }))
    ];

    var Toggling = create$7({
      fields: ToggleSchema,
      name: 'toggling',
      active: ActiveToggle,
      apis: ToggleApis,
      state: SetupBehaviourCellState(false)
    });

    var pointerEvents = function () {
      var onClick = function (component, simulatedEvent) {
        simulatedEvent.stop();
        emitExecute(component);
      };
      return [
        run$1(click(), onClick),
        run$1(tap(), onClick),
        cutter(touchstart()),
        cutter(mousedown())
      ];
    };
    var events$a = function (optAction) {
      var executeHandler = function (action) {
        return runOnExecute$1(function (component, simulatedEvent) {
          action(component);
          simulatedEvent.stop();
        });
      };
      return derive$2(flatten([
        optAction.map(executeHandler).toArray(),
        pointerEvents()
      ]));
    };

    var hoverEvent = 'alloy.item-hover';
    var focusEvent = 'alloy.item-focus';
    var onHover = function (item) {
      if (search(item.element).isNone() || Focusing.isFocused(item)) {
        if (!Focusing.isFocused(item)) {
          Focusing.focus(item);
        }
        emitWith(item, hoverEvent, { item: item });
      }
    };
    var onFocus$1 = function (item) {
      emitWith(item, focusEvent, { item: item });
    };
    var hover = constant$1(hoverEvent);
    var focus$1 = constant$1(focusEvent);

    var builder$2 = function (detail) {
      return {
        dom: detail.dom,
        domModification: __assign(__assign({}, detail.domModification), { attributes: __assign(__assign(__assign({ 'role': detail.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem' }, detail.domModification.attributes), { 'aria-haspopup': detail.hasSubmenu }), detail.hasSubmenu ? { 'aria-expanded': false } : {}) }),
        behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
          detail.toggling.fold(Toggling.revoke, function (tConfig) {
            return Toggling.config(__assign({ aria: { mode: 'checked' } }, tConfig));
          }),
          Focusing.config({
            ignore: detail.ignoreFocus,
            stopMousedown: detail.ignoreFocus,
            onFocus: function (component) {
              onFocus$1(component);
            }
          }),
          Keying.config({ mode: 'execution' }),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: detail.data
            }
          }),
          config('item-type-events', __spreadArray(__spreadArray([], pointerEvents(), true), [
            run$1(mouseover(), onHover),
            run$1(focusItem(), Focusing.focus)
          ], false))
        ]),
        components: detail.components,
        eventOrder: detail.eventOrder
      };
    };
    var schema$p = [
      required$1('data'),
      required$1('components'),
      required$1('dom'),
      defaulted('hasSubmenu', false),
      option('toggling'),
      SketchBehaviours.field('itemBehaviours', [
        Toggling,
        Focusing,
        Keying,
        Representing
      ]),
      defaulted('ignoreFocus', false),
      defaulted('domModification', {}),
      output$1('builder', builder$2),
      defaulted('eventOrder', {})
    ];

    var builder$1 = function (detail) {
      return {
        dom: detail.dom,
        components: detail.components,
        events: derive$2([stopper(focusItem())])
      };
    };
    var schema$o = [
      required$1('dom'),
      required$1('components'),
      output$1('builder', builder$1)
    ];

    var owner$2 = constant$1('item-widget');
    var parts$h = constant$1([required({
        name: 'widget',
        overrides: function (detail) {
          return {
            behaviours: derive$1([Representing.config({
                store: {
                  mode: 'manual',
                  getValue: function (_component) {
                    return detail.data;
                  },
                  setValue: noop
                }
              })])
          };
        }
      })]);

    var builder = function (detail) {
      var subs = substitutes(owner$2(), detail, parts$h());
      var components = components$1(owner$2(), detail, subs.internals());
      var focusWidget = function (component) {
        return getPart(component, detail, 'widget').map(function (widget) {
          Keying.focusIn(widget);
          return widget;
        });
      };
      var onHorizontalArrow = function (component, simulatedEvent) {
        return inside(simulatedEvent.event.target) ? Optional.none() : function () {
          if (detail.autofocus) {
            simulatedEvent.setSource(component.element);
            return Optional.none();
          } else {
            return Optional.none();
          }
        }();
      };
      return {
        dom: detail.dom,
        components: components,
        domModification: detail.domModification,
        events: derive$2([
          runOnExecute$1(function (component, simulatedEvent) {
            focusWidget(component).each(function (_widget) {
              simulatedEvent.stop();
            });
          }),
          run$1(mouseover(), onHover),
          run$1(focusItem(), function (component, _simulatedEvent) {
            if (detail.autofocus) {
              focusWidget(component);
            } else {
              Focusing.focus(component);
            }
          })
        ]),
        behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: detail.data
            }
          }),
          Focusing.config({
            ignore: detail.ignoreFocus,
            onFocus: function (component) {
              onFocus$1(component);
            }
          }),
          Keying.config({
            mode: 'special',
            focusIn: detail.autofocus ? function (component) {
              focusWidget(component);
            } : revoke(),
            onLeft: onHorizontalArrow,
            onRight: onHorizontalArrow,
            onEscape: function (component, simulatedEvent) {
              if (!Focusing.isFocused(component) && !detail.autofocus) {
                Focusing.focus(component);
                return Optional.some(true);
              } else if (detail.autofocus) {
                simulatedEvent.setSource(component.element);
                return Optional.none();
              } else {
                return Optional.none();
              }
            }
          })
        ])
      };
    };
    var schema$n = [
      required$1('uid'),
      required$1('data'),
      required$1('components'),
      required$1('dom'),
      defaulted('autofocus', false),
      defaulted('ignoreFocus', false),
      SketchBehaviours.field('widgetBehaviours', [
        Representing,
        Focusing,
        Keying
      ]),
      defaulted('domModification', {}),
      defaultUidsSchema(parts$h()),
      output$1('builder', builder)
    ];

    var itemSchema$2 = choose$1('type', {
      widget: schema$n,
      item: schema$p,
      separator: schema$o
    });
    var configureGrid = function (detail, movementInfo) {
      return {
        mode: 'flatgrid',
        selector: '.' + detail.markers.item,
        initSize: {
          numColumns: movementInfo.initSize.numColumns,
          numRows: movementInfo.initSize.numRows
        },
        focusManager: detail.focusManager
      };
    };
    var configureMatrix = function (detail, movementInfo) {
      return {
        mode: 'matrix',
        selectors: {
          row: movementInfo.rowSelector,
          cell: '.' + detail.markers.item
        },
        focusManager: detail.focusManager
      };
    };
    var configureMenu = function (detail, movementInfo) {
      return {
        mode: 'menu',
        selector: '.' + detail.markers.item,
        moveOnTab: movementInfo.moveOnTab,
        focusManager: detail.focusManager
      };
    };
    var parts$g = constant$1([group({
        factory: {
          sketch: function (spec) {
            var itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);
            return itemInfo.builder(itemInfo);
          }
        },
        name: 'items',
        unit: 'item',
        defaults: function (detail, u) {
          return has$2(u, 'uid') ? u : __assign(__assign({}, u), { uid: generate$5('item') });
        },
        overrides: function (detail, u) {
          return {
            type: u.type,
            ignoreFocus: detail.fakeFocus,
            domModification: { classes: [detail.markers.item] }
          };
        }
      })]);
    var schema$m = constant$1([
      required$1('value'),
      required$1('items'),
      required$1('dom'),
      required$1('components'),
      defaulted('eventOrder', {}),
      field('menuBehaviours', [
        Highlighting,
        Representing,
        Composing,
        Keying
      ]),
      defaultedOf('movement', {
        mode: 'menu',
        moveOnTab: true
      }, choose$1('mode', {
        grid: [
          initSize(),
          output$1('config', configureGrid)
        ],
        matrix: [
          output$1('config', configureMatrix),
          required$1('rowSelector')
        ],
        menu: [
          defaulted('moveOnTab', true),
          output$1('config', configureMenu)
        ]
      })),
      itemMarkers(),
      defaulted('fakeFocus', false),
      defaulted('focusManager', dom$2()),
      onHandler('onHighlight')
    ]);

    var focus = constant$1('alloy.menu-focus');

    var make$7 = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        markers: detail.markers,
        behaviours: augment(detail.menuBehaviours, [
          Highlighting.config({
            highlightClass: detail.markers.selectedItem,
            itemClass: detail.markers.item,
            onHighlight: detail.onHighlight
          }),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: detail.value
            }
          }),
          Composing.config({ find: Optional.some }),
          Keying.config(detail.movement.config(detail, detail.movement))
        ]),
        events: derive$2([
          run$1(focus$1(), function (menu, simulatedEvent) {
            var event = simulatedEvent.event;
            menu.getSystem().getByDom(event.target).each(function (item) {
              Highlighting.highlight(menu, item);
              simulatedEvent.stop();
              emitWith(menu, focus(), {
                menu: menu,
                item: item
              });
            });
          }),
          run$1(hover(), function (menu, simulatedEvent) {
            var item = simulatedEvent.event.item;
            Highlighting.highlight(menu, item);
          })
        ]),
        components: components,
        eventOrder: detail.eventOrder,
        domModification: { attributes: { role: 'menu' } }
      };
    };

    var Menu = composite({
      name: 'Menu',
      configFields: schema$m(),
      partFields: parts$g(),
      factory: make$7
    });

    var transpose$1 = function (obj) {
      return tupleMap(obj, function (v, k) {
        return {
          k: v,
          v: k
        };
      });
    };
    var trace = function (items, byItem, byMenu, finish) {
      return get$e(byMenu, finish).bind(function (triggerItem) {
        return get$e(items, triggerItem).bind(function (triggerMenu) {
          var rest = trace(items, byItem, byMenu, triggerMenu);
          return Optional.some([triggerMenu].concat(rest));
        });
      }).getOr([]);
    };
    var generate$2 = function (menus, expansions) {
      var items = {};
      each(menus, function (menuItems, menu) {
        each$1(menuItems, function (item) {
          items[item] = menu;
        });
      });
      var byItem = expansions;
      var byMenu = transpose$1(expansions);
      var menuPaths = map$1(byMenu, function (_triggerItem, submenu) {
        return [submenu].concat(trace(items, byItem, byMenu, submenu));
      });
      return map$1(items, function (menu) {
        return get$e(menuPaths, menu).getOr([menu]);
      });
    };

    var init$c = function () {
      var expansions = Cell({});
      var menus = Cell({});
      var paths = Cell({});
      var primary = value$1();
      var directory = Cell({});
      var clear = function () {
        expansions.set({});
        menus.set({});
        paths.set({});
        primary.clear();
      };
      var isClear = function () {
        return primary.get().isNone();
      };
      var setMenuBuilt = function (menuName, built) {
        var _a;
        menus.set(__assign(__assign({}, menus.get()), (_a = {}, _a[menuName] = {
          type: 'prepared',
          menu: built
        }, _a)));
      };
      var setContents = function (sPrimary, sMenus, sExpansions, dir) {
        primary.set(sPrimary);
        expansions.set(sExpansions);
        menus.set(sMenus);
        directory.set(dir);
        var sPaths = generate$2(dir, sExpansions);
        paths.set(sPaths);
      };
      var getTriggeringItem = function (menuValue) {
        return find$4(expansions.get(), function (v, _k) {
          return v === menuValue;
        });
      };
      var getTriggerData = function (menuValue, getItemByValue, path) {
        return getPreparedMenu(menuValue).bind(function (menu) {
          return getTriggeringItem(menuValue).bind(function (triggeringItemValue) {
            return getItemByValue(triggeringItemValue).map(function (triggeredItem) {
              return {
                triggeredMenu: menu,
                triggeringItem: triggeredItem,
                triggeringPath: path
              };
            });
          });
        });
      };
      var getTriggeringPath = function (itemValue, getItemByValue) {
        var extraPath = filter$2(lookupItem(itemValue).toArray(), function (menuValue) {
          return getPreparedMenu(menuValue).isSome();
        });
        return get$e(paths.get(), itemValue).bind(function (path) {
          var revPath = reverse(extraPath.concat(path));
          var triggers = bind$3(revPath, function (menuValue, menuIndex) {
            return getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(function () {
              return is$1(primary.get(), menuValue) ? [] : [Optional.none()];
            }, function (data) {
              return [Optional.some(data)];
            });
          });
          return sequence(triggers);
        });
      };
      var expand = function (itemValue) {
        return get$e(expansions.get(), itemValue).map(function (menu) {
          var current = get$e(paths.get(), itemValue).getOr([]);
          return [menu].concat(current);
        });
      };
      var collapse = function (itemValue) {
        return get$e(paths.get(), itemValue).bind(function (path) {
          return path.length > 1 ? Optional.some(path.slice(1)) : Optional.none();
        });
      };
      var refresh = function (itemValue) {
        return get$e(paths.get(), itemValue);
      };
      var getPreparedMenu = function (menuValue) {
        return lookupMenu(menuValue).bind(extractPreparedMenu);
      };
      var lookupMenu = function (menuValue) {
        return get$e(menus.get(), menuValue);
      };
      var lookupItem = function (itemValue) {
        return get$e(expansions.get(), itemValue);
      };
      var otherMenus = function (path) {
        var menuValues = directory.get();
        return difference(keys(menuValues), path);
      };
      var getPrimary = function () {
        return primary.get().bind(getPreparedMenu);
      };
      var getMenus = function () {
        return menus.get();
      };
      return {
        setMenuBuilt: setMenuBuilt,
        setContents: setContents,
        expand: expand,
        refresh: refresh,
        collapse: collapse,
        lookupMenu: lookupMenu,
        lookupItem: lookupItem,
        otherMenus: otherMenus,
        getPrimary: getPrimary,
        getMenus: getMenus,
        clear: clear,
        isClear: isClear,
        getTriggeringPath: getTriggeringPath
      };
    };
    var extractPreparedMenu = function (prep) {
      return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();
    };
    var LayeredState = {
      init: init$c,
      extractPreparedMenu: extractPreparedMenu
    };

    var make$6 = function (detail, _rawUiSpec) {
      var submenuParentItems = value$1();
      var buildMenus = function (container, primaryName, menus) {
        return map$1(menus, function (spec, name) {
          var makeSketch = function () {
            return Menu.sketch(__assign(__assign({}, spec), {
              value: name,
              markers: detail.markers,
              fakeFocus: detail.fakeFocus,
              onHighlight: detail.onHighlight,
              focusManager: detail.fakeFocus ? highlights() : dom$2()
            }));
          };
          return name === primaryName ? {
            type: 'prepared',
            menu: container.getSystem().build(makeSketch())
          } : {
            type: 'notbuilt',
            nbMenu: makeSketch
          };
        });
      };
      var layeredState = LayeredState.init();
      var setup = function (container) {
        var componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
        var directory = toDirectory();
        layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
        return layeredState.getPrimary();
      };
      var getItemValue = function (item) {
        return Representing.getValue(item).value;
      };
      var getItemByValue = function (_container, menus, itemValue) {
        return findMap(menus, function (menu) {
          if (!menu.getSystem().isConnected()) {
            return Optional.none();
          }
          var candidates = Highlighting.getCandidates(menu);
          return find$5(candidates, function (c) {
            return getItemValue(c) === itemValue;
          });
        });
      };
      var toDirectory = function (_container) {
        return map$1(detail.data.menus, function (data, _menuName) {
          return bind$3(data.items, function (item) {
            return item.type === 'separator' ? [] : [item.data.value];
          });
        });
      };
      var setActiveMenu = function (container, menu) {
        Highlighting.highlight(container, menu);
        Highlighting.getHighlighted(menu).orThunk(function () {
          return Highlighting.getFirst(menu);
        }).each(function (item) {
          dispatch(container, item.element, focusItem());
        });
      };
      var getMenus = function (state, menuValues) {
        return cat(map$2(menuValues, function (mv) {
          return state.lookupMenu(mv).bind(function (prep) {
            return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();
          });
        }));
      };
      var closeOthers = function (container, state, path) {
        var others = getMenus(state, state.otherMenus(path));
        each$1(others, function (o) {
          remove$1(o.element, [detail.markers.backgroundMenu]);
          if (!detail.stayInDom) {
            Replacing.remove(container, o);
          }
        });
      };
      var getSubmenuParents = function (container) {
        return submenuParentItems.get().getOrThunk(function () {
          var r = {};
          var items = descendants(container.element, '.' + detail.markers.item);
          var parentItems = filter$2(items, function (i) {
            return get$d(i, 'aria-haspopup') === 'true';
          });
          each$1(parentItems, function (i) {
            container.getSystem().getByDom(i).each(function (itemComp) {
              var key = getItemValue(itemComp);
              r[key] = itemComp;
            });
          });
          submenuParentItems.set(r);
          return r;
        });
      };
      var updateAriaExpansions = function (container, path) {
        var parentItems = getSubmenuParents(container);
        each(parentItems, function (v, k) {
          var expanded = contains$2(path, k);
          set$8(v.element, 'aria-expanded', expanded);
        });
      };
      var updateMenuPath = function (container, state, path) {
        return Optional.from(path[0]).bind(function (latestMenuName) {
          return state.lookupMenu(latestMenuName).bind(function (menuPrep) {
            if (menuPrep.type === 'notbuilt') {
              return Optional.none();
            } else {
              var activeMenu = menuPrep.menu;
              var rest = getMenus(state, path.slice(1));
              each$1(rest, function (r) {
                add$2(r.element, detail.markers.backgroundMenu);
              });
              if (!inBody(activeMenu.element)) {
                Replacing.append(container, premade(activeMenu));
              }
              remove$1(activeMenu.element, [detail.markers.backgroundMenu]);
              setActiveMenu(container, activeMenu);
              closeOthers(container, state, path);
              return Optional.some(activeMenu);
            }
          });
        });
      };
      var ExpandHighlightDecision;
      (function (ExpandHighlightDecision) {
        ExpandHighlightDecision[ExpandHighlightDecision['HighlightSubmenu'] = 0] = 'HighlightSubmenu';
        ExpandHighlightDecision[ExpandHighlightDecision['HighlightParent'] = 1] = 'HighlightParent';
      }(ExpandHighlightDecision || (ExpandHighlightDecision = {})));
      var buildIfRequired = function (container, menuName, menuPrep) {
        if (menuPrep.type === 'notbuilt') {
          var menu = container.getSystem().build(menuPrep.nbMenu());
          layeredState.setMenuBuilt(menuName, menu);
          return menu;
        } else {
          return menuPrep.menu;
        }
      };
      var expandRight = function (container, item, decision) {
        if (decision === void 0) {
          decision = ExpandHighlightDecision.HighlightSubmenu;
        }
        if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) {
          return Optional.some(item);
        } else {
          var value = getItemValue(item);
          return layeredState.expand(value).bind(function (path) {
            updateAriaExpansions(container, path);
            return Optional.from(path[0]).bind(function (menuName) {
              return layeredState.lookupMenu(menuName).bind(function (activeMenuPrep) {
                var activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
                if (!inBody(activeMenu.element)) {
                  Replacing.append(container, premade(activeMenu));
                }
                detail.onOpenSubmenu(container, item, activeMenu, reverse(path));
                if (decision === ExpandHighlightDecision.HighlightSubmenu) {
                  Highlighting.highlightFirst(activeMenu);
                  return updateMenuPath(container, layeredState, path);
                } else {
                  Highlighting.dehighlightAll(activeMenu);
                  return Optional.some(item);
                }
              });
            });
          });
        }
      };
      var collapseLeft = function (container, item) {
        var value = getItemValue(item);
        return layeredState.collapse(value).bind(function (path) {
          updateAriaExpansions(container, path);
          return updateMenuPath(container, layeredState, path).map(function (activeMenu) {
            detail.onCollapseMenu(container, item, activeMenu);
            return activeMenu;
          });
        });
      };
      var updateView = function (container, item) {
        var value = getItemValue(item);
        return layeredState.refresh(value).bind(function (path) {
          updateAriaExpansions(container, path);
          return updateMenuPath(container, layeredState, path);
        });
      };
      var onRight = function (container, item) {
        return inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);
      };
      var onLeft = function (container, item) {
        return inside(item.element) ? Optional.none() : collapseLeft(container, item);
      };
      var onEscape = function (container, item) {
        return collapseLeft(container, item).orThunk(function () {
          return detail.onEscape(container, item).map(function () {
            return container;
          });
        });
      };
      var keyOnItem = function (f) {
        return function (container, simulatedEvent) {
          return closest$1(simulatedEvent.getSource(), '.' + detail.markers.item).bind(function (target) {
            return container.getSystem().getByDom(target).toOptional().bind(function (item) {
              return f(container, item).map(always);
            });
          });
        };
      };
      var events = derive$2([
        run$1(focus(), function (sandbox, simulatedEvent) {
          var item = simulatedEvent.event.item;
          layeredState.lookupItem(getItemValue(item)).each(function () {
            var menu = simulatedEvent.event.menu;
            Highlighting.highlight(sandbox, menu);
            var value = getItemValue(simulatedEvent.event.item);
            layeredState.refresh(value).each(function (path) {
              return closeOthers(sandbox, layeredState, path);
            });
          });
        }),
        runOnExecute$1(function (component, simulatedEvent) {
          var target = simulatedEvent.event.target;
          component.getSystem().getByDom(target).each(function (item) {
            var itemValue = getItemValue(item);
            if (itemValue.indexOf('collapse-item') === 0) {
              collapseLeft(component, item);
            }
            expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(function () {
              detail.onExecute(component, item);
            }, noop);
          });
        }),
        runOnAttached(function (container, _simulatedEvent) {
          setup(container).each(function (primary) {
            Replacing.append(container, premade(primary));
            detail.onOpenMenu(container, primary);
            if (detail.highlightImmediately) {
              setActiveMenu(container, primary);
            }
          });
        })
      ].concat(detail.navigateOnHover ? [run$1(hover(), function (sandbox, simulatedEvent) {
          var item = simulatedEvent.event.item;
          updateView(sandbox, item);
          expandRight(sandbox, item, ExpandHighlightDecision.HighlightParent);
          detail.onHover(sandbox, item);
        })] : []));
      var getActiveItem = function (container) {
        return Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);
      };
      var collapseMenuApi = function (container) {
        getActiveItem(container).each(function (currentItem) {
          collapseLeft(container, currentItem);
        });
      };
      var highlightPrimary = function (container) {
        layeredState.getPrimary().each(function (primary) {
          setActiveMenu(container, primary);
        });
      };
      var extractMenuFromContainer = function (container) {
        return Optional.from(container.components()[0]).filter(function (comp) {
          return get$d(comp.element, 'role') === 'menu';
        });
      };
      var repositionMenus = function (container) {
        var maybeActivePrimary = layeredState.getPrimary().bind(function (primary) {
          return getActiveItem(container).bind(function (currentItem) {
            var itemValue = getItemValue(currentItem);
            var allMenus = values(layeredState.getMenus());
            var preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));
            return layeredState.getTriggeringPath(itemValue, function (v) {
              return getItemByValue(container, preparedMenus, v);
            });
          }).map(function (triggeringPath) {
            return {
              primary: primary,
              triggeringPath: triggeringPath
            };
          });
        });
        maybeActivePrimary.fold(function () {
          extractMenuFromContainer(container).each(function (primaryMenu) {
            detail.onRepositionMenu(container, primaryMenu, []);
          });
        }, function (_a) {
          var primary = _a.primary, triggeringPath = _a.triggeringPath;
          detail.onRepositionMenu(container, primary, triggeringPath);
        });
      };
      var apis = {
        collapseMenu: collapseMenuApi,
        highlightPrimary: highlightPrimary,
        repositionMenus: repositionMenus
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        markers: detail.markers,
        behaviours: augment(detail.tmenuBehaviours, [
          Keying.config({
            mode: 'special',
            onRight: keyOnItem(onRight),
            onLeft: keyOnItem(onLeft),
            onEscape: keyOnItem(onEscape),
            focusIn: function (container, _keyInfo) {
              layeredState.getPrimary().each(function (primary) {
                dispatch(container, primary.element, focusItem());
              });
            }
          }),
          Highlighting.config({
            highlightClass: detail.markers.selectedMenu,
            itemClass: detail.markers.menu
          }),
          Composing.config({
            find: function (container) {
              return Highlighting.getHighlighted(container);
            }
          }),
          Replacing.config({})
        ]),
        eventOrder: detail.eventOrder,
        apis: apis,
        events: events
      };
    };
    var collapseItem$1 = constant$1('collapse-item');

    var tieredData = function (primary, menus, expansions) {
      return {
        primary: primary,
        menus: menus,
        expansions: expansions
      };
    };
    var singleData = function (name, menu) {
      return {
        primary: name,
        menus: wrap$1(name, menu),
        expansions: {}
      };
    };
    var collapseItem = function (text) {
      return {
        value: generate$6(collapseItem$1()),
        meta: { text: text }
      };
    };
    var tieredMenu = single({
      name: 'TieredMenu',
      configFields: [
        onStrictKeyboardHandler('onExecute'),
        onStrictKeyboardHandler('onEscape'),
        onStrictHandler('onOpenMenu'),
        onStrictHandler('onOpenSubmenu'),
        onHandler('onRepositionMenu'),
        onHandler('onCollapseMenu'),
        defaulted('highlightImmediately', true),
        requiredObjOf('data', [
          required$1('primary'),
          required$1('menus'),
          required$1('expansions')
        ]),
        defaulted('fakeFocus', false),
        onHandler('onHighlight'),
        onHandler('onHover'),
        tieredMenuMarkers(),
        required$1('dom'),
        defaulted('navigateOnHover', true),
        defaulted('stayInDom', false),
        field('tmenuBehaviours', [
          Keying,
          Highlighting,
          Composing,
          Replacing
        ]),
        defaulted('eventOrder', {})
      ],
      apis: {
        collapseMenu: function (apis, tmenu) {
          apis.collapseMenu(tmenu);
        },
        highlightPrimary: function (apis, tmenu) {
          apis.highlightPrimary(tmenu);
        },
        repositionMenus: function (apis, tmenu) {
          apis.repositionMenus(tmenu);
        }
      },
      factory: make$6,
      extraApis: {
        tieredData: tieredData,
        singleData: singleData,
        collapseItem: collapseItem
      }
    });

    var makeMenu = function (detail, menuSandbox, placementSpec, menuSpec, getBounds) {
      var lazySink = function () {
        return detail.lazySink(menuSandbox);
      };
      var layouts = menuSpec.type === 'horizontal' ? {
        layouts: {
          onLtr: function () {
            return belowOrAbove();
          },
          onRtl: function () {
            return belowOrAboveRtl();
          }
        }
      } : {};
      var isFirstTierSubmenu = function (triggeringPaths) {
        return triggeringPaths.length === 2;
      };
      var getSubmenuLayouts = function (triggeringPaths) {
        return isFirstTierSubmenu(triggeringPaths) ? layouts : {};
      };
      return tieredMenu.sketch({
        dom: { tag: 'div' },
        data: menuSpec.data,
        markers: menuSpec.menu.markers,
        highlightImmediately: menuSpec.menu.highlightImmediately,
        onEscape: function () {
          Sandboxing.close(menuSandbox);
          detail.onEscape.map(function (handler) {
            return handler(menuSandbox);
          });
          return Optional.some(true);
        },
        onExecute: function () {
          return Optional.some(true);
        },
        onOpenMenu: function (tmenu, menu) {
          Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());
        },
        onOpenSubmenu: function (tmenu, item, submenu, triggeringPaths) {
          var sink = lazySink().getOrDie();
          Positioning.position(sink, submenu, {
            anchor: __assign({
              type: 'submenu',
              item: item
            }, getSubmenuLayouts(triggeringPaths))
          });
        },
        onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {
          var sink = lazySink().getOrDie();
          Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());
          each$1(submenuTriggers, function (st) {
            var submenuLayouts = getSubmenuLayouts(st.triggeringPath);
            Positioning.position(sink, st.triggeredMenu, {
              anchor: __assign({
                type: 'submenu',
                item: st.triggeringItem
              }, submenuLayouts)
            });
          });
        }
      });
    };
    var factory$m = function (detail, spec) {
      var isPartOfRelated = function (sandbox, queryElem) {
        var related = detail.getRelated(sandbox);
        return related.exists(function (rel) {
          return isPartOf$1(rel, queryElem);
        });
      };
      var setContent = function (sandbox, thing) {
        Sandboxing.setContent(sandbox, thing);
      };
      var showAt = function (sandbox, thing, placementSpec) {
        showWithin(sandbox, thing, placementSpec, Optional.none());
      };
      var showWithin = function (sandbox, thing, placementSpec, boxElement) {
        showWithinBounds(sandbox, thing, placementSpec, function () {
          return boxElement.map(function (elem) {
            return box$1(elem);
          });
        });
      };
      var showWithinBounds = function (sandbox, thing, placementSpec, getBounds) {
        var sink = detail.lazySink(sandbox).getOrDie();
        Sandboxing.openWhileCloaked(sandbox, thing, function () {
          return Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds());
        });
        Representing.setValue(sandbox, Optional.some({
          mode: 'position',
          config: placementSpec,
          getBounds: getBounds
        }));
      };
      var showMenuAt = function (sandbox, placementSpec, menuSpec) {
        showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
      };
      var showMenuWithinBounds = function (sandbox, placementSpec, menuSpec, getBounds) {
        var menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);
        Sandboxing.open(sandbox, menu);
        Representing.setValue(sandbox, Optional.some({
          mode: 'menu',
          menu: menu
        }));
      };
      var hide = function (sandbox) {
        if (Sandboxing.isOpen(sandbox)) {
          Representing.setValue(sandbox, Optional.none());
          Sandboxing.close(sandbox);
        }
      };
      var getContent = function (sandbox) {
        return Sandboxing.getState(sandbox);
      };
      var reposition = function (sandbox) {
        if (Sandboxing.isOpen(sandbox)) {
          Representing.getValue(sandbox).each(function (state) {
            switch (state.mode) {
            case 'menu':
              Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);
              break;
            case 'position':
              var sink = detail.lazySink(sandbox).getOrDie();
              Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
              break;
            }
          });
        }
      };
      var apis = {
        setContent: setContent,
        showAt: showAt,
        showWithin: showWithin,
        showWithinBounds: showWithinBounds,
        showMenuAt: showMenuAt,
        showMenuWithinBounds: showMenuWithinBounds,
        hide: hide,
        getContent: getContent,
        reposition: reposition,
        isOpen: Sandboxing.isOpen
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        behaviours: augment(detail.inlineBehaviours, [
          Sandboxing.config({
            isPartOf: function (sandbox, data, queryElem) {
              return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);
            },
            getAttachPoint: function (sandbox) {
              return detail.lazySink(sandbox).getOrDie();
            },
            onOpen: function (sandbox) {
              detail.onShow(sandbox);
            },
            onClose: function (sandbox) {
              detail.onHide(sandbox);
            }
          }),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: Optional.none()
            }
          }),
          Receiving.config({
            channels: __assign(__assign({}, receivingChannel$1(__assign({ isExtraPart: spec.isExtraPart }, detail.fireDismissalEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})))), receivingChannel(__assign(__assign({}, detail.fireRepositionEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})), { doReposition: reposition })))
          })
        ]),
        eventOrder: detail.eventOrder,
        apis: apis
      };
    };
    var InlineView = single({
      name: 'InlineView',
      configFields: [
        required$1('lazySink'),
        onHandler('onShow'),
        onHandler('onHide'),
        optionFunction('onEscape'),
        field('inlineBehaviours', [
          Sandboxing,
          Representing,
          Receiving
        ]),
        optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),
        optionObjOf('fireRepositionEventInstead', [defaulted('event', repositionRequested())]),
        defaulted('getRelated', Optional.none),
        defaulted('isExtraPart', never),
        defaulted('eventOrder', Optional.none)
      ],
      factory: factory$m,
      apis: {
        showAt: function (apis, component, anchor, thing) {
          apis.showAt(component, anchor, thing);
        },
        showWithin: function (apis, component, anchor, thing, boxElement) {
          apis.showWithin(component, anchor, thing, boxElement);
        },
        showWithinBounds: function (apis, component, anchor, thing, bounds) {
          apis.showWithinBounds(component, anchor, thing, bounds);
        },
        showMenuAt: function (apis, component, anchor, menuSpec) {
          apis.showMenuAt(component, anchor, menuSpec);
        },
        showMenuWithinBounds: function (apis, component, anchor, menuSpec, bounds) {
          apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
        },
        hide: function (apis, component) {
          apis.hide(component);
        },
        isOpen: function (apis, component) {
          return apis.isOpen(component);
        },
        getContent: function (apis, component) {
          return apis.getContent(component);
        },
        setContent: function (apis, component, thing) {
          apis.setContent(component, thing);
        },
        reposition: function (apis, component) {
          apis.reposition(component);
        }
      }
    });

    var labelPrefix = 'layout-inset';
    var westEdgeX = function (anchor) {
      return anchor.x;
    };
    var middleX = function (anchor, element) {
      return anchor.x + anchor.width / 2 - element.width / 2;
    };
    var eastEdgeX = function (anchor, element) {
      return anchor.x + anchor.width - element.width;
    };
    var northY = function (anchor) {
      return anchor.y;
    };
    var southY = function (anchor, element) {
      return anchor.y + anchor.height - element.height;
    };
    var centreY = function (anchor, element) {
      return anchor.y + anchor.height / 2 - element.height / 2;
    };
    var southwest = function (anchor, element, bubbles) {
      return nu$6(eastEdgeX(anchor, element), southY(anchor, element), bubbles.insetSouthwest(), northwest$3(), 'southwest', boundsRestriction(anchor, {
        right: 0,
        bottom: 3
      }), labelPrefix);
    };
    var southeast = function (anchor, element, bubbles) {
      return nu$6(westEdgeX(anchor), southY(anchor, element), bubbles.insetSoutheast(), northeast$3(), 'southeast', boundsRestriction(anchor, {
        left: 1,
        bottom: 3
      }), labelPrefix);
    };
    var northwest = function (anchor, element, bubbles) {
      return nu$6(eastEdgeX(anchor, element), northY(anchor), bubbles.insetNorthwest(), southwest$3(), 'northwest', boundsRestriction(anchor, {
        right: 0,
        top: 2
      }), labelPrefix);
    };
    var northeast = function (anchor, element, bubbles) {
      return nu$6(westEdgeX(anchor), northY(anchor), bubbles.insetNortheast(), southeast$3(), 'northeast', boundsRestriction(anchor, {
        left: 1,
        top: 2
      }), labelPrefix);
    };
    var north = function (anchor, element, bubbles) {
      return nu$6(middleX(anchor, element), northY(anchor), bubbles.insetNorth(), south$3(), 'north', boundsRestriction(anchor, { top: 2 }), labelPrefix);
    };
    var south = function (anchor, element, bubbles) {
      return nu$6(middleX(anchor, element), southY(anchor, element), bubbles.insetSouth(), north$3(), 'south', boundsRestriction(anchor, { bottom: 3 }), labelPrefix);
    };
    var east = function (anchor, element, bubbles) {
      return nu$6(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), 'east', boundsRestriction(anchor, { right: 0 }), labelPrefix);
    };
    var west = function (anchor, element, bubbles) {
      return nu$6(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), 'west', boundsRestriction(anchor, { left: 1 }), labelPrefix);
    };
    var lookupPreserveLayout = function (lastPlacement) {
      switch (lastPlacement) {
      case 'north':
        return north;
      case 'northeast':
        return northeast;
      case 'northwest':
        return northwest;
      case 'south':
        return south;
      case 'southeast':
        return southeast;
      case 'southwest':
        return southwest;
      case 'east':
        return east;
      case 'west':
        return west;
      }
    };
    var preserve = function (anchor, element, bubbles, placee, bounds) {
      var layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north);
      return layout(anchor, element, bubbles, placee, bounds);
    };
    var lookupFlippedLayout = function (lastPlacement) {
      switch (lastPlacement) {
      case 'north':
        return south;
      case 'northeast':
        return southeast;
      case 'northwest':
        return southwest;
      case 'south':
        return north;
      case 'southeast':
        return northeast;
      case 'southwest':
        return northwest;
      case 'east':
        return west;
      case 'west':
        return east;
      }
    };
    var flip$2 = function (anchor, element, bubbles, placee, bounds) {
      var layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north);
      return layout(anchor, element, bubbles, placee, bounds);
    };

    var global$f = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var factory$l = function (detail) {
      var events = events$a(detail.action);
      var tag = detail.dom.tag;
      var lookupAttr = function (attr) {
        return get$e(detail.dom, 'attributes').bind(function (attrs) {
          return get$e(attrs, attr);
        });
      };
      var getModAttributes = function () {
        if (tag === 'button') {
          var type = lookupAttr('type').getOr('button');
          var roleAttrs = lookupAttr('role').map(function (role) {
            return { role: role };
          }).getOr({});
          return __assign({ type: type }, roleAttrs);
        } else {
          var role = lookupAttr('role').getOr('button');
          return { role: role };
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: detail.components,
        events: events,
        behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
          Focusing.config({}),
          Keying.config({
            mode: 'execution',
            useSpace: true,
            useEnter: true
          })
        ]),
        domModification: { attributes: getModAttributes() },
        eventOrder: detail.eventOrder
      };
    };
    var Button = single({
      name: 'Button',
      factory: factory$l,
      configFields: [
        defaulted('uid', undefined),
        required$1('dom'),
        defaulted('components', []),
        SketchBehaviours.field('buttonBehaviours', [
          Focusing,
          Keying
        ]),
        option('action'),
        option('role'),
        defaulted('eventOrder', {})
      ]
    });

    var record = function (spec) {
      var uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$5('memento');
      var get = function (anyInSystem) {
        return anyInSystem.getSystem().getByUid(uid).getOrDie();
      };
      var getOpt = function (anyInSystem) {
        return anyInSystem.getSystem().getByUid(uid).toOptional();
      };
      var asSpec = function () {
        return __assign(__assign({}, spec), { uid: uid });
      };
      return {
        get: get,
        getOpt: getOpt,
        asSpec: asSpec
      };
    };

    var global$e = tinymce.util.Tools.resolve('tinymce.util.I18n');

    var rtlTransform = {
      'indent': true,
      'outdent': true,
      'table-insert-column-after': true,
      'table-insert-column-before': true,
      'paste-column-after': true,
      'paste-column-before': true,
      'unordered-list': true,
      'list-bull-circle': true,
      'list-bull-default': true,
      'list-bull-square': true
    };
    var defaultIconName = 'temporary-placeholder';
    var defaultIcon = function (icons) {
      return function () {
        return get$e(icons, defaultIconName).getOr('!not found!');
      };
    };
    var getIconName = function (name, icons) {
      var lcName = name.toLowerCase();
      if (global$e.isRtl()) {
        var rtlName = ensureTrailing(lcName, '-rtl');
        return has$2(icons, rtlName) ? rtlName : lcName;
      } else {
        return lcName;
      }
    };
    var lookupIcon = function (name, icons) {
      return get$e(icons, getIconName(name, icons));
    };
    var get$1 = function (name, iconProvider) {
      var icons = iconProvider();
      return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));
    };
    var getOr = function (name, iconProvider, fallbackIcon) {
      var icons = iconProvider();
      return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));
    };
    var needsRtlTransform = function (iconName) {
      return global$e.isRtl() ? has$2(rtlTransform, iconName) : false;
    };
    var addFocusableBehaviour = function () {
      return config('add-focusable', [runOnAttached(function (comp) {
          child(comp.element, 'svg').each(function (svg) {
            return set$8(svg, 'focusable', 'false');
          });
        })]);
    };
    var renderIcon$2 = function (spec, iconName, icons, fallbackIcon) {
      var _a, _b;
      var rtlIconClasses = needsRtlTransform(iconName) ? ['tox-icon--flip'] : [];
      var iconHtml = get$e(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));
      return {
        dom: {
          tag: spec.tag,
          attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
          classes: spec.classes.concat(rtlIconClasses),
          innerHtml: iconHtml
        },
        behaviours: derive$1(__spreadArray(__spreadArray([], (_b = spec.behaviours) !== null && _b !== void 0 ? _b : [], true), [addFocusableBehaviour()], false))
      };
    };
    var render$3 = function (iconName, spec, iconProvider, fallbackIcon) {
      if (fallbackIcon === void 0) {
        fallbackIcon = Optional.none();
      }
      return renderIcon$2(spec, iconName, iconProvider(), fallbackIcon);
    };
    var renderFirst = function (iconNames, spec, iconProvider) {
      var icons = iconProvider();
      var iconName = find$5(iconNames, function (name) {
        return has$2(icons, getIconName(name, icons));
      });
      return renderIcon$2(spec, iconName.getOr(defaultIconName), icons, Optional.none());
    };

    var notificationIconMap = {
      success: 'checkmark',
      error: 'warning',
      err: 'error',
      warning: 'warning',
      warn: 'warning',
      info: 'info'
    };
    var factory$k = function (detail) {
      var memBannerText = record({
        dom: {
          tag: 'p',
          innerHtml: detail.translationProvider(detail.text)
        },
        behaviours: derive$1([Replacing.config({})])
      });
      var renderPercentBar = function (percent) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-bar'],
            attributes: { style: 'width: ' + percent + '%' }
          }
        };
      };
      var renderPercentText = function (percent) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-text'],
            innerHtml: percent + '%'
          }
        };
      };
      var memBannerProgress = record({
        dom: {
          tag: 'div',
          classes: detail.progress ? [
            'tox-progress-bar',
            'tox-progress-indicator'
          ] : ['tox-progress-bar']
        },
        components: [
          {
            dom: {
              tag: 'div',
              classes: ['tox-bar-container']
            },
            components: [renderPercentBar(0)]
          },
          renderPercentText(0)
        ],
        behaviours: derive$1([Replacing.config({})])
      });
      var updateProgress = function (comp, percent) {
        if (comp.getSystem().isConnected()) {
          memBannerProgress.getOpt(comp).each(function (progress) {
            Replacing.set(progress, [
              {
                dom: {
                  tag: 'div',
                  classes: ['tox-bar-container']
                },
                components: [renderPercentBar(percent)]
              },
              renderPercentText(percent)
            ]);
          });
        }
      };
      var updateText = function (comp, text$1) {
        if (comp.getSystem().isConnected()) {
          var banner = memBannerText.get(comp);
          Replacing.set(banner, [text(text$1)]);
        }
      };
      var apis = {
        updateProgress: updateProgress,
        updateText: updateText
      };
      var iconChoices = flatten([
        detail.icon.toArray(),
        detail.level.toArray(),
        detail.level.bind(function (level) {
          return Optional.from(notificationIconMap[level]);
        }).toArray()
      ]);
      var memButton = record(Button.sketch({
        dom: {
          tag: 'button',
          classes: [
            'tox-notification__dismiss',
            'tox-button',
            'tox-button--naked',
            'tox-button--icon'
          ]
        },
        components: [render$3('close', {
            tag: 'div',
            classes: ['tox-icon'],
            attributes: { 'aria-label': detail.translationProvider('Close') }
          }, detail.iconProvider)],
        action: function (comp) {
          detail.onAction(comp);
        }
      }));
      var notificationIconSpec = renderFirst(iconChoices, {
        tag: 'div',
        classes: ['tox-notification__icon']
      }, detail.iconProvider);
      var notificationBodySpec = {
        dom: {
          tag: 'div',
          classes: ['tox-notification__body']
        },
        components: [memBannerText.asSpec()],
        behaviours: derive$1([Replacing.config({})])
      };
      var components = [
        notificationIconSpec,
        notificationBodySpec
      ];
      return {
        uid: detail.uid,
        dom: {
          tag: 'div',
          attributes: { role: 'alert' },
          classes: detail.level.map(function (level) {
            return [
              'tox-notification',
              'tox-notification--in',
              'tox-notification--' + level
            ];
          }).getOr([
            'tox-notification',
            'tox-notification--in'
          ])
        },
        behaviours: derive$1([
          Focusing.config({}),
          config('notification-events', [run$1(focusin(), function (comp) {
              memButton.getOpt(comp).each(Focusing.focus);
            })])
        ]),
        components: components.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [memButton.asSpec()]),
        apis: apis
      };
    };
    var Notification = single({
      name: 'Notification',
      factory: factory$k,
      configFields: [
        option('level'),
        required$1('progress'),
        required$1('icon'),
        required$1('onAction'),
        required$1('text'),
        required$1('iconProvider'),
        required$1('translationProvider'),
        defaultedBoolean('closeButton', true)
      ],
      apis: {
        updateProgress: function (apis, comp, percent) {
          apis.updateProgress(comp, percent);
        },
        updateText: function (apis, comp, text) {
          apis.updateText(comp, text);
        }
      }
    });

    function NotificationManagerImpl (editor, extras, uiMothership) {
      var sharedBackstage = extras.backstage.shared;
      var getLayoutDirection = function (rel) {
        switch (rel) {
        case 'bc-bc':
          return south;
        case 'tc-tc':
          return north;
        case 'tc-bc':
          return north$2;
        case 'bc-tc':
        default:
          return south$2;
        }
      };
      var reposition = function (notifications) {
        if (notifications.length > 0) {
          each$1(notifications, function (notification, index) {
            if (index === 0) {
              notification.moveRel(null, 'banner');
            } else {
              notification.moveRel(notifications[index - 1].getEl(), 'bc-tc');
            }
          });
        }
      };
      var open = function (settings, closeCallback) {
        var hideCloseButton = !settings.closeButton && settings.timeout && (settings.timeout > 0 || settings.timeout < 0);
        var close = function () {
          closeCallback();
          InlineView.hide(notificationWrapper);
        };
        var notification = build$1(Notification.sketch({
          text: settings.text,
          level: contains$2([
            'success',
            'error',
            'warning',
            'warn',
            'info'
          ], settings.type) ? settings.type : undefined,
          progress: settings.progressBar === true,
          icon: Optional.from(settings.icon),
          closeButton: !hideCloseButton,
          onAction: close,
          iconProvider: sharedBackstage.providers.icons,
          translationProvider: sharedBackstage.providers.translate
        }));
        var notificationWrapper = build$1(InlineView.sketch(__assign({
          dom: {
            tag: 'div',
            classes: ['tox-notifications-container']
          },
          lazySink: sharedBackstage.getSink,
          fireDismissalEventInstead: {}
        }, sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} })));
        uiMothership.add(notificationWrapper);
        if (settings.timeout > 0) {
          global$f.setTimeout(function () {
            close();
          }, settings.timeout);
        }
        var getBounds = function () {
          var contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
          var win$1 = win();
          var x = clamp$1(win$1.x, contentArea.x, contentArea.right);
          var y = clamp$1(win$1.y, contentArea.y, contentArea.bottom);
          var right = Math.max(contentArea.right, win$1.right);
          var bottom = Math.max(contentArea.bottom, win$1.bottom);
          return Optional.some(bounds(x, y, right - x, bottom - y));
        };
        return {
          close: close,
          moveTo: function (x, y) {
            InlineView.showAt(notificationWrapper, premade(notification), {
              anchor: {
                type: 'makeshift',
                x: x,
                y: y
              }
            });
          },
          moveRel: function (element, rel) {
            var notificationSpec = premade(notification);
            var anchorOverrides = { maxHeightFunction: expandable$1() };
            if (rel !== 'banner' && isNonNullable(element)) {
              var layoutDirection_1 = getLayoutDirection(rel);
              var nodeAnchor = {
                type: 'node',
                root: body(),
                node: Optional.some(SugarElement.fromDom(element)),
                overrides: anchorOverrides,
                layouts: {
                  onRtl: function () {
                    return [layoutDirection_1];
                  },
                  onLtr: function () {
                    return [layoutDirection_1];
                  }
                }
              };
              InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: nodeAnchor }, getBounds);
            } else {
              var anchor = __assign(__assign({}, sharedBackstage.anchors.banner()), { overrides: anchorOverrides });
              InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: anchor }, getBounds);
            }
          },
          text: function (nuText) {
            Notification.updateText(notification, nuText);
          },
          settings: settings,
          getEl: function () {
            return notification.element.dom;
          },
          progressBar: {
            value: function (percent) {
              Notification.updateProgress(notification, percent);
            }
          }
        };
      };
      var close = function (notification) {
        notification.close();
      };
      var getArgs = function (notification) {
        return notification.settings;
      };
      return {
        open: open,
        close: close,
        reposition: reposition,
        getArgs: getArgs
      };
    }

    var first = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (isNull(timer)) {
          timer = setTimeout(function () {
            timer = null;
            fn.apply(null, args);
          }, rate);
        }
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };
    var last = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        cancel();
        timer = setTimeout(function () {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var global$d = tinymce.util.Tools.resolve('tinymce.dom.TextSeeker');

    var isBoundary = function (dom, node) {
      return dom.isBlock(node) || contains$2([
        'BR',
        'IMG',
        'HR',
        'INPUT'
      ], node.nodeName) || dom.getContentEditable(node) === 'false';
    };
    var repeatLeft = function (dom, node, offset, process, rootNode) {
      var search = global$d(dom, function (node) {
        return isBoundary(dom, node);
      });
      return Optional.from(search.backwards(node, offset, process, rootNode));
    };

    var autocompleteSelector = '[data-mce-autocompleter]';
    var create$4 = function (editor, range) {
      return detect(SugarElement.fromDom(editor.selection.getNode())).getOrThunk(function () {
        var wrapper = SugarElement.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', editor.getDoc());
        append$2(wrapper, SugarElement.fromDom(range.extractContents()));
        range.insertNode(wrapper.dom);
        parent(wrapper).each(function (elm) {
          return elm.dom.normalize();
        });
        last$1(wrapper).map(function (last) {
          editor.selection.setCursorLocation(last.dom, getEnd(last));
        });
        return wrapper;
      });
    };
    var detect = function (elm) {
      return closest$1(elm, autocompleteSelector);
    };

    var isValidTextRange = function (rng) {
      return rng.collapsed && rng.startContainer.nodeType === 3;
    };
    var getText = function (rng) {
      return rng.toString().replace(/\u00A0/g, ' ').replace(/\uFEFF/g, '');
    };
    var isWhitespace = function (chr) {
      return chr !== '' && ' \xA0\f\n\r\t\x0B'.indexOf(chr) !== -1;
    };

    var stripTriggerChar = function (text, triggerCh) {
      return text.substring(triggerCh.length);
    };
    var findChar = function (text, index, ch) {
      var i;
      for (i = index - 1; i >= 0; i--) {
        var char = text.charAt(i);
        if (isWhitespace(char)) {
          return Optional.none();
        }
        if (char === ch) {
          break;
        }
      }
      return Optional.some(i);
    };
    var findStart = function (dom, initRange, ch, minChars) {
      if (minChars === void 0) {
        minChars = 0;
      }
      if (!isValidTextRange(initRange)) {
        return Optional.none();
      }
      var findTriggerChIndex = function (element, offset, text) {
        return findChar(text, offset, ch).getOr(offset);
      };
      var root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(function (spot) {
        var range = initRange.cloneRange();
        range.setStart(spot.container, spot.offset);
        range.setEnd(initRange.endContainer, initRange.endOffset);
        if (range.collapsed) {
          return Optional.none();
        }
        var text = getText(range);
        var triggerCharIndex = text.lastIndexOf(ch);
        if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length < minChars) {
          return Optional.none();
        } else {
          return Optional.some({
            text: stripTriggerChar(text, ch),
            range: range,
            triggerChar: ch
          });
        }
      });
    };
    var getContext = function (dom, initRange, ch, minChars) {
      if (minChars === void 0) {
        minChars = 0;
      }
      return detect(SugarElement.fromDom(initRange.startContainer)).fold(function () {
        return findStart(dom, initRange, ch, minChars);
      }, function (elm) {
        var range = dom.createRng();
        range.selectNode(elm.dom);
        var text = getText(range);
        return Optional.some({
          range: range,
          text: stripTriggerChar(text, ch),
          triggerChar: ch
        });
      });
    };

    var setup$e = function (api, editor) {
      editor.on('keypress compositionend', api.onKeypress.throttle);
      editor.on('remove', api.onKeypress.cancel);
      var redirectKeyToItem = function (item, e) {
        emitWith(item, keydown(), { raw: e });
      };
      editor.on('keydown', function (e) {
        var getItem = function () {
          return api.getView().bind(Highlighting.getHighlighted);
        };
        if (e.which === 8) {
          api.onKeypress.throttle(e);
        }
        if (api.isActive()) {
          if (e.which === 27) {
            api.cancelIfNecessary();
          }
          if (api.isMenuOpen()) {
            if (e.which === 13) {
              getItem().each(emitExecute);
              e.preventDefault();
            } else if (e.which === 40) {
              getItem().fold(function () {
                api.getView().each(Highlighting.highlightFirst);
              }, function (item) {
                redirectKeyToItem(item, e);
              });
              e.preventDefault();
              e.stopImmediatePropagation();
            } else if (e.which === 37 || e.which === 38 || e.which === 39) {
              getItem().each(function (item) {
                redirectKeyToItem(item, e);
                e.preventDefault();
                e.stopImmediatePropagation();
              });
            }
          } else {
            if (e.which === 13 || e.which === 38 || e.which === 40) {
              api.cancelIfNecessary();
            }
          }
        }
      });
      editor.on('NodeChange', function (e) {
        if (api.isActive() && !api.isProcessingAction() && detect(SugarElement.fromDom(e.element)).isNone()) {
          api.cancelIfNecessary();
        }
      });
    };
    var AutocompleterEditorEvents = { setup: setup$e };

    var global$c = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var point = function (container, offset) {
      return {
        container: container,
        offset: offset
      };
    };

    var isText = function (node) {
      return node.nodeType === TEXT;
    };
    var isElement$1 = function (node) {
      return node.nodeType === ELEMENT;
    };
    var toLast = function (node) {
      if (isText(node)) {
        return point(node, node.data.length);
      } else {
        var children = node.childNodes;
        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);
      }
    };
    var toLeaf = function (node, offset) {
      var children = node.childNodes;
      if (children.length > 0 && offset < children.length) {
        return toLeaf(children[offset], 0);
      } else if (children.length > 0 && isElement$1(node) && children.length === offset) {
        return toLast(children[children.length - 1]);
      } else {
        return point(node, offset);
      }
    };

    var isPreviousCharContent = function (dom, leaf) {
      return repeatLeft(dom, leaf.container, leaf.offset, function (element, offset) {
        return offset === 0 ? -1 : offset;
      }, dom.getRoot()).filter(function (spot) {
        var char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      }).isSome();
    };
    var isStartOfWord = function (dom) {
      return function (rng) {
        var leaf = toLeaf(rng.startContainer, rng.startOffset);
        return !isPreviousCharContent(dom, leaf);
      };
    };
    var getTriggerContext = function (dom, initRange, database) {
      return findMap(database.triggerChars, function (ch) {
        return getContext(dom, initRange, ch);
      });
    };
    var lookup$2 = function (editor, getDatabase) {
      var database = getDatabase();
      var rng = editor.selection.getRng();
      return getTriggerContext(editor.dom, rng, database).bind(function (context) {
        return lookupWithContext(editor, getDatabase, context);
      });
    };
    var lookupWithContext = function (editor, getDatabase, context, fetchOptions) {
      if (fetchOptions === void 0) {
        fetchOptions = {};
      }
      var database = getDatabase();
      var rng = editor.selection.getRng();
      var startText = rng.startContainer.nodeValue;
      var autocompleters = filter$2(database.lookupByChar(context.triggerChar), function (autocompleter) {
        return context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(function () {
          return isStartOfWord(editor.dom);
        })(context.range, startText, context.text);
      });
      if (autocompleters.length === 0) {
        return Optional.none();
      }
      var lookupData = global$c.all(map$2(autocompleters, function (ac) {
        var fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
        return fetchResult.then(function (results) {
          return {
            matchText: context.text,
            items: results,
            columns: ac.columns,
            onAction: ac.onAction,
            highlightOn: ac.highlightOn
          };
        });
      }));
      return Optional.some({
        lookupData: lookupData,
        context: context
      });
    };

    var separatorMenuItemSchema = objOf([
      requiredString('type'),
      optionString('text')
    ]);
    var createSeparatorMenuItem = function (spec) {
      return asRaw('separatormenuitem', separatorMenuItemSchema, spec);
    };

    var autocompleterItemSchema = objOf([
      defaulted('type', 'autocompleteitem'),
      defaulted('active', false),
      defaulted('disabled', false),
      defaulted('meta', {}),
      requiredString('value'),
      optionString('text'),
      optionString('icon')
    ]);
    var autocompleterSchema = objOf([
      requiredString('type'),
      requiredString('ch'),
      defaultedNumber('minChars', 1),
      defaulted('columns', 1),
      defaultedNumber('maxResults', 10),
      optionFunction('matches'),
      requiredFunction('fetch'),
      requiredFunction('onAction'),
      defaultedArrayOf('highlightOn', [], string)
    ]);
    var createSeparatorItem = function (spec) {
      return asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);
    };
    var createAutocompleterItem = function (spec) {
      return asRaw('Autocompleter.Item', autocompleterItemSchema, spec);
    };
    var createAutocompleter = function (spec) {
      return asRaw('Autocompleter', autocompleterSchema, spec);
    };

    var baseToolbarButtonFields = [
      defaultedBoolean('disabled', false),
      optionString('tooltip'),
      optionString('icon'),
      optionString('text'),
      defaultedFunction('onSetup', function () {
        return noop;
      })
    ];
    var toolbarButtonSchema = objOf([
      requiredString('type'),
      requiredFunction('onAction')
    ].concat(baseToolbarButtonFields));
    var createToolbarButton = function (spec) {
      return asRaw('toolbarbutton', toolbarButtonSchema, spec);
    };

    var baseToolbarToggleButtonFields = [defaultedBoolean('active', false)].concat(baseToolbarButtonFields);
    var toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([
      requiredString('type'),
      requiredFunction('onAction')
    ]));
    var createToggleButton = function (spec) {
      return asRaw('ToggleButton', toggleButtonSchema, spec);
    };

    var contextBarFields = [
      defaultedFunction('predicate', never),
      defaultedStringEnum('scope', 'node', [
        'node',
        'editor'
      ]),
      defaultedStringEnum('position', 'selection', [
        'node',
        'selection',
        'line'
      ])
    ];

    var contextButtonFields = baseToolbarButtonFields.concat([
      defaulted('type', 'contextformbutton'),
      defaulted('primary', false),
      requiredFunction('onAction'),
      customField('original', identity$1)
    ]);
    var contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
      defaulted('type', 'contextformbutton'),
      defaulted('primary', false),
      requiredFunction('onAction'),
      customField('original', identity$1)
    ]);
    var launchButtonFields = baseToolbarButtonFields.concat([defaulted('type', 'contextformbutton')]);
    var launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaulted('type', 'contextformtogglebutton')]);
    var toggleOrNormal = choose$1('type', {
      contextformbutton: contextButtonFields,
      contextformtogglebutton: contextToggleButtonFields
    });
    var contextFormSchema = objOf([
      defaulted('type', 'contextform'),
      defaultedFunction('initValue', constant$1('')),
      optionString('label'),
      requiredArrayOf('commands', toggleOrNormal),
      optionOf('launch', choose$1('type', {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields
      }))
    ].concat(contextBarFields));
    var createContextForm = function (spec) {
      return asRaw('ContextForm', contextFormSchema, spec);
    };

    var contextToolbarSchema = objOf([
      defaulted('type', 'contexttoolbar'),
      requiredString('items')
    ].concat(contextBarFields));
    var createContextToolbar = function (spec) {
      return asRaw('ContextToolbar', contextToolbarSchema, spec);
    };

    var stringArray = function (a) {
      var all = {};
      each$1(a, function (key) {
        all[key] = {};
      });
      return keys(all);
    };

    var register$b = function (editor) {
      var popups = editor.ui.registry.getAll().popups;
      var dataset = map$1(popups, function (popup) {
        return createAutocompleter(popup).fold(function (err) {
          throw new Error(formatError(err));
        }, identity$1);
      });
      var triggerChars = stringArray(mapToArray(dataset, function (v) {
        return v.ch;
      }));
      var datasetValues = values(dataset);
      var lookupByChar = function (ch) {
        return filter$2(datasetValues, function (dv) {
          return dv.ch === ch;
        });
      };
      return {
        dataset: dataset,
        triggerChars: triggerChars,
        lookupByChar: lookupByChar
      };
    };

    var ItemResponse;
    (function (ItemResponse) {
      ItemResponse[ItemResponse['CLOSE_ON_EXECUTE'] = 0] = 'CLOSE_ON_EXECUTE';
      ItemResponse[ItemResponse['BUBBLE_TO_SANDBOX'] = 1] = 'BUBBLE_TO_SANDBOX';
    }(ItemResponse || (ItemResponse = {})));
    var ItemResponse$1 = ItemResponse;

    var navClass = 'tox-menu-nav__js';
    var selectableClass = 'tox-collection__item';
    var colorClass = 'tox-swatch';
    var presetClasses = {
      normal: navClass,
      color: colorClass
    };
    var tickedClass = 'tox-collection__item--enabled';
    var groupHeadingClass = 'tox-collection__group-heading';
    var iconClass = 'tox-collection__item-icon';
    var textClass = 'tox-collection__item-label';
    var accessoryClass = 'tox-collection__item-accessory';
    var caretClass = 'tox-collection__item-caret';
    var checkmarkClass = 'tox-collection__item-checkmark';
    var activeClass = 'tox-collection__item--active';
    var containerClass = 'tox-collection__item-container';
    var containerColumnClass = 'tox-collection__item-container--column';
    var containerRowClass = 'tox-collection__item-container--row';
    var containerAlignRightClass = 'tox-collection__item-container--align-right';
    var containerAlignLeftClass = 'tox-collection__item-container--align-left';
    var containerValignTopClass = 'tox-collection__item-container--valign-top';
    var containerValignMiddleClass = 'tox-collection__item-container--valign-middle';
    var containerValignBottomClass = 'tox-collection__item-container--valign-bottom';
    var classForPreset = function (presets) {
      return get$e(presetClasses, presets).getOr(navClass);
    };

    var forMenu = function (presets) {
      if (presets === 'color') {
        return 'tox-swatches';
      } else {
        return 'tox-menu';
      }
    };
    var classes = function (presets) {
      return {
        backgroundMenu: 'tox-background-menu',
        selectedMenu: 'tox-selected-menu',
        selectedItem: 'tox-collection__item--active',
        hasIcons: 'tox-menu--has-icons',
        menu: forMenu(presets),
        tieredMenu: 'tox-tiered-menu'
      };
    };

    var markers = function (presets) {
      var menuClasses = classes(presets);
      return {
        backgroundMenu: menuClasses.backgroundMenu,
        selectedMenu: menuClasses.selectedMenu,
        menu: menuClasses.menu,
        selectedItem: menuClasses.selectedItem,
        item: classForPreset(presets)
      };
    };
    var dom$1 = function (hasIcons, columns, presets) {
      var menuClasses = classes(presets);
      return {
        tag: 'div',
        classes: flatten([
          [
            menuClasses.menu,
            'tox-menu-' + columns + '-column'
          ],
          hasIcons ? [menuClasses.hasIcons] : []
        ])
      };
    };
    var components = [Menu.parts.items({})];
    var part = function (hasIcons, columns, presets) {
      var menuClasses = classes(presets);
      var d = {
        tag: 'div',
        classes: flatten([[menuClasses.tieredMenu]])
      };
      return {
        dom: d,
        markers: markers(presets)
      };
    };

    var chunk = function (rowDom, numColumns) {
      return function (items) {
        var chunks = chunk$1(items, numColumns);
        return map$2(chunks, function (c) {
          return {
            dom: rowDom,
            components: c
          };
        });
      };
    };
    var forSwatch = function (columns) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-menu',
            'tox-swatches-menu'
          ]
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-swatches']
            },
            components: [Menu.parts.items({
                preprocess: columns !== 'auto' ? chunk({
                  tag: 'div',
                  classes: ['tox-swatches__row']
                }, columns) : identity$1
              })]
          }]
      };
    };
    var forToolbar = function (columns) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-menu',
            'tox-collection',
            'tox-collection--toolbar',
            'tox-collection--toolbar-lg'
          ]
        },
        components: [Menu.parts.items({
            preprocess: chunk({
              tag: 'div',
              classes: ['tox-collection__group']
            }, columns)
          })]
      };
    };
    var preprocessCollection = function (items, isSeparator) {
      var allSplits = [];
      var currentSplit = [];
      each$1(items, function (item, i) {
        if (isSeparator(item, i)) {
          if (currentSplit.length > 0) {
            allSplits.push(currentSplit);
          }
          currentSplit = [];
          if (has$2(item.dom, 'innerHtml')) {
            currentSplit.push(item);
          }
        } else {
          currentSplit.push(item);
        }
      });
      if (currentSplit.length > 0) {
        allSplits.push(currentSplit);
      }
      return map$2(allSplits, function (s) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-collection__group']
          },
          components: s
        };
      });
    };
    var forCollection = function (columns, initItems, _hasIcons) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-menu',
            'tox-collection'
          ].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])
        },
        components: [Menu.parts.items({
            preprocess: function (items) {
              if (columns !== 'auto' && columns > 1) {
                return chunk({
                  tag: 'div',
                  classes: ['tox-collection__group']
                }, columns)(items);
              } else {
                return preprocessCollection(items, function (_item, i) {
                  return initItems[i].type === 'separator';
                });
              }
            }
          })]
      };
    };
    var forHorizontalCollection = function (initItems, _hasIcons) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-collection',
            'tox-collection--horizontal'
          ]
        },
        components: [Menu.parts.items({
            preprocess: function (items) {
              return preprocessCollection(items, function (_item, i) {
                return initItems[i].type === 'separator';
              });
            }
          })]
      };
    };

    var menuHasIcons = function (xs) {
      return exists(xs, function (item) {
        return 'icon' in item && item.icon !== undefined;
      });
    };
    var handleError = function (error) {
      console.error(formatError(error));
      console.log(error);
      return Optional.none();
    };
    var createHorizontalPartialMenuWithAlloyItems = function (value, _hasIcons, items, _columns, _presets) {
      var structure = forHorizontalCollection(items);
      return {
        value: value,
        dom: structure.dom,
        components: structure.components,
        items: items
      };
    };
    var createPartialMenuWithAlloyItems = function (value, hasIcons, items, columns, presets) {
      if (presets === 'color') {
        var structure = forSwatch(columns);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === 'normal' && columns === 'auto') {
        var structure = forCollection(columns, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === 'normal' && columns === 1) {
        var structure = forCollection(1, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === 'normal') {
        var structure = forCollection(columns, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === 'listpreview' && columns !== 'auto') {
        var structure = forToolbar(columns);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      return {
        value: value,
        dom: dom$1(hasIcons, columns, presets),
        components: components,
        items: items
      };
    };

    var cardImageFields = [
      requiredString('type'),
      requiredString('src'),
      optionString('alt'),
      defaultedArrayOf('classes', [], string)
    ];
    var cardImageSchema = objOf(cardImageFields);

    var cardTextFields = [
      requiredString('type'),
      requiredString('text'),
      optionString('name'),
      defaultedArrayOf('classes', ['tox-collection__item-label'], string)
    ];
    var cardTextSchema = objOf(cardTextFields);

    var itemSchema$1 = valueThunk(function () {
      return choose$2('type', {
        cardimage: cardImageSchema,
        cardtext: cardTextSchema,
        cardcontainer: cardContainerSchema
      });
    });
    var cardContainerSchema = objOf([
      requiredString('type'),
      defaultedString('direction', 'horizontal'),
      defaultedString('align', 'left'),
      defaultedString('valign', 'middle'),
      requiredArrayOf('items', itemSchema$1)
    ]);

    var commonMenuItemFields = [
      defaultedBoolean('disabled', false),
      optionString('text'),
      optionString('shortcut'),
      field$1('value', 'value', defaultedThunk(function () {
        return generate$6('menuitem-value');
      }), anyValue()),
      defaulted('meta', {})
    ];

    var cardMenuItemSchema = objOf([
      requiredString('type'),
      optionString('label'),
      requiredArrayOf('items', itemSchema$1),
      defaultedFunction('onSetup', function () {
        return noop;
      }),
      defaultedFunction('onAction', noop)
    ].concat(commonMenuItemFields));
    var createCardMenuItem = function (spec) {
      return asRaw('cardmenuitem', cardMenuItemSchema, spec);
    };

    var choiceMenuItemSchema = objOf([
      requiredString('type'),
      defaultedBoolean('active', false),
      optionString('icon')
    ].concat(commonMenuItemFields));
    var createChoiceMenuItem = function (spec) {
      return asRaw('choicemenuitem', choiceMenuItemSchema, spec);
    };

    var baseFields = [
      requiredString('type'),
      requiredString('fancytype'),
      defaultedFunction('onAction', noop)
    ];
    var insertTableFields = [defaulted('initData', {})].concat(baseFields);
    var colorSwatchFields = [defaultedObjOf('initData', {}, [
        defaultedBoolean('allowCustomColors', true),
        optionArrayOf('colors', anyValue())
      ])].concat(baseFields);
    var fancyMenuItemSchema = choose$1('fancytype', {
      inserttable: insertTableFields,
      colorswatch: colorSwatchFields
    });
    var createFancyMenuItem = function (spec) {
      return asRaw('fancymenuitem', fancyMenuItemSchema, spec);
    };

    var menuItemSchema = objOf([
      requiredString('type'),
      defaultedFunction('onSetup', function () {
        return noop;
      }),
      defaultedFunction('onAction', noop),
      optionString('icon')
    ].concat(commonMenuItemFields));
    var createMenuItem = function (spec) {
      return asRaw('menuitem', menuItemSchema, spec);
    };

    var nestedMenuItemSchema = objOf([
      requiredString('type'),
      requiredFunction('getSubmenuItems'),
      defaultedFunction('onSetup', function () {
        return noop;
      }),
      optionString('icon')
    ].concat(commonMenuItemFields));
    var createNestedMenuItem = function (spec) {
      return asRaw('nestedmenuitem', nestedMenuItemSchema, spec);
    };

    var toggleMenuItemSchema = objOf([
      requiredString('type'),
      optionString('icon'),
      defaultedBoolean('active', false),
      defaultedFunction('onSetup', function () {
        return noop;
      }),
      requiredFunction('onAction')
    ].concat(commonMenuItemFields));
    var createToggleMenuItem = function (spec) {
      return asRaw('togglemenuitem', toggleMenuItemSchema, spec);
    };

    var detectSize = function (comp, margin, selectorClass) {
      var descendants$1 = descendants(comp.element, '.' + selectorClass);
      if (descendants$1.length > 0) {
        var columnLength = findIndex$1(descendants$1, function (c) {
          var thisTop = c.dom.getBoundingClientRect().top;
          var cTop = descendants$1[0].dom.getBoundingClientRect().top;
          return Math.abs(thisTop - cTop) > margin;
        }).getOr(descendants$1.length);
        return Optional.some({
          numColumns: columnLength,
          numRows: Math.ceil(descendants$1.length / columnLength)
        });
      } else {
        return Optional.none();
      }
    };

    var namedEvents = function (name, handlers) {
      return derive$1([config(name, handlers)]);
    };
    var unnamedEvents = function (handlers) {
      return namedEvents(generate$6('unnamed-events'), handlers);
    };
    var SimpleBehaviours = {
      namedEvents: namedEvents,
      unnamedEvents: unnamedEvents
    };

    var ExclusivityChannel = generate$6('tooltip.exclusive');
    var ShowTooltipEvent = generate$6('tooltip.show');
    var HideTooltipEvent = generate$6('tooltip.hide');

    var hideAllExclusive = function (component, _tConfig, _tState) {
      component.getSystem().broadcastOn([ExclusivityChannel], {});
    };
    var setComponents = function (component, tConfig, tState, specs) {
      tState.getTooltip().each(function (tooltip) {
        if (tooltip.getSystem().isConnected()) {
          Replacing.set(tooltip, specs);
        }
      });
    };

    var TooltippingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hideAllExclusive: hideAllExclusive,
        setComponents: setComponents
    });

    var events$9 = function (tooltipConfig, state) {
      var hide = function (comp) {
        state.getTooltip().each(function (p) {
          detach(p);
          tooltipConfig.onHide(comp, p);
          state.clearTooltip();
        });
        state.clearTimer();
      };
      var show = function (comp) {
        if (!state.isShowing()) {
          hideAllExclusive(comp);
          var sink = tooltipConfig.lazySink(comp).getOrDie();
          var popup = comp.getSystem().build({
            dom: tooltipConfig.tooltipDom,
            components: tooltipConfig.tooltipComponents,
            events: derive$2(tooltipConfig.mode === 'normal' ? [
              run$1(mouseover(), function (_) {
                emit(comp, ShowTooltipEvent);
              }),
              run$1(mouseout(), function (_) {
                emit(comp, HideTooltipEvent);
              })
            ] : []),
            behaviours: derive$1([Replacing.config({})])
          });
          state.setTooltip(popup);
          attach(sink, popup);
          tooltipConfig.onShow(comp, popup);
          Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });
        }
      };
      return derive$2(flatten([
        [
          run$1(ShowTooltipEvent, function (comp) {
            state.resetTimer(function () {
              show(comp);
            }, tooltipConfig.delay);
          }),
          run$1(HideTooltipEvent, function (comp) {
            state.resetTimer(function () {
              hide(comp);
            }, tooltipConfig.delay);
          }),
          run$1(receive(), function (comp, message) {
            var receivingData = message;
            if (!receivingData.universal) {
              if (contains$2(receivingData.channels, ExclusivityChannel)) {
                hide(comp);
              }
            }
          }),
          runOnDetached(function (comp) {
            hide(comp);
          })
        ],
        tooltipConfig.mode === 'normal' ? [
          run$1(focusin(), function (comp) {
            emit(comp, ShowTooltipEvent);
          }),
          run$1(postBlur(), function (comp) {
            emit(comp, HideTooltipEvent);
          }),
          run$1(mouseover(), function (comp) {
            emit(comp, ShowTooltipEvent);
          }),
          run$1(mouseout(), function (comp) {
            emit(comp, HideTooltipEvent);
          })
        ] : [
          run$1(highlight$1(), function (comp, _se) {
            emit(comp, ShowTooltipEvent);
          }),
          run$1(dehighlight$1(), function (comp) {
            emit(comp, HideTooltipEvent);
          })
        ]
      ]));
    };

    var ActiveTooltipping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$9
    });

    var TooltippingSchema = [
      required$1('lazySink'),
      required$1('tooltipDom'),
      defaulted('exclusive', true),
      defaulted('tooltipComponents', []),
      defaulted('delay', 300),
      defaultedStringEnum('mode', 'normal', [
        'normal',
        'follow-highlight'
      ]),
      defaulted('anchor', function (comp) {
        return {
          type: 'hotspot',
          hotspot: comp,
          layouts: {
            onLtr: constant$1([
              south$2,
              north$2,
              southeast$2,
              northeast$2,
              southwest$2,
              northwest$2
            ]),
            onRtl: constant$1([
              south$2,
              north$2,
              southeast$2,
              northeast$2,
              southwest$2,
              northwest$2
            ])
          }
        };
      }),
      onHandler('onHide'),
      onHandler('onShow')
    ];

    var init$b = function () {
      var timer = value$1();
      var popup = value$1();
      var clearTimer = function () {
        timer.on(clearTimeout);
      };
      var resetTimer = function (f, delay) {
        clearTimer();
        timer.set(setTimeout(f, delay));
      };
      var readState = constant$1('not-implemented');
      return nu$8({
        getTooltip: popup.get,
        isShowing: popup.isSet,
        setTooltip: popup.set,
        clearTooltip: popup.clear,
        clearTimer: clearTimer,
        resetTimer: resetTimer,
        readState: readState
      });
    };

    var TooltippingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$b
    });

    var Tooltipping = create$7({
      fields: TooltippingSchema,
      name: 'tooltipping',
      active: ActiveTooltipping,
      state: TooltippingState,
      apis: TooltippingApis
    });

    var escape = function (text) {
      return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };

    var global$b = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$a = tinymce.util.Tools.resolve('tinymce.EditorManager');

    var getSkinUrl = function (editor) {
      var skin = editor.getParam('skin');
      var skinUrl = editor.getParam('skin_url');
      if (skin !== false) {
        var skinName = skin ? skin : 'oxide';
        if (skinUrl) {
          skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
        } else {
          skinUrl = global$a.baseURL + '/skins/ui/' + skinName;
        }
      }
      return skinUrl;
    };
    var isReadOnly = function (editor) {
      return editor.getParam('readonly', false, 'boolean');
    };
    var isSkinDisabled = function (editor) {
      return editor.getParam('skin') === false;
    };
    var getHeightSetting = function (editor) {
      return editor.getParam('height', Math.max(editor.getElement().offsetHeight, 200));
    };
    var getWidthSetting = function (editor) {
      return editor.getParam('width', global$b.DOM.getStyle(editor.getElement(), 'width'));
    };
    var getMinWidthSetting = function (editor) {
      return Optional.from(editor.getParam('min_width')).filter(isNumber);
    };
    var getMinHeightSetting = function (editor) {
      return Optional.from(editor.getParam('min_height')).filter(isNumber);
    };
    var getMaxWidthSetting = function (editor) {
      return Optional.from(editor.getParam('max_width')).filter(isNumber);
    };
    var getMaxHeightSetting = function (editor) {
      return Optional.from(editor.getParam('max_height')).filter(isNumber);
    };
    var getUserStyleFormats = function (editor) {
      return Optional.from(editor.getParam('style_formats')).filter(isArray);
    };
    var isMergeStyleFormats = function (editor) {
      return editor.getParam('style_formats_merge', false, 'boolean');
    };
    var getLineHeightFormats = function (editor) {
      return editor.getParam('lineheight_formats', '1 1.1 1.2 1.3 1.4 1.5 2', 'string').split(' ');
    };
    var getContentLanguages = function (editor) {
      return editor.getParam('content_langs', undefined, 'array');
    };
    var getRemovedMenuItems = function (editor) {
      return editor.getParam('removed_menuitems', '');
    };
    var isMenubarEnabled = function (editor) {
      return editor.getParam('menubar', true, 'boolean') !== false;
    };
    var isToolbarEnabled = function (editor) {
      var toolbar = editor.getParam('toolbar', true);
      var isToolbarTrue = toolbar === true;
      var isToolbarString = isString(toolbar);
      var isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;
      return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || isToolbarTrue);
    };
    var getMultipleToolbarsSetting = function (editor) {
      var toolbars = range$2(9, function (num) {
        return editor.getParam('toolbar' + (num + 1), false, 'string');
      });
      var toolbarArray = filter$2(toolbars, function (toolbar) {
        return typeof toolbar === 'string';
      });
      return toolbarArray.length > 0 ? Optional.some(toolbarArray) : Optional.none();
    };
    var isMultipleToolbars = function (editor) {
      return getMultipleToolbarsSetting(editor).fold(function () {
        var toolbar = editor.getParam('toolbar', [], 'string[]');
        return toolbar.length > 0;
      }, always);
    };
    var ToolbarMode;
    (function (ToolbarMode) {
      ToolbarMode['default'] = 'wrap';
      ToolbarMode['floating'] = 'floating';
      ToolbarMode['sliding'] = 'sliding';
      ToolbarMode['scrolling'] = 'scrolling';
    }(ToolbarMode || (ToolbarMode = {})));
    var getToolbarMode = function (editor) {
      return editor.getParam('toolbar_mode', '', 'string');
    };
    var ToolbarLocation;
    (function (ToolbarLocation) {
      ToolbarLocation['auto'] = 'auto';
      ToolbarLocation['top'] = 'top';
      ToolbarLocation['bottom'] = 'bottom';
    }(ToolbarLocation || (ToolbarLocation = {})));
    var getToolbarGroups = function (editor) {
      return editor.getParam('toolbar_groups', {}, 'object');
    };
    var getToolbarLocation = function (editor) {
      return editor.getParam('toolbar_location', ToolbarLocation.auto, 'string');
    };
    var isToolbarLocationBottom = function (editor) {
      return getToolbarLocation(editor) === ToolbarLocation.bottom;
    };
    var fixedContainerSelector = function (editor) {
      return editor.getParam('fixed_toolbar_container', '', 'string');
    };
    var fixedToolbarContainerTarget = function (editor) {
      return editor.getParam('fixed_toolbar_container_target');
    };
    var isToolbarPersist = function (editor) {
      return editor.getParam('toolbar_persist', false, 'boolean');
    };
    var fixedContainerTarget = function (editor) {
      if (!editor.inline) {
        return Optional.none();
      }
      var selector = fixedContainerSelector(editor);
      if (selector.length > 0) {
        return descendant(body(), selector);
      }
      var element = fixedToolbarContainerTarget(editor);
      if (isNonNullable(element)) {
        return Optional.some(SugarElement.fromDom(element));
      }
      return Optional.none();
    };
    var useFixedContainer = function (editor) {
      return editor.inline && fixedContainerTarget(editor).isSome();
    };
    var getUiContainer = function (editor) {
      var fixedContainer = fixedContainerTarget(editor);
      return fixedContainer.getOrThunk(function () {
        return getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement())));
      });
    };
    var isDistractionFree = function (editor) {
      return editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);
    };
    var isStickyToolbar = function (editor) {
      var isStickyToolbar = editor.getParam('toolbar_sticky', false, 'boolean');
      return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);
    };
    var getStickyToolbarOffset = function (editor) {
      return editor.getParam('toolbar_sticky_offset', 0, 'number');
    };
    var isDraggableModal$1 = function (editor) {
      return editor.getParam('draggable_modal', false, 'boolean');
    };
    var getMenus = function (editor) {
      var menu = editor.getParam('menu');
      if (menu) {
        return map$1(menu, function (menu) {
          return __assign(__assign({}, menu), { items: menu.items });
        });
      } else {
        return {};
      }
    };
    var getMenubar = function (editor) {
      return editor.getParam('menubar');
    };
    var getToolbar = function (editor) {
      return editor.getParam('toolbar', true);
    };
    var getFilePickerCallback = function (editor) {
      return editor.getParam('file_picker_callback');
    };
    var getFilePickerTypes = function (editor) {
      return editor.getParam('file_picker_types');
    };
    var getFileBrowserCallbackTypes = function (editor) {
      return editor.getParam('file_browser_callback_types');
    };
    var noTypeaheadUrls = function (editor) {
      return editor.getParam('typeahead_urls') === false;
    };
    var getAnchorTop = function (editor) {
      return editor.getParam('anchor_top', '#top');
    };
    var getAnchorBottom = function (editor) {
      return editor.getParam('anchor_bottom', '#bottom');
    };
    var getFilePickerValidatorHandler = function (editor) {
      var handler = editor.getParam('file_picker_validator_handler', undefined, 'function');
      if (handler === undefined) {
        return editor.getParam('filepicker_validator_handler', undefined, 'function');
      } else {
        return handler;
      }
    };

    var ReadOnlyChannel = 'silver.readonly';
    var ReadOnlyDataSchema = objOf([requiredBoolean('readonly')]);
    var broadcastReadonly = function (uiComponents, readonly) {
      var outerContainer = uiComponents.outerContainer;
      var target = outerContainer.element;
      if (readonly) {
        uiComponents.mothership.broadcastOn([dismissPopups()], { target: target });
        uiComponents.uiMothership.broadcastOn([dismissPopups()], { target: target });
      }
      uiComponents.mothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });
      uiComponents.uiMothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });
    };
    var setupReadonlyModeSwitch = function (editor, uiComponents) {
      editor.on('init', function () {
        if (editor.mode.isReadOnly()) {
          broadcastReadonly(uiComponents, true);
        }
      });
      editor.on('SwitchMode', function () {
        return broadcastReadonly(uiComponents, editor.mode.isReadOnly());
      });
      if (isReadOnly(editor)) {
        editor.setMode('readonly');
      }
    };
    var receivingConfig = function () {
      var _a;
      return Receiving.config({
        channels: (_a = {}, _a[ReadOnlyChannel] = {
          schema: ReadOnlyDataSchema,
          onReceive: function (comp, data) {
            Disabling.set(comp, data.readonly);
          }
        }, _a)
      });
    };

    var item = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: 'tox-collection__item--state-disabled'
      });
    };
    var button = function (disabled) {
      return Disabling.config({ disabled: disabled });
    };
    var splitButton = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: 'tox-tbtn--disabled'
      });
    };
    var toolbarButton = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: 'tox-tbtn--disabled',
        useNative: false
      });
    };
    var DisablingConfigs = {
      item: item,
      button: button,
      splitButton: splitButton,
      toolbarButton: toolbarButton
    };

    var runWithApi = function (info, comp) {
      var api = info.getApi(comp);
      return function (f) {
        f(api);
      };
    };
    var onControlAttached = function (info, editorOffCell) {
      return runOnAttached(function (comp) {
        var run = runWithApi(info, comp);
        run(function (api) {
          var onDestroy = info.onSetup(api);
          if (isFunction(onDestroy)) {
            editorOffCell.set(onDestroy);
          }
        });
      });
    };
    var onControlDetached = function (getApi, editorOffCell) {
      return runOnDetached(function (comp) {
        return runWithApi(getApi, comp)(editorOffCell.get());
      });
    };

    var _a$1;
    var onMenuItemExecute = function (info, itemResponse) {
      return runOnExecute$1(function (comp, simulatedEvent) {
        runWithApi(info, comp)(info.onAction);
        if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
          emit(comp, sandboxClose());
          simulatedEvent.stop();
        }
      });
    };
    var menuItemEventOrder = (_a$1 = {}, _a$1[execute$5()] = [
      'disabling',
      'alloy.base.behaviour',
      'toggling',
      'item-events'
    ], _a$1);

    var componentRenderPipeline = cat;
    var renderCommonItem = function (spec, structure, itemResponse, providersbackstage) {
      var editorOffCell = Cell(noop);
      return {
        type: 'item',
        dom: structure.dom,
        components: componentRenderPipeline(structure.optComponents),
        data: spec.data,
        eventOrder: menuItemEventOrder,
        hasSubmenu: spec.triggersSubmenu,
        itemBehaviours: derive$1([
          config('item-events', [
            onMenuItemExecute(spec, itemResponse),
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell)
          ]),
          DisablingConfigs.item(function () {
            return spec.disabled || providersbackstage.isDisabled();
          }),
          receivingConfig(),
          Replacing.config({})
        ].concat(spec.itemBehaviours))
      };
    };
    var buildData = function (source) {
      return {
        value: source.value,
        meta: __assign({ text: source.text.getOr('') }, source.meta)
      };
    };

    var global$9 = tinymce.util.Tools.resolve('tinymce.Env');

    var convertText = function (source) {
      var mac = {
        alt: '&#x2325;',
        ctrl: '&#x2303;',
        shift: '&#x21E7;',
        meta: '&#x2318;',
        access: '&#x2303;&#x2325;'
      };
      var other = {
        meta: 'Ctrl',
        access: 'Shift+Alt'
      };
      var replace = global$9.mac ? mac : other;
      var shortcut = source.split('+');
      var updated = map$2(shortcut, function (segment) {
        var search = segment.toLowerCase().trim();
        return has$2(replace, search) ? replace[search] : segment;
      });
      return global$9.mac ? updated.join('') : updated.join('+');
    };

    var renderIcon$1 = function (name, icons, classes) {
      if (classes === void 0) {
        classes = [iconClass];
      }
      return render$3(name, {
        tag: 'div',
        classes: classes
      }, icons);
    };
    var renderText = function (text$1) {
      return {
        dom: {
          tag: 'div',
          classes: [textClass]
        },
        components: [text(global$e.translate(text$1))]
      };
    };
    var renderHtml = function (html, classes) {
      return {
        dom: {
          tag: 'div',
          classes: classes,
          innerHtml: html
        }
      };
    };
    var renderStyledText = function (style, text$1) {
      return {
        dom: {
          tag: 'div',
          classes: [textClass]
        },
        components: [{
            dom: {
              tag: style.tag,
              styles: style.styles
            },
            components: [text(global$e.translate(text$1))]
          }]
      };
    };
    var renderShortcut = function (shortcut) {
      return {
        dom: {
          tag: 'div',
          classes: [accessoryClass],
          innerHtml: convertText(shortcut)
        }
      };
    };
    var renderCheckmark = function (icons) {
      return renderIcon$1('checkmark', icons, [checkmarkClass]);
    };
    var renderSubmenuCaret = function (icons) {
      return renderIcon$1('chevron-right', icons, [caretClass]);
    };
    var renderDownwardsCaret = function (icons) {
      return renderIcon$1('chevron-down', icons, [caretClass]);
    };
    var renderContainer = function (container, components) {
      var directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;
      var alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;
      var getValignClass = function () {
        switch (container.valign) {
        case 'top':
          return containerValignTopClass;
        case 'middle':
          return containerValignMiddleClass;
        case 'bottom':
          return containerValignBottomClass;
        }
      };
      return {
        dom: {
          tag: 'div',
          classes: [
            containerClass,
            directionClass,
            alignClass,
            getValignClass()
          ]
        },
        components: components
      };
    };
    var renderImage = function (src, classes, alt) {
      return {
        dom: {
          tag: 'img',
          classes: classes,
          attributes: {
            src: src,
            alt: alt.getOr('')
          }
        }
      };
    };

    var renderColorStructure = function (item, providerBackstage, fallbackIcon) {
      var colorPickerCommand = 'custom';
      var removeColorCommand = 'remove';
      var itemText = item.ariaLabel;
      var itemValue = item.value;
      var iconSvg = item.iconContent.map(function (name) {
        return getOr(name, providerBackstage.icons, fallbackIcon);
      });
      var getDom = function () {
        var common = colorClass;
        var icon = iconSvg.getOr('');
        var attributes = itemText.map(function (text) {
          return { title: providerBackstage.translate(text) };
        }).getOr({});
        var baseDom = {
          tag: 'div',
          attributes: attributes,
          classes: [common]
        };
        if (itemValue === colorPickerCommand) {
          return __assign(__assign({}, baseDom), {
            tag: 'button',
            classes: __spreadArray(__spreadArray([], baseDom.classes, true), ['tox-swatches__picker-btn'], false),
            innerHtml: icon
          });
        } else if (itemValue === removeColorCommand) {
          return __assign(__assign({}, baseDom), {
            classes: __spreadArray(__spreadArray([], baseDom.classes, true), ['tox-swatch--remove'], false),
            innerHtml: icon
          });
        } else {
          return __assign(__assign({}, baseDom), {
            attributes: __assign(__assign({}, baseDom.attributes), { 'data-mce-color': itemValue }),
            styles: { 'background-color': itemValue }
          });
        }
      };
      return {
        dom: getDom(),
        optComponents: []
      };
    };
    var renderItemDomStructure = function (ariaLabel) {
      var domTitle = ariaLabel.map(function (label) {
        return { attributes: { title: global$e.translate(label) } };
      }).getOr({});
      return __assign({
        tag: 'div',
        classes: [
          navClass,
          selectableClass
        ]
      }, domTitle);
    };
    var renderNormalItemStructure = function (info, providersBackstage, renderIcons, fallbackIcon) {
      var iconSpec = {
        tag: 'div',
        classes: [iconClass]
      };
      var renderIcon = function (iconName) {
        return render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);
      };
      var renderEmptyIcon = function () {
        return Optional.some({ dom: iconSpec });
      };
      var leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();
      var checkmark = info.checkMark;
      var textRender = Optional.from(info.meta).fold(function () {
        return renderText;
      }, function (meta) {
        return has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText;
      });
      var content = info.htmlContent.fold(function () {
        return info.textContent.map(textRender);
      }, function (html) {
        return Optional.some(renderHtml(html, [textClass]));
      });
      var menuItem = {
        dom: renderItemDomStructure(info.ariaLabel),
        optComponents: [
          leftIcon,
          content,
          info.shortcutContent.map(renderShortcut),
          checkmark,
          info.caret
        ]
      };
      return menuItem;
    };
    var renderItemStructure = function (info, providersBackstage, renderIcons, fallbackIcon) {
      if (fallbackIcon === void 0) {
        fallbackIcon = Optional.none();
      }
      if (info.presets === 'color') {
        return renderColorStructure(info, providersBackstage, fallbackIcon);
      } else {
        return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);
      }
    };

    var tooltipBehaviour = function (meta, sharedBackstage) {
      return get$e(meta, 'tooltipWorker').map(function (tooltipWorker) {
        return [Tooltipping.config({
            lazySink: sharedBackstage.getSink,
            tooltipDom: {
              tag: 'div',
              classes: ['tox-tooltip-worker-container']
            },
            tooltipComponents: [],
            anchor: function (comp) {
              return {
                type: 'submenu',
                item: comp,
                overrides: { maxHeightFunction: expandable$1 }
              };
            },
            mode: 'follow-highlight',
            onShow: function (component, _tooltip) {
              tooltipWorker(function (elm) {
                Tooltipping.setComponents(component, [external$2({ element: SugarElement.fromDom(elm) })]);
              });
            }
          })];
      }).getOr([]);
    };
    var encodeText = function (text) {
      return global$b.DOM.encode(text);
    };
    var replaceText = function (text, matchText) {
      var translated = global$e.translate(text);
      var encoded = encodeText(translated);
      if (matchText.length > 0) {
        var escapedMatchRegex = new RegExp(escape(matchText), 'gi');
        return encoded.replace(escapedMatchRegex, function (match) {
          return '<span class="tox-autocompleter-highlight">' + match + '</span>';
        });
      } else {
        return encoded;
      }
    };
    var renderAutocompleteItem = function (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var structure = renderItemStructure({
        presets: presets,
        textContent: Optional.none(),
        htmlContent: useText ? spec.text.map(function (text) {
          return replaceText(text, matchText);
        }) : Optional.none(),
        ariaLabel: spec.text,
        iconContent: spec.icon,
        shortcutContent: Optional.none(),
        checkMark: Optional.none(),
        caret: Optional.none(),
        value: spec.value
      }, sharedBackstage.providers, renderIcons, spec.icon);
      return renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: constant$1({}),
        onAction: function (_api) {
          return onItemValueHandler(spec.value, spec.meta);
        },
        onSetup: constant$1(noop),
        triggersSubmenu: false,
        itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)
      }, structure, itemResponse, sharedBackstage.providers);
    };

    var render$2 = function (items, extras) {
      return map$2(items, function (item) {
        switch (item.type) {
        case 'cardcontainer':
          return renderContainer(item, render$2(item.items, extras));
        case 'cardimage':
          return renderImage(item.src, item.classes, item.alt);
        case 'cardtext':
          var shouldHighlight = item.name.exists(function (name) {
            return contains$2(extras.cardText.highlightOn, name);
          });
          var matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';
          return renderHtml(replaceText(item.text, matchText), item.classes);
        }
      });
    };
    var renderCardMenuItem = function (spec, itemResponse, sharedBackstage, extras) {
      var getApi = function (component) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            Disabling.set(component, state);
            each$1(descendants(component.element, '*'), function (elm) {
              component.getSystem().getByDom(elm).each(function (comp) {
                if (comp.hasConfigured(Disabling)) {
                  Disabling.set(comp, state);
                }
              });
            });
          }
        };
      };
      var structure = {
        dom: renderItemDomStructure(spec.label),
        optComponents: [Optional.some({
            dom: {
              tag: 'div',
              classes: [
                containerClass,
                containerRowClass
              ]
            },
            components: render$2(spec.items, extras)
          })]
      };
      return renderCommonItem({
        data: buildData(__assign({ text: Optional.none() }, spec)),
        disabled: spec.disabled,
        getApi: getApi,
        onAction: spec.onAction,
        onSetup: spec.onSetup,
        triggersSubmenu: false,
        itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])
      }, structure, itemResponse, sharedBackstage.providers);
    };

    var renderChoiceItem = function (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          setActive: function (state) {
            Toggling.set(component, state);
          },
          isActive: function () {
            return Toggling.isOn(component);
          },
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: presets,
        textContent: useText ? spec.text : Optional.none(),
        htmlContent: Optional.none(),
        ariaLabel: spec.text,
        iconContent: spec.icon,
        shortcutContent: useText ? spec.shortcut : Optional.none(),
        checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),
        caret: Optional.none(),
        value: spec.value
      }, providersBackstage, renderIcons);
      return deepMerge(renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: getApi,
        onAction: function (_api) {
          return onItemValueHandler(spec.value);
        },
        onSetup: function (api) {
          api.setActive(isSelected);
          return noop;
        },
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage), {
        toggling: {
          toggleClass: tickedClass,
          toggleOnExecute: false,
          selected: spec.active
        }
      });
    };

    var parts$f = generate$3(owner$2(), parts$h());

    var hexColour = function (value) {
      return { value: value };
    };
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    var longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var isHexString = function (hex) {
      return shorthandRegex.test(hex) || longformRegex.test(hex);
    };
    var normalizeHex = function (hex) {
      return removeLeading(hex, '#').toUpperCase();
    };
    var fromString$1 = function (hex) {
      return isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
    };
    var getLongForm = function (hex) {
      var hexString = hex.value.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      return { value: hexString };
    };
    var extractValues = function (hex) {
      var longForm = getLongForm(hex);
      var splitForm = longformRegex.exec(longForm.value);
      return splitForm === null ? [
        'FFFFFF',
        'FF',
        'FF',
        'FF'
      ] : splitForm;
    };
    var toHex = function (component) {
      var hex = component.toString(16);
      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    var fromRgba = function (rgbaColour) {
      var value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
      return hexColour(value);
    };

    var min = Math.min;
    var max = Math.max;
    var round$1 = Math.round;
    var rgbRegex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
    var rgbaRegex = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/;
    var rgbaColour = function (red, green, blue, alpha) {
      return {
        red: red,
        green: green,
        blue: blue,
        alpha: alpha
      };
    };
    var isRgbaComponent = function (value) {
      var num = parseInt(value, 10);
      return num.toString() === value && num >= 0 && num <= 255;
    };
    var fromHsv = function (hsv) {
      var r;
      var g;
      var b;
      var hue = (hsv.hue || 0) % 360;
      var saturation = hsv.saturation / 100;
      var brightness = hsv.value / 100;
      saturation = max(0, min(saturation, 1));
      brightness = max(0, min(brightness, 1));
      if (saturation === 0) {
        r = g = b = round$1(255 * brightness);
        return rgbaColour(r, g, b, 1);
      }
      var side = hue / 60;
      var chroma = brightness * saturation;
      var x = chroma * (1 - Math.abs(side % 2 - 1));
      var match = brightness - chroma;
      switch (Math.floor(side)) {
      case 0:
        r = chroma;
        g = x;
        b = 0;
        break;
      case 1:
        r = x;
        g = chroma;
        b = 0;
        break;
      case 2:
        r = 0;
        g = chroma;
        b = x;
        break;
      case 3:
        r = 0;
        g = x;
        b = chroma;
        break;
      case 4:
        r = x;
        g = 0;
        b = chroma;
        break;
      case 5:
        r = chroma;
        g = 0;
        b = x;
        break;
      default:
        r = g = b = 0;
      }
      r = round$1(255 * (r + match));
      g = round$1(255 * (g + match));
      b = round$1(255 * (b + match));
      return rgbaColour(r, g, b, 1);
    };
    var fromHex = function (hexColour) {
      var result = extractValues(hexColour);
      var red = parseInt(result[1], 16);
      var green = parseInt(result[2], 16);
      var blue = parseInt(result[3], 16);
      return rgbaColour(red, green, blue, 1);
    };
    var fromStringValues = function (red, green, blue, alpha) {
      var r = parseInt(red, 10);
      var g = parseInt(green, 10);
      var b = parseInt(blue, 10);
      var a = parseFloat(alpha);
      return rgbaColour(r, g, b, a);
    };
    var fromString = function (rgbaString) {
      if (rgbaString === 'transparent') {
        return Optional.some(rgbaColour(0, 0, 0, 0));
      }
      var rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
      }
      var rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Optional.none();
    };
    var toString = function (rgba) {
      return 'rgba(' + rgba.red + ',' + rgba.green + ',' + rgba.blue + ',' + rgba.alpha + ')';
    };
    var red = rgbaColour(255, 0, 0, 1);

    var fireSkinLoaded$1 = function (editor) {
      return editor.fire('SkinLoaded');
    };
    var fireSkinLoadError$1 = function (editor, error) {
      return editor.fire('SkinLoadError', error);
    };
    var fireResizeEditor = function (editor) {
      return editor.fire('ResizeEditor');
    };
    var fireResizeContent = function (editor, e) {
      return editor.fire('ResizeContent', e);
    };
    var fireScrollContent = function (editor, e) {
      return editor.fire('ScrollContent', e);
    };
    var fireTextColorChange = function (editor, data) {
      return editor.fire('TextColorChange', data);
    };

    var hsvColour = function (hue, saturation, value) {
      return {
        hue: hue,
        saturation: saturation,
        value: value
      };
    };
    var fromRgb = function (rgbaColour) {
      var h = 0;
      var s = 0;
      var v = 0;
      var r = rgbaColour.red / 255;
      var g = rgbaColour.green / 255;
      var b = rgbaColour.blue / 255;
      var minRGB = Math.min(r, Math.min(g, b));
      var maxRGB = Math.max(r, Math.max(g, b));
      if (minRGB === maxRGB) {
        v = minRGB;
        return hsvColour(0, 0, v * 100);
      }
      var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
      h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
      h = 60 * (h - d / (maxRGB - minRGB));
      s = (maxRGB - minRGB) / maxRGB;
      v = maxRGB;
      return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
    };

    var hexToHsv = function (hex) {
      return fromRgb(fromHex(hex));
    };
    var hsvToHex = function (hsv) {
      return fromRgba(fromHsv(hsv));
    };
    var anyToHex = function (color) {
      return fromString$1(color).orThunk(function () {
        return fromString(color).map(fromRgba);
      }).getOrThunk(function () {
        var canvas = document.createElement('canvas');
        canvas.height = 1;
        canvas.width = 1;
        var canvasContext = canvas.getContext('2d');
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        canvasContext.fillStyle = '#FFFFFF';
        canvasContext.fillStyle = color;
        canvasContext.fillRect(0, 0, 1, 1);
        var rgba = canvasContext.getImageData(0, 0, 1, 1).data;
        var r = rgba[0];
        var g = rgba[1];
        var b = rgba[2];
        var a = rgba[3];
        return fromRgba(rgbaColour(r, g, b, a));
      });
    };

    var global$8 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');

    var storageName = 'tinymce-custom-colors';
    function ColorCache (max) {
      if (max === void 0) {
        max = 10;
      }
      var storageString = global$8.getItem(storageName);
      var localstorage = isString(storageString) ? JSON.parse(storageString) : [];
      var prune = function (list) {
        var diff = max - list.length;
        return diff < 0 ? list.slice(0, max) : list;
      };
      var cache = prune(localstorage);
      var add = function (key) {
        indexOf(cache, key).each(remove);
        cache.unshift(key);
        if (cache.length > max) {
          cache.pop();
        }
        global$8.setItem(storageName, JSON.stringify(cache));
      };
      var remove = function (idx) {
        cache.splice(idx, 1);
      };
      var state = function () {
        return cache.slice(0);
      };
      return {
        add: add,
        state: state
      };
    }

    var choiceItem = 'choiceitem';
    var defaultColors = [
      {
        type: choiceItem,
        text: 'Light Green',
        value: '#BFEDD2'
      },
      {
        type: choiceItem,
        text: 'Light Yellow',
        value: '#FBEEB8'
      },
      {
        type: choiceItem,
        text: 'Light Red',
        value: '#F8CAC6'
      },
      {
        type: choiceItem,
        text: 'Light Purple',
        value: '#ECCAFA'
      },
      {
        type: choiceItem,
        text: 'Light Blue',
        value: '#C2E0F4'
      },
      {
        type: choiceItem,
        text: 'Green',
        value: '#2DC26B'
      },
      {
        type: choiceItem,
        text: 'Yellow',
        value: '#F1C40F'
      },
      {
        type: choiceItem,
        text: 'Red',
        value: '#E03E2D'
      },
      {
        type: choiceItem,
        text: 'Purple',
        value: '#B96AD9'
      },
      {
        type: choiceItem,
        text: 'Blue',
        value: '#3598DB'
      },
      {
        type: choiceItem,
        text: 'Dark Turquoise',
        value: '#169179'
      },
      {
        type: choiceItem,
        text: 'Orange',
        value: '#E67E23'
      },
      {
        type: choiceItem,
        text: 'Dark Red',
        value: '#BA372A'
      },
      {
        type: choiceItem,
        text: 'Dark Purple',
        value: '#843FA1'
      },
      {
        type: choiceItem,
        text: 'Dark Blue',
        value: '#236FA1'
      },
      {
        type: choiceItem,
        text: 'Light Gray',
        value: '#ECF0F1'
      },
      {
        type: choiceItem,
        text: 'Medium Gray',
        value: '#CED4D9'
      },
      {
        type: choiceItem,
        text: 'Gray',
        value: '#95A5A6'
      },
      {
        type: choiceItem,
        text: 'Dark Gray',
        value: '#7E8C8D'
      },
      {
        type: choiceItem,
        text: 'Navy Blue',
        value: '#34495E'
      },
      {
        type: choiceItem,
        text: 'Black',
        value: '#000000'
      },
      {
        type: choiceItem,
        text: 'White',
        value: '#ffffff'
      }
    ];
    var colorCache = ColorCache(10);
    var mapColors = function (colorMap) {
      var colors = [];
      for (var i = 0; i < colorMap.length; i += 2) {
        colors.push({
          text: colorMap[i + 1],
          value: '#' + anyToHex(colorMap[i]).value,
          type: 'choiceitem'
        });
      }
      return colors;
    };
    var getColorCols$2 = function (editor, defaultCols) {
      return editor.getParam('color_cols', defaultCols, 'number');
    };
    var hasCustomColors$1 = function (editor) {
      return editor.getParam('custom_colors') !== false;
    };
    var getColorMap = function (editor) {
      return editor.getParam('color_map');
    };
    var getColors$2 = function (editor) {
      var unmapped = getColorMap(editor);
      return unmapped !== undefined ? mapColors(unmapped) : defaultColors;
    };
    var getCurrentColors = function () {
      return map$2(colorCache.state(), function (color) {
        return {
          type: choiceItem,
          text: color,
          value: color
        };
      });
    };
    var addColor = function (color) {
      colorCache.add(color);
    };

    var fallbackColor = '#000000';
    var getCurrentColor = function (editor, format) {
      var color;
      editor.dom.getParents(editor.selection.getStart(), function (elm) {
        var value;
        if (value = elm.style[format === 'forecolor' ? 'color' : 'background-color']) {
          color = color ? color : value;
        }
      });
      return Optional.from(color);
    };
    var applyFormat = function (editor, format, value) {
      editor.undoManager.transact(function () {
        editor.focus();
        editor.formatter.apply(format, { value: value });
        editor.nodeChanged();
      });
    };
    var removeFormat = function (editor, format) {
      editor.undoManager.transact(function () {
        editor.focus();
        editor.formatter.remove(format, { value: null }, null, true);
        editor.nodeChanged();
      });
    };
    var registerCommands = function (editor) {
      editor.addCommand('mceApplyTextcolor', function (format, value) {
        applyFormat(editor, format, value);
      });
      editor.addCommand('mceRemoveTextcolor', function (format) {
        removeFormat(editor, format);
      });
    };
    var calcCols = function (colors) {
      return Math.max(5, Math.ceil(Math.sqrt(colors)));
    };
    var getColorCols$1 = function (editor) {
      var colors = getColors$2(editor);
      var defaultCols = calcCols(colors.length);
      return getColorCols$2(editor, defaultCols);
    };
    var getAdditionalColors = function (hasCustom) {
      var type = 'choiceitem';
      var remove = {
        type: type,
        text: 'Remove color',
        icon: 'color-swatch-remove-color',
        value: 'remove'
      };
      var custom = {
        type: type,
        text: 'Custom color',
        icon: 'color-picker',
        value: 'custom'
      };
      return hasCustom ? [
        remove,
        custom
      ] : [remove];
    };
    var applyColor = function (editor, format, value, onChoice) {
      if (value === 'custom') {
        var dialog = colorPickerDialog(editor);
        dialog(function (colorOpt) {
          colorOpt.each(function (color) {
            addColor(color);
            editor.execCommand('mceApplyTextcolor', format, color);
            onChoice(color);
          });
        }, fallbackColor);
      } else if (value === 'remove') {
        onChoice('');
        editor.execCommand('mceRemoveTextcolor', format);
      } else {
        onChoice(value);
        editor.execCommand('mceApplyTextcolor', format, value);
      }
    };
    var getColors$1 = function (colors, hasCustom) {
      return colors.concat(getCurrentColors().concat(getAdditionalColors(hasCustom)));
    };
    var getFetch$1 = function (colors, hasCustom) {
      return function (callback) {
        callback(getColors$1(colors, hasCustom));
      };
    };
    var setIconColor = function (splitButtonApi, name, newColor) {
      var id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';
      splitButtonApi.setIconFill(id, newColor);
    };
    var registerTextColorButton = function (editor, name, format, tooltip, lastColor) {
      editor.ui.registry.addSplitButton(name, {
        tooltip: tooltip,
        presets: 'color',
        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
        select: function (value) {
          var optCurrentRgb = getCurrentColor(editor, format);
          return optCurrentRgb.bind(function (currentRgb) {
            return fromString(currentRgb).map(function (rgba) {
              var currentHex = fromRgba(rgba).value;
              return contains$1(value.toLowerCase(), currentHex);
            });
          }).getOr(false);
        },
        columns: getColorCols$1(editor),
        fetch: getFetch$1(getColors$2(editor), hasCustomColors$1(editor)),
        onAction: function (_splitButtonApi) {
          applyColor(editor, format, lastColor.get(), noop);
        },
        onItemAction: function (_splitButtonApi, value) {
          applyColor(editor, format, value, function (newColor) {
            lastColor.set(newColor);
            fireTextColorChange(editor, {
              name: name,
              color: newColor
            });
          });
        },
        onSetup: function (splitButtonApi) {
          setIconColor(splitButtonApi, name, lastColor.get());
          var handler = function (e) {
            if (e.name === name) {
              setIconColor(splitButtonApi, e.name, e.color);
            }
          };
          editor.on('TextColorChange', handler);
          return function () {
            editor.off('TextColorChange', handler);
          };
        }
      });
    };
    var registerTextColorMenuItem = function (editor, name, format, text) {
      editor.ui.registry.addNestedMenuItem(name, {
        text: text,
        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',
        getSubmenuItems: function () {
          return [{
              type: 'fancymenuitem',
              fancytype: 'colorswatch',
              onAction: function (data) {
                applyColor(editor, format, data.value, noop);
              }
            }];
        }
      });
    };
    var colorPickerDialog = function (editor) {
      return function (callback, value) {
        var isValid = false;
        var onSubmit = function (api) {
          var data = api.getData();
          var hex = data.colorpicker;
          if (isValid) {
            callback(Optional.from(hex));
            api.close();
          } else {
            editor.windowManager.alert(editor.translate([
              'Invalid hex color code: {0}',
              hex
            ]));
          }
        };
        var onAction = function (_api, details) {
          if (details.name === 'hex-valid') {
            isValid = details.value;
          }
        };
        var initialData = { colorpicker: value };
        editor.windowManager.open({
          title: 'Color Picker',
          size: 'normal',
          body: {
            type: 'panel',
            items: [{
                type: 'colorpicker',
                name: 'colorpicker',
                label: 'Color'
              }]
          },
          buttons: [
            {
              type: 'cancel',
              name: 'cancel',
              text: 'Cancel'
            },
            {
              type: 'submit',
              name: 'save',
              text: 'Save',
              primary: true
            }
          ],
          initialData: initialData,
          onAction: onAction,
          onSubmit: onSubmit,
          onClose: noop,
          onCancel: function () {
            callback(Optional.none());
          }
        });
      };
    };
    var register$a = function (editor) {
      registerCommands(editor);
      var lastForeColor = Cell(fallbackColor);
      var lastBackColor = Cell(fallbackColor);
      registerTextColorButton(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);
      registerTextColorButton(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);
      registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color');
      registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color');
    };

    var createPartialChoiceMenu = function (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) {
      var hasIcons = menuHasIcons(items);
      var presetItemTypes = presets !== 'color' ? 'normal' : 'color';
      var alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);
      return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, presets);
    };
    var createChoiceItems = function (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) {
      return cat(map$2(items, function (item) {
        if (item.type === 'choiceitem') {
          return createChoiceMenuItem(item).fold(handleError, function (d) {
            return Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(item.value), itemResponse, providersBackstage, menuHasIcons(items)));
          });
        } else {
          return Optional.none();
        }
      }));
    };

    var deriveMenuMovement = function (columns, presets) {
      var menuMarkers = markers(presets);
      if (columns === 1) {
        return {
          mode: 'menu',
          moveOnTab: true
        };
      } else if (columns === 'auto') {
        return {
          mode: 'grid',
          selector: '.' + menuMarkers.item,
          initSize: {
            numColumns: 1,
            numRows: 1
          }
        };
      } else {
        var rowClass = presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';
        return {
          mode: 'matrix',
          rowSelector: '.' + rowClass
        };
      }
    };
    var deriveCollectionMovement = function (columns, presets) {
      if (columns === 1) {
        return {
          mode: 'menu',
          moveOnTab: false,
          selector: '.tox-collection__item'
        };
      } else if (columns === 'auto') {
        return {
          mode: 'flatgrid',
          selector: '.' + 'tox-collection__item',
          initSize: {
            numColumns: 1,
            numRows: 1
          }
        };
      } else {
        return {
          mode: 'matrix',
          selectors: {
            row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',
            cell: presets === 'color' ? '.' + colorClass : '.' + selectableClass
          }
        };
      }
    };

    var renderColorSwatchItem = function (spec, backstage) {
      var items = getColorItems(spec, backstage);
      var columns = backstage.colorinput.getColorCols();
      var presets = 'color';
      var menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {
        spec.onAction({ value: value });
      }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, backstage.shared.providers);
      var widgetSpec = __assign(__assign({}, menuSpec), {
        markers: markers(presets),
        movement: deriveMenuMovement(columns, presets)
      });
      return {
        type: 'widget',
        data: { value: generate$6('widget-id') },
        dom: {
          tag: 'div',
          classes: ['tox-fancymenuitem']
        },
        autofocus: true,
        components: [parts$f.widget(Menu.sketch(widgetSpec))]
      };
    };
    var getColorItems = function (spec, backstage) {
      var useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();
      return spec.initData.colors.fold(function () {
        return getColors$1(backstage.colorinput.getColors(), useCustomColors);
      }, function (colors) {
        return colors.concat(getAdditionalColors(useCustomColors));
      });
    };

    var cellOverEvent = generate$6('cell-over');
    var cellExecuteEvent = generate$6('cell-execute');
    var makeCell = function (row, col, labelId) {
      var _a;
      var emitCellOver = function (c) {
        return emitWith(c, cellOverEvent, {
          row: row,
          col: col
        });
      };
      var emitExecute = function (c) {
        return emitWith(c, cellExecuteEvent, {
          row: row,
          col: col
        });
      };
      var onClick = function (c, se) {
        se.stop();
        emitExecute(c);
      };
      return build$1({
        dom: {
          tag: 'div',
          attributes: (_a = { role: 'button' }, _a['aria-labelledby'] = labelId, _a)
        },
        behaviours: derive$1([
          config('insert-table-picker-cell', [
            run$1(mouseover(), Focusing.focus),
            run$1(execute$5(), emitExecute),
            run$1(click(), onClick),
            run$1(tap(), onClick)
          ]),
          Toggling.config({
            toggleClass: 'tox-insert-table-picker__selected',
            toggleOnExecute: false
          }),
          Focusing.config({ onFocus: emitCellOver })
        ])
      });
    };
    var makeCells = function (labelId, numRows, numCols) {
      var cells = [];
      for (var i = 0; i < numRows; i++) {
        var row = [];
        for (var j = 0; j < numCols; j++) {
          row.push(makeCell(i, j, labelId));
        }
        cells.push(row);
      }
      return cells;
    };
    var selectCells = function (cells, selectedRow, selectedColumn, numRows, numColumns) {
      for (var i = 0; i < numRows; i++) {
        for (var j = 0; j < numColumns; j++) {
          Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);
        }
      }
    };
    var makeComponents = function (cells) {
      return bind$3(cells, function (cellRow) {
        return map$2(cellRow, premade);
      });
    };
    var makeLabelText = function (row, col) {
      return text(col + 'x' + row);
    };
    var renderInsertTableMenuItem = function (spec) {
      var numRows = 10;
      var numColumns = 10;
      var sizeLabelId = generate$6('size-label');
      var cells = makeCells(sizeLabelId, numRows, numColumns);
      var emptyLabelText = makeLabelText(0, 0);
      var memLabel = record({
        dom: {
          tag: 'span',
          classes: ['tox-insert-table-picker__label'],
          attributes: { id: sizeLabelId }
        },
        components: [emptyLabelText],
        behaviours: derive$1([Replacing.config({})])
      });
      return {
        type: 'widget',
        data: { value: generate$6('widget-id') },
        dom: {
          tag: 'div',
          classes: ['tox-fancymenuitem']
        },
        autofocus: true,
        components: [parts$f.widget({
            dom: {
              tag: 'div',
              classes: ['tox-insert-table-picker']
            },
            components: makeComponents(cells).concat(memLabel.asSpec()),
            behaviours: derive$1([
              config('insert-table-picker', [
                runOnAttached(function (c) {
                  Replacing.set(memLabel.get(c), [emptyLabelText]);
                }),
                runWithTarget(cellOverEvent, function (c, t, e) {
                  var _a = e.event, row = _a.row, col = _a.col;
                  selectCells(cells, row, col, numRows, numColumns);
                  Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);
                }),
                runWithTarget(cellExecuteEvent, function (c, _, e) {
                  var _a = e.event, row = _a.row, col = _a.col;
                  spec.onAction({
                    numRows: row + 1,
                    numColumns: col + 1
                  });
                  emit(c, sandboxClose());
                })
              ]),
              Keying.config({
                initSize: {
                  numRows: numRows,
                  numColumns: numColumns
                },
                mode: 'flatgrid',
                selector: '[role="button"]'
              })
            ])
          })]
      };
    };

    var fancyMenuItems = {
      inserttable: renderInsertTableMenuItem,
      colorswatch: renderColorSwatchItem
    };
    var renderFancyMenuItem = function (spec, backstage) {
      return get$e(fancyMenuItems, spec.fancytype).map(function (render) {
        return render(spec, backstage);
      });
    };

    var renderNestedItem = function (spec, itemResponse, providersBackstage, renderIcons, downwardsCaret) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      if (downwardsCaret === void 0) {
        downwardsCaret = false;
      }
      var caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
      var getApi = function (component) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: 'normal',
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Optional.none(),
        ariaLabel: spec.text,
        caret: Optional.some(caret),
        checkMark: Optional.none(),
        shortcutContent: spec.shortcut
      }, providersBackstage, renderIcons);
      return renderCommonItem({
        data: buildData(spec),
        getApi: getApi,
        disabled: spec.disabled,
        onAction: noop,
        onSetup: spec.onSetup,
        triggersSubmenu: true,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage);
    };

    var renderNormalItem = function (spec, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: 'normal',
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Optional.none(),
        ariaLabel: spec.text,
        caret: Optional.none(),
        checkMark: Optional.none(),
        shortcutContent: spec.shortcut
      }, providersBackstage, renderIcons);
      return renderCommonItem({
        data: buildData(spec),
        getApi: getApi,
        disabled: spec.disabled,
        onAction: spec.onAction,
        onSetup: spec.onSetup,
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage);
    };

    var renderSeparatorItem = function (spec) {
      var innerHtml = spec.text.fold(function () {
        return {};
      }, function (text) {
        return { innerHtml: text };
      });
      return {
        type: 'separator',
        dom: __assign({
          tag: 'div',
          classes: [
            selectableClass,
            groupHeadingClass
          ]
        }, innerHtml),
        components: []
      };
    };

    var renderToggleMenuItem = function (spec, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          setActive: function (state) {
            Toggling.set(component, state);
          },
          isActive: function () {
            return Toggling.isOn(component);
          },
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Optional.none(),
        ariaLabel: spec.text,
        checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
        caret: Optional.none(),
        shortcutContent: spec.shortcut,
        presets: 'normal',
        meta: spec.meta
      }, providersBackstage, renderIcons);
      return deepMerge(renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: getApi,
        onAction: spec.onAction,
        onSetup: spec.onSetup,
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage), {
        toggling: {
          toggleClass: tickedClass,
          toggleOnExecute: false,
          selected: spec.active
        }
      });
    };

    var autocomplete = renderAutocompleteItem;
    var separator$3 = renderSeparatorItem;
    var normal = renderNormalItem;
    var nested = renderNestedItem;
    var toggle$1 = renderToggleMenuItem;
    var fancy = renderFancyMenuItem;
    var card = renderCardMenuItem;

    var FocusMode;
    (function (FocusMode) {
      FocusMode[FocusMode['ContentFocus'] = 0] = 'ContentFocus';
      FocusMode[FocusMode['UiFocus'] = 1] = 'UiFocus';
    }(FocusMode || (FocusMode = {})));
    var createMenuItemFromBridge = function (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) {
      var providersBackstage = backstage.shared.providers;
      var parseForHorizontalMenu = function (menuitem) {
        return !isHorizontalMenu ? menuitem : __assign(__assign({}, menuitem), {
          shortcut: Optional.none(),
          icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon
        });
      };
      switch (item.type) {
      case 'menuitem':
        return createMenuItem(item).fold(handleError, function (d) {
          return Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));
        });
      case 'nestedmenuitem':
        return createNestedMenuItem(item).fold(handleError, function (d) {
          return Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu));
        });
      case 'togglemenuitem':
        return createToggleMenuItem(item).fold(handleError, function (d) {
          return Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));
        });
      case 'separator':
        return createSeparatorMenuItem(item).fold(handleError, function (d) {
          return Optional.some(separator$3(d));
        });
      case 'fancymenuitem':
        return createFancyMenuItem(item).fold(handleError, function (d) {
          return fancy(parseForHorizontalMenu(d), backstage);
        });
      default: {
          console.error('Unknown item in general menu', item);
          return Optional.none();
        }
      }
    };
    var createAutocompleteItems = function (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) {
      var renderText = columns === 1;
      var renderIcons = !renderText || menuHasIcons(items);
      return cat(map$2(items, function (item) {
        switch (item.type) {
        case 'separator':
          return createSeparatorItem(item).fold(handleError, function (d) {
            return Optional.some(separator$3(d));
          });
        case 'cardmenuitem':
          return createCardMenuItem(item).fold(handleError, function (d) {
            return Optional.some(card(__assign(__assign({}, d), {
              onAction: function (api) {
                d.onAction(api);
                onItemValueHandler(d.value, d.meta);
              }
            }), itemResponse, sharedBackstage, {
              itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),
              cardText: {
                matchText: matchText,
                highlightOn: highlightOn
              }
            }));
          });
        case 'autocompleteitem':
        default:
          return createAutocompleterItem(item).fold(handleError, function (d) {
            return Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons));
          });
        }
      }));
    };
    var createPartialMenu = function (value, items, itemResponse, backstage, isHorizontalMenu) {
      var hasIcons = menuHasIcons(items);
      var alloyItems = cat(map$2(items, function (item) {
        var itemHasIcon = function (i) {
          return isHorizontalMenu ? !has$2(i, 'text') : hasIcons;
        };
        var createItem = function (i) {
          return createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);
        };
        if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) {
          return createItem(__assign(__assign({}, item), { disabled: true }));
        } else {
          return createItem(item);
        }
      }));
      var createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;
      return createPartial(value, hasIcons, alloyItems, 1, 'normal');
    };
    var createTieredDataFrom = function (partialMenu) {
      return tieredMenu.singleData(partialMenu.value, partialMenu);
    };
    var createMenuFrom = function (partialMenu, columns, focusMode, presets) {
      var focusManager = focusMode === FocusMode.ContentFocus ? highlights() : dom$2();
      var movement = deriveMenuMovement(columns, presets);
      var menuMarkers = markers(presets);
      return {
        dom: partialMenu.dom,
        components: partialMenu.components,
        items: partialMenu.items,
        value: partialMenu.value,
        markers: {
          selectedItem: menuMarkers.selectedItem,
          item: menuMarkers.item
        },
        movement: movement,
        fakeFocus: focusMode === FocusMode.ContentFocus,
        focusManager: focusManager,
        menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {
            detectSize(comp, 4, menuMarkers.item).each(function (_a) {
              var numColumns = _a.numColumns, numRows = _a.numRows;
              Keying.setGridSize(comp, numRows, numColumns);
            });
          })])
      };
    };

    var register$9 = function (editor, sharedBackstage) {
      var activeAutocompleter = value$1();
      var processingAction = Cell(false);
      var autocompleter = build$1(InlineView.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-autocompleter']
        },
        components: [],
        fireDismissalEventInstead: {},
        inlineBehaviours: derive$1([config('dismissAutocompleter', [run$1(dismissRequested(), function () {
              return cancelIfNecessary();
            })])]),
        lazySink: sharedBackstage.getSink
      }));
      var isMenuOpen = function () {
        return InlineView.isOpen(autocompleter);
      };
      var isActive = function () {
        return activeAutocompleter.get().isSome();
      };
      var hideIfNecessary = function () {
        if (isActive()) {
          InlineView.hide(autocompleter);
        }
      };
      var cancelIfNecessary = function () {
        if (isActive()) {
          var lastElement = activeAutocompleter.get().map(function (ac) {
            return ac.element;
          });
          detect(lastElement.getOr(SugarElement.fromDom(editor.selection.getNode()))).each(unwrap);
          hideIfNecessary();
          activeAutocompleter.clear();
          processingAction.set(false);
        }
      };
      var getAutocompleters = cached(function () {
        return register$b(editor);
      });
      var getCombinedItems = function (triggerChar, matches) {
        var columns = findMap(matches, function (m) {
          return Optional.from(m.columns);
        }).getOr(1);
        return bind$3(matches, function (match) {
          var choices = match.items;
          return createAutocompleteItems(choices, match.matchText, function (itemValue, itemMeta) {
            var nr = editor.selection.getRng();
            getContext(editor.dom, nr, triggerChar).fold(function () {
              return console.error('Lost context. Cursor probably moved');
            }, function (_a) {
              var range = _a.range;
              var autocompleterApi = {
                hide: function () {
                  cancelIfNecessary();
                },
                reload: function (fetchOptions) {
                  hideIfNecessary();
                  load(fetchOptions);
                }
              };
              processingAction.set(true);
              match.onAction(autocompleterApi, range, itemValue, itemMeta);
              processingAction.set(false);
            });
          }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);
        });
      };
      var commenceIfNecessary = function (context) {
        if (!isActive()) {
          var wrapper = create$4(editor, context.range);
          activeAutocompleter.set({
            triggerChar: context.triggerChar,
            element: wrapper,
            matchLength: context.text.length
          });
          processingAction.set(false);
        }
      };
      var display = function (ac, context, lookupData, items) {
        ac.matchLength = context.text.length;
        var columns = findMap(lookupData, function (ld) {
          return Optional.from(ld.columns);
        }).getOr(1);
        InlineView.showAt(autocompleter, Menu.sketch(createMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, 'normal'), columns, FocusMode.ContentFocus, 'normal')), {
          anchor: {
            type: 'node',
            root: SugarElement.fromDom(editor.getBody()),
            node: Optional.from(ac.element)
          }
        });
        InlineView.getContent(autocompleter).each(Highlighting.highlightFirst);
      };
      var doLookup = function (fetchOptions) {
        return activeAutocompleter.get().map(function (ac) {
          return getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(function (newContext) {
            return lookupWithContext(editor, getAutocompleters, newContext, fetchOptions);
          });
        }).getOrThunk(function () {
          return lookup$2(editor, getAutocompleters);
        });
      };
      var load = function (fetchOptions) {
        doLookup(fetchOptions).fold(cancelIfNecessary, function (lookupInfo) {
          commenceIfNecessary(lookupInfo.context);
          lookupInfo.lookupData.then(function (lookupData) {
            activeAutocompleter.get().map(function (ac) {
              var context = lookupInfo.context;
              if (ac.triggerChar === context.triggerChar) {
                var combinedItems = getCombinedItems(context.triggerChar, lookupData);
                if (combinedItems.length > 0) {
                  display(ac, context, lookupData, combinedItems);
                } else if (context.text.length - ac.matchLength >= 10) {
                  cancelIfNecessary();
                } else {
                  hideIfNecessary();
                }
              }
            });
          });
        });
      };
      var onKeypress = last(function (e) {
        if (e.which === 27) {
          return;
        }
        load();
      }, 50);
      var autocompleterUiApi = {
        onKeypress: onKeypress,
        cancelIfNecessary: cancelIfNecessary,
        isMenuOpen: isMenuOpen,
        isActive: isActive,
        isProcessingAction: processingAction.get,
        getView: function () {
          return InlineView.getContent(autocompleter);
        }
      };
      if (editor.hasPlugin('rtc') === false) {
        AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
      }
    };
    var Autocompleter = { register: register$9 };

    var closest = function (scope, selector, isRoot) {
      return closest$1(scope, selector, isRoot).isSome();
    };

    var DelayedFunction = function (fun, delay) {
      var ref = null;
      var schedule = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        ref = setTimeout(function () {
          fun.apply(null, args);
          ref = null;
        }, delay);
      };
      var cancel = function () {
        if (ref !== null) {
          clearTimeout(ref);
          ref = null;
        }
      };
      return {
        cancel: cancel,
        schedule: schedule
      };
    };

    var SIGNIFICANT_MOVE = 5;
    var LONGPRESS_DELAY = 400;
    var getTouch = function (event) {
      var raw = event.raw;
      if (raw.touches === undefined || raw.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(raw.touches[0]);
    };
    var isFarEnough = function (touch, data) {
      var distX = Math.abs(touch.clientX - data.x);
      var distY = Math.abs(touch.clientY - data.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    var monitor = function (settings) {
      var startData = value$1();
      var longpressFired = Cell(false);
      var longpress$1 = DelayedFunction(function (event) {
        settings.triggerEvent(longpress(), event);
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      var handleTouchstart = function (event) {
        getTouch(event).each(function (touch) {
          longpress$1.cancel();
          var data = {
            x: touch.clientX,
            y: touch.clientY,
            target: event.target
          };
          longpress$1.schedule(event);
          longpressFired.set(false);
          startData.set(data);
        });
        return Optional.none();
      };
      var handleTouchmove = function (event) {
        longpress$1.cancel();
        getTouch(event).each(function (touch) {
          startData.on(function (data) {
            if (isFarEnough(touch, data)) {
              startData.clear();
            }
          });
        });
        return Optional.none();
      };
      var handleTouchend = function (event) {
        longpress$1.cancel();
        var isSame = function (data) {
          return eq(data.target, event.target);
        };
        return startData.get().filter(isSame).map(function (_data) {
          if (longpressFired.get()) {
            event.prevent();
            return false;
          } else {
            return settings.triggerEvent(tap(), event);
          }
        });
      };
      var handlers = wrapAll([
        {
          key: touchstart(),
          value: handleTouchstart
        },
        {
          key: touchmove(),
          value: handleTouchmove
        },
        {
          key: touchend(),
          value: handleTouchend
        }
      ]);
      var fireIfReady = function (event, type) {
        return get$e(handlers, type).bind(function (handler) {
          return handler(event);
        });
      };
      return { fireIfReady: fireIfReady };
    };

    var isDangerous = function (event) {
      var keyEv = event.raw;
      return keyEv.which === BACKSPACE[0] && !contains$2([
        'input',
        'textarea'
      ], name$2(event.target)) && !closest(event.target, '[contenteditable="true"]');
    };
    var isFirefox = function () {
      return detect$1().browser.isFirefox();
    };
    var bindFocus = function (container, handler) {
      if (isFirefox()) {
        return capture(container, 'focus', handler);
      } else {
        return bind(container, 'focusin', handler);
      }
    };
    var bindBlur = function (container, handler) {
      if (isFirefox()) {
        return capture(container, 'blur', handler);
      } else {
        return bind(container, 'focusout', handler);
      }
    };
    var setup$d = function (container, rawSettings) {
      var settings = __assign({ stopBackspace: true }, rawSettings);
      var pointerEvents = [
        'touchstart',
        'touchmove',
        'touchend',
        'touchcancel',
        'gesturestart',
        'mousedown',
        'mouseup',
        'mouseover',
        'mousemove',
        'mouseout',
        'click'
      ];
      var tapEvent = monitor(settings);
      var simpleEvents = map$2(pointerEvents.concat([
        'selectstart',
        'input',
        'contextmenu',
        'change',
        'transitionend',
        'transitioncancel',
        'drag',
        'dragstart',
        'dragend',
        'dragenter',
        'dragleave',
        'dragover',
        'drop',
        'keyup'
      ]), function (type) {
        return bind(container, type, function (event) {
          tapEvent.fireIfReady(event, type).each(function (tapStopped) {
            if (tapStopped) {
              event.kill();
            }
          });
          var stopped = settings.triggerEvent(type, event);
          if (stopped) {
            event.kill();
          }
        });
      });
      var pasteTimeout = value$1();
      var onPaste = bind(container, 'paste', function (event) {
        tapEvent.fireIfReady(event, 'paste').each(function (tapStopped) {
          if (tapStopped) {
            event.kill();
          }
        });
        var stopped = settings.triggerEvent('paste', event);
        if (stopped) {
          event.kill();
        }
        pasteTimeout.set(setTimeout(function () {
          settings.triggerEvent(postPaste(), event);
        }, 0));
      });
      var onKeydown = bind(container, 'keydown', function (event) {
        var stopped = settings.triggerEvent('keydown', event);
        if (stopped) {
          event.kill();
        } else if (settings.stopBackspace && isDangerous(event)) {
          event.prevent();
        }
      });
      var onFocusIn = bindFocus(container, function (event) {
        var stopped = settings.triggerEvent('focusin', event);
        if (stopped) {
          event.kill();
        }
      });
      var focusoutTimeout = value$1();
      var onFocusOut = bindBlur(container, function (event) {
        var stopped = settings.triggerEvent('focusout', event);
        if (stopped) {
          event.kill();
        }
        focusoutTimeout.set(setTimeout(function () {
          settings.triggerEvent(postBlur(), event);
        }, 0));
      });
      var unbind = function () {
        each$1(simpleEvents, function (e) {
          e.unbind();
        });
        onKeydown.unbind();
        onFocusIn.unbind();
        onFocusOut.unbind();
        onPaste.unbind();
        pasteTimeout.on(clearTimeout);
        focusoutTimeout.on(clearTimeout);
      };
      return { unbind: unbind };
    };

    var derive = function (rawEvent, rawTarget) {
      var source = get$e(rawEvent, 'target').getOr(rawTarget);
      return Cell(source);
    };

    var fromSource = function (event, source) {
      var stopper = Cell(false);
      var cutter = Cell(false);
      var stop = function () {
        stopper.set(true);
      };
      var cut = function () {
        cutter.set(true);
      };
      return {
        stop: stop,
        cut: cut,
        isStopped: stopper.get,
        isCut: cutter.get,
        event: event,
        setSource: source.set,
        getSource: source.get
      };
    };
    var fromExternal = function (event) {
      var stopper = Cell(false);
      var stop = function () {
        stopper.set(true);
      };
      return {
        stop: stop,
        cut: noop,
        isStopped: stopper.get,
        isCut: never,
        event: event,
        setSource: die('Cannot set source of a broadcasted event'),
        getSource: die('Cannot get source of a broadcasted event')
      };
    };

    var adt$1 = Adt.generate([
      { stopped: [] },
      { resume: ['element'] },
      { complete: [] }
    ]);
    var doTriggerHandler = function (lookup, eventType, rawEvent, target, source, logger) {
      var handler = lookup(eventType, target);
      var simulatedEvent = fromSource(rawEvent, source);
      return handler.fold(function () {
        logger.logEventNoHandlers(eventType, target);
        return adt$1.complete();
      }, function (handlerInfo) {
        var descHandler = handlerInfo.descHandler;
        var eventHandler = getCurried(descHandler);
        eventHandler(simulatedEvent);
        if (simulatedEvent.isStopped()) {
          logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
          return adt$1.stopped();
        } else if (simulatedEvent.isCut()) {
          logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
          return adt$1.complete();
        } else {
          return parent(handlerInfo.element).fold(function () {
            logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
            return adt$1.complete();
          }, function (parent) {
            logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
            return adt$1.resume(parent);
          });
        }
      });
    };
    var doTriggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, source, logger) {
      return doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(always, function (parent) {
        return doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger);
      }, never);
    };
    var triggerHandler = function (lookup, eventType, rawEvent, target, logger) {
      var source = derive(rawEvent, target);
      return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
    };
    var broadcast = function (listeners, rawEvent, _logger) {
      var simulatedEvent = fromExternal(rawEvent);
      each$1(listeners, function (listener) {
        var descHandler = listener.descHandler;
        var handler = getCurried(descHandler);
        handler(simulatedEvent);
      });
      return simulatedEvent.isStopped();
    };
    var triggerUntilStopped = function (lookup, eventType, rawEvent, logger) {
      return triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);
    };
    var triggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, logger) {
      var source = derive(rawEvent, rawTarget);
      return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
    };

    var eventHandler = function (element, descHandler) {
      return {
        element: element,
        descHandler: descHandler
      };
    };
    var broadcastHandler = function (id, handler) {
      return {
        id: id,
        descHandler: handler
      };
    };
    var EventRegistry = function () {
      var registry = {};
      var registerId = function (extraArgs, id, events) {
        each(events, function (v, k) {
          var handlers = registry[k] !== undefined ? registry[k] : {};
          handlers[id] = curryArgs(v, extraArgs);
          registry[k] = handlers;
        });
      };
      var findHandler = function (handlers, elem) {
        return read$1(elem).bind(function (id) {
          return get$e(handlers, id);
        }).map(function (descHandler) {
          return eventHandler(elem, descHandler);
        });
      };
      var filterByType = function (type) {
        return get$e(registry, type).map(function (handlers) {
          return mapToArray(handlers, function (f, id) {
            return broadcastHandler(id, f);
          });
        }).getOr([]);
      };
      var find = function (isAboveRoot, type, target) {
        return get$e(registry, type).bind(function (handlers) {
          return closest$4(target, function (elem) {
            return findHandler(handlers, elem);
          }, isAboveRoot);
        });
      };
      var unregisterId = function (id) {
        each(registry, function (handlersById, _eventName) {
          if (has$2(handlersById, id)) {
            delete handlersById[id];
          }
        });
      };
      return {
        registerId: registerId,
        unregisterId: unregisterId,
        filterByType: filterByType,
        find: find
      };
    };

    var Registry = function () {
      var events = EventRegistry();
      var components = {};
      var readOrTag = function (component) {
        var elem = component.element;
        return read$1(elem).getOrThunk(function () {
          return write('uid-', component.element);
        });
      };
      var failOnDuplicate = function (component, tagId) {
        var conflict = components[tagId];
        if (conflict === component) {
          unregister(component);
        } else {
          throw new Error('The tagId "' + tagId + '" is already used by: ' + element(conflict.element) + '\nCannot use it for: ' + element(component.element) + '\n' + 'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');
        }
      };
      var register = function (component) {
        var tagId = readOrTag(component);
        if (hasNonNullableKey(components, tagId)) {
          failOnDuplicate(component, tagId);
        }
        var extraArgs = [component];
        events.registerId(extraArgs, tagId, component.events);
        components[tagId] = component;
      };
      var unregister = function (component) {
        read$1(component.element).each(function (tagId) {
          delete components[tagId];
          events.unregisterId(tagId);
        });
      };
      var filter = function (type) {
        return events.filterByType(type);
      };
      var find = function (isAboveRoot, type, target) {
        return events.find(isAboveRoot, type, target);
      };
      var getById = function (id) {
        return get$e(components, id);
      };
      return {
        find: find,
        filter: filter,
        register: register,
        unregister: unregister,
        getById: getById
      };
    };

    var factory$j = function (detail) {
      var _a = detail.dom, attributes = _a.attributes, domWithoutAttributes = __rest(_a, ['attributes']);
      return {
        uid: detail.uid,
        dom: __assign({
          tag: 'div',
          attributes: __assign({ role: 'presentation' }, attributes)
        }, domWithoutAttributes),
        components: detail.components,
        behaviours: get$2(detail.containerBehaviours),
        events: detail.events,
        domModification: detail.domModification,
        eventOrder: detail.eventOrder
      };
    };
    var Container = single({
      name: 'Container',
      factory: factory$j,
      configFields: [
        defaulted('components', []),
        field('containerBehaviours', []),
        defaulted('events', {}),
        defaulted('domModification', {}),
        defaulted('eventOrder', {})
      ]
    });

    var takeover = function (root) {
      var isAboveRoot = function (el) {
        return parent(root.element).fold(always, function (parent) {
          return eq(el, parent);
        });
      };
      var registry = Registry();
      var lookup = function (eventName, target) {
        return registry.find(isAboveRoot, eventName, target);
      };
      var domEvents = setup$d(root.element, {
        triggerEvent: function (eventName, event) {
          return monitorEvent(eventName, event.target, function (logger) {
            return triggerUntilStopped(lookup, eventName, event, logger);
          });
        }
      });
      var systemApi = {
        debugInfo: constant$1('real'),
        triggerEvent: function (eventName, target, data) {
          monitorEvent(eventName, target, function (logger) {
            return triggerOnUntilStopped(lookup, eventName, data, target, logger);
          });
        },
        triggerFocus: function (target, originator) {
          read$1(target).fold(function () {
            focus$3(target);
          }, function (_alloyId) {
            monitorEvent(focus$4(), target, function (logger) {
              triggerHandler(lookup, focus$4(), {
                originator: originator,
                kill: noop,
                prevent: noop,
                target: target
              }, target, logger);
              return false;
            });
          });
        },
        triggerEscape: function (comp, simulatedEvent) {
          systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);
        },
        getByUid: function (uid) {
          return getByUid(uid);
        },
        getByDom: function (elem) {
          return getByDom(elem);
        },
        build: build$1,
        addToGui: function (c) {
          add(c);
        },
        removeFromGui: function (c) {
          remove(c);
        },
        addToWorld: function (c) {
          addToWorld(c);
        },
        removeFromWorld: function (c) {
          removeFromWorld(c);
        },
        broadcast: function (message) {
          broadcast$1(message);
        },
        broadcastOn: function (channels, message) {
          broadcastOn(channels, message);
        },
        broadcastEvent: function (eventName, event) {
          broadcastEvent(eventName, event);
        },
        isConnected: always
      };
      var addToWorld = function (component) {
        component.connect(systemApi);
        if (!isText$1(component.element)) {
          registry.register(component);
          each$1(component.components(), addToWorld);
          systemApi.triggerEvent(systemInit(), component.element, { target: component.element });
        }
      };
      var removeFromWorld = function (component) {
        if (!isText$1(component.element)) {
          each$1(component.components(), removeFromWorld);
          registry.unregister(component);
        }
        component.disconnect();
      };
      var add = function (component) {
        attach(root, component);
      };
      var remove = function (component) {
        detach(component);
      };
      var destroy = function () {
        domEvents.unbind();
        remove$5(root.element);
      };
      var broadcastData = function (data) {
        var receivers = registry.filter(receive());
        each$1(receivers, function (receiver) {
          var descHandler = receiver.descHandler;
          var handler = getCurried(descHandler);
          handler(data);
        });
      };
      var broadcast$1 = function (message) {
        broadcastData({
          universal: true,
          data: message
        });
      };
      var broadcastOn = function (channels, message) {
        broadcastData({
          universal: false,
          channels: channels,
          data: message
        });
      };
      var broadcastEvent = function (eventName, event) {
        var listeners = registry.filter(eventName);
        return broadcast(listeners, event);
      };
      var getByUid = function (uid) {
        return registry.getById(uid).fold(function () {
          return Result.error(new Error('Could not find component with uid: "' + uid + '" in system.'));
        }, Result.value);
      };
      var getByDom = function (elem) {
        var uid = read$1(elem).getOr('not found');
        return getByUid(uid);
      };
      addToWorld(root);
      return {
        root: root,
        element: root.element,
        destroy: destroy,
        add: add,
        remove: remove,
        getByUid: getByUid,
        getByDom: getByDom,
        addToWorld: addToWorld,
        removeFromWorld: removeFromWorld,
        broadcast: broadcast$1,
        broadcastOn: broadcastOn,
        broadcastEvent: broadcastEvent
      };
    };

    var renderBar = function (spec, backstage) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-bar',
            'tox-form__controls-h-stack'
          ]
        },
        components: map$2(spec.items, backstage.interpreter)
      };
    };

    var schema$l = constant$1([
      defaulted('prefix', 'form-field'),
      field('fieldBehaviours', [
        Composing,
        Representing
      ])
    ]);
    var parts$e = constant$1([
      optional({
        schema: [required$1('dom')],
        name: 'label'
      }),
      optional({
        factory: {
          sketch: function (spec) {
            return {
              uid: spec.uid,
              dom: {
                tag: 'span',
                styles: { display: 'none' },
                attributes: { 'aria-hidden': 'true' },
                innerHtml: spec.text
              }
            };
          }
        },
        schema: [required$1('text')],
        name: 'aria-descriptor'
      }),
      required({
        factory: {
          sketch: function (spec) {
            var excludeFactory = exclude(spec, ['factory']);
            return spec.factory.sketch(excludeFactory);
          }
        },
        schema: [required$1('factory')],
        name: 'field'
      })
    ]);

    var factory$i = function (detail, components, _spec, _externals) {
      var behaviours = augment(detail.fieldBehaviours, [
        Composing.config({
          find: function (container) {
            return getPart(container, detail, 'field');
          }
        }),
        Representing.config({
          store: {
            mode: 'manual',
            getValue: function (field) {
              return Composing.getCurrent(field).bind(Representing.getValue);
            },
            setValue: function (field, value) {
              Composing.getCurrent(field).each(function (current) {
                Representing.setValue(current, value);
              });
            }
          }
        })
      ]);
      var events = derive$2([runOnAttached(function (component, _simulatedEvent) {
          var ps = getParts(component, detail, [
            'label',
            'field',
            'aria-descriptor'
          ]);
          ps.field().each(function (field) {
            var id = generate$6(detail.prefix);
            ps.label().each(function (label) {
              set$8(label.element, 'for', id);
              set$8(field.element, 'id', id);
            });
            ps['aria-descriptor']().each(function (descriptor) {
              var descriptorId = generate$6(detail.prefix);
              set$8(descriptor.element, 'id', descriptorId);
              set$8(field.element, 'aria-describedby', descriptorId);
            });
          });
        })]);
      var apis = {
        getField: function (container) {
          return getPart(container, detail, 'field');
        },
        getLabel: function (container) {
          return getPart(container, detail, 'label');
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: behaviours,
        events: events,
        apis: apis
      };
    };
    var FormField = composite({
      name: 'FormField',
      configFields: schema$l(),
      partFields: parts$e(),
      factory: factory$i,
      apis: {
        getField: function (apis, comp) {
          return apis.getField(comp);
        },
        getLabel: function (apis, comp) {
          return apis.getLabel(comp);
        }
      }
    });

    var exhibit$2 = function (base, tabConfig) {
      return nu$7({
        attributes: wrapAll([{
            key: tabConfig.tabAttr,
            value: 'true'
          }])
      });
    };

    var ActiveTabstopping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$2
    });

    var TabstopSchema = [defaulted('tabAttr', 'data-alloy-tabstop')];

    var Tabstopping = create$7({
      fields: TabstopSchema,
      name: 'tabstopping',
      active: ActiveTabstopping
    });

    var global$7 = tinymce.util.Tools.resolve('tinymce.html.Entities');

    var renderFormFieldWith = function (pLabel, pField, extraClasses, extraBehaviours) {
      var spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
      return FormField.sketch(spec);
    };
    var renderFormField = function (pLabel, pField) {
      return renderFormFieldWith(pLabel, pField, [], []);
    };
    var renderFormFieldSpecWith = function (pLabel, pField, extraClasses, extraBehaviours) {
      return {
        dom: renderFormFieldDomWith(extraClasses),
        components: pLabel.toArray().concat([pField]),
        fieldBehaviours: derive$1(extraBehaviours)
      };
    };
    var renderFormFieldDom = function () {
      return renderFormFieldDomWith([]);
    };
    var renderFormFieldDomWith = function (extraClasses) {
      return {
        tag: 'div',
        classes: ['tox-form__group'].concat(extraClasses)
      };
    };
    var renderLabel$2 = function (label, providersBackstage) {
      return FormField.parts.label({
        dom: {
          tag: 'label',
          classes: ['tox-label'],
          innerHtml: providersBackstage.translate(label)
        }
      });
    };

    var formChangeEvent = generate$6('form-component-change');
    var formCloseEvent = generate$6('form-close');
    var formCancelEvent = generate$6('form-cancel');
    var formActionEvent = generate$6('form-action');
    var formSubmitEvent = generate$6('form-submit');
    var formBlockEvent = generate$6('form-block');
    var formUnblockEvent = generate$6('form-unblock');
    var formTabChangeEvent = generate$6('form-tabchange');
    var formResizeEvent = generate$6('form-resize');

    var renderCollection = function (spec, providersBackstage) {
      var _a;
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var runOnItem = function (f) {
        return function (comp, se) {
          closest$1(se.event.target, '[data-collection-item-value]').each(function (target) {
            f(comp, se, target, get$d(target, 'data-collection-item-value'));
          });
        };
      };
      var setContents = function (comp, items) {
        var htmlLines = map$2(items, function (item) {
          var itemText = global$e.translate(item.text);
          var textContent = spec.columns === 1 ? '<div class="tox-collection__item-label">' + itemText + '</div>' : '';
          var iconContent = '<div class="tox-collection__item-icon">' + item.icon + '</div>';
          var mapItemName = {
            '_': ' ',
            ' - ': ' ',
            '-': ' '
          };
          var ariaLabel = itemText.replace(/\_| \- |\-/g, function (match) {
            return mapItemName[match];
          });
          var disabledClass = providersBackstage.isDisabled() ? ' tox-collection__item--state-disabled' : '';
          return '<div class="tox-collection__item' + disabledClass + '" tabindex="-1" data-collection-item-value="' + global$7.encodeAllRaw(item.value) + '" title="' + ariaLabel + '" aria-label="' + ariaLabel + '">' + iconContent + textContent + '</div>';
        });
        var chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];
        var html = map$2(chunks, function (ch) {
          return '<div class="tox-collection__group">' + ch.join('') + '</div>';
        });
        set$5(comp.element, html.join(''));
      };
      var onClick = runOnItem(function (comp, se, tgt, itemValue) {
        se.stop();
        if (!providersBackstage.isDisabled()) {
          emitWith(comp, formActionEvent, {
            name: spec.name,
            value: itemValue
          });
        }
      });
      var collectionEvents = [
        run$1(mouseover(), runOnItem(function (comp, se, tgt) {
          focus$3(tgt);
        })),
        run$1(click(), onClick),
        run$1(tap(), onClick),
        run$1(focusin(), runOnItem(function (comp, se, tgt) {
          descendant(comp.element, '.' + activeClass).each(function (currentActive) {
            remove$2(currentActive, activeClass);
          });
          add$2(tgt, activeClass);
        })),
        run$1(focusout(), runOnItem(function (comp) {
          descendant(comp.element, '.' + activeClass).each(function (currentActive) {
            remove$2(currentActive, activeClass);
          });
        })),
        runOnExecute$1(runOnItem(function (comp, se, tgt, itemValue) {
          emitWith(comp, formActionEvent, {
            name: spec.name,
            value: itemValue
          });
        }))
      ];
      var iterCollectionItems = function (comp, applyAttributes) {
        return map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes);
      };
      var pField = FormField.parts.field({
        dom: {
          tag: 'div',
          classes: ['tox-collection'].concat(spec.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list'])
        },
        components: [],
        factory: { sketch: identity$1 },
        behaviours: derive$1([
          Disabling.config({
            disabled: providersBackstage.isDisabled,
            onDisabled: function (comp) {
              iterCollectionItems(comp, function (childElm) {
                add$2(childElm, 'tox-collection__item--state-disabled');
                set$8(childElm, 'aria-disabled', true);
              });
            },
            onEnabled: function (comp) {
              iterCollectionItems(comp, function (childElm) {
                remove$2(childElm, 'tox-collection__item--state-disabled');
                remove$7(childElm, 'aria-disabled');
              });
            }
          }),
          receivingConfig(),
          Replacing.config({}),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: []
            },
            onSetValue: function (comp, items) {
              setContents(comp, items);
              if (spec.columns === 'auto') {
                detectSize(comp, 5, 'tox-collection__item').each(function (_a) {
                  var numRows = _a.numRows, numColumns = _a.numColumns;
                  Keying.setGridSize(comp, numRows, numColumns);
                });
              }
              emit(comp, formResizeEvent);
            }
          }),
          Tabstopping.config({}),
          Keying.config(deriveCollectionMovement(spec.columns, 'normal')),
          config('collection-events', collectionEvents)
        ]),
        eventOrder: (_a = {}, _a[execute$5()] = [
          'disabling',
          'alloy.base.behaviour',
          'collection-events'
        ], _a)
      });
      var extraClasses = ['tox-form__group--collection'];
      return renderFormFieldWith(pLabel, pField, extraClasses, []);
    };

    var schema$k = constant$1([
      option('data'),
      defaulted('inputAttributes', {}),
      defaulted('inputStyles', {}),
      defaulted('tag', 'input'),
      defaulted('inputClasses', []),
      onHandler('onSetValue'),
      defaulted('styles', {}),
      defaulted('eventOrder', {}),
      field('inputBehaviours', [
        Representing,
        Focusing
      ]),
      defaulted('selectOnFocus', true)
    ]);
    var focusBehaviours = function (detail) {
      return derive$1([Focusing.config({
          onFocus: !detail.selectOnFocus ? noop : function (component) {
            var input = component.element;
            var value = get$5(input);
            input.dom.setSelectionRange(0, value.length);
          }
        })]);
    };
    var behaviours = function (detail) {
      return __assign(__assign({}, focusBehaviours(detail)), augment(detail.inputBehaviours, [Representing.config({
          store: __assign(__assign({ mode: 'manual' }, detail.data.map(function (data) {
            return { initialValue: data };
          }).getOr({})), {
            getValue: function (input) {
              return get$5(input.element);
            },
            setValue: function (input, data) {
              var current = get$5(input.element);
              if (current !== data) {
                set$4(input.element, data);
              }
            }
          }),
          onSetValue: detail.onSetValue
        })]));
    };
    var dom = function (detail) {
      return {
        tag: detail.tag,
        attributes: __assign({ type: 'text' }, detail.inputAttributes),
        styles: detail.inputStyles,
        classes: detail.inputClasses
      };
    };

    var factory$h = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: dom(detail),
        components: [],
        behaviours: behaviours(detail),
        eventOrder: detail.eventOrder
      };
    };
    var Input = single({
      name: 'Input',
      configFields: schema$k(),
      factory: factory$h
    });

    var exports$1 = {}, module = { exports: exports$1 };
    (function (define, exports, module, require) {
      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EphoxContactWrapper = factory());
      }(this, function () {
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        var promise = { exports: {} };
        (function (module) {
          (function (root) {
            var setTimeoutFunc = setTimeout;
            function noop() {
            }
            function bind(fn, thisArg) {
              return function () {
                fn.apply(thisArg, arguments);
              };
            }
            function Promise(fn) {
              if (typeof this !== 'object')
                throw new TypeError('Promises must be constructed via new');
              if (typeof fn !== 'function')
                throw new TypeError('not a function');
              this._state = 0;
              this._handled = false;
              this._value = undefined;
              this._deferreds = [];
              doResolve(fn, this);
            }
            function handle(self, deferred) {
              while (self._state === 3) {
                self = self._value;
              }
              if (self._state === 0) {
                self._deferreds.push(deferred);
                return;
              }
              self._handled = true;
              Promise._immediateFn(function () {
                var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                if (cb === null) {
                  (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                  return;
                }
                var ret;
                try {
                  ret = cb(self._value);
                } catch (e) {
                  reject(deferred.promise, e);
                  return;
                }
                resolve(deferred.promise, ret);
              });
            }
            function resolve(self, newValue) {
              try {
                if (newValue === self)
                  throw new TypeError('A promise cannot be resolved with itself.');
                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                  var then = newValue.then;
                  if (newValue instanceof Promise) {
                    self._state = 3;
                    self._value = newValue;
                    finale(self);
                    return;
                  } else if (typeof then === 'function') {
                    doResolve(bind(then, newValue), self);
                    return;
                  }
                }
                self._state = 1;
                self._value = newValue;
                finale(self);
              } catch (e) {
                reject(self, e);
              }
            }
            function reject(self, newValue) {
              self._state = 2;
              self._value = newValue;
              finale(self);
            }
            function finale(self) {
              if (self._state === 2 && self._deferreds.length === 0) {
                Promise._immediateFn(function () {
                  if (!self._handled) {
                    Promise._unhandledRejectionFn(self._value);
                  }
                });
              }
              for (var i = 0, len = self._deferreds.length; i < len; i++) {
                handle(self, self._deferreds[i]);
              }
              self._deferreds = null;
            }
            function Handler(onFulfilled, onRejected, promise) {
              this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
              this.onRejected = typeof onRejected === 'function' ? onRejected : null;
              this.promise = promise;
            }
            function doResolve(fn, self) {
              var done = false;
              try {
                fn(function (value) {
                  if (done)
                    return;
                  done = true;
                  resolve(self, value);
                }, function (reason) {
                  if (done)
                    return;
                  done = true;
                  reject(self, reason);
                });
              } catch (ex) {
                if (done)
                  return;
                done = true;
                reject(self, ex);
              }
            }
            Promise.prototype['catch'] = function (onRejected) {
              return this.then(null, onRejected);
            };
            Promise.prototype.then = function (onFulfilled, onRejected) {
              var prom = new this.constructor(noop);
              handle(this, new Handler(onFulfilled, onRejected, prom));
              return prom;
            };
            Promise.all = function (arr) {
              var args = Array.prototype.slice.call(arr);
              return new Promise(function (resolve, reject) {
                if (args.length === 0)
                  return resolve([]);
                var remaining = args.length;
                function res(i, val) {
                  try {
                    if (val && (typeof val === 'object' || typeof val === 'function')) {
                      var then = val.then;
                      if (typeof then === 'function') {
                        then.call(val, function (val) {
                          res(i, val);
                        }, reject);
                        return;
                      }
                    }
                    args[i] = val;
                    if (--remaining === 0) {
                      resolve(args);
                    }
                  } catch (ex) {
                    reject(ex);
                  }
                }
                for (var i = 0; i < args.length; i++) {
                  res(i, args[i]);
                }
              });
            };
            Promise.resolve = function (value) {
              if (value && typeof value === 'object' && value.constructor === Promise) {
                return value;
              }
              return new Promise(function (resolve) {
                resolve(value);
              });
            };
            Promise.reject = function (value) {
              return new Promise(function (resolve, reject) {
                reject(value);
              });
            };
            Promise.race = function (values) {
              return new Promise(function (resolve, reject) {
                for (var i = 0, len = values.length; i < len; i++) {
                  values[i].then(resolve, reject);
                }
              });
            };
            Promise._immediateFn = typeof setImmediate === 'function' ? function (fn) {
              setImmediate(fn);
            } : function (fn) {
              setTimeoutFunc(fn, 0);
            };
            Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
              if (typeof console !== 'undefined' && console) {
                console.warn('Possible Unhandled Promise Rejection:', err);
              }
            };
            Promise._setImmediateFn = function _setImmediateFn(fn) {
              Promise._immediateFn = fn;
            };
            Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
              Promise._unhandledRejectionFn = fn;
            };
            if (module.exports) {
              module.exports = Promise;
            } else if (!root.Promise) {
              root.Promise = Promise;
            }
          }(commonjsGlobal));
        }(promise));
        var promisePolyfill = promise.exports;
        var Global = function () {
          if (typeof window !== 'undefined') {
            return window;
          } else {
            return Function('return this;')();
          }
        }();
        var promisePolyfill_1 = { boltExport: Global.Promise || promisePolyfill };
        return promisePolyfill_1;
      }));
    }(undefined, exports$1, module));
    var Promise$1 = module.exports.boltExport;

    var nu$3 = function (baseFn) {
      var data = Optional.none();
      var callbacks = [];
      var map = function (f) {
        return nu$3(function (nCallback) {
          get(function (data) {
            nCallback(f(data));
          });
        });
      };
      var get = function (nCallback) {
        if (isReady()) {
          call(nCallback);
        } else {
          callbacks.push(nCallback);
        }
      };
      var set = function (x) {
        if (!isReady()) {
          data = Optional.some(x);
          run(callbacks);
          callbacks = [];
        }
      };
      var isReady = function () {
        return data.isSome();
      };
      var run = function (cbs) {
        each$1(cbs, call);
      };
      var call = function (cb) {
        data.each(function (x) {
          setTimeout(function () {
            cb(x);
          }, 0);
        });
      };
      baseFn(set);
      return {
        get: get,
        map: map,
        isReady: isReady
      };
    };
    var pure$1 = function (a) {
      return nu$3(function (callback) {
        callback(a);
      });
    };
    var LazyValue = {
      nu: nu$3,
      pure: pure$1
    };

    var errorReporter = function (err) {
      setTimeout(function () {
        throw err;
      }, 0);
    };
    var make$5 = function (run) {
      var get = function (callback) {
        run().then(callback, errorReporter);
      };
      var map = function (fab) {
        return make$5(function () {
          return run().then(fab);
        });
      };
      var bind = function (aFutureB) {
        return make$5(function () {
          return run().then(function (v) {
            return aFutureB(v).toPromise();
          });
        });
      };
      var anonBind = function (futureB) {
        return make$5(function () {
          return run().then(function () {
            return futureB.toPromise();
          });
        });
      };
      var toLazy = function () {
        return LazyValue.nu(get);
      };
      var toCached = function () {
        var cache = null;
        return make$5(function () {
          if (cache === null) {
            cache = run();
          }
          return cache;
        });
      };
      var toPromise = run;
      return {
        map: map,
        bind: bind,
        anonBind: anonBind,
        toLazy: toLazy,
        toCached: toCached,
        toPromise: toPromise,
        get: get
      };
    };
    var nu$2 = function (baseFn) {
      return make$5(function () {
        return new Promise$1(baseFn);
      });
    };
    var pure = function (a) {
      return make$5(function () {
        return Promise$1.resolve(a);
      });
    };
    var Future = {
      nu: nu$2,
      pure: pure
    };

    var ariaElements = [
      'input',
      'textarea'
    ];
    var isAriaElement = function (elem) {
      var name = name$2(elem);
      return contains$2(ariaElements, name);
    };
    var markValid = function (component, invalidConfig) {
      var elem = invalidConfig.getRoot(component).getOr(component.element);
      remove$2(elem, invalidConfig.invalidClass);
      invalidConfig.notify.each(function (notifyInfo) {
        if (isAriaElement(component.element)) {
          set$8(component.element, 'aria-invalid', false);
        }
        notifyInfo.getContainer(component).each(function (container) {
          set$5(container, notifyInfo.validHtml);
        });
        notifyInfo.onValid(component);
      });
    };
    var markInvalid = function (component, invalidConfig, invalidState, text) {
      var elem = invalidConfig.getRoot(component).getOr(component.element);
      add$2(elem, invalidConfig.invalidClass);
      invalidConfig.notify.each(function (notifyInfo) {
        if (isAriaElement(component.element)) {
          set$8(component.element, 'aria-invalid', true);
        }
        notifyInfo.getContainer(component).each(function (container) {
          set$5(container, text);
        });
        notifyInfo.onInvalid(component, text);
      });
    };
    var query = function (component, invalidConfig, _invalidState) {
      return invalidConfig.validator.fold(function () {
        return Future.pure(Result.value(true));
      }, function (validatorInfo) {
        return validatorInfo.validate(component);
      });
    };
    var run = function (component, invalidConfig, invalidState) {
      invalidConfig.notify.each(function (notifyInfo) {
        notifyInfo.onValidate(component);
      });
      return query(component, invalidConfig).map(function (valid) {
        if (component.getSystem().isConnected()) {
          return valid.fold(function (err) {
            markInvalid(component, invalidConfig, invalidState, err);
            return Result.error(err);
          }, function (v) {
            markValid(component, invalidConfig);
            return Result.value(v);
          });
        } else {
          return Result.error('No longer in system');
        }
      });
    };
    var isInvalid = function (component, invalidConfig) {
      var elem = invalidConfig.getRoot(component).getOr(component.element);
      return has(elem, invalidConfig.invalidClass);
    };

    var InvalidateApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        markValid: markValid,
        markInvalid: markInvalid,
        query: query,
        run: run,
        isInvalid: isInvalid
    });

    var events$8 = function (invalidConfig, invalidState) {
      return invalidConfig.validator.map(function (validatorInfo) {
        return derive$2([run$1(validatorInfo.onEvent, function (component) {
            run(component, invalidConfig, invalidState).get(identity$1);
          })].concat(validatorInfo.validateOnLoad ? [runOnAttached(function (component) {
            run(component, invalidConfig, invalidState).get(noop);
          })] : []));
      }).getOr({});
    };

    var ActiveInvalidate = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$8
    });

    var InvalidateSchema = [
      required$1('invalidClass'),
      defaulted('getRoot', Optional.none),
      optionObjOf('notify', [
        defaulted('aria', 'alert'),
        defaulted('getContainer', Optional.none),
        defaulted('validHtml', ''),
        onHandler('onValid'),
        onHandler('onInvalid'),
        onHandler('onValidate')
      ]),
      optionObjOf('validator', [
        required$1('validate'),
        defaulted('onEvent', 'input'),
        defaulted('validateOnLoad', true)
      ])
    ];

    var Invalidating = create$7({
      fields: InvalidateSchema,
      name: 'invalidating',
      active: ActiveInvalidate,
      apis: InvalidateApis,
      extra: {
        validation: function (validator) {
          return function (component) {
            var v = Representing.getValue(component);
            return Future.pure(validator(v));
          };
        }
      }
    });

    var getCoupled = function (component, coupleConfig, coupleState, name) {
      return coupleState.getOrCreate(component, coupleConfig, name);
    };

    var CouplingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCoupled: getCoupled
    });

    var CouplingSchema = [requiredOf('others', setOf(Result.value, anyValue()))];

    var init$a = function () {
      var coupled = {};
      var getOrCreate = function (component, coupleConfig, name) {
        var available = keys(coupleConfig.others);
        if (!available) {
          throw new Error('Cannot find coupled component: ' + name + '. Known coupled components: ' + JSON.stringify(available, null, 2));
        } else {
          return get$e(coupled, name).getOrThunk(function () {
            var builder = get$e(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);
            var spec = builder(component);
            var built = component.getSystem().build(spec);
            coupled[name] = built;
            return built;
          });
        }
      };
      var readState = constant$1({});
      return nu$8({
        readState: readState,
        getOrCreate: getOrCreate
      });
    };

    var CouplingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$a
    });

    var Coupling = create$7({
      fields: CouplingSchema,
      name: 'coupling',
      apis: CouplingApis,
      state: CouplingState
    });

    var suffix = constant$1('sink');
    var partType$1 = constant$1(optional({
      name: suffix(),
      overrides: constant$1({
        dom: { tag: 'div' },
        behaviours: derive$1([Positioning.config({ useFixed: always })]),
        events: derive$2([
          cutter(keydown()),
          cutter(mousedown()),
          cutter(click())
        ])
      })
    }));

    var HighlightOnOpen;
    (function (HighlightOnOpen) {
      HighlightOnOpen[HighlightOnOpen['HighlightFirst'] = 0] = 'HighlightFirst';
      HighlightOnOpen[HighlightOnOpen['HighlightNone'] = 1] = 'HighlightNone';
    }(HighlightOnOpen || (HighlightOnOpen = {})));
    var getAnchor = function (detail, component) {
      var hotspot = detail.getHotspot(component).getOr(component);
      var type = 'hotspot';
      var overrides = detail.getAnchorOverrides();
      return detail.layouts.fold(function () {
        return {
          type: type,
          hotspot: hotspot,
          overrides: overrides
        };
      }, function (layouts) {
        return {
          type: type,
          hotspot: hotspot,
          overrides: overrides,
          layouts: layouts
        };
      });
    };
    var fetch = function (detail, mapFetch, component) {
      var fetcher = detail.fetch;
      return fetcher(component).map(mapFetch);
    };
    var openF = function (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) {
      var futureData = fetch(detail, mapFetch, component);
      var getLazySink = getSink(component, detail);
      return futureData.map(function (tdata) {
        return tdata.bind(function (data) {
          return Optional.from(tieredMenu.sketch(__assign(__assign({}, externals.menu()), {
            uid: generate$5(''),
            data: data,
            highlightImmediately: highlightOnOpen === HighlightOnOpen.HighlightFirst,
            onOpenMenu: function (tmenu, menu) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, menu, { anchor: anchor });
              Sandboxing.decloak(sandbox);
            },
            onOpenSubmenu: function (tmenu, item, submenu) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, submenu, {
                anchor: {
                  type: 'submenu',
                  item: item
                }
              });
              Sandboxing.decloak(sandbox);
            },
            onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, primaryMenu, { anchor: anchor });
              each$1(submenuTriggers, function (st) {
                Positioning.position(sink, st.triggeredMenu, {
                  anchor: {
                    type: 'submenu',
                    item: st.triggeringItem
                  }
                });
              });
            },
            onEscape: function () {
              Focusing.focus(component);
              Sandboxing.close(sandbox);
              return Optional.some(true);
            }
          })));
        });
      });
    };
    var open = function (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) {
      var anchor = getAnchor(detail, hotspot);
      var processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
      return processed.map(function (tdata) {
        tdata.fold(function () {
          if (Sandboxing.isOpen(sandbox)) {
            Sandboxing.close(sandbox);
          }
        }, function (data) {
          Sandboxing.cloak(sandbox);
          Sandboxing.open(sandbox, data);
          onOpenSync(sandbox);
        });
        return sandbox;
      });
    };
    var close = function (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) {
      Sandboxing.close(sandbox);
      return Future.pure(sandbox);
    };
    var togglePopup = function (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) {
      var sandbox = Coupling.getCoupled(hotspot, 'sandbox');
      var showing = Sandboxing.isOpen(sandbox);
      var action = showing ? close : open;
      return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
    };
    var matchWidth = function (hotspot, container, useMinWidth) {
      var menu = Composing.getCurrent(container).getOr(container);
      var buttonWidth = get$a(hotspot.element);
      if (useMinWidth) {
        set$7(menu.element, 'min-width', buttonWidth + 'px');
      } else {
        set$6(menu.element, buttonWidth);
      }
    };
    var getSink = function (anyInSystem, sinkDetail) {
      return anyInSystem.getSystem().getByUid(sinkDetail.uid + '-' + suffix()).map(function (internalSink) {
        return function () {
          return Result.value(internalSink);
        };
      }).getOrThunk(function () {
        return sinkDetail.lazySink.fold(function () {
          return function () {
            return Result.error(new Error('No internal sink is specified, nor could an external sink be found'));
          };
        }, function (lazySinkFn) {
          return function () {
            return lazySinkFn(anyInSystem);
          };
        });
      });
    };
    var doRepositionMenus = function (sandbox) {
      Sandboxing.getState(sandbox).each(function (tmenu) {
        tieredMenu.repositionMenus(tmenu);
      });
    };
    var makeSandbox$1 = function (detail, hotspot, extras) {
      var ariaOwner = manager();
      var onOpen = function (component, menu) {
        var anchor = getAnchor(detail, hotspot);
        ariaOwner.link(hotspot.element);
        if (detail.matchWidth) {
          matchWidth(anchor.hotspot, menu, detail.useMinWidth);
        }
        detail.onOpen(anchor, component, menu);
        if (extras !== undefined && extras.onOpen !== undefined) {
          extras.onOpen(component, menu);
        }
      };
      var onClose = function (component, menu) {
        ariaOwner.unlink(hotspot.element);
        if (extras !== undefined && extras.onClose !== undefined) {
          extras.onClose(component, menu);
        }
      };
      var lazySink = getSink(hotspot, detail);
      return {
        dom: {
          tag: 'div',
          classes: detail.sandboxClasses,
          attributes: {
            id: ariaOwner.id,
            role: 'listbox'
          }
        },
        behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: hotspot
            }
          }),
          Sandboxing.config({
            onOpen: onOpen,
            onClose: onClose,
            isPartOf: function (container, data, queryElem) {
              return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);
            },
            getAttachPoint: function () {
              return lazySink().getOrDie();
            }
          }),
          Composing.config({
            find: function (sandbox) {
              return Sandboxing.getState(sandbox).bind(function (menu) {
                return Composing.getCurrent(menu);
              });
            }
          }),
          Receiving.config({ channels: __assign(__assign({}, receivingChannel$1({ isExtraPart: never })), receivingChannel({ doReposition: doRepositionMenus })) })
        ])
      };
    };
    var repositionMenus = function (comp) {
      var sandbox = Coupling.getCoupled(comp, 'sandbox');
      doRepositionMenus(sandbox);
    };

    var sandboxFields = function () {
      return [
        defaulted('sandboxClasses', []),
        SketchBehaviours.field('sandboxBehaviours', [
          Composing,
          Receiving,
          Sandboxing,
          Representing
        ])
      ];
    };

    var schema$j = constant$1([
      required$1('dom'),
      required$1('fetch'),
      onHandler('onOpen'),
      onKeyboardHandler('onExecute'),
      defaulted('getHotspot', Optional.some),
      defaulted('getAnchorOverrides', constant$1({})),
      schema$y(),
      field('dropdownBehaviours', [
        Toggling,
        Coupling,
        Keying,
        Focusing
      ]),
      required$1('toggleClass'),
      defaulted('eventOrder', {}),
      option('lazySink'),
      defaulted('matchWidth', false),
      defaulted('useMinWidth', false),
      option('role')
    ].concat(sandboxFields()));
    var parts$d = constant$1([
      external$1({
        schema: [tieredMenuMarkers()],
        name: 'menu',
        defaults: function (detail) {
          return { onExecute: detail.onExecute };
        }
      }),
      partType$1()
    ]);

    var factory$g = function (detail, components, _spec, externals) {
      var _a;
      var lookupAttr = function (attr) {
        return get$e(detail.dom, 'attributes').bind(function (attrs) {
          return get$e(attrs, attr);
        });
      };
      var switchToMenu = function (sandbox) {
        Sandboxing.getState(sandbox).each(function (tmenu) {
          tieredMenu.highlightPrimary(tmenu);
        });
      };
      var action = function (component) {
        var onOpenSync = switchToMenu;
        togglePopup(detail, identity$1, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
      };
      var apis = {
        expand: function (comp) {
          if (!Toggling.isOn(comp)) {
            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightNone).get(noop);
          }
        },
        open: function (comp) {
          if (!Toggling.isOn(comp)) {
            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);
          }
        },
        isOpen: Toggling.isOn,
        close: function (comp) {
          if (Toggling.isOn(comp)) {
            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);
          }
        },
        repositionMenus: function (comp) {
          if (Toggling.isOn(comp)) {
            repositionMenus(comp);
          }
        }
      };
      var triggerExecute = function (comp, _se) {
        emitExecute(comp);
        return Optional.some(true);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.dropdownBehaviours, [
          Toggling.config({
            toggleClass: detail.toggleClass,
            aria: { mode: 'expanded' }
          }),
          Coupling.config({
            others: {
              sandbox: function (hotspot) {
                return makeSandbox$1(detail, hotspot, {
                  onOpen: function () {
                    return Toggling.on(hotspot);
                  },
                  onClose: function () {
                    return Toggling.off(hotspot);
                  }
                });
              }
            }
          }),
          Keying.config({
            mode: 'special',
            onSpace: triggerExecute,
            onEnter: triggerExecute,
            onDown: function (comp, _se) {
              if (Dropdown.isOpen(comp)) {
                var sandbox = Coupling.getCoupled(comp, 'sandbox');
                switchToMenu(sandbox);
              } else {
                Dropdown.open(comp);
              }
              return Optional.some(true);
            },
            onEscape: function (comp, _se) {
              if (Dropdown.isOpen(comp)) {
                Dropdown.close(comp);
                return Optional.some(true);
              } else {
                return Optional.none();
              }
            }
          }),
          Focusing.config({})
        ]),
        events: events$a(Optional.some(action)),
        eventOrder: __assign(__assign({}, detail.eventOrder), (_a = {}, _a[execute$5()] = [
          'disabling',
          'toggling',
          'alloy.base.behaviour'
        ], _a)),
        apis: apis,
        domModification: {
          attributes: __assign(__assign({ 'aria-haspopup': 'true' }, detail.role.fold(function () {
            return {};
          }, function (role) {
            return { role: role };
          })), detail.dom.tag === 'button' ? { type: lookupAttr('type').getOr('button') } : {})
        }
      };
    };
    var Dropdown = composite({
      name: 'Dropdown',
      configFields: schema$j(),
      partFields: parts$d(),
      factory: factory$g,
      apis: {
        open: function (apis, comp) {
          return apis.open(comp);
        },
        expand: function (apis, comp) {
          return apis.expand(comp);
        },
        close: function (apis, comp) {
          return apis.close(comp);
        },
        isOpen: function (apis, comp) {
          return apis.isOpen(comp);
        },
        repositionMenus: function (apis, comp) {
          return apis.repositionMenus(comp);
        }
      }
    });

    var exhibit$1 = function () {
      return nu$7({
        styles: {
          '-webkit-user-select': 'none',
          'user-select': 'none',
          '-ms-user-select': 'none',
          '-moz-user-select': '-moz-none'
        },
        attributes: { unselectable: 'on' }
      });
    };
    var events$7 = function () {
      return derive$2([abort(selectstart(), always)]);
    };

    var ActiveUnselecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$7,
        exhibit: exhibit$1
    });

    var Unselecting = create$7({
      fields: [],
      name: 'unselecting',
      active: ActiveUnselecting
    });

    var renderPanelButton = function (spec, sharedBackstage) {
      return Dropdown.sketch({
        dom: spec.dom,
        components: spec.components,
        toggleClass: 'mce-active',
        dropdownBehaviours: derive$1([
          DisablingConfigs.button(sharedBackstage.providers.isDisabled),
          receivingConfig(),
          Unselecting.config({}),
          Tabstopping.config({})
        ]),
        layouts: spec.layouts,
        sandboxClasses: ['tox-dialog__popups'],
        lazySink: sharedBackstage.getSink,
        fetch: function (comp) {
          return Future.nu(function (callback) {
            return spec.fetch(callback);
          }).map(function (items) {
            return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {
              spec.onItemAction(comp, value);
            }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })));
          });
        },
        parts: { menu: part(false, 1, spec.presets) }
      });
    };

    var colorInputChangeEvent = generate$6('color-input-change');
    var colorSwatchChangeEvent = generate$6('color-swatch-change');
    var colorPickerCancelEvent = generate$6('color-picker-cancel');
    var renderColorInput = function (spec, sharedBackstage, colorInputBackstage) {
      var pField = FormField.parts.field({
        factory: Input,
        inputClasses: ['tox-textfield'],
        onSetValue: function (c) {
          return Invalidating.run(c).get(noop);
        },
        inputBehaviours: derive$1([
          Disabling.config({ disabled: sharedBackstage.providers.isDisabled }),
          receivingConfig(),
          Tabstopping.config({}),
          Invalidating.config({
            invalidClass: 'tox-textbox-field-invalid',
            getRoot: function (comp) {
              return parent(comp.element);
            },
            notify: {
              onValid: function (comp) {
                var val = Representing.getValue(comp);
                emitWith(comp, colorInputChangeEvent, { color: val });
              }
            },
            validator: {
              validateOnLoad: false,
              validate: function (input) {
                var inputValue = Representing.getValue(input);
                if (inputValue.length === 0) {
                  return Future.pure(Result.value(true));
                } else {
                  var span = SugarElement.fromTag('span');
                  set$7(span, 'background-color', inputValue);
                  var res = getRaw(span, 'background-color').fold(function () {
                    return Result.error('blah');
                  }, function (_) {
                    return Result.value(inputValue);
                  });
                  return Future.pure(res);
                }
              }
            }
          })
        ]),
        selectOnFocus: false
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, sharedBackstage.providers);
      });
      var emitSwatchChange = function (colorBit, value) {
        emitWith(colorBit, colorSwatchChangeEvent, { value: value });
      };
      var onItemAction = function (comp, value) {
        memColorButton.getOpt(comp).each(function (colorBit) {
          if (value === 'custom') {
            colorInputBackstage.colorPicker(function (valueOpt) {
              valueOpt.fold(function () {
                return emit(colorBit, colorPickerCancelEvent);
              }, function (value) {
                emitSwatchChange(colorBit, value);
                addColor(value);
              });
            }, '#ffffff');
          } else if (value === 'remove') {
            emitSwatchChange(colorBit, '');
          } else {
            emitSwatchChange(colorBit, value);
          }
        });
      };
      var memColorButton = record(renderPanelButton({
        dom: {
          tag: 'span',
          attributes: { 'aria-label': sharedBackstage.providers.translate('Color swatch') }
        },
        layouts: {
          onRtl: function () {
            return [
              southwest$2,
              southeast$2,
              south$2
            ];
          },
          onLtr: function () {
            return [
              southeast$2,
              southwest$2,
              south$2
            ];
          }
        },
        components: [],
        fetch: getFetch$1(colorInputBackstage.getColors(), colorInputBackstage.hasCustomColors()),
        columns: colorInputBackstage.getColorCols(),
        presets: 'color',
        onItemAction: onItemAction
      }, sharedBackstage));
      return FormField.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-form__group']
        },
        components: pLabel.toArray().concat([{
            dom: {
              tag: 'div',
              classes: ['tox-color-input']
            },
            components: [
              pField,
              memColorButton.asSpec()
            ]
          }]),
        fieldBehaviours: derive$1([config('form-field-events', [
            run$1(colorInputChangeEvent, function (comp, se) {
              memColorButton.getOpt(comp).each(function (colorButton) {
                set$7(colorButton.element, 'background-color', se.event.color);
              });
              emitWith(comp, formChangeEvent, { name: spec.name });
            }),
            run$1(colorSwatchChangeEvent, function (comp, se) {
              FormField.getField(comp).each(function (field) {
                Representing.setValue(field, se.event.value);
                Composing.getCurrent(comp).each(Focusing.focus);
              });
            }),
            run$1(colorPickerCancelEvent, function (comp, _se) {
              FormField.getField(comp).each(function (_field) {
                Composing.getCurrent(comp).each(Focusing.focus);
              });
            })
          ])])
      });
    };

    var labelPart = optional({
      schema: [required$1('dom')],
      name: 'label'
    });
    var edgePart = function (name) {
      return optional({
        name: '' + name + '-edge',
        overrides: function (detail) {
          var action = detail.model.manager.edgeActions[name];
          return action.fold(function () {
            return {};
          }, function (a) {
            return {
              events: derive$2([
                runActionExtra(touchstart(), function (comp, se, d) {
                  return a(comp, d);
                }, [detail]),
                runActionExtra(mousedown(), function (comp, se, d) {
                  return a(comp, d);
                }, [detail]),
                runActionExtra(mousemove(), function (comp, se, det) {
                  if (det.mouseIsDown.get()) {
                    a(comp, det);
                  }
                }, [detail])
              ])
            };
          });
        }
      });
    };
    var tlEdgePart = edgePart('top-left');
    var tedgePart = edgePart('top');
    var trEdgePart = edgePart('top-right');
    var redgePart = edgePart('right');
    var brEdgePart = edgePart('bottom-right');
    var bedgePart = edgePart('bottom');
    var blEdgePart = edgePart('bottom-left');
    var ledgePart = edgePart('left');
    var thumbPart = required({
      name: 'thumb',
      defaults: constant$1({ dom: { styles: { position: 'absolute' } } }),
      overrides: function (detail) {
        return {
          events: derive$2([
            redirectToPart(touchstart(), detail, 'spectrum'),
            redirectToPart(touchmove(), detail, 'spectrum'),
            redirectToPart(touchend(), detail, 'spectrum'),
            redirectToPart(mousedown(), detail, 'spectrum'),
            redirectToPart(mousemove(), detail, 'spectrum'),
            redirectToPart(mouseup(), detail, 'spectrum')
          ])
        };
      }
    });
    var spectrumPart = required({
      schema: [customField('mouseIsDown', function () {
          return Cell(false);
        })],
      name: 'spectrum',
      overrides: function (detail) {
        var modelDetail = detail.model;
        var model = modelDetail.manager;
        var setValueFrom = function (component, simulatedEvent) {
          return model.getValueFromEvent(simulatedEvent).map(function (value) {
            return model.setValueFrom(component, detail, value);
          });
        };
        return {
          behaviours: derive$1([
            Keying.config({
              mode: 'special',
              onLeft: function (spectrum) {
                return model.onLeft(spectrum, detail);
              },
              onRight: function (spectrum) {
                return model.onRight(spectrum, detail);
              },
              onUp: function (spectrum) {
                return model.onUp(spectrum, detail);
              },
              onDown: function (spectrum) {
                return model.onDown(spectrum, detail);
              }
            }),
            Focusing.config({})
          ]),
          events: derive$2([
            run$1(touchstart(), setValueFrom),
            run$1(touchmove(), setValueFrom),
            run$1(mousedown(), setValueFrom),
            run$1(mousemove(), function (spectrum, se) {
              if (detail.mouseIsDown.get()) {
                setValueFrom(spectrum, se);
              }
            })
          ])
        };
      }
    });
    var SliderParts = [
      labelPart,
      ledgePart,
      redgePart,
      tedgePart,
      bedgePart,
      tlEdgePart,
      trEdgePart,
      blEdgePart,
      brEdgePart,
      thumbPart,
      spectrumPart
    ];

    var _sliderChangeEvent = 'slider.change.value';
    var sliderChangeEvent = constant$1(_sliderChangeEvent);
    var isTouchEvent$2 = function (evt) {
      return evt.type.indexOf('touch') !== -1;
    };
    var getEventSource = function (simulatedEvent) {
      var evt = simulatedEvent.event.raw;
      if (isTouchEvent$2(evt)) {
        var touchEvent = evt;
        return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map(function (t) {
          return SugarPosition(t.clientX, t.clientY);
        }) : Optional.none();
      } else {
        var mouseEvent = evt;
        return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map(function (me) {
          return SugarPosition(me.clientX, me.clientY);
        }) : Optional.none();
      }
    };

    var t = 'top', r = 'right', b = 'bottom', l = 'left';
    var minX = function (detail) {
      return detail.model.minX;
    };
    var minY = function (detail) {
      return detail.model.minY;
    };
    var min1X = function (detail) {
      return detail.model.minX - 1;
    };
    var min1Y = function (detail) {
      return detail.model.minY - 1;
    };
    var maxX = function (detail) {
      return detail.model.maxX;
    };
    var maxY = function (detail) {
      return detail.model.maxY;
    };
    var max1X = function (detail) {
      return detail.model.maxX + 1;
    };
    var max1Y = function (detail) {
      return detail.model.maxY + 1;
    };
    var range = function (detail, max, min) {
      return max(detail) - min(detail);
    };
    var xRange = function (detail) {
      return range(detail, maxX, minX);
    };
    var yRange = function (detail) {
      return range(detail, maxY, minY);
    };
    var halfX = function (detail) {
      return xRange(detail) / 2;
    };
    var halfY = function (detail) {
      return yRange(detail) / 2;
    };
    var step = function (detail) {
      return detail.stepSize;
    };
    var snap = function (detail) {
      return detail.snapToGrid;
    };
    var snapStart = function (detail) {
      return detail.snapStart;
    };
    var rounded = function (detail) {
      return detail.rounded;
    };
    var hasEdge = function (detail, edgeName) {
      return detail[edgeName + '-edge'] !== undefined;
    };
    var hasLEdge = function (detail) {
      return hasEdge(detail, l);
    };
    var hasREdge = function (detail) {
      return hasEdge(detail, r);
    };
    var hasTEdge = function (detail) {
      return hasEdge(detail, t);
    };
    var hasBEdge = function (detail) {
      return hasEdge(detail, b);
    };
    var currentValue = function (detail) {
      return detail.model.value.get();
    };

    var xValue = function (x) {
      return { x: x };
    };
    var yValue = function (y) {
      return { y: y };
    };
    var xyValue = function (x, y) {
      return {
        x: x,
        y: y
      };
    };
    var fireSliderChange$3 = function (component, value) {
      emitWith(component, sliderChangeEvent(), { value: value });
    };
    var setToTLEdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));
    };
    var setToTEdge = function (edge, detail) {
      fireSliderChange$3(edge, yValue(min1Y(detail)));
    };
    var setToTEdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));
    };
    var setToTREdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));
    };
    var setToREdge = function (edge, detail) {
      fireSliderChange$3(edge, xValue(max1X(detail)));
    };
    var setToREdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));
    };
    var setToBREdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));
    };
    var setToBEdge = function (edge, detail) {
      fireSliderChange$3(edge, yValue(max1Y(detail)));
    };
    var setToBEdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));
    };
    var setToBLEdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));
    };
    var setToLEdge = function (edge, detail) {
      fireSliderChange$3(edge, xValue(min1X(detail)));
    };
    var setToLEdgeXY = function (edge, detail) {
      fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));
    };

    var reduceBy = function (value, min, max, step) {
      if (value < min) {
        return value;
      } else if (value > max) {
        return max;
      } else if (value === min) {
        return min - 1;
      } else {
        return Math.max(min, value - step);
      }
    };
    var increaseBy = function (value, min, max, step) {
      if (value > max) {
        return value;
      } else if (value < min) {
        return min;
      } else if (value === max) {
        return max + 1;
      } else {
        return Math.min(max, value + step);
      }
    };
    var capValue = function (value, min, max) {
      return Math.max(min, Math.min(max, value));
    };
    var snapValueOf = function (value, min, max, step, snapStart) {
      return snapStart.fold(function () {
        var initValue = value - min;
        var extraValue = Math.round(initValue / step) * step;
        return capValue(min + extraValue, min - 1, max + 1);
      }, function (start) {
        var remainder = (value - start) % step;
        var adjustment = Math.round(remainder / step);
        var rawSteps = Math.floor((value - start) / step);
        var maxSteps = Math.floor((max - start) / step);
        var numSteps = Math.min(maxSteps, rawSteps + adjustment);
        var r = start + numSteps * step;
        return Math.max(start, r);
      });
    };
    var findOffsetOf = function (value, min, max) {
      return Math.min(max, Math.max(value, min)) - min;
    };
    var findValueOf = function (args) {
      var min = args.min, max = args.max, range = args.range, value = args.value, step = args.step, snap = args.snap, snapStart = args.snapStart, rounded = args.rounded, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, minBound = args.minBound, maxBound = args.maxBound, screenRange = args.screenRange;
      var capMin = hasMinEdge ? min - 1 : min;
      var capMax = hasMaxEdge ? max + 1 : max;
      if (value < minBound) {
        return capMin;
      } else if (value > maxBound) {
        return capMax;
      } else {
        var offset = findOffsetOf(value, minBound, maxBound);
        var newValue = capValue(offset / screenRange * range + min, capMin, capMax);
        if (snap && newValue >= min && newValue <= max) {
          return snapValueOf(newValue, min, max, step, snapStart);
        } else if (rounded) {
          return Math.round(newValue);
        } else {
          return newValue;
        }
      }
    };
    var findOffsetOfValue$2 = function (args) {
      var min = args.min, max = args.max, range = args.range, value = args.value, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, maxBound = args.maxBound, maxOffset = args.maxOffset, centerMinEdge = args.centerMinEdge, centerMaxEdge = args.centerMaxEdge;
      if (value < min) {
        return hasMinEdge ? 0 : centerMinEdge;
      } else if (value > max) {
        return hasMaxEdge ? maxBound : centerMaxEdge;
      } else {
        return (value - min) / range * maxOffset;
      }
    };

    var top = 'top', right = 'right', bottom = 'bottom', left = 'left', width = 'width', height = 'height';
    var getBounds = function (component) {
      return component.element.dom.getBoundingClientRect();
    };
    var getBoundsProperty = function (bounds, property) {
      return bounds[property];
    };
    var getMinXBounds = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, left);
    };
    var getMaxXBounds = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, right);
    };
    var getMinYBounds = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, top);
    };
    var getMaxYBounds = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, bottom);
    };
    var getXScreenRange = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, width);
    };
    var getYScreenRange = function (component) {
      var bounds = getBounds(component);
      return getBoundsProperty(bounds, height);
    };
    var getCenterOffsetOf = function (componentMinEdge, componentMaxEdge, spectrumMinEdge) {
      return (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
    };
    var getXCenterOffSetOf = function (component, spectrum) {
      var componentBounds = getBounds(component);
      var spectrumBounds = getBounds(spectrum);
      var componentMinEdge = getBoundsProperty(componentBounds, left);
      var componentMaxEdge = getBoundsProperty(componentBounds, right);
      var spectrumMinEdge = getBoundsProperty(spectrumBounds, left);
      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };
    var getYCenterOffSetOf = function (component, spectrum) {
      var componentBounds = getBounds(component);
      var spectrumBounds = getBounds(spectrum);
      var componentMinEdge = getBoundsProperty(componentBounds, top);
      var componentMaxEdge = getBoundsProperty(componentBounds, bottom);
      var spectrumMinEdge = getBoundsProperty(spectrumBounds, top);
      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };

    var fireSliderChange$2 = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue$2 = function (x) {
      return { x: x };
    };
    var findValueOfOffset$1 = function (spectrum, detail, left) {
      var args = {
        min: minX(detail),
        max: maxX(detail),
        range: xRange(detail),
        value: left,
        step: step(detail),
        snap: snap(detail),
        snapStart: snapStart(detail),
        rounded: rounded(detail),
        hasMinEdge: hasLEdge(detail),
        hasMaxEdge: hasREdge(detail),
        minBound: getMinXBounds(spectrum),
        maxBound: getMaxXBounds(spectrum),
        screenRange: getXScreenRange(spectrum)
      };
      return findValueOf(args);
    };
    var setValueFrom$2 = function (spectrum, detail, value) {
      var xValue = findValueOfOffset$1(spectrum, detail, value);
      var sliderVal = sliderValue$2(xValue);
      fireSliderChange$2(spectrum, sliderVal);
      return xValue;
    };
    var setToMin$2 = function (spectrum, detail) {
      var min = minX(detail);
      fireSliderChange$2(spectrum, sliderValue$2(min));
    };
    var setToMax$2 = function (spectrum, detail) {
      var max = maxX(detail);
      fireSliderChange$2(spectrum, sliderValue$2(max));
    };
    var moveBy$2 = function (direction, spectrum, detail) {
      var f = direction > 0 ? increaseBy : reduceBy;
      var xValue = f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
      fireSliderChange$2(spectrum, sliderValue$2(xValue));
      return Optional.some(xValue);
    };
    var handleMovement$2 = function (direction) {
      return function (spectrum, detail) {
        return moveBy$2(direction, spectrum, detail).map(always);
      };
    };
    var getValueFromEvent$2 = function (simulatedEvent) {
      var pos = getEventSource(simulatedEvent);
      return pos.map(function (p) {
        return p.left;
      });
    };
    var findOffsetOfValue$1 = function (spectrum, detail, value, minEdge, maxEdge) {
      var minOffset = 0;
      var maxOffset = getXScreenRange(spectrum);
      var centerMinEdge = minEdge.bind(function (edge) {
        return Optional.some(getXCenterOffSetOf(edge, spectrum));
      }).getOr(minOffset);
      var centerMaxEdge = maxEdge.bind(function (edge) {
        return Optional.some(getXCenterOffSetOf(edge, spectrum));
      }).getOr(maxOffset);
      var args = {
        min: minX(detail),
        max: maxX(detail),
        range: xRange(detail),
        value: value,
        hasMinEdge: hasLEdge(detail),
        hasMaxEdge: hasREdge(detail),
        minBound: getMinXBounds(spectrum),
        minOffset: minOffset,
        maxBound: getMaxXBounds(spectrum),
        maxOffset: maxOffset,
        centerMinEdge: centerMinEdge,
        centerMaxEdge: centerMaxEdge
      };
      return findOffsetOfValue$2(args);
    };
    var findPositionOfValue$1 = function (slider, spectrum, value, minEdge, maxEdge, detail) {
      var offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);
      return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;
    };
    var setPositionFromValue$2 = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
      var thumbRadius = get$a(thumb.element) / 2;
      set$7(thumb.element, 'left', pos - thumbRadius + 'px');
    };
    var onLeft$2 = handleMovement$2(-1);
    var onRight$2 = handleMovement$2(1);
    var onUp$2 = Optional.none;
    var onDown$2 = Optional.none;
    var edgeActions$2 = {
      'top-left': Optional.none(),
      'top': Optional.none(),
      'top-right': Optional.none(),
      'right': Optional.some(setToREdge),
      'bottom-right': Optional.none(),
      'bottom': Optional.none(),
      'bottom-left': Optional.none(),
      'left': Optional.some(setToLEdge)
    };

    var HorizontalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$2,
        setToMin: setToMin$2,
        setToMax: setToMax$2,
        findValueOfOffset: findValueOfOffset$1,
        getValueFromEvent: getValueFromEvent$2,
        findPositionOfValue: findPositionOfValue$1,
        setPositionFromValue: setPositionFromValue$2,
        onLeft: onLeft$2,
        onRight: onRight$2,
        onUp: onUp$2,
        onDown: onDown$2,
        edgeActions: edgeActions$2
    });

    var fireSliderChange$1 = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue$1 = function (y) {
      return { y: y };
    };
    var findValueOfOffset = function (spectrum, detail, top) {
      var args = {
        min: minY(detail),
        max: maxY(detail),
        range: yRange(detail),
        value: top,
        step: step(detail),
        snap: snap(detail),
        snapStart: snapStart(detail),
        rounded: rounded(detail),
        hasMinEdge: hasTEdge(detail),
        hasMaxEdge: hasBEdge(detail),
        minBound: getMinYBounds(spectrum),
        maxBound: getMaxYBounds(spectrum),
        screenRange: getYScreenRange(spectrum)
      };
      return findValueOf(args);
    };
    var setValueFrom$1 = function (spectrum, detail, value) {
      var yValue = findValueOfOffset(spectrum, detail, value);
      var sliderVal = sliderValue$1(yValue);
      fireSliderChange$1(spectrum, sliderVal);
      return yValue;
    };
    var setToMin$1 = function (spectrum, detail) {
      var min = minY(detail);
      fireSliderChange$1(spectrum, sliderValue$1(min));
    };
    var setToMax$1 = function (spectrum, detail) {
      var max = maxY(detail);
      fireSliderChange$1(spectrum, sliderValue$1(max));
    };
    var moveBy$1 = function (direction, spectrum, detail) {
      var f = direction > 0 ? increaseBy : reduceBy;
      var yValue = f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));
      fireSliderChange$1(spectrum, sliderValue$1(yValue));
      return Optional.some(yValue);
    };
    var handleMovement$1 = function (direction) {
      return function (spectrum, detail) {
        return moveBy$1(direction, spectrum, detail).map(always);
      };
    };
    var getValueFromEvent$1 = function (simulatedEvent) {
      var pos = getEventSource(simulatedEvent);
      return pos.map(function (p) {
        return p.top;
      });
    };
    var findOffsetOfValue = function (spectrum, detail, value, minEdge, maxEdge) {
      var minOffset = 0;
      var maxOffset = getYScreenRange(spectrum);
      var centerMinEdge = minEdge.bind(function (edge) {
        return Optional.some(getYCenterOffSetOf(edge, spectrum));
      }).getOr(minOffset);
      var centerMaxEdge = maxEdge.bind(function (edge) {
        return Optional.some(getYCenterOffSetOf(edge, spectrum));
      }).getOr(maxOffset);
      var args = {
        min: minY(detail),
        max: maxY(detail),
        range: yRange(detail),
        value: value,
        hasMinEdge: hasTEdge(detail),
        hasMaxEdge: hasBEdge(detail),
        minBound: getMinYBounds(spectrum),
        minOffset: minOffset,
        maxBound: getMaxYBounds(spectrum),
        maxOffset: maxOffset,
        centerMinEdge: centerMinEdge,
        centerMaxEdge: centerMaxEdge
      };
      return findOffsetOfValue$2(args);
    };
    var findPositionOfValue = function (slider, spectrum, value, minEdge, maxEdge, detail) {
      var offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
      return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;
    };
    var setPositionFromValue$1 = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var pos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
      var thumbRadius = get$b(thumb.element) / 2;
      set$7(thumb.element, 'top', pos - thumbRadius + 'px');
    };
    var onLeft$1 = Optional.none;
    var onRight$1 = Optional.none;
    var onUp$1 = handleMovement$1(-1);
    var onDown$1 = handleMovement$1(1);
    var edgeActions$1 = {
      'top-left': Optional.none(),
      'top': Optional.some(setToTEdge),
      'top-right': Optional.none(),
      'right': Optional.none(),
      'bottom-right': Optional.none(),
      'bottom': Optional.some(setToBEdge),
      'bottom-left': Optional.none(),
      'left': Optional.none()
    };

    var VerticalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$1,
        setToMin: setToMin$1,
        setToMax: setToMax$1,
        findValueOfOffset: findValueOfOffset,
        getValueFromEvent: getValueFromEvent$1,
        findPositionOfValue: findPositionOfValue,
        setPositionFromValue: setPositionFromValue$1,
        onLeft: onLeft$1,
        onRight: onRight$1,
        onUp: onUp$1,
        onDown: onDown$1,
        edgeActions: edgeActions$1
    });

    var fireSliderChange = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue = function (x, y) {
      return {
        x: x,
        y: y
      };
    };
    var setValueFrom = function (spectrum, detail, value) {
      var xValue = findValueOfOffset$1(spectrum, detail, value.left);
      var yValue = findValueOfOffset(spectrum, detail, value.top);
      var val = sliderValue(xValue, yValue);
      fireSliderChange(spectrum, val);
      return val;
    };
    var moveBy = function (direction, isVerticalMovement, spectrum, detail) {
      var f = direction > 0 ? increaseBy : reduceBy;
      var xValue = isVerticalMovement ? currentValue(detail).x : f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
      var yValue = !isVerticalMovement ? currentValue(detail).y : f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));
      fireSliderChange(spectrum, sliderValue(xValue, yValue));
      return Optional.some(xValue);
    };
    var handleMovement = function (direction, isVerticalMovement) {
      return function (spectrum, detail) {
        return moveBy(direction, isVerticalMovement, spectrum, detail).map(always);
      };
    };
    var setToMin = function (spectrum, detail) {
      var mX = minX(detail);
      var mY = minY(detail);
      fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    var setToMax = function (spectrum, detail) {
      var mX = maxX(detail);
      var mY = maxY(detail);
      fireSliderChange(spectrum, sliderValue(mX, mY));
    };
    var getValueFromEvent = function (simulatedEvent) {
      return getEventSource(simulatedEvent);
    };
    var setPositionFromValue = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
      var yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
      var thumbXRadius = get$a(thumb.element) / 2;
      var thumbYRadius = get$b(thumb.element) / 2;
      set$7(thumb.element, 'left', xPos - thumbXRadius + 'px');
      set$7(thumb.element, 'top', yPos - thumbYRadius + 'px');
    };
    var onLeft = handleMovement(-1, false);
    var onRight = handleMovement(1, false);
    var onUp = handleMovement(-1, true);
    var onDown = handleMovement(1, true);
    var edgeActions = {
      'top-left': Optional.some(setToTLEdgeXY),
      'top': Optional.some(setToTEdgeXY),
      'top-right': Optional.some(setToTREdgeXY),
      'right': Optional.some(setToREdgeXY),
      'bottom-right': Optional.some(setToBREdgeXY),
      'bottom': Optional.some(setToBEdgeXY),
      'bottom-left': Optional.some(setToBLEdgeXY),
      'left': Optional.some(setToLEdgeXY)
    };

    var TwoDModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom,
        setToMin: setToMin,
        setToMax: setToMax,
        getValueFromEvent: getValueFromEvent,
        setPositionFromValue: setPositionFromValue,
        onLeft: onLeft,
        onRight: onRight,
        onUp: onUp,
        onDown: onDown,
        edgeActions: edgeActions
    });

    var SliderSchema = [
      defaulted('stepSize', 1),
      defaulted('onChange', noop),
      defaulted('onChoose', noop),
      defaulted('onInit', noop),
      defaulted('onDragStart', noop),
      defaulted('onDragEnd', noop),
      defaulted('snapToGrid', false),
      defaulted('rounded', true),
      option('snapStart'),
      requiredOf('model', choose$1('mode', {
        x: [
          defaulted('minX', 0),
          defaulted('maxX', 100),
          customField('value', function (spec) {
            return Cell(spec.mode.minX);
          }),
          required$1('getInitialValue'),
          output$1('manager', HorizontalModel)
        ],
        y: [
          defaulted('minY', 0),
          defaulted('maxY', 100),
          customField('value', function (spec) {
            return Cell(spec.mode.minY);
          }),
          required$1('getInitialValue'),
          output$1('manager', VerticalModel)
        ],
        xy: [
          defaulted('minX', 0),
          defaulted('maxX', 100),
          defaulted('minY', 0),
          defaulted('maxY', 100),
          customField('value', function (spec) {
            return Cell({
              x: spec.mode.minX,
              y: spec.mode.minY
            });
          }),
          required$1('getInitialValue'),
          output$1('manager', TwoDModel)
        ]
      })),
      field('sliderBehaviours', [
        Keying,
        Representing
      ]),
      customField('mouseIsDown', function () {
        return Cell(false);
      })
    ];

    var sketch$2 = function (detail, components, _spec, _externals) {
      var _a;
      var getThumb = function (component) {
        return getPartOrDie(component, detail, 'thumb');
      };
      var getSpectrum = function (component) {
        return getPartOrDie(component, detail, 'spectrum');
      };
      var getLeftEdge = function (component) {
        return getPart(component, detail, 'left-edge');
      };
      var getRightEdge = function (component) {
        return getPart(component, detail, 'right-edge');
      };
      var getTopEdge = function (component) {
        return getPart(component, detail, 'top-edge');
      };
      var getBottomEdge = function (component) {
        return getPart(component, detail, 'bottom-edge');
      };
      var modelDetail = detail.model;
      var model = modelDetail.manager;
      var refresh = function (slider, thumb) {
        model.setPositionFromValue(slider, thumb, detail, {
          getLeftEdge: getLeftEdge,
          getRightEdge: getRightEdge,
          getTopEdge: getTopEdge,
          getBottomEdge: getBottomEdge,
          getSpectrum: getSpectrum
        });
      };
      var setValue = function (slider, newValue) {
        modelDetail.value.set(newValue);
        var thumb = getThumb(slider);
        refresh(slider, thumb);
      };
      var changeValue = function (slider, newValue) {
        setValue(slider, newValue);
        var thumb = getThumb(slider);
        detail.onChange(slider, thumb, newValue);
        return Optional.some(true);
      };
      var resetToMin = function (slider) {
        model.setToMin(slider, detail);
      };
      var resetToMax = function (slider) {
        model.setToMax(slider, detail);
      };
      var choose = function (slider) {
        var fireOnChoose = function () {
          getPart(slider, detail, 'thumb').each(function (thumb) {
            var value = modelDetail.value.get();
            detail.onChoose(slider, thumb, value);
          });
        };
        var wasDown = detail.mouseIsDown.get();
        detail.mouseIsDown.set(false);
        if (wasDown) {
          fireOnChoose();
        }
      };
      var onDragStart = function (slider, simulatedEvent) {
        simulatedEvent.stop();
        detail.mouseIsDown.set(true);
        detail.onDragStart(slider, getThumb(slider));
      };
      var onDragEnd = function (slider, simulatedEvent) {
        simulatedEvent.stop();
        detail.onDragEnd(slider, getThumb(slider));
        choose(slider);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.sliderBehaviours, [
          Keying.config({
            mode: 'special',
            focusIn: function (slider) {
              return getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(always);
            }
          }),
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function (_) {
                return modelDetail.value.get();
              }
            }
          }),
          Receiving.config({ channels: (_a = {}, _a[mouseReleased()] = { onReceive: choose }, _a) })
        ]),
        events: derive$2([
          run$1(sliderChangeEvent(), function (slider, simulatedEvent) {
            changeValue(slider, simulatedEvent.event.value);
          }),
          runOnAttached(function (slider, _simulatedEvent) {
            var getInitial = modelDetail.getInitialValue();
            modelDetail.value.set(getInitial);
            var thumb = getThumb(slider);
            refresh(slider, thumb);
            var spectrum = getSpectrum(slider);
            detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
          }),
          run$1(touchstart(), onDragStart),
          run$1(touchend(), onDragEnd),
          run$1(mousedown(), onDragStart),
          run$1(mouseup(), onDragEnd)
        ]),
        apis: {
          resetToMin: resetToMin,
          resetToMax: resetToMax,
          setValue: setValue,
          refresh: refresh
        },
        domModification: { styles: { position: 'relative' } }
      };
    };

    var Slider = composite({
      name: 'Slider',
      configFields: SliderSchema,
      partFields: SliderParts,
      factory: sketch$2,
      apis: {
        setValue: function (apis, slider, value) {
          apis.setValue(slider, value);
        },
        resetToMin: function (apis, slider) {
          apis.resetToMin(slider);
        },
        resetToMax: function (apis, slider) {
          apis.resetToMax(slider);
        },
        refresh: function (apis, slider) {
          apis.refresh(slider);
        }
      }
    });

    var fieldsUpdate = generate$6('rgb-hex-update');
    var sliderUpdate = generate$6('slider-update');
    var paletteUpdate = generate$6('palette-update');

    var sliderFactory = function (translate, getClass) {
      var spectrum = Slider.parts.spectrum({
        dom: {
          tag: 'div',
          classes: [getClass('hue-slider-spectrum')],
          attributes: { role: 'presentation' }
        }
      });
      var thumb = Slider.parts.thumb({
        dom: {
          tag: 'div',
          classes: [getClass('hue-slider-thumb')],
          attributes: { role: 'presentation' }
        }
      });
      return Slider.sketch({
        dom: {
          tag: 'div',
          classes: [getClass('hue-slider')],
          attributes: { role: 'presentation' }
        },
        rounded: false,
        model: {
          mode: 'y',
          getInitialValue: constant$1({ y: 0 })
        },
        components: [
          spectrum,
          thumb
        ],
        sliderBehaviours: derive$1([Focusing.config({})]),
        onChange: function (slider, _thumb, value) {
          emitWith(slider, sliderUpdate, { value: value });
        }
      });
    };

    var owner$1 = 'form';
    var schema$i = [field('formBehaviours', [Representing])];
    var getPartName$1 = function (name) {
      return '<alloy.field.' + name + '>';
    };
    var sketch$1 = function (fSpec) {
      var parts = function () {
        var record = [];
        var field = function (name, config) {
          record.push(name);
          return generateOne$1(owner$1, getPartName$1(name), config);
        };
        return {
          field: field,
          record: constant$1(record)
        };
      }();
      var spec = fSpec(parts);
      var partNames = parts.record();
      var fieldParts = map$2(partNames, function (n) {
        return required({
          name: n,
          pname: getPartName$1(n)
        });
      });
      return composite$1(owner$1, schema$i, fieldParts, make$4, spec);
    };
    var toResult = function (o, e) {
      return o.fold(function () {
        return Result.error(e);
      }, Result.value);
    };
    var make$4 = function (detail, components) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.formBehaviours, [Representing.config({
            store: {
              mode: 'manual',
              getValue: function (form) {
                var resPs = getAllParts(form, detail);
                return map$1(resPs, function (resPThunk, pName) {
                  return resPThunk().bind(function (v) {
                    var opt = Composing.getCurrent(v);
                    return toResult(opt, new Error('Cannot find a current component to extract the value from for form part \'' + pName + '\': ' + element(v.element)));
                  }).map(Representing.getValue);
                });
              },
              setValue: function (form, values) {
                each(values, function (newValue, key) {
                  getPart(form, detail, key).each(function (wrapper) {
                    Composing.getCurrent(wrapper).each(function (field) {
                      Representing.setValue(field, newValue);
                    });
                  });
                });
              }
            }
          })]),
        apis: {
          getField: function (form, key) {
            return getPart(form, detail, key).bind(Composing.getCurrent);
          }
        }
      };
    };
    var Form = {
      getField: makeApi(function (apis, component, key) {
        return apis.getField(component, key);
      }),
      sketch: sketch$1
    };

    var validInput = generate$6('valid-input');
    var invalidInput = generate$6('invalid-input');
    var validatingInput = generate$6('validating-input');
    var translatePrefix = 'colorcustom.rgb.';
    var rgbFormFactory = function (translate, getClass, onValidHexx, onInvalidHexx) {
      var invalidation = function (label, isValid) {
        return Invalidating.config({
          invalidClass: getClass('invalid'),
          notify: {
            onValidate: function (comp) {
              emitWith(comp, validatingInput, { type: label });
            },
            onValid: function (comp) {
              emitWith(comp, validInput, {
                type: label,
                value: Representing.getValue(comp)
              });
            },
            onInvalid: function (comp) {
              emitWith(comp, invalidInput, {
                type: label,
                value: Representing.getValue(comp)
              });
            }
          },
          validator: {
            validate: function (comp) {
              var value = Representing.getValue(comp);
              var res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));
              return Future.pure(res);
            },
            validateOnLoad: false
          }
        });
      };
      var renderTextField = function (isValid, name, label, description, data) {
        var helptext = translate(translatePrefix + 'range');
        var pLabel = FormField.parts.label({
          dom: {
            tag: 'label',
            innerHtml: label,
            attributes: { 'aria-label': description }
          }
        });
        var pField = FormField.parts.field({
          data: data,
          factory: Input,
          inputAttributes: __assign({ type: 'text' }, name === 'hex' ? { 'aria-live': 'polite' } : {}),
          inputClasses: [getClass('textfield')],
          inputBehaviours: derive$1([
            invalidation(name, isValid),
            Tabstopping.config({})
          ]),
          onSetValue: function (input) {
            if (Invalidating.isInvalid(input)) {
              var run = Invalidating.run(input);
              run.get(noop);
            }
          }
        });
        var comps = [
          pLabel,
          pField
        ];
        var concats = name !== 'hex' ? [FormField.parts['aria-descriptor']({ text: helptext })] : [];
        var components = comps.concat(concats);
        return {
          dom: {
            tag: 'div',
            attributes: { role: 'presentation' }
          },
          components: components
        };
      };
      var copyRgbToHex = function (form, rgba) {
        var hex = fromRgba(rgba);
        Form.getField(form, 'hex').each(function (hexField) {
          if (!Focusing.isFocused(hexField)) {
            Representing.setValue(form, { hex: hex.value });
          }
        });
        return hex;
      };
      var copyRgbToForm = function (form, rgb) {
        var red = rgb.red;
        var green = rgb.green;
        var blue = rgb.blue;
        Representing.setValue(form, {
          red: red,
          green: green,
          blue: blue
        });
      };
      var memPreview = record({
        dom: {
          tag: 'div',
          classes: [getClass('rgba-preview')],
          styles: { 'background-color': 'white' },
          attributes: { role: 'presentation' }
        }
      });
      var updatePreview = function (anyInSystem, hex) {
        memPreview.getOpt(anyInSystem).each(function (preview) {
          set$7(preview.element, 'background-color', '#' + hex.value);
        });
      };
      var factory = function () {
        var state = {
          red: Cell(Optional.some(255)),
          green: Cell(Optional.some(255)),
          blue: Cell(Optional.some(255)),
          hex: Cell(Optional.some('ffffff'))
        };
        var copyHexToRgb = function (form, hex) {
          var rgb = fromHex(hex);
          copyRgbToForm(form, rgb);
          setValueRgb(rgb);
        };
        var get = function (prop) {
          return state[prop].get();
        };
        var set = function (prop, value) {
          state[prop].set(value);
        };
        var getValueRgb = function () {
          return get('red').bind(function (red) {
            return get('green').bind(function (green) {
              return get('blue').map(function (blue) {
                return rgbaColour(red, green, blue, 1);
              });
            });
          });
        };
        var setValueRgb = function (rgb) {
          var red = rgb.red;
          var green = rgb.green;
          var blue = rgb.blue;
          set('red', Optional.some(red));
          set('green', Optional.some(green));
          set('blue', Optional.some(blue));
        };
        var onInvalidInput = function (form, simulatedEvent) {
          var data = simulatedEvent.event;
          if (data.type !== 'hex') {
            set(data.type, Optional.none());
          } else {
            onInvalidHexx(form);
          }
        };
        var onValidHex = function (form, value) {
          onValidHexx(form);
          var hex = hexColour(value);
          set('hex', Optional.some(value));
          var rgb = fromHex(hex);
          copyRgbToForm(form, rgb);
          setValueRgb(rgb);
          emitWith(form, fieldsUpdate, { hex: hex });
          updatePreview(form, hex);
        };
        var onValidRgb = function (form, prop, value) {
          var val = parseInt(value, 10);
          set(prop, Optional.some(val));
          getValueRgb().each(function (rgb) {
            var hex = copyRgbToHex(form, rgb);
            emitWith(form, fieldsUpdate, { hex: hex });
            updatePreview(form, hex);
          });
        };
        var isHexInputEvent = function (data) {
          return data.type === 'hex';
        };
        var onValidInput = function (form, simulatedEvent) {
          var data = simulatedEvent.event;
          if (isHexInputEvent(data)) {
            onValidHex(form, data.value);
          } else {
            onValidRgb(form, data.type, data.value);
          }
        };
        var formPartStrings = function (key) {
          return {
            label: translate(translatePrefix + key + '.label'),
            description: translate(translatePrefix + key + '.description')
          };
        };
        var redStrings = formPartStrings('red');
        var greenStrings = formPartStrings('green');
        var blueStrings = formPartStrings('blue');
        var hexStrings = formPartStrings('hex');
        return deepMerge(Form.sketch(function (parts) {
          return {
            dom: {
              tag: 'form',
              classes: [getClass('rgb-form')],
              attributes: { 'aria-label': translate('aria.color.picker') }
            },
            components: [
              parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))),
              parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))),
              parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))),
              parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))),
              memPreview.asSpec()
            ],
            formBehaviours: derive$1([
              Invalidating.config({ invalidClass: getClass('form-invalid') }),
              config('rgb-form-events', [
                run$1(validInput, onValidInput),
                run$1(invalidInput, onInvalidInput),
                run$1(validatingInput, onInvalidInput)
              ])
            ])
          };
        }), {
          apis: {
            updateHex: function (form, hex) {
              Representing.setValue(form, { hex: hex.value });
              copyHexToRgb(form, hex);
              updatePreview(form, hex);
            }
          }
        });
      };
      var rgbFormSketcher = single({
        factory: factory,
        name: 'RgbForm',
        configFields: [],
        apis: {
          updateHex: function (apis, form, hex) {
            apis.updateHex(form, hex);
          }
        },
        extraApis: {}
      });
      return rgbFormSketcher;
    };

    var paletteFactory = function (_translate, getClass) {
      var spectrumPart = Slider.parts.spectrum({
        dom: {
          tag: 'canvas',
          attributes: { role: 'presentation' },
          classes: [getClass('sv-palette-spectrum')]
        }
      });
      var thumbPart = Slider.parts.thumb({
        dom: {
          tag: 'div',
          attributes: { role: 'presentation' },
          classes: [getClass('sv-palette-thumb')],
          innerHtml: '<div class=' + getClass('sv-palette-inner-thumb') + ' role="presentation"></div>'
        }
      });
      var setColour = function (canvas, rgba) {
        var width = canvas.width, height = canvas.height;
        var ctx = canvas.getContext('2d');
        if (ctx === null) {
          return;
        }
        ctx.fillStyle = rgba;
        ctx.fillRect(0, 0, width, height);
        var grdWhite = ctx.createLinearGradient(0, 0, width, 0);
        grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
        grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grdWhite;
        ctx.fillRect(0, 0, width, height);
        var grdBlack = ctx.createLinearGradient(0, 0, 0, height);
        grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
        grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
        ctx.fillStyle = grdBlack;
        ctx.fillRect(0, 0, width, height);
      };
      var setPaletteHue = function (slider, hue) {
        var canvas = slider.components()[0].element.dom;
        var hsv = hsvColour(hue, 100, 100);
        var rgba = fromHsv(hsv);
        setColour(canvas, toString(rgba));
      };
      var setPaletteThumb = function (slider, hex) {
        var hsv = fromRgb(fromHex(hex));
        Slider.setValue(slider, {
          x: hsv.saturation,
          y: 100 - hsv.value
        });
      };
      var factory = function (_detail) {
        var getInitialValue = constant$1({
          x: 0,
          y: 0
        });
        var onChange = function (slider, _thumb, value) {
          emitWith(slider, paletteUpdate, { value: value });
        };
        var onInit = function (_slider, _thumb, spectrum, _value) {
          setColour(spectrum.element.dom, toString(red));
        };
        var sliderBehaviours = derive$1([
          Composing.config({ find: Optional.some }),
          Focusing.config({})
        ]);
        return Slider.sketch({
          dom: {
            tag: 'div',
            attributes: { role: 'presentation' },
            classes: [getClass('sv-palette')]
          },
          model: {
            mode: 'xy',
            getInitialValue: getInitialValue
          },
          rounded: false,
          components: [
            spectrumPart,
            thumbPart
          ],
          onChange: onChange,
          onInit: onInit,
          sliderBehaviours: sliderBehaviours
        });
      };
      var saturationBrightnessPaletteSketcher = single({
        factory: factory,
        name: 'SaturationBrightnessPalette',
        configFields: [],
        apis: {
          setHue: function (_apis, slider, hue) {
            setPaletteHue(slider, hue);
          },
          setThumb: function (_apis, slider, hex) {
            setPaletteThumb(slider, hex);
          }
        },
        extraApis: {}
      });
      return saturationBrightnessPaletteSketcher;
    };

    var makeFactory = function (translate, getClass) {
      var factory = function (detail) {
        var rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);
        var sbPalette = paletteFactory(translate, getClass);
        var hueSliderToDegrees = function (hue) {
          return (100 - hue) / 100 * 360;
        };
        var hueDegreesToSlider = function (hue) {
          return 100 - hue / 360 * 100;
        };
        var state = {
          paletteRgba: Cell(red),
          paletteHue: Cell(0)
        };
        var memSlider = record(sliderFactory(translate, getClass));
        var memPalette = record(sbPalette.sketch({}));
        var memRgb = record(rgbForm.sketch({}));
        var updatePalette = function (anyInSystem, _hex, hue) {
          memPalette.getOpt(anyInSystem).each(function (palette) {
            sbPalette.setHue(palette, hue);
          });
        };
        var updateFields = function (anyInSystem, hex) {
          memRgb.getOpt(anyInSystem).each(function (form) {
            rgbForm.updateHex(form, hex);
          });
        };
        var updateSlider = function (anyInSystem, _hex, hue) {
          memSlider.getOpt(anyInSystem).each(function (slider) {
            Slider.setValue(slider, { y: hueDegreesToSlider(hue) });
          });
        };
        var updatePaletteThumb = function (anyInSystem, hex) {
          memPalette.getOpt(anyInSystem).each(function (palette) {
            sbPalette.setThumb(palette, hex);
          });
        };
        var updateState = function (hex, hue) {
          var rgba = fromHex(hex);
          state.paletteRgba.set(rgba);
          state.paletteHue.set(hue);
        };
        var runUpdates = function (anyInSystem, hex, hue, updates) {
          updateState(hex, hue);
          each$1(updates, function (update) {
            update(anyInSystem, hex, hue);
          });
        };
        var onPaletteUpdate = function () {
          var updates = [updateFields];
          return function (form, simulatedEvent) {
            var value = simulatedEvent.event.value;
            var oldHue = state.paletteHue.get();
            var newHsv = hsvColour(oldHue, value.x, 100 - value.y);
            var newHex = hsvToHex(newHsv);
            runUpdates(form, newHex, oldHue, updates);
          };
        };
        var onSliderUpdate = function () {
          var updates = [
            updatePalette,
            updateFields
          ];
          return function (form, simulatedEvent) {
            var hue = hueSliderToDegrees(simulatedEvent.event.value.y);
            var oldRgb = state.paletteRgba.get();
            var oldHsv = fromRgb(oldRgb);
            var newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);
            var newHex = hsvToHex(newHsv);
            runUpdates(form, newHex, hue, updates);
          };
        };
        var onFieldsUpdate = function () {
          var updates = [
            updatePalette,
            updateSlider,
            updatePaletteThumb
          ];
          return function (form, simulatedEvent) {
            var hex = simulatedEvent.event.hex;
            var hsv = hexToHsv(hex);
            runUpdates(form, hex, hsv.hue, updates);
          };
        };
        return {
          uid: detail.uid,
          dom: detail.dom,
          components: [
            memPalette.asSpec(),
            memSlider.asSpec(),
            memRgb.asSpec()
          ],
          behaviours: derive$1([
            config('colour-picker-events', [
              run$1(fieldsUpdate, onFieldsUpdate()),
              run$1(paletteUpdate, onPaletteUpdate()),
              run$1(sliderUpdate, onSliderUpdate())
            ]),
            Composing.config({
              find: function (comp) {
                return memRgb.getOpt(comp);
              }
            }),
            Keying.config({ mode: 'acyclic' })
          ])
        };
      };
      var colourPickerSketcher = single({
        name: 'ColourPicker',
        configFields: [
          required$1('dom'),
          defaulted('onValidHex', noop),
          defaulted('onInvalidHex', noop)
        ],
        factory: factory
      });
      return colourPickerSketcher;
    };

    var self$1 = function () {
      return Composing.config({ find: Optional.some });
    };
    var memento$1 = function (mem) {
      return Composing.config({ find: mem.getOpt });
    };
    var childAt = function (index) {
      return Composing.config({
        find: function (comp) {
          return child$2(comp.element, index).bind(function (element) {
            return comp.getSystem().getByDom(element).toOptional();
          });
        }
      });
    };
    var ComposingConfigs = {
      self: self$1,
      memento: memento$1,
      childAt: childAt
    };

    var english = {
      'colorcustom.rgb.red.label': 'R',
      'colorcustom.rgb.red.description': 'Red component',
      'colorcustom.rgb.green.label': 'G',
      'colorcustom.rgb.green.description': 'Green component',
      'colorcustom.rgb.blue.label': 'B',
      'colorcustom.rgb.blue.description': 'Blue component',
      'colorcustom.rgb.hex.label': '#',
      'colorcustom.rgb.hex.description': 'Hex color code',
      'colorcustom.rgb.range': 'Range 0 to 255',
      'colorcustom.sb.saturation': 'Saturation',
      'colorcustom.sb.brightness': 'Brightness',
      'colorcustom.sb.picker': 'Saturation and Brightness Picker',
      'colorcustom.sb.palette': 'Saturation and Brightness Palette',
      'colorcustom.sb.instructions': 'Use arrow keys to select saturation and brightness, on x and y axes',
      'colorcustom.hue.hue': 'Hue',
      'colorcustom.hue.slider': 'Hue Slider',
      'colorcustom.hue.palette': 'Hue Palette',
      'colorcustom.hue.instructions': 'Use arrow keys to select a hue',
      'aria.color.picker': 'Color Picker',
      'aria.input.invalid': 'Invalid input'
    };
    var getEnglishText = function (key) {
      return english[key];
    };
    var translate$1 = function (key) {
      return getEnglishText(key);
    };
    var renderColorPicker = function (_spec) {
      var getClass = function (key) {
        return 'tox-' + key;
      };
      var colourPickerFactory = makeFactory(translate$1, getClass);
      var onValidHex = function (form) {
        emitWith(form, formActionEvent, {
          name: 'hex-valid',
          value: true
        });
      };
      var onInvalidHex = function (form) {
        emitWith(form, formActionEvent, {
          name: 'hex-valid',
          value: false
        });
      };
      var memPicker = record(colourPickerFactory.sketch({
        dom: {
          tag: 'div',
          classes: [getClass('color-picker-container')],
          attributes: { role: 'presentation' }
        },
        onValidHex: onValidHex,
        onInvalidHex: onInvalidHex
      }));
      return {
        dom: { tag: 'div' },
        components: [memPicker.asSpec()],
        behaviours: derive$1([
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function (comp) {
                var picker = memPicker.get(comp);
                var optRgbForm = Composing.getCurrent(picker);
                var optHex = optRgbForm.bind(function (rgbForm) {
                  var formValues = Representing.getValue(rgbForm);
                  return formValues.hex;
                });
                return optHex.map(function (hex) {
                  return '#' + hex;
                }).getOr('');
              },
              setValue: function (comp, newValue) {
                var pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
                var m = pattern.exec(newValue);
                var picker = memPicker.get(comp);
                var optRgbForm = Composing.getCurrent(picker);
                optRgbForm.fold(function () {
                  console.log('Can not find form');
                }, function (rgbForm) {
                  Representing.setValue(rgbForm, { hex: Optional.from(m[1]).getOr('') });
                  Form.getField(rgbForm, 'hex').each(function (hexField) {
                    emit(hexField, input());
                  });
                });
              }
            }
          }),
          ComposingConfigs.self()
        ])
      };
    };

    var global$6 = tinymce.util.Tools.resolve('tinymce.Resource');

    var isOldCustomEditor = function (spec) {
      return has$2(spec, 'init');
    };
    var renderCustomEditor = function (spec) {
      var editorApi = value$1();
      var memReplaced = record({ dom: { tag: spec.tag } });
      var initialValue = value$1();
      return {
        dom: {
          tag: 'div',
          classes: ['tox-custom-editor']
        },
        behaviours: derive$1([
          config('custom-editor-events', [runOnAttached(function (component) {
              memReplaced.getOpt(component).each(function (ta) {
                (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$6.load(spec.scriptId, spec.scriptUrl).then(function (init) {
                  return init(ta.element.dom, spec.settings);
                })).then(function (ea) {
                  initialValue.on(function (cvalue) {
                    ea.setValue(cvalue);
                  });
                  initialValue.clear();
                  editorApi.set(ea);
                });
              });
            })]),
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function () {
                return editorApi.get().fold(function () {
                  return initialValue.get().getOr('');
                }, function (ed) {
                  return ed.getValue();
                });
              },
              setValue: function (component, value) {
                editorApi.get().fold(function () {
                  initialValue.set(value);
                }, function (ed) {
                  return ed.setValue(value);
                });
              }
            }
          }),
          ComposingConfigs.self()
        ]),
        components: [memReplaced.asSpec()]
      };
    };

    var global$5 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var processors = objOf([
      defaulted('preprocess', identity$1),
      defaulted('postprocess', identity$1)
    ]);
    var memento = function (mem, rawProcessors) {
      var ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);
      return Representing.config({
        store: {
          mode: 'manual',
          getValue: function (comp) {
            var other = mem.get(comp);
            var rawValue = Representing.getValue(other);
            return ps.postprocess(rawValue);
          },
          setValue: function (comp, rawValue) {
            var newValue = ps.preprocess(rawValue);
            var other = mem.get(comp);
            Representing.setValue(other, newValue);
          }
        }
      });
    };
    var withComp = function (optInitialValue, getter, setter) {
      return Representing.config(deepMerge({
        store: {
          mode: 'manual',
          getValue: getter,
          setValue: setter
        }
      }, optInitialValue.map(function (initialValue) {
        return { store: { initialValue: initialValue } };
      }).getOr({})));
    };
    var withElement = function (initialValue, getter, setter) {
      return withComp(initialValue, function (c) {
        return getter(c.element);
      }, function (c, v) {
        return setter(c.element, v);
      });
    };
    var domValue = function (optInitialValue) {
      return withElement(optInitialValue, get$5, set$4);
    };
    var domHtml = function (optInitialValue) {
      return withElement(optInitialValue, get$7, set$5);
    };
    var memory = function (initialValue) {
      return Representing.config({
        store: {
          mode: 'memory',
          initialValue: initialValue
        }
      });
    };
    var RepresentingConfigs = {
      memento: memento,
      withElement: withElement,
      withComp: withComp,
      domValue: domValue,
      domHtml: domHtml,
      memory: memory
    };

    var defaultImageFileTypes = 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp';
    var filterByExtension = function (files, providersBackstage) {
      var allowedImageFileTypes = global$5.explode(providersBackstage.getSetting('images_file_types', defaultImageFileTypes, 'string'));
      var isFileInAllowedTypes = function (file) {
        return exists(allowedImageFileTypes, function (type) {
          return endsWith(file.name.toLowerCase(), '.' + type.toLowerCase());
        });
      };
      return filter$2(from(files), isFileInAllowedTypes);
    };
    var renderDropZone = function (spec, providersBackstage) {
      var stopper = function (_, se) {
        se.stop();
      };
      var sequence = function (actions) {
        return function (comp, se) {
          each$1(actions, function (a) {
            a(comp, se);
          });
        };
      };
      var onDrop = function (comp, se) {
        if (!Disabling.isDisabled(comp)) {
          var transferEvent = se.event.raw;
          handleFiles(comp, transferEvent.dataTransfer.files);
        }
      };
      var onSelect = function (component, simulatedEvent) {
        var input = simulatedEvent.event.raw.target;
        handleFiles(component, input.files);
      };
      var handleFiles = function (component, files) {
        Representing.setValue(component, filterByExtension(files, providersBackstage));
        emitWith(component, formChangeEvent, { name: spec.name });
      };
      var memInput = record({
        dom: {
          tag: 'input',
          attributes: {
            type: 'file',
            accept: 'image/*'
          },
          styles: { display: 'none' }
        },
        behaviours: derive$1([config('input-file-events', [
            cutter(click()),
            cutter(tap())
          ])])
      });
      var renderField = function (s) {
        return {
          uid: s.uid,
          dom: {
            tag: 'div',
            classes: ['tox-dropzone-container']
          },
          behaviours: derive$1([
            RepresentingConfigs.memory([]),
            ComposingConfigs.self(),
            Disabling.config({}),
            Toggling.config({
              toggleClass: 'dragenter',
              toggleOnExecute: false
            }),
            config('dropzone-events', [
              run$1('dragenter', sequence([
                stopper,
                Toggling.toggle
              ])),
              run$1('dragleave', sequence([
                stopper,
                Toggling.toggle
              ])),
              run$1('dragover', stopper),
              run$1('drop', sequence([
                stopper,
                onDrop
              ])),
              run$1(change(), onSelect)
            ])
          ]),
          components: [{
              dom: {
                tag: 'div',
                classes: ['tox-dropzone'],
                styles: {}
              },
              components: [
                {
                  dom: {
                    tag: 'p',
                    innerHtml: providersBackstage.translate('Drop an image here')
                  }
                },
                Button.sketch({
                  dom: {
                    tag: 'button',
                    innerHtml: providersBackstage.translate('Browse for an image'),
                    styles: { position: 'relative' },
                    classes: [
                      'tox-button',
                      'tox-button--secondary'
                    ]
                  },
                  components: [memInput.asSpec()],
                  action: function (comp) {
                    var inputComp = memInput.get(comp);
                    inputComp.element.dom.click();
                  },
                  buttonBehaviours: derive$1([
                    Tabstopping.config({}),
                    DisablingConfigs.button(providersBackstage.isDisabled),
                    receivingConfig()
                  ])
                })
              ]
            }]
        };
      };
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var pField = FormField.parts.field({ factory: { sketch: renderField } });
      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);
    };

    var renderGrid = function (spec, backstage) {
      return {
        dom: {
          tag: 'div',
          classes: [
            'tox-form__grid',
            'tox-form__grid--' + spec.columns + 'col'
          ]
        },
        components: map$2(spec.items, backstage.interpreter)
      };
    };

    var beforeObject = generate$6('alloy-fake-before-tabstop');
    var afterObject = generate$6('alloy-fake-after-tabstop');
    var craftWithClasses = function (classes) {
      return {
        dom: {
          tag: 'div',
          styles: {
            width: '1px',
            height: '1px',
            outline: 'none'
          },
          attributes: { tabindex: '0' },
          classes: classes
        },
        behaviours: derive$1([
          Focusing.config({ ignore: true }),
          Tabstopping.config({})
        ])
      };
    };
    var craft = function (spec) {
      return {
        dom: {
          tag: 'div',
          classes: ['tox-navobj']
        },
        components: [
          craftWithClasses([beforeObject]),
          spec,
          craftWithClasses([afterObject])
        ],
        behaviours: derive$1([ComposingConfigs.childAt(1)])
      };
    };
    var triggerTab = function (placeholder, shiftKey) {
      emitWith(placeholder, keydown(), {
        raw: {
          which: 9,
          shiftKey: shiftKey
        }
      });
    };
    var onFocus = function (container, targetComp) {
      var target = targetComp.element;
      if (has(target, beforeObject)) {
        triggerTab(container, true);
      } else if (has(target, afterObject)) {
        triggerTab(container, false);
      }
    };
    var isPseudoStop = function (element) {
      return closest(element, [
        '.' + beforeObject,
        '.' + afterObject
      ].join(','), never);
    };

    var platformNeedsSandboxing = !(detect$1().browser.isIE() || detect$1().browser.isEdge());
    var getDynamicSource = function (isSandbox) {
      var cachedValue = Cell('');
      return {
        getValue: function (_frameComponent) {
          return cachedValue.get();
        },
        setValue: function (frameComponent, html) {
          if (!isSandbox) {
            set$8(frameComponent.element, 'src', 'javascript:\'\'');
            var doc = frameComponent.element.dom.contentWindow.document;
            doc.open();
            doc.write(html);
            doc.close();
          } else {
            set$8(frameComponent.element, 'srcdoc', html);
          }
          cachedValue.set(html);
        }
      };
    };
    var renderIFrame = function (spec, providersBackstage) {
      var isSandbox = platformNeedsSandboxing && spec.sandboxed;
      var attributes = __assign(__assign({}, spec.label.map(function (title) {
        return { title: title };
      }).getOr({})), isSandbox ? { sandbox: 'allow-scripts allow-same-origin' } : {});
      var sourcing = getDynamicSource(isSandbox);
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var factory = function (newSpec) {
        return craft({
          uid: newSpec.uid,
          dom: {
            tag: 'iframe',
            attributes: attributes
          },
          behaviours: derive$1([
            Tabstopping.config({}),
            Focusing.config({}),
            RepresentingConfigs.withComp(Optional.none(), sourcing.getValue, sourcing.setValue)
          ])
        });
      };
      var pField = FormField.parts.field({ factory: { sketch: factory } });
      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);
    };

    var create$3 = function (width, height) {
      return resize$3(document.createElement('canvas'), width, height);
    };
    var clone = function (canvas) {
      var tCanvas = create$3(canvas.width, canvas.height);
      var ctx = get2dContext(tCanvas);
      ctx.drawImage(canvas, 0, 0);
      return tCanvas;
    };
    var get2dContext = function (canvas) {
      return canvas.getContext('2d');
    };
    var resize$3 = function (canvas, width, height) {
      canvas.width = width;
      canvas.height = height;
      return canvas;
    };

    var getWidth$1 = function (image) {
      return image.naturalWidth || image.width;
    };
    var getHeight$1 = function (image) {
      return image.naturalHeight || image.height;
    };

    var blobToImage = function (blob) {
      return new Promise$1(function (resolve, reject) {
        var blobUrl = URL.createObjectURL(blob);
        var image = new Image();
        var removeListeners = function () {
          image.removeEventListener('load', loaded);
          image.removeEventListener('error', error);
        };
        var loaded = function () {
          removeListeners();
          resolve(image);
        };
        var error = function () {
          removeListeners();
          reject('Unable to load data of type ' + blob.type + ': ' + blobUrl);
        };
        image.addEventListener('load', loaded);
        image.addEventListener('error', error);
        image.src = blobUrl;
        if (image.complete) {
          setTimeout(loaded, 0);
        }
      });
    };
    var dataUriToBlobSync = function (uri) {
      var data = uri.split(',');
      var matches = /data:([^;]+)/.exec(data[0]);
      if (!matches) {
        return Optional.none();
      }
      var mimetype = matches[1];
      var base64 = data[1];
      var sliceSize = 1024;
      var byteCharacters = atob(base64);
      var bytesLength = byteCharacters.length;
      var slicesCount = Math.ceil(bytesLength / sliceSize);
      var byteArrays = new Array(slicesCount);
      for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);
        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
          bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
      }
      return Optional.some(new Blob(byteArrays, { type: mimetype }));
    };
    var dataUriToBlob = function (uri) {
      return new Promise$1(function (resolve, reject) {
        dataUriToBlobSync(uri).fold(function () {
          reject('uri is not base64: ' + uri);
        }, resolve);
      });
    };
    var canvasToBlob = function (canvas, type, quality) {
      type = type || 'image/png';
      if (isFunction(HTMLCanvasElement.prototype.toBlob)) {
        return new Promise$1(function (resolve, reject) {
          canvas.toBlob(function (blob) {
            if (blob) {
              resolve(blob);
            } else {
              reject();
            }
          }, type, quality);
        });
      } else {
        return dataUriToBlob(canvas.toDataURL(type, quality));
      }
    };
    var canvasToDataURL = function (canvas, type, quality) {
      type = type || 'image/png';
      return canvas.toDataURL(type, quality);
    };
    var blobToCanvas = function (blob) {
      return blobToImage(blob).then(function (image) {
        revokeImageUrl(image);
        var canvas = create$3(getWidth$1(image), getHeight$1(image));
        var context = get2dContext(canvas);
        context.drawImage(image, 0, 0);
        return canvas;
      });
    };
    var blobToDataUri = function (blob) {
      return new Promise$1(function (resolve) {
        var reader = new FileReader();
        reader.onloadend = function () {
          resolve(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    };
    var revokeImageUrl = function (image) {
      URL.revokeObjectURL(image.src);
    };

    var create$2 = function (getCanvas, blob, uri) {
      var initialType = blob.type;
      var getType = constant$1(initialType);
      var toBlob = function () {
        return Promise$1.resolve(blob);
      };
      var toDataURL = constant$1(uri);
      var toBase64 = function () {
        return uri.split(',')[1];
      };
      var toAdjustedBlob = function (type, quality) {
        return getCanvas.then(function (canvas) {
          return canvasToBlob(canvas, type, quality);
        });
      };
      var toAdjustedDataURL = function (type, quality) {
        return getCanvas.then(function (canvas) {
          return canvasToDataURL(canvas, type, quality);
        });
      };
      var toAdjustedBase64 = function (type, quality) {
        return toAdjustedDataURL(type, quality).then(function (dataurl) {
          return dataurl.split(',')[1];
        });
      };
      var toCanvas = function () {
        return getCanvas.then(clone);
      };
      return {
        getType: getType,
        toBlob: toBlob,
        toDataURL: toDataURL,
        toBase64: toBase64,
        toAdjustedBlob: toAdjustedBlob,
        toAdjustedDataURL: toAdjustedDataURL,
        toAdjustedBase64: toAdjustedBase64,
        toCanvas: toCanvas
      };
    };
    var fromBlob = function (blob) {
      return blobToDataUri(blob).then(function (uri) {
        return create$2(blobToCanvas(blob), blob, uri);
      });
    };
    var fromCanvas = function (canvas, type) {
      return canvasToBlob(canvas, type).then(function (blob) {
        return create$2(Promise$1.resolve(canvas), blob, canvas.toDataURL());
      });
    };

    var blobToImageResult = function (blob) {
      return fromBlob(blob);
    };

    var clamp = function (value, min, max) {
      var parsedValue = typeof value === 'string' ? parseFloat(value) : value;
      if (parsedValue > max) {
        parsedValue = max;
      } else if (parsedValue < min) {
        parsedValue = min;
      }
      return parsedValue;
    };
    var identity = function () {
      return [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ];
    };
    var DELTA_INDEX = [
      0,
      0.01,
      0.02,
      0.04,
      0.05,
      0.06,
      0.07,
      0.08,
      0.1,
      0.11,
      0.12,
      0.14,
      0.15,
      0.16,
      0.17,
      0.18,
      0.2,
      0.21,
      0.22,
      0.24,
      0.25,
      0.27,
      0.28,
      0.3,
      0.32,
      0.34,
      0.36,
      0.38,
      0.4,
      0.42,
      0.44,
      0.46,
      0.48,
      0.5,
      0.53,
      0.56,
      0.59,
      0.62,
      0.65,
      0.68,
      0.71,
      0.74,
      0.77,
      0.8,
      0.83,
      0.86,
      0.89,
      0.92,
      0.95,
      0.98,
      1,
      1.06,
      1.12,
      1.18,
      1.24,
      1.3,
      1.36,
      1.42,
      1.48,
      1.54,
      1.6,
      1.66,
      1.72,
      1.78,
      1.84,
      1.9,
      1.96,
      2,
      2.12,
      2.25,
      2.37,
      2.5,
      2.62,
      2.75,
      2.87,
      3,
      3.2,
      3.4,
      3.6,
      3.8,
      4,
      4.3,
      4.7,
      4.9,
      5,
      5.5,
      6,
      6.5,
      6.8,
      7,
      7.3,
      7.5,
      7.8,
      8,
      8.4,
      8.7,
      9,
      9.4,
      9.6,
      9.8,
      10
    ];
    var multiply = function (matrix1, matrix2) {
      var col = [];
      var out = new Array(25);
      var val;
      for (var i = 0; i < 5; i++) {
        for (var j = 0; j < 5; j++) {
          col[j] = matrix2[j + i * 5];
        }
        for (var j = 0; j < 5; j++) {
          val = 0;
          for (var k = 0; k < 5; k++) {
            val += matrix1[j + k * 5] * col[k];
          }
          out[j + i * 5] = val;
        }
      }
      return out;
    };
    var adjustContrast = function (matrix, value) {
      var x;
      value = clamp(value, -1, 1);
      value *= 100;
      if (value < 0) {
        x = 127 + value / 100 * 127;
      } else {
        x = value % 1;
        if (x === 0) {
          x = DELTA_INDEX[value];
        } else {
          x = DELTA_INDEX[Math.floor(value)] * (1 - x) + DELTA_INDEX[Math.floor(value) + 1] * x;
        }
        x = x * 127 + 127;
      }
      return multiply(matrix, [
        x / 127,
        0,
        0,
        0,
        0.5 * (127 - x),
        0,
        x / 127,
        0,
        0,
        0.5 * (127 - x),
        0,
        0,
        x / 127,
        0,
        0.5 * (127 - x),
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    };
    var adjustBrightness = function (matrix, value) {
      value = clamp(255 * value, -255, 255);
      return multiply(matrix, [
        1,
        0,
        0,
        0,
        value,
        0,
        1,
        0,
        0,
        value,
        0,
        0,
        1,
        0,
        value,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    };
    var adjustColors = function (matrix, adjustR, adjustG, adjustB) {
      adjustR = clamp(adjustR, 0, 2);
      adjustG = clamp(adjustG, 0, 2);
      adjustB = clamp(adjustB, 0, 2);
      return multiply(matrix, [
        adjustR,
        0,
        0,
        0,
        0,
        0,
        adjustG,
        0,
        0,
        0,
        0,
        0,
        adjustB,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    };

    var colorFilter = function (ir, matrix) {
      return ir.toCanvas().then(function (canvas) {
        return applyColorFilter(canvas, ir.getType(), matrix);
      });
    };
    var applyColorFilter = function (canvas, type, matrix) {
      var context = get2dContext(canvas);
      var applyMatrix = function (pixelsData, m) {
        var r, g, b, a;
        var data = pixelsData.data, m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7], m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11], m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15], m16 = m[16], m17 = m[17], m18 = m[18], m19 = m[19];
        for (var i = 0; i < data.length; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          a = data[i + 3];
          data[i] = r * m0 + g * m1 + b * m2 + a * m3 + m4;
          data[i + 1] = r * m5 + g * m6 + b * m7 + a * m8 + m9;
          data[i + 2] = r * m10 + g * m11 + b * m12 + a * m13 + m14;
          data[i + 3] = r * m15 + g * m16 + b * m17 + a * m18 + m19;
        }
        return pixelsData;
      };
      var pixels = applyMatrix(context.getImageData(0, 0, canvas.width, canvas.height), matrix);
      context.putImageData(pixels, 0, 0);
      return fromCanvas(canvas, type);
    };
    var convoluteFilter = function (ir, matrix) {
      return ir.toCanvas().then(function (canvas) {
        return applyConvoluteFilter(canvas, ir.getType(), matrix);
      });
    };
    var applyConvoluteFilter = function (canvas, type, matrix) {
      var context = get2dContext(canvas);
      var applyMatrix = function (pIn, pOut, aMatrix) {
        var clamp = function (value, min, max) {
          if (value > max) {
            value = max;
          } else if (value < min) {
            value = min;
          }
          return value;
        };
        var side = Math.round(Math.sqrt(aMatrix.length));
        var halfSide = Math.floor(side / 2);
        var rgba = pIn.data;
        var drgba = pOut.data;
        var w = pIn.width;
        var h = pIn.height;
        for (var y = 0; y < h; y++) {
          for (var x = 0; x < w; x++) {
            var r = 0;
            var g = 0;
            var b = 0;
            for (var cy = 0; cy < side; cy++) {
              for (var cx = 0; cx < side; cx++) {
                var scx = clamp(x + cx - halfSide, 0, w - 1);
                var scy = clamp(y + cy - halfSide, 0, h - 1);
                var innerOffset = (scy * w + scx) * 4;
                var wt = aMatrix[cy * side + cx];
                r += rgba[innerOffset] * wt;
                g += rgba[innerOffset + 1] * wt;
                b += rgba[innerOffset + 2] * wt;
              }
            }
            var offset = (y * w + x) * 4;
            drgba[offset] = clamp(r, 0, 255);
            drgba[offset + 1] = clamp(g, 0, 255);
            drgba[offset + 2] = clamp(b, 0, 255);
          }
        }
        return pOut;
      };
      var pixelsIn = context.getImageData(0, 0, canvas.width, canvas.height);
      var pixelsOut = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelsOut = applyMatrix(pixelsIn, pixelsOut, matrix);
      context.putImageData(pixelsOut, 0, 0);
      return fromCanvas(canvas, type);
    };
    var functionColorFilter = function (colorFn) {
      var filterImpl = function (canvas, type, value) {
        var context = get2dContext(canvas);
        var lookup = new Array(256);
        var applyLookup = function (pixelsData, lookupData) {
          var data = pixelsData.data;
          for (var i = 0; i < data.length; i += 4) {
            data[i] = lookupData[data[i]];
            data[i + 1] = lookupData[data[i + 1]];
            data[i + 2] = lookupData[data[i + 2]];
          }
          return pixelsData;
        };
        for (var i = 0; i < lookup.length; i++) {
          lookup[i] = colorFn(i, value);
        }
        var pixels = applyLookup(context.getImageData(0, 0, canvas.width, canvas.height), lookup);
        context.putImageData(pixels, 0, 0);
        return fromCanvas(canvas, type);
      };
      return function (ir, value) {
        return ir.toCanvas().then(function (canvas) {
          return filterImpl(canvas, ir.getType(), value);
        });
      };
    };
    var complexAdjustableColorFilter = function (matrixAdjustFn) {
      return function (ir, adjust) {
        return colorFilter(ir, matrixAdjustFn(identity(), adjust));
      };
    };
    var basicColorFilter = function (matrix) {
      return function (ir) {
        return colorFilter(ir, matrix);
      };
    };
    var basicConvolutionFilter = function (kernel) {
      return function (ir) {
        return convoluteFilter(ir, kernel);
      };
    };
    var invert$1 = basicColorFilter([
      -1,
      0,
      0,
      0,
      255,
      0,
      -1,
      0,
      0,
      255,
      0,
      0,
      -1,
      0,
      255,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1
    ]);
    var brightness$1 = complexAdjustableColorFilter(adjustBrightness);
    var contrast$1 = complexAdjustableColorFilter(adjustContrast);
    var colorize$1 = function (ir, adjustR, adjustG, adjustB) {
      return colorFilter(ir, adjustColors(identity(), adjustR, adjustG, adjustB));
    };
    var sharpen$1 = basicConvolutionFilter([
      0,
      -1,
      0,
      -1,
      5,
      -1,
      0,
      -1,
      0
    ]);
    var gamma$1 = functionColorFilter(function (color, value) {
      return Math.pow(color / 255, 1 - value) * 255;
    });

    var scale = function (image, dW, dH) {
      var sW = getWidth$1(image);
      var sH = getHeight$1(image);
      var wRatio = dW / sW;
      var hRatio = dH / sH;
      var scaleCapped = false;
      if (wRatio < 0.5 || wRatio > 2) {
        wRatio = wRatio < 0.5 ? 0.5 : 2;
        scaleCapped = true;
      }
      if (hRatio < 0.5 || hRatio > 2) {
        hRatio = hRatio < 0.5 ? 0.5 : 2;
        scaleCapped = true;
      }
      var scaled = _scale(image, wRatio, hRatio);
      return !scaleCapped ? scaled : scaled.then(function (tCanvas) {
        return scale(tCanvas, dW, dH);
      });
    };
    var _scale = function (image, wRatio, hRatio) {
      return new Promise$1(function (resolve) {
        var sW = getWidth$1(image);
        var sH = getHeight$1(image);
        var dW = Math.floor(sW * wRatio);
        var dH = Math.floor(sH * hRatio);
        var canvas = create$3(dW, dH);
        var context = get2dContext(canvas);
        context.drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);
        resolve(canvas);
      });
    };

    var ceilWithPrecision = function (num, precision) {
      if (precision === void 0) {
        precision = 2;
      }
      var mul = Math.pow(10, precision);
      var upper = Math.round(num * mul);
      return Math.ceil(upper / mul);
    };
    var rotate$1 = function (ir, angle) {
      return ir.toCanvas().then(function (canvas) {
        return applyRotate(canvas, ir.getType(), angle);
      });
    };
    var applyRotate = function (image, type, angle) {
      var degrees = angle < 0 ? 360 + angle : angle;
      var rad = degrees * Math.PI / 180;
      var width = image.width;
      var height = image.height;
      var sin = Math.sin(rad);
      var cos = Math.cos(rad);
      var newWidth = ceilWithPrecision(Math.abs(width * cos) + Math.abs(height * sin));
      var newHeight = ceilWithPrecision(Math.abs(width * sin) + Math.abs(height * cos));
      var canvas = create$3(newWidth, newHeight);
      var context = get2dContext(canvas);
      context.translate(newWidth / 2, newHeight / 2);
      context.rotate(rad);
      context.drawImage(image, -width / 2, -height / 2);
      return fromCanvas(canvas, type);
    };
    var flip$1 = function (ir, axis) {
      return ir.toCanvas().then(function (canvas) {
        return applyFlip(canvas, ir.getType(), axis);
      });
    };
    var applyFlip = function (image, type, axis) {
      var canvas = create$3(image.width, image.height);
      var context = get2dContext(canvas);
      if (axis === 'v') {
        context.scale(1, -1);
        context.drawImage(image, 0, -canvas.height);
      } else {
        context.scale(-1, 1);
        context.drawImage(image, -canvas.width, 0);
      }
      return fromCanvas(canvas, type);
    };
    var crop$1 = function (ir, x, y, w, h) {
      return ir.toCanvas().then(function (canvas) {
        return applyCrop(canvas, ir.getType(), x, y, w, h);
      });
    };
    var applyCrop = function (image, type, x, y, w, h) {
      var canvas = create$3(w, h);
      var context = get2dContext(canvas);
      context.drawImage(image, -x, -y);
      return fromCanvas(canvas, type);
    };
    var resize$2 = function (ir, w, h) {
      return ir.toCanvas().then(function (canvas) {
        return scale(canvas, w, h).then(function (newCanvas) {
          return fromCanvas(newCanvas, ir.getType());
        });
      });
    };

    var invert = function (ir) {
      return invert$1(ir);
    };
    var sharpen = function (ir) {
      return sharpen$1(ir);
    };
    var gamma = function (ir, value) {
      return gamma$1(ir, value);
    };
    var colorize = function (ir, adjustR, adjustG, adjustB) {
      return colorize$1(ir, adjustR, adjustG, adjustB);
    };
    var brightness = function (ir, adjust) {
      return brightness$1(ir, adjust);
    };
    var contrast = function (ir, adjust) {
      return contrast$1(ir, adjust);
    };
    var flip = function (ir, axis) {
      return flip$1(ir, axis);
    };
    var crop = function (ir, x, y, w, h) {
      return crop$1(ir, x, y, w, h);
    };
    var resize$1 = function (ir, w, h) {
      return resize$2(ir, w, h);
    };
    var rotate = function (ir, angle) {
      return rotate$1(ir, angle);
    };

    var renderIcon = function (iconName, iconsProvider, behaviours) {
      return render$3(iconName, {
        tag: 'span',
        classes: [
          'tox-icon',
          'tox-tbtn__icon-wrap'
        ],
        behaviours: behaviours
      }, iconsProvider);
    };
    var renderIconFromPack = function (iconName, iconsProvider) {
      return renderIcon(iconName, iconsProvider, []);
    };
    var renderReplacableIconFromPack = function (iconName, iconsProvider) {
      return renderIcon(iconName, iconsProvider, [Replacing.config({})]);
    };
    var renderLabel$1 = function (text, prefix, providersBackstage) {
      return {
        dom: {
          tag: 'span',
          innerHtml: providersBackstage.translate(text),
          classes: [prefix + '__select-label']
        },
        behaviours: derive$1([Replacing.config({})])
      };
    };

    var _a;
    var internalToolbarButtonExecute = generate$6('toolbar.button.execute');
    var onToolbarButtonExecute = function (info) {
      return runOnExecute$1(function (comp, _simulatedEvent) {
        runWithApi(info, comp)(function (itemApi) {
          emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });
          info.onAction(itemApi);
        });
      });
    };
    var toolbarButtonEventOrder = (_a = {}, _a[execute$5()] = [
      'disabling',
      'alloy.base.behaviour',
      'toggling',
      'toolbar-button-events'
    ], _a);

    var updateMenuText = generate$6('update-menu-text');
    var updateMenuIcon = generate$6('update-menu-icon');
    var renderCommonDropdown = function (spec, prefix, sharedBackstage) {
      var editorOffCell = Cell(noop);
      var optMemDisplayText = spec.text.map(function (text) {
        return record(renderLabel$1(text, prefix, sharedBackstage.providers));
      });
      var optMemDisplayIcon = spec.icon.map(function (iconName) {
        return record(renderReplacableIconFromPack(iconName, sharedBackstage.providers.icons));
      });
      var onLeftOrRightInMenu = function (comp, se) {
        var dropdown = Representing.getValue(comp);
        Focusing.focus(dropdown);
        emitWith(dropdown, 'keydown', { raw: se.event.raw });
        Dropdown.close(dropdown);
        return Optional.some(true);
      };
      var role = spec.role.fold(function () {
        return {};
      }, function (role) {
        return { role: role };
      });
      var tooltipAttributes = spec.tooltip.fold(function () {
        return {};
      }, function (tooltip) {
        var translatedTooltip = sharedBackstage.providers.translate(tooltip);
        return {
          'title': translatedTooltip,
          'aria-label': translatedTooltip
        };
      });
      var iconSpec = render$3('chevron-down', {
        tag: 'div',
        classes: [prefix + '__select-chevron']
      }, sharedBackstage.providers.icons);
      var memDropdown = record(Dropdown.sketch(__assign(__assign(__assign({}, spec.uid ? { uid: spec.uid } : {}), role), {
        dom: {
          tag: 'button',
          classes: [
            prefix,
            prefix + '--select'
          ].concat(map$2(spec.classes, function (c) {
            return prefix + '--' + c;
          })),
          attributes: __assign({}, tooltipAttributes)
        },
        components: componentRenderPipeline([
          optMemDisplayIcon.map(function (mem) {
            return mem.asSpec();
          }),
          optMemDisplayText.map(function (mem) {
            return mem.asSpec();
          }),
          Optional.some(iconSpec)
        ]),
        matchWidth: true,
        useMinWidth: true,
        dropdownBehaviours: derive$1(__spreadArray(__spreadArray([], spec.dropdownBehaviours, true), [
          DisablingConfigs.button(function () {
            return spec.disabled || sharedBackstage.providers.isDisabled();
          }),
          receivingConfig(),
          Unselecting.config({}),
          Replacing.config({}),
          config('dropdown-events', [
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell)
          ]),
          config('menubutton-update-display-text', [
            run$1(updateMenuText, function (comp, se) {
              optMemDisplayText.bind(function (mem) {
                return mem.getOpt(comp);
              }).each(function (displayText) {
                Replacing.set(displayText, [text(sharedBackstage.providers.translate(se.event.text))]);
              });
            }),
            run$1(updateMenuIcon, function (comp, se) {
              optMemDisplayIcon.bind(function (mem) {
                return mem.getOpt(comp);
              }).each(function (displayIcon) {
                Replacing.set(displayIcon, [renderReplacableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);
              });
            })
          ])
        ], false)),
        eventOrder: deepMerge(toolbarButtonEventOrder, {
          mousedown: [
            'focusing',
            'alloy.base.behaviour',
            'item-type-events',
            'normal-dropdown-events'
          ]
        }),
        sandboxBehaviours: derive$1([Keying.config({
            mode: 'special',
            onLeft: onLeftOrRightInMenu,
            onRight: onLeftOrRightInMenu
          })]),
        lazySink: sharedBackstage.getSink,
        toggleClass: prefix + '--active',
        parts: { menu: part(false, spec.columns, spec.presets) },
        fetch: function (comp) {
          return Future.nu(curry(spec.fetch, comp));
        }
      })));
      return memDropdown.asSpec();
    };

    var isMenuItemReference = function (item) {
      return isString(item);
    };
    var isSeparator$1 = function (item) {
      return item.type === 'separator';
    };
    var isExpandingMenuItem = function (item) {
      return has$2(item, 'getSubmenuItems');
    };
    var separator$2 = { type: 'separator' };
    var unwrapReferences = function (items, menuItems) {
      var realItems = foldl(items, function (acc, item) {
        if (isMenuItemReference(item)) {
          if (item === '') {
            return acc;
          } else if (item === '|') {
            return acc.length > 0 && !isSeparator$1(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;
          } else if (has$2(menuItems, item.toLowerCase())) {
            return acc.concat([menuItems[item.toLowerCase()]]);
          } else {
            return acc;
          }
        } else {
          return acc.concat([item]);
        }
      }, []);
      if (realItems.length > 0 && isSeparator$1(realItems[realItems.length - 1])) {
        realItems.pop();
      }
      return realItems;
    };
    var getFromExpandingItem = function (item, menuItems) {
      var submenuItems = item.getSubmenuItems();
      var rest = expand(submenuItems, menuItems);
      var newMenus = deepMerge(rest.menus, wrap$1(item.value, rest.items));
      var newExpansions = deepMerge(rest.expansions, wrap$1(item.value, item.value));
      return {
        item: item,
        menus: newMenus,
        expansions: newExpansions
      };
    };
    var getFromItem = function (item, menuItems) {
      return isExpandingMenuItem(item) ? getFromExpandingItem(item, menuItems) : {
        item: item,
        menus: {},
        expansions: {}
      };
    };
    var generateValueIfRequired = function (item) {
      if (isSeparator$1(item)) {
        return item;
      } else {
        var itemValue = get$e(item, 'value').getOrThunk(function () {
          return generate$6('generated-menu-item');
        });
        return deepMerge({ value: itemValue }, item);
      }
    };
    var expand = function (items, menuItems) {
      var realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);
      return foldr(realItems, function (acc, item) {
        var itemWithValue = generateValueIfRequired(item);
        var newData = getFromItem(itemWithValue, menuItems);
        return {
          menus: deepMerge(acc.menus, newData.menus),
          items: [newData.item].concat(acc.items),
          expansions: deepMerge(acc.expansions, newData.expansions)
        };
      }, {
        menus: {},
        expansions: {},
        items: []
      });
    };

    var build = function (items, itemResponse, backstage, isHorizontalMenu) {
      var primary = generate$6('primary-menu');
      var data = expand(items, backstage.shared.providers.menuItems());
      if (data.items.length === 0) {
        return Optional.none();
      }
      var mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, isHorizontalMenu);
      var submenus = map$1(data.menus, function (menuItems, menuName) {
        return createPartialMenu(menuName, menuItems, itemResponse, backstage, false);
      });
      var menus = deepMerge(submenus, wrap$1(primary, mainMenu));
      return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));
    };

    var getMenuButtonApi = function (component) {
      return {
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        },
        setActive: function (state) {
          var elm = component.element;
          if (state) {
            add$2(elm, 'tox-tbtn--enabled');
            set$8(elm, 'aria-pressed', true);
          } else {
            remove$2(elm, 'tox-tbtn--enabled');
            remove$7(elm, 'aria-pressed');
          }
        },
        isActive: function () {
          return has(component.element, 'tox-tbtn--enabled');
        }
      };
    };
    var renderMenuButton = function (spec, prefix, backstage, role) {
      return renderCommonDropdown({
        text: spec.text,
        icon: spec.icon,
        tooltip: spec.tooltip,
        role: role,
        fetch: function (_comp, callback) {
          spec.fetch(function (items) {
            callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));
          });
        },
        onSetup: spec.onSetup,
        getApi: getMenuButtonApi,
        columns: 1,
        presets: 'normal',
        classes: [],
        dropdownBehaviours: [Tabstopping.config({})]
      }, prefix, backstage.shared);
    };
    var getFetch = function (items, getButton, backstage) {
      var getMenuItemAction = function (item) {
        return function (api) {
          var newValue = !api.isActive();
          api.setActive(newValue);
          item.storage.set(newValue);
          backstage.shared.getSink().each(function (sink) {
            getButton().getOpt(sink).each(function (orig) {
              focus$3(orig.element);
              emitWith(orig, formActionEvent, {
                name: item.name,
                value: item.storage.get()
              });
            });
          });
        };
      };
      var getMenuItemSetup = function (item) {
        return function (api) {
          api.setActive(item.storage.get());
        };
      };
      return function (success) {
        success(map$2(items, function (item) {
          var text = item.text.fold(function () {
            return {};
          }, function (text) {
            return { text: text };
          });
          return __assign(__assign({
            type: item.type,
            active: false
          }, text), {
            onAction: getMenuItemAction(item),
            onSetup: getMenuItemSetup(item)
          });
        }));
      };
    };

    var renderCommonSpec = function (spec, actionOpt, extraBehaviours, dom, components, providersBackstage) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var action = actionOpt.fold(function () {
        return {};
      }, function (action) {
        return { action: action };
      });
      var common = __assign({
        buttonBehaviours: derive$1([
          DisablingConfigs.button(function () {
            return spec.disabled || providersBackstage.isDisabled();
          }),
          receivingConfig(),
          Tabstopping.config({}),
          config('button press', [
            preventDefault('click'),
            preventDefault('mousedown')
          ])
        ].concat(extraBehaviours)),
        eventOrder: {
          click: [
            'button press',
            'alloy.base.behaviour'
          ],
          mousedown: [
            'button press',
            'alloy.base.behaviour'
          ]
        }
      }, action);
      var domFinal = deepMerge(common, { dom: dom });
      return deepMerge(domFinal, { components: components });
    };
    var renderIconButtonSpec = function (spec, action, providersBackstage, extraBehaviours) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var tooltipAttributes = spec.tooltip.map(function (tooltip) {
        return {
          'aria-label': providersBackstage.translate(tooltip),
          'title': providersBackstage.translate(tooltip)
        };
      }).getOr({});
      var dom = {
        tag: 'button',
        classes: ['tox-tbtn'],
        attributes: tooltipAttributes
      };
      var icon = spec.icon.map(function (iconName) {
        return renderIconFromPack(iconName, providersBackstage.icons);
      });
      var components = componentRenderPipeline([icon]);
      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    var renderIconButton = function (spec, action, providersBackstage, extraBehaviours) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var iconButtonSpec = renderIconButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours);
      return Button.sketch(iconButtonSpec);
    };
    var renderButtonSpec = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      if (extraClasses === void 0) {
        extraClasses = [];
      }
      var translatedText = providersBackstage.translate(spec.text);
      var icon = spec.icon ? spec.icon.map(function (iconName) {
        return renderIconFromPack(iconName, providersBackstage.icons);
      }) : Optional.none();
      var components = icon.isSome() ? componentRenderPipeline([icon]) : [];
      var innerHtml = icon.isSome() ? {} : { innerHtml: translatedText };
      var classes = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], !spec.primary && !spec.borderless ? [
        'tox-button',
        'tox-button--secondary'
      ] : ['tox-button'], true), icon.isSome() ? ['tox-button--icon'] : [], true), spec.borderless ? ['tox-button--naked'] : [], true), extraClasses, true);
      var dom = __assign(__assign({
        tag: 'button',
        classes: classes
      }, innerHtml), { attributes: { title: translatedText } });
      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    var renderButton = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      if (extraClasses === void 0) {
        extraClasses = [];
      }
      var buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);
      return Button.sketch(buttonSpec);
    };
    var getAction = function (name, buttonType) {
      return function (comp) {
        if (buttonType === 'custom') {
          emitWith(comp, formActionEvent, {
            name: name,
            value: {}
          });
        } else if (buttonType === 'submit') {
          emit(comp, formSubmitEvent);
        } else if (buttonType === 'cancel') {
          emit(comp, formCancelEvent);
        } else {
          console.error('Unknown button type: ', buttonType);
        }
      };
    };
    var isMenuFooterButtonSpec = function (spec, buttonType) {
      return buttonType === 'menu';
    };
    var isNormalFooterButtonSpec = function (spec, buttonType) {
      return buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit';
    };
    var renderFooterButton = function (spec, buttonType, backstage) {
      if (isMenuFooterButtonSpec(spec, buttonType)) {
        var getButton = function () {
          return memButton_1;
        };
        var menuButtonSpec = spec;
        var fixedSpec = __assign(__assign({}, spec), {
          onSetup: function (api) {
            api.setDisabled(spec.disabled);
            return noop;
          },
          fetch: getFetch(menuButtonSpec.items, getButton, backstage)
        });
        var memButton_1 = record(renderMenuButton(fixedSpec, 'tox-tbtn', backstage, Optional.none()));
        return memButton_1.asSpec();
      } else if (isNormalFooterButtonSpec(spec, buttonType)) {
        var action = getAction(spec.name, buttonType);
        var buttonSpec = __assign(__assign({}, spec), { borderless: false });
        return renderButton(buttonSpec, action, backstage.shared.providers, []);
      } else {
        console.error('Unknown footer button type: ', buttonType);
      }
    };
    var renderDialogButton = function (spec, providersBackstage) {
      var action = getAction(spec.name, 'custom');
      return renderFormField(Optional.none(), FormField.parts.field(__assign({ factory: Button }, renderButtonSpec(spec, Optional.some(action), providersBackstage, [
        RepresentingConfigs.memory(''),
        ComposingConfigs.self()
      ]))));
    };

    var schema$h = constant$1([
      defaulted('field1Name', 'field1'),
      defaulted('field2Name', 'field2'),
      onStrictHandler('onLockedChange'),
      markers$1(['lockClass']),
      defaulted('locked', false),
      SketchBehaviours.field('coupledFieldBehaviours', [
        Composing,
        Representing
      ])
    ]);
    var getField = function (comp, detail, partName) {
      return getPart(comp, detail, partName).bind(Composing.getCurrent);
    };
    var coupledPart = function (selfName, otherName) {
      return required({
        factory: FormField,
        name: selfName,
        overrides: function (detail) {
          return {
            fieldBehaviours: derive$1([config('coupled-input-behaviour', [run$1(input(), function (me) {
                  getField(me, detail, otherName).each(function (other) {
                    getPart(me, detail, 'lock').each(function (lock) {
                      if (Toggling.isOn(lock)) {
                        detail.onLockedChange(me, other, lock);
                      }
                    });
                  });
                })])])
          };
        }
      });
    };
    var parts$c = constant$1([
      coupledPart('field1', 'field2'),
      coupledPart('field2', 'field1'),
      required({
        factory: Button,
        schema: [required$1('dom')],
        name: 'lock',
        overrides: function (detail) {
          return {
            buttonBehaviours: derive$1([Toggling.config({
                selected: detail.locked,
                toggleClass: detail.markers.lockClass,
                aria: { mode: 'pressed' }
              })])
          };
        }
      })
    ]);

    var factory$f = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [
          Composing.config({ find: Optional.some }),
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function (comp) {
                var _a;
                var parts = getPartsOrDie(comp, detail, [
                  'field1',
                  'field2'
                ]);
                return _a = {}, _a[detail.field1Name] = Representing.getValue(parts.field1()), _a[detail.field2Name] = Representing.getValue(parts.field2()), _a;
              },
              setValue: function (comp, value) {
                var parts = getPartsOrDie(comp, detail, [
                  'field1',
                  'field2'
                ]);
                if (hasNonNullableKey(value, detail.field1Name)) {
                  Representing.setValue(parts.field1(), value[detail.field1Name]);
                }
                if (hasNonNullableKey(value, detail.field2Name)) {
                  Representing.setValue(parts.field2(), value[detail.field2Name]);
                }
              }
            }
          })
        ]),
        apis: {
          getField1: function (component) {
            return getPart(component, detail, 'field1');
          },
          getField2: function (component) {
            return getPart(component, detail, 'field2');
          },
          getLock: function (component) {
            return getPart(component, detail, 'lock');
          }
        }
      };
    };
    var FormCoupledInputs = composite({
      name: 'FormCoupledInputs',
      configFields: schema$h(),
      partFields: parts$c(),
      factory: factory$f,
      apis: {
        getField1: function (apis, component) {
          return apis.getField1(component);
        },
        getField2: function (apis, component) {
          return apis.getField2(component);
        },
        getLock: function (apis, component) {
          return apis.getLock(component);
        }
      }
    });

    var formatSize = function (size) {
      var unitDec = {
        '': 0,
        'px': 0,
        'pt': 1,
        'mm': 1,
        'pc': 2,
        'ex': 2,
        'em': 2,
        'ch': 2,
        'rem': 2,
        'cm': 3,
        'in': 4,
        '%': 4
      };
      var maxDecimal = function (unit) {
        return unit in unitDec ? unitDec[unit] : 1;
      };
      var numText = size.value.toFixed(maxDecimal(size.unit));
      if (numText.indexOf('.') !== -1) {
        numText = numText.replace(/\.?0*$/, '');
      }
      return numText + size.unit;
    };
    var parseSize = function (sizeText) {
      var numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
      var match = numPattern.exec(sizeText);
      if (match !== null) {
        var value = parseFloat(match[1]);
        var unit = match[2];
        return Result.value({
          value: value,
          unit: unit
        });
      } else {
        return Result.error(sizeText);
      }
    };
    var convertUnit = function (size, unit) {
      var inInch = {
        '': 96,
        'px': 96,
        'pt': 72,
        'cm': 2.54,
        'pc': 12,
        'mm': 25.4,
        'in': 1
      };
      var supported = function (u) {
        return has$2(inInch, u);
      };
      if (size.unit === unit) {
        return Optional.some(size.value);
      } else if (supported(size.unit) && supported(unit)) {
        if (inInch[size.unit] === inInch[unit]) {
          return Optional.some(size.value);
        } else {
          return Optional.some(size.value / inInch[size.unit] * inInch[unit]);
        }
      } else {
        return Optional.none();
      }
    };
    var noSizeConversion = function (_input) {
      return Optional.none();
    };
    var ratioSizeConversion = function (scale, unit) {
      return function (size) {
        return convertUnit(size, unit).map(function (value) {
          return {
            value: value * scale,
            unit: unit
          };
        });
      };
    };
    var makeRatioConverter = function (currentFieldText, otherFieldText) {
      var cValue = parseSize(currentFieldText).toOptional();
      var oValue = parseSize(otherFieldText).toOptional();
      return lift2(cValue, oValue, function (cSize, oSize) {
        return convertUnit(cSize, oSize.unit).map(function (val) {
          return oSize.value / val;
        }).map(function (r) {
          return ratioSizeConversion(r, oSize.unit);
        }).getOr(noSizeConversion);
      }).getOr(noSizeConversion);
    };

    var renderSizeInput = function (spec, providersBackstage) {
      var converter = noSizeConversion;
      var ratioEvent = generate$6('ratio-event');
      var makeIcon = function (iconName) {
        return render$3(iconName, {
          tag: 'span',
          classes: [
            'tox-icon',
            'tox-lock-icon__' + iconName
          ]
        }, providersBackstage.icons);
      };
      var pLock = FormCoupledInputs.parts.lock({
        dom: {
          tag: 'button',
          classes: [
            'tox-lock',
            'tox-button',
            'tox-button--naked',
            'tox-button--icon'
          ],
          attributes: { title: providersBackstage.translate(spec.label.getOr('Constrain proportions')) }
        },
        components: [
          makeIcon('lock'),
          makeIcon('unlock')
        ],
        buttonBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            }
          }),
          receivingConfig(),
          Tabstopping.config({})
        ])
      });
      var formGroup = function (components) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-form__group']
          },
          components: components
        };
      };
      var getFieldPart = function (isField1) {
        return FormField.parts.field({
          factory: Input,
          inputClasses: ['tox-textfield'],
          inputBehaviours: derive$1([
            Disabling.config({
              disabled: function () {
                return spec.disabled || providersBackstage.isDisabled();
              }
            }),
            receivingConfig(),
            Tabstopping.config({}),
            config('size-input-events', [
              run$1(focusin(), function (component, _simulatedEvent) {
                emitWith(component, ratioEvent, { isField1: isField1 });
              }),
              run$1(change(), function (component, _simulatedEvent) {
                emitWith(component, formChangeEvent, { name: spec.name });
              })
            ])
          ]),
          selectOnFocus: false
        });
      };
      var getLabel = function (label) {
        return {
          dom: {
            tag: 'label',
            classes: ['tox-label'],
            innerHtml: providersBackstage.translate(label)
          }
        };
      };
      var widthField = FormCoupledInputs.parts.field1(formGroup([
        FormField.parts.label(getLabel('Width')),
        getFieldPart(true)
      ]));
      var heightField = FormCoupledInputs.parts.field2(formGroup([
        FormField.parts.label(getLabel('Height')),
        getFieldPart(false)
      ]));
      return FormCoupledInputs.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-form__group']
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-form__controls-h-stack']
            },
            components: [
              widthField,
              heightField,
              formGroup([
                getLabel('&nbsp;'),
                pLock
              ])
            ]
          }],
        field1Name: 'width',
        field2Name: 'height',
        locked: true,
        markers: { lockClass: 'tox-locked' },
        onLockedChange: function (current, other, _lock) {
          parseSize(Representing.getValue(current)).each(function (size) {
            converter(size).each(function (newSize) {
              Representing.setValue(other, formatSize(newSize));
            });
          });
        },
        coupledFieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            },
            onDisabled: function (comp) {
              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
              FormCoupledInputs.getLock(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
              FormCoupledInputs.getLock(comp).each(Disabling.enable);
            }
          }),
          receivingConfig(),
          config('size-input-events2', [run$1(ratioEvent, function (component, simulatedEvent) {
              var isField1 = simulatedEvent.event.isField1;
              var optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
              var optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
              var value1 = optCurrent.map(Representing.getValue).getOr('');
              var value2 = optOther.map(Representing.getValue).getOr('');
              converter = makeRatioConverter(value1, value2);
            })])
        ])
      });
    };

    var undo = constant$1(generate$6('undo'));
    var redo = constant$1(generate$6('redo'));
    var zoom = constant$1(generate$6('zoom'));
    var back = constant$1(generate$6('back'));
    var apply = constant$1(generate$6('apply'));
    var swap = constant$1(generate$6('swap'));
    var transform$1 = constant$1(generate$6('transform'));
    var tempTransform = constant$1(generate$6('temp-transform'));
    var transformApply = constant$1(generate$6('transform-apply'));
    var internal = {
      undo: undo,
      redo: redo,
      zoom: zoom,
      back: back,
      apply: apply,
      swap: swap,
      transform: transform$1,
      tempTransform: tempTransform,
      transformApply: transformApply
    };
    var saveState = constant$1('save-state');
    var disable = constant$1('disable');
    var enable = constant$1('enable');
    var external = {
      formActionEvent: formActionEvent,
      saveState: saveState,
      disable: disable,
      enable: enable
    };

    var renderEditPanel = function (imagePanel, providersBackstage) {
      var createButton = function (text, action, disabled, primary) {
        return record(renderButton({
          name: text,
          text: text,
          disabled: disabled,
          primary: primary,
          icon: Optional.none(),
          borderless: false
        }, action, providersBackstage));
      };
      var createIconButton = function (icon, tooltip, action, disabled) {
        return record(renderIconButton({
          name: icon,
          icon: Optional.some(icon),
          tooltip: Optional.some(tooltip),
          disabled: disabled,
          primary: false,
          borderless: false
        }, action, providersBackstage));
      };
      var disableAllComponents = function (comps, eventcomp) {
        comps.map(function (mem) {
          var component = mem.get(eventcomp);
          if (component.hasConfigured(Disabling)) {
            Disabling.disable(component);
          }
        });
      };
      var enableAllComponents = function (comps, eventcomp) {
        comps.map(function (mem) {
          var component = mem.get(eventcomp);
          if (component.hasConfigured(Disabling)) {
            Disabling.enable(component);
          }
        });
      };
      var panelDom = {
        tag: 'div',
        classes: [
          'tox-image-tools__toolbar',
          'tox-image-tools-edit-panel'
        ]
      };
      var noop$1 = noop;
      var emit$1 = function (comp, event, data) {
        emitWith(comp, event, data);
      };
      var emitDisable = function (component) {
        return emit(component, external.disable());
      };
      var emitEnable = function (component) {
        return emit(component, external.enable());
      };
      var emitTransform = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.transform(), { transform: transform });
        emitEnable(comp);
      };
      var emitTempTransform = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.tempTransform(), { transform: transform });
        emitEnable(comp);
      };
      var getBackSwap = function (anyInSystem) {
        return function () {
          memContainer.getOpt(anyInSystem).each(function (container) {
            Replacing.set(container, [ButtonPanel]);
          });
        };
      };
      var emitTransformApply = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.transformApply(), {
          transform: transform,
          swap: getBackSwap(comp)
        });
        emitEnable(comp);
      };
      var createBackButton = function () {
        return createButton('Back', function (button) {
          return emit$1(button, internal.back(), { swap: getBackSwap(button) });
        }, false, false);
      };
      var createSpacer = function () {
        return record({
          dom: {
            tag: 'div',
            classes: ['tox-spacer']
          },
          behaviours: derive$1([Disabling.config({})])
        });
      };
      var createApplyButton = function () {
        return createButton('Apply', function (button) {
          return emit$1(button, internal.apply(), { swap: getBackSwap(button) });
        }, true, true);
      };
      var makeCropTransform = function () {
        return function (ir) {
          var rect = imagePanel.getRect();
          return crop(ir, rect.x, rect.y, rect.w, rect.h);
        };
      };
      var cropPanelComponents = [
        createBackButton(),
        createSpacer(),
        createButton('Apply', function (button) {
          var transform = makeCropTransform();
          emitTransformApply(button, transform);
          imagePanel.hideCrop();
        }, false, true)
      ];
      var CropPanel = Container.sketch({
        dom: panelDom,
        components: cropPanelComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config('image-tools-crop-buttons-events', [
            run$1(external.disable(), function (comp, _se) {
              disableAllComponents(cropPanelComponents, comp);
            }),
            run$1(external.enable(), function (comp, _se) {
              enableAllComponents(cropPanelComponents, comp);
            })
          ])])
      });
      var memSize = record(renderSizeInput({
        name: 'size',
        label: Optional.none(),
        constrain: true,
        disabled: false
      }, providersBackstage));
      var makeResizeTransform = function (width, height) {
        return function (ir) {
          return resize$1(ir, width, height);
        };
      };
      var resizePanelComponents = [
        createBackButton(),
        createSpacer(),
        memSize,
        createSpacer(),
        createButton('Apply', function (button) {
          memSize.getOpt(button).each(function (sizeInput) {
            var value = Representing.getValue(sizeInput);
            var width = parseInt(value.width, 10);
            var height = parseInt(value.height, 10);
            var transform = makeResizeTransform(width, height);
            emitTransformApply(button, transform);
          });
        }, false, true)
      ];
      var ResizePanel = Container.sketch({
        dom: panelDom,
        components: resizePanelComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config('image-tools-resize-buttons-events', [
            run$1(external.disable(), function (comp, _se) {
              disableAllComponents(resizePanelComponents, comp);
            }),
            run$1(external.enable(), function (comp, _se) {
              enableAllComponents(resizePanelComponents, comp);
            })
          ])])
      });
      var makeValueTransform = function (transform, value) {
        return function (ir) {
          return transform(ir, value);
        };
      };
      var horizontalFlip = makeValueTransform(flip, 'h');
      var verticalFlip = makeValueTransform(flip, 'v');
      var counterclockwiseRotate = makeValueTransform(rotate, -90);
      var clockwiseRotate = makeValueTransform(rotate, 90);
      var flipRotateOnAction = function (comp, operation) {
        emitTempTransform(comp, operation);
      };
      var flipRotateComponents = [
        createBackButton(),
        createSpacer(),
        createIconButton('flip-horizontally', 'Flip horizontally', function (button) {
          flipRotateOnAction(button, horizontalFlip);
        }, false),
        createIconButton('flip-vertically', 'Flip vertically', function (button) {
          flipRotateOnAction(button, verticalFlip);
        }, false),
        createIconButton('rotate-left', 'Rotate counterclockwise', function (button) {
          flipRotateOnAction(button, counterclockwiseRotate);
        }, false),
        createIconButton('rotate-right', 'Rotate clockwise', function (button) {
          flipRotateOnAction(button, clockwiseRotate);
        }, false),
        createSpacer(),
        createApplyButton()
      ];
      var FlipRotatePanel = Container.sketch({
        dom: panelDom,
        components: flipRotateComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config('image-tools-fliprotate-buttons-events', [
            run$1(external.disable(), function (comp, _se) {
              disableAllComponents(flipRotateComponents, comp);
            }),
            run$1(external.enable(), function (comp, _se) {
              enableAllComponents(flipRotateComponents, comp);
            })
          ])])
      });
      var makeSlider = function (label, onChoose, min, value, max) {
        var labelPart = Slider.parts.label({
          dom: {
            tag: 'label',
            classes: ['tox-label'],
            innerHtml: providersBackstage.translate(label)
          }
        });
        var spectrum = Slider.parts.spectrum({
          dom: {
            tag: 'div',
            classes: ['tox-slider__rail'],
            attributes: { role: 'presentation' }
          }
        });
        var thumb = Slider.parts.thumb({
          dom: {
            tag: 'div',
            classes: ['tox-slider__handle'],
            attributes: { role: 'presentation' }
          }
        });
        return record(Slider.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-slider'],
            attributes: { role: 'presentation' }
          },
          model: {
            mode: 'x',
            minX: min,
            maxX: max,
            getInitialValue: constant$1({ x: value })
          },
          components: [
            labelPart,
            spectrum,
            thumb
          ],
          sliderBehaviours: derive$1([Focusing.config({})]),
          onChoose: onChoose
        }));
      };
      var makeVariableSlider = function (label, transform, min, value, max) {
        var onChoose = function (slider, _thumb, value) {
          var valTransform = makeValueTransform(transform, value.x / 100);
          emitTransform(slider, valTransform);
        };
        return makeSlider(label, onChoose, min, value, max);
      };
      var variableFilterPanelComponents = function (label, transform, min, value, max) {
        return [
          createBackButton(),
          makeVariableSlider(label, transform, min, value, max),
          createApplyButton()
        ];
      };
      var createVariableFilterPanel = function (label, transform, min, value, max) {
        var filterPanelComponents = variableFilterPanelComponents(label, transform, min, value, max);
        return Container.sketch({
          dom: panelDom,
          components: filterPanelComponents.map(function (mem) {
            return mem.asSpec();
          }),
          containerBehaviours: derive$1([config('image-tools-filter-panel-buttons-events', [
              run$1(external.disable(), function (comp, _se) {
                disableAllComponents(filterPanelComponents, comp);
              }),
              run$1(external.enable(), function (comp, _se) {
                enableAllComponents(filterPanelComponents, comp);
              })
            ])])
        });
      };
      var filterPanelComponents = [
        createBackButton(),
        createSpacer(),
        createApplyButton()
      ];
      var FilterPanel = Container.sketch({
        dom: panelDom,
        components: filterPanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var BrightnessPanel = createVariableFilterPanel('Brightness', brightness, -100, 0, 100);
      var ContrastPanel = createVariableFilterPanel('Contrast', contrast, -100, 0, 100);
      var GammaPanel = createVariableFilterPanel('Gamma', gamma, -100, 0, 100);
      var makeColorTransform = function (red, green, blue) {
        return function (ir) {
          return colorize(ir, red, green, blue);
        };
      };
      var makeColorSlider = function (label) {
        var onChoose = function (slider, _thumb, _value) {
          var redOpt = memRed.getOpt(slider);
          var blueOpt = memBlue.getOpt(slider);
          var greenOpt = memGreen.getOpt(slider);
          redOpt.each(function (red) {
            blueOpt.each(function (blue) {
              greenOpt.each(function (green) {
                var r = Representing.getValue(red).x / 100;
                var g = Representing.getValue(green).x / 100;
                var b = Representing.getValue(blue).x / 100;
                var transform = makeColorTransform(r, g, b);
                emitTransform(slider, transform);
              });
            });
          });
        };
        return makeSlider(label, onChoose, 0, 100, 200);
      };
      var memRed = makeColorSlider('R');
      var memGreen = makeColorSlider('G');
      var memBlue = makeColorSlider('B');
      var colorizePanelComponents = [
        createBackButton(),
        memRed,
        memGreen,
        memBlue,
        createApplyButton()
      ];
      var ColorizePanel = Container.sketch({
        dom: panelDom,
        components: colorizePanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var getTransformPanelEvent = function (panel, transform, update) {
        return function (button) {
          var swap = function () {
            memContainer.getOpt(button).each(function (container) {
              Replacing.set(container, [panel]);
              update(container);
            });
          };
          emit$1(button, internal.swap(), {
            transform: transform,
            swap: swap
          });
        };
      };
      var cropPanelUpdate = function (_anyInSystem) {
        imagePanel.showCrop();
      };
      var resizePanelUpdate = function (anyInSystem) {
        memSize.getOpt(anyInSystem).each(function (sizeInput) {
          var measurements = imagePanel.getMeasurements();
          var width = measurements.width;
          var height = measurements.height;
          Representing.setValue(sizeInput, {
            width: width,
            height: height
          });
        });
      };
      var sharpenTransform = Optional.some(sharpen);
      var invertTransform = Optional.some(invert);
      var buttonPanelComponents = [
        createIconButton('crop', 'Crop', getTransformPanelEvent(CropPanel, Optional.none(), cropPanelUpdate), false),
        createIconButton('resize', 'Resize', getTransformPanelEvent(ResizePanel, Optional.none(), resizePanelUpdate), false),
        createIconButton('orientation', 'Orientation', getTransformPanelEvent(FlipRotatePanel, Optional.none(), noop$1), false),
        createIconButton('brightness', 'Brightness', getTransformPanelEvent(BrightnessPanel, Optional.none(), noop$1), false),
        createIconButton('sharpen', 'Sharpen', getTransformPanelEvent(FilterPanel, sharpenTransform, noop$1), false),
        createIconButton('contrast', 'Contrast', getTransformPanelEvent(ContrastPanel, Optional.none(), noop$1), false),
        createIconButton('color-levels', 'Color levels', getTransformPanelEvent(ColorizePanel, Optional.none(), noop$1), false),
        createIconButton('gamma', 'Gamma', getTransformPanelEvent(GammaPanel, Optional.none(), noop$1), false),
        createIconButton('invert', 'Invert', getTransformPanelEvent(FilterPanel, invertTransform, noop$1), false)
      ];
      var ButtonPanel = Container.sketch({
        dom: panelDom,
        components: buttonPanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var container = Container.sketch({
        dom: { tag: 'div' },
        components: [ButtonPanel],
        containerBehaviours: derive$1([Replacing.config({})])
      });
      var memContainer = record(container);
      var getApplyButton = function (anyInSystem) {
        return memContainer.getOpt(anyInSystem).map(function (container) {
          var panel = container.components()[0];
          return panel.components()[panel.components().length - 1];
        });
      };
      return {
        memContainer: memContainer,
        getApplyButton: getApplyButton
      };
    };

    var global$4 = tinymce.util.Tools.resolve('tinymce.geom.Rect');

    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Observable');

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.VK');

    var getDocumentSize = function (doc) {
      var max = Math.max;
      var documentElement = doc.documentElement;
      var body = doc.body;
      var scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
      var clientWidth = max(documentElement.clientWidth, body.clientWidth);
      var offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
      var scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
      var clientHeight = max(documentElement.clientHeight, body.clientHeight);
      var offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
      return {
        width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
        height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
      };
    };
    var isTouchEvent$1 = function (e) {
      return isNonNullable(e.changedTouches);
    };
    var updateWithTouchData = function (e) {
      if (isTouchEvent$1(e)) {
        var keys = 'screenX screenY pageX pageY clientX clientY'.split(' ');
        for (var i = 0; i < keys.length; i++) {
          e[keys[i]] = e.changedTouches[0][keys[i]];
        }
      }
    };
    function DragHelper (id, settings) {
      var _a, _b, _c;
      var eventOverlay;
      var handleEvents = [];
      var overlayEvents = [];
      var doc = (_a = settings.document) !== null && _a !== void 0 ? _a : document;
      var root = (_b = settings.root) !== null && _b !== void 0 ? _b : doc;
      var sugarDoc = SugarElement.fromDom(doc);
      var downButton;
      var startX;
      var startY;
      var handleElement = SugarElement.fromDom(root.getElementById((_c = settings.handle) !== null && _c !== void 0 ? _c : id));
      var start = function (e) {
        var rawEvent = e.raw;
        var docSize = getDocumentSize(doc);
        updateWithTouchData(rawEvent);
        e.prevent();
        downButton = rawEvent.button;
        startX = rawEvent.screenX;
        startY = rawEvent.screenY;
        var cursor = get$c(handleElement, 'cursor');
        eventOverlay = SugarElement.fromTag('div', doc);
        setAll(eventOverlay, {
          'position': 'absolute',
          'top': '0',
          'left': '0',
          'width': docSize.width + 'px',
          'height': docSize.height + 'px',
          'z-index': 2147483647 + '',
          'opacity': '0.0001',
          cursor: cursor
        });
        append$2(getBody(sugarDoc), eventOverlay);
        overlayEvents.push(bind(sugarDoc, 'mousemove', drag), bind(sugarDoc, 'touchmove', drag), bind(sugarDoc, 'mouseup', stop), bind(sugarDoc, 'touchend', stop));
        settings.start(rawEvent);
      };
      var drag = function (e) {
        var rawEvent = e.raw;
        updateWithTouchData(rawEvent);
        if (rawEvent.button !== downButton) {
          return stop(e);
        }
        rawEvent.deltaX = rawEvent.screenX - startX;
        rawEvent.deltaY = rawEvent.screenY - startY;
        e.prevent();
        settings.drag(rawEvent);
      };
      var stop = function (e) {
        updateWithTouchData(e.raw);
        each$1(overlayEvents, function (e) {
          return e.unbind();
        });
        overlayEvents = [];
        remove$5(eventOverlay);
        if (settings.stop) {
          settings.stop(e.raw);
        }
      };
      var destroy = function () {
        each$1(overlayEvents.concat(handleEvents), function (e) {
          return e.unbind();
        });
        overlayEvents = [];
        handleEvents = [];
        if (isNonNullable(eventOverlay)) {
          remove$5(eventOverlay);
        }
      };
      handleEvents.push(bind(handleElement, 'mousedown', start), bind(handleElement, 'touchstart', start));
      return { destroy: destroy };
    }

    var count = 0;
    var create$1 = function (currentRect, viewPortRect, clampRect, containerElm, action) {
      var dragHelpers;
      var events = [];
      var prefix = 'tox-';
      var id = prefix + 'crid-' + count++;
      var container = SugarElement.fromDom(containerElm);
      var handles = [
        {
          name: 'move',
          xMul: 0,
          yMul: 0,
          deltaX: 1,
          deltaY: 1,
          deltaW: 0,
          deltaH: 0,
          label: 'Crop Mask'
        },
        {
          name: 'nw',
          xMul: 0,
          yMul: 0,
          deltaX: 1,
          deltaY: 1,
          deltaW: -1,
          deltaH: -1,
          label: 'Top Left Crop Handle'
        },
        {
          name: 'ne',
          xMul: 1,
          yMul: 0,
          deltaX: 0,
          deltaY: 1,
          deltaW: 1,
          deltaH: -1,
          label: 'Top Right Crop Handle'
        },
        {
          name: 'sw',
          xMul: 0,
          yMul: 1,
          deltaX: 1,
          deltaY: 0,
          deltaW: -1,
          deltaH: 1,
          label: 'Bottom Left Crop Handle'
        },
        {
          name: 'se',
          xMul: 1,
          yMul: 1,
          deltaX: 0,
          deltaY: 0,
          deltaW: 1,
          deltaH: 1,
          label: 'Bottom Right Crop Handle'
        }
      ];
      var blockers = [
        'top',
        'right',
        'bottom',
        'left'
      ];
      var getAbsoluteRect = function (outerRect, relativeRect) {
        return {
          x: relativeRect.x + outerRect.x,
          y: relativeRect.y + outerRect.y,
          w: relativeRect.w,
          h: relativeRect.h
        };
      };
      var getRelativeRect = function (outerRect, innerRect) {
        return {
          x: innerRect.x - outerRect.x,
          y: innerRect.y - outerRect.y,
          w: innerRect.w,
          h: innerRect.h
        };
      };
      var getInnerRect = function () {
        return getRelativeRect(clampRect, currentRect);
      };
      var moveRect = function (handle, startRect, deltaX, deltaY) {
        var x = startRect.x + deltaX * handle.deltaX;
        var y = startRect.y + deltaY * handle.deltaY;
        var w = Math.max(20, startRect.w + deltaX * handle.deltaW);
        var h = Math.max(20, startRect.h + deltaY * handle.deltaH);
        var rect = currentRect = global$4.clamp({
          x: x,
          y: y,
          w: w,
          h: h
        }, clampRect, handle.name === 'move');
        rect = getRelativeRect(clampRect, rect);
        instance.fire('updateRect', { rect: rect });
        setInnerRect(rect);
      };
      var render = function () {
        var createDragHelper = function (handle) {
          var startRect;
          return DragHelper(id, {
            document: containerElm.ownerDocument,
            root: getRootNode(container).dom,
            handle: id + '-' + handle.name,
            start: function () {
              startRect = currentRect;
            },
            drag: function (e) {
              moveRect(handle, startRect, e.deltaX, e.deltaY);
            }
          });
        };
        var cropContainer = SugarElement.fromTag('div');
        setAll$1(cropContainer, {
          id: id,
          'class': prefix + 'croprect-container',
          'role': 'grid',
          'aria-dropeffect': 'execute'
        });
        append$2(container, cropContainer);
        each$1(blockers, function (blocker) {
          descendant(container, '#' + id).each(function (blockerElm) {
            var cropBlocker = SugarElement.fromTag('div');
            setAll$1(cropBlocker, {
              'id': id + '-' + blocker,
              'class': prefix + 'croprect-block',
              'data-mce-bogus': 'all'
            });
            set$7(cropBlocker, 'display', 'none');
            append$2(blockerElm, cropBlocker);
          });
        });
        each$1(handles, function (handle) {
          descendant(container, '#' + id).each(function (handleElm) {
            var cropHandle = SugarElement.fromTag('div');
            setAll$1(cropHandle, {
              'id': id + '-' + handle.name,
              'aria-label': handle.label,
              'aria-grabbed': 'false',
              'data-mce-bogus': 'all',
              'role': 'gridcell',
              'tabindex': '-1',
              'title': handle.label
            });
            add$1(cropHandle, [
              prefix + 'croprect-handle',
              prefix + 'croprect-handle-' + handle.name
            ]);
            set$7(cropHandle, 'display', 'none');
            append$2(handleElm, cropHandle);
          });
        });
        dragHelpers = map$2(handles, createDragHelper);
        repaint(currentRect);
        var handleFocus = function (e) {
          set$8(e.target, 'aria-grabbed', e.raw.type === 'focus' ? 'true' : 'false');
        };
        var handleKeydown = function (e) {
          var activeHandle;
          each$1(handles, function (handle) {
            if (get$d(e.target, 'id') === id + '-' + handle.name) {
              activeHandle = handle;
              return false;
            }
          });
          var moveAndBlock = function (evt, handle, startRect, deltaX, deltaY) {
            evt.stopPropagation();
            evt.preventDefault();
            moveRect(activeHandle, startRect, deltaX, deltaY);
          };
          switch (e.raw.keyCode) {
          case global$2.LEFT:
            moveAndBlock(e, activeHandle, currentRect, -10, 0);
            break;
          case global$2.RIGHT:
            moveAndBlock(e, activeHandle, currentRect, 10, 0);
            break;
          case global$2.UP:
            moveAndBlock(e, activeHandle, currentRect, 0, -10);
            break;
          case global$2.DOWN:
            moveAndBlock(e, activeHandle, currentRect, 0, 10);
            break;
          case global$2.ENTER:
          case global$2.SPACEBAR:
            e.prevent();
            action();
            break;
          }
        };
        events.push(bind(container, 'focusin', handleFocus), bind(container, 'focusout', handleFocus), bind(container, 'keydown', handleKeydown));
      };
      var toggleVisibility = function (state) {
        var selectors = __spreadArray(__spreadArray([], map$2(handles, function (handle) {
          return '#' + id + '-' + handle.name;
        }), true), map$2(blockers, function (blocker) {
          return '#' + id + '-' + blocker;
        }), true).join(',');
        var elems = descendants(container, selectors);
        if (state) {
          each$1(elems, function (elm) {
            return remove$6(elm, 'display');
          });
        } else {
          each$1(elems, function (elm) {
            return set$7(elm, 'display', 'none');
          });
        }
      };
      var repaint = function (rect) {
        var updateElementRect = function (name, newRect) {
          descendant(container, '#' + id + '-' + name).each(function (elm) {
            setAll(elm, {
              left: newRect.x + 'px',
              top: newRect.y + 'px',
              width: Math.max(0, newRect.w) + 'px',
              height: Math.max(0, newRect.h) + 'px'
            });
          });
        };
        each$1(handles, function (handle) {
          descendant(container, '#' + id + '-' + handle.name).each(function (elm) {
            setAll(elm, {
              left: rect.w * handle.xMul + rect.x + 'px',
              top: rect.h * handle.yMul + rect.y + 'px'
            });
          });
        });
        updateElementRect('top', {
          x: viewPortRect.x,
          y: viewPortRect.y,
          w: viewPortRect.w,
          h: rect.y - viewPortRect.y
        });
        updateElementRect('right', {
          x: rect.x + rect.w,
          y: rect.y,
          w: viewPortRect.w - rect.x - rect.w + viewPortRect.x,
          h: rect.h
        });
        updateElementRect('bottom', {
          x: viewPortRect.x,
          y: rect.y + rect.h,
          w: viewPortRect.w,
          h: viewPortRect.h - rect.y - rect.h + viewPortRect.y
        });
        updateElementRect('left', {
          x: viewPortRect.x,
          y: rect.y,
          w: rect.x - viewPortRect.x,
          h: rect.h
        });
        updateElementRect('move', rect);
      };
      var setRect = function (rect) {
        currentRect = rect;
        repaint(currentRect);
      };
      var setViewPortRect = function (rect) {
        viewPortRect = rect;
        repaint(currentRect);
      };
      var setInnerRect = function (rect) {
        setRect(getAbsoluteRect(clampRect, rect));
      };
      var setClampRect = function (rect) {
        clampRect = rect;
        repaint(currentRect);
      };
      var destroy = function () {
        each$1(dragHelpers, function (helper) {
          return helper.destroy();
        });
        dragHelpers = [];
        each$1(events, function (e) {
          return e.unbind();
        });
        events = [];
      };
      render();
      var instance = __assign(__assign({}, global$3), {
        toggleVisibility: toggleVisibility,
        setClampRect: setClampRect,
        setRect: setRect,
        getInnerRect: getInnerRect,
        setInnerRect: setInnerRect,
        setViewPortRect: setViewPortRect,
        destroy: destroy
      });
      return instance;
    };
    var CropRect = { create: create$1 };

    var loadImage = function (image) {
      return new global$c(function (resolve) {
        var loaded = function () {
          image.removeEventListener('load', loaded);
          resolve(image);
        };
        if (image.complete) {
          resolve(image);
        } else {
          image.addEventListener('load', loaded);
        }
      });
    };
    var renderImagePanel = function (initialUrl) {
      var memBg = record({
        dom: {
          tag: 'div',
          classes: ['tox-image-tools__image-bg'],
          attributes: { role: 'presentation' }
        }
      });
      var zoomState = Cell(1);
      var cropRect = api$1();
      var rectState = Cell({
        x: 0,
        y: 0,
        w: 1,
        h: 1
      });
      var viewRectState = Cell({
        x: 0,
        y: 0,
        w: 1,
        h: 1
      });
      var repaintImg = function (anyInSystem, img) {
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var zoom = zoomState.get();
          var panelW = get$a(panel.element);
          var panelH = get$b(panel.element);
          var width = img.dom.naturalWidth * zoom;
          var height = img.dom.naturalHeight * zoom;
          var left = Math.max(0, panelW / 2 - width / 2);
          var top = Math.max(0, panelH / 2 - height / 2);
          var css = {
            left: left.toString() + 'px',
            top: top.toString() + 'px',
            width: width.toString() + 'px',
            height: height.toString() + 'px',
            position: 'absolute'
          };
          setAll(img, css);
          memBg.getOpt(panel).each(function (bg) {
            setAll(bg.element, css);
          });
          cropRect.run(function (cRect) {
            var rect = rectState.get();
            cRect.setRect({
              x: rect.x * zoom + left,
              y: rect.y * zoom + top,
              w: rect.w * zoom,
              h: rect.h * zoom
            });
            cRect.setClampRect({
              x: left,
              y: top,
              w: width,
              h: height
            });
            cRect.setViewPortRect({
              x: 0,
              y: 0,
              w: panelW,
              h: panelH
            });
          });
        });
      };
      var zoomFit = function (anyInSystem, img) {
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var panelW = get$a(panel.element);
          var panelH = get$b(panel.element);
          var width = img.dom.naturalWidth;
          var height = img.dom.naturalHeight;
          var zoom = Math.min(panelW / width, panelH / height);
          if (zoom >= 1) {
            zoomState.set(1);
          } else {
            zoomState.set(zoom);
          }
        });
      };
      var updateSrc = function (anyInSystem, url) {
        var img = SugarElement.fromTag('img');
        set$8(img, 'src', url);
        return loadImage(img.dom).then(function () {
          if (anyInSystem.getSystem().isConnected()) {
            memContainer.getOpt(anyInSystem).map(function (panel) {
              var aImg = external$2({ element: img });
              Replacing.replaceAt(panel, 1, Optional.some(aImg));
              var lastViewRect = viewRectState.get();
              var viewRect = {
                x: 0,
                y: 0,
                w: img.dom.naturalWidth,
                h: img.dom.naturalHeight
              };
              viewRectState.set(viewRect);
              var rect = global$4.inflate(viewRect, -20, -20);
              rectState.set(rect);
              if (lastViewRect.w !== viewRect.w || lastViewRect.h !== viewRect.h) {
                zoomFit(panel, img);
              }
              repaintImg(panel, img);
            });
          }
        });
      };
      var zoom = function (anyInSystem, direction) {
        var currentZoom = zoomState.get();
        var newZoom = direction > 0 ? Math.min(2, currentZoom + 0.1) : Math.max(0.1, currentZoom - 0.1);
        zoomState.set(newZoom);
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var img = panel.components()[1].element;
          repaintImg(panel, img);
        });
      };
      var showCrop = function () {
        cropRect.run(function (cRect) {
          cRect.toggleVisibility(true);
        });
      };
      var hideCrop = function () {
        cropRect.run(function (cRect) {
          cRect.toggleVisibility(false);
        });
      };
      var getRect = function () {
        return rectState.get();
      };
      var container = Container.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-image-tools__image']
        },
        components: [
          memBg.asSpec(),
          {
            dom: {
              tag: 'img',
              attributes: { src: initialUrl }
            }
          },
          {
            dom: { tag: 'div' },
            behaviours: derive$1([config('image-panel-crop-events', [
                runOnAttached(function (comp) {
                  memContainer.getOpt(comp).each(function (container) {
                    var el = container.element.dom;
                    var cRect = CropRect.create({
                      x: 10,
                      y: 10,
                      w: 100,
                      h: 100
                    }, {
                      x: 0,
                      y: 0,
                      w: 200,
                      h: 200
                    }, {
                      x: 0,
                      y: 0,
                      w: 200,
                      h: 200
                    }, el, noop);
                    cRect.toggleVisibility(false);
                    cRect.on('updateRect', function (e) {
                      var rect = e.rect;
                      var zoom = zoomState.get();
                      var newRect = {
                        x: Math.round(rect.x / zoom),
                        y: Math.round(rect.y / zoom),
                        w: Math.round(rect.w / zoom),
                        h: Math.round(rect.h / zoom)
                      };
                      rectState.set(newRect);
                    });
                    cropRect.set(cRect);
                  });
                }),
                runOnDetached(function () {
                  cropRect.clear();
                })
              ])])
          }
        ],
        containerBehaviours: derive$1([
          Replacing.config({}),
          config('image-panel-events', [runOnAttached(function (comp) {
              updateSrc(comp, initialUrl);
            })])
        ])
      });
      var memContainer = record(container);
      var getMeasurements = function () {
        var viewRect = viewRectState.get();
        return {
          width: viewRect.w,
          height: viewRect.h
        };
      };
      return {
        memContainer: memContainer,
        updateSrc: updateSrc,
        zoom: zoom,
        showCrop: showCrop,
        hideCrop: hideCrop,
        getRect: getRect,
        getMeasurements: getMeasurements
      };
    };

    var createButton = function (innerHtml, icon, disabled, action, providersBackstage) {
      return renderIconButton({
        name: innerHtml,
        icon: Optional.some(icon),
        disabled: disabled,
        tooltip: Optional.some(innerHtml),
        primary: false,
        borderless: false
      }, action, providersBackstage);
    };
    var setButtonEnabled = function (button, enabled) {
      if (enabled) {
        Disabling.enable(button);
      } else {
        Disabling.disable(button);
      }
    };
    var renderSideBar = function (providersBackstage) {
      var updateButtonUndoStates = function (anyInSystem, undoEnabled, redoEnabled) {
        memUndo.getOpt(anyInSystem).each(function (undo) {
          setButtonEnabled(undo, undoEnabled);
        });
        memRedo.getOpt(anyInSystem).each(function (redo) {
          setButtonEnabled(redo, redoEnabled);
        });
      };
      var memUndo = record(createButton('Undo', 'undo', true, function (button) {
        emitWith(button, internal.undo(), { direction: 1 });
      }, providersBackstage));
      var memRedo = record(createButton('Redo', 'redo', true, function (button) {
        emitWith(button, internal.redo(), { direction: 1 });
      }, providersBackstage));
      var container = Container.sketch({
        dom: {
          tag: 'div',
          classes: [
            'tox-image-tools__toolbar',
            'tox-image-tools__sidebar'
          ]
        },
        components: [
          memUndo.asSpec(),
          memRedo.asSpec(),
          createButton('Zoom in', 'zoom-in', false, function (button) {
            emitWith(button, internal.zoom(), { direction: 1 });
          }, providersBackstage),
          createButton('Zoom out', 'zoom-out', false, function (button) {
            emitWith(button, internal.zoom(), { direction: -1 });
          }, providersBackstage)
        ]
      });
      return {
        container: container,
        updateButtonUndoStates: updateButtonUndoStates
      };
    };

    function UndoStack () {
      var data = [];
      var index = -1;
      var add = function (state) {
        var removed = data.splice(++index);
        data.push(state);
        return {
          state: state,
          removed: removed
        };
      };
      var undo = function () {
        if (canUndo()) {
          return data[--index];
        }
      };
      var redo = function () {
        if (canRedo()) {
          return data[++index];
        }
      };
      var canUndo = function () {
        return index > 0;
      };
      var canRedo = function () {
        return index !== -1 && index < data.length - 1;
      };
      return {
        data: data,
        add: add,
        undo: undo,
        redo: redo,
        canUndo: canUndo,
        canRedo: canRedo
      };
    }

    var makeState = function (initialState) {
      var blobState = Cell(initialState);
      var tempState = value$1();
      var undoStack = UndoStack();
      undoStack.add(initialState);
      var getBlobState = function () {
        return blobState.get();
      };
      var setBlobState = function (state) {
        blobState.set(state);
      };
      var getTempState = function () {
        return tempState.get().getOrThunk(blobState.get);
      };
      var updateTempState = function (blob) {
        var newTempState = createState(blob);
        destroyTempState();
        tempState.set(newTempState);
        return newTempState.url;
      };
      var createState = function (blob) {
        return {
          blob: blob,
          url: URL.createObjectURL(blob)
        };
      };
      var destroyState = function (state) {
        URL.revokeObjectURL(state.url);
      };
      var destroyStates = function (states) {
        global$5.each(states, destroyState);
      };
      var destroyTempState = function () {
        tempState.on(destroyState);
        tempState.clear();
      };
      var addBlobState = function (blob) {
        var newState = createState(blob);
        setBlobState(newState);
        var removed = undoStack.add(newState).removed;
        destroyStates(removed);
        return newState.url;
      };
      var addTempState = function (blob) {
        var newState = createState(blob);
        tempState.set(newState);
        return newState.url;
      };
      var applyTempState = function (postApply) {
        return tempState.get().fold(noop, function (temp) {
          addBlobState(temp.blob);
          postApply();
        });
      };
      var undo = function () {
        var currentState = undoStack.undo();
        setBlobState(currentState);
        return currentState.url;
      };
      var redo = function () {
        var currentState = undoStack.redo();
        setBlobState(currentState);
        return currentState.url;
      };
      var getHistoryStates = function () {
        var undoEnabled = undoStack.canUndo();
        var redoEnabled = undoStack.canRedo();
        return {
          undoEnabled: undoEnabled,
          redoEnabled: redoEnabled
        };
      };
      return {
        getBlobState: getBlobState,
        setBlobState: setBlobState,
        addBlobState: addBlobState,
        getTempState: getTempState,
        updateTempState: updateTempState,
        addTempState: addTempState,
        applyTempState: applyTempState,
        destroyTempState: destroyTempState,
        undo: undo,
        redo: redo,
        getHistoryStates: getHistoryStates
      };
    };

    var renderImageTools = function (detail, providersBackstage) {
      var state = makeState(detail.currentState);
      var zoom = function (anyInSystem, simulatedEvent) {
        var direction = simulatedEvent.event.direction;
        imagePanel.zoom(anyInSystem, direction);
      };
      var updateButtonUndoStates = function (anyInSystem) {
        var historyStates = state.getHistoryStates();
        sideBar.updateButtonUndoStates(anyInSystem, historyStates.undoEnabled, historyStates.redoEnabled);
        emitWith(anyInSystem, external.formActionEvent, {
          name: external.saveState(),
          value: historyStates.undoEnabled
        });
      };
      var disableUndoRedo = function (anyInSystem) {
        sideBar.updateButtonUndoStates(anyInSystem, false, false);
      };
      var undo = function (anyInSystem, _simulatedEvent) {
        var url = state.undo();
        updateSrc(anyInSystem, url).then(function (_oImg) {
          unblock(anyInSystem);
          updateButtonUndoStates(anyInSystem);
        });
      };
      var redo = function (anyInSystem, _simulatedEvent) {
        var url = state.redo();
        updateSrc(anyInSystem, url).then(function (_oImg) {
          unblock(anyInSystem);
          updateButtonUndoStates(anyInSystem);
        });
      };
      var imageResultToBlob = function (ir) {
        return ir.toBlob();
      };
      var block = function (anyInSystem) {
        emitWith(anyInSystem, external.formActionEvent, {
          name: external.disable(),
          value: {}
        });
      };
      var unblock = function (anyInSystem) {
        editPanel.getApplyButton(anyInSystem).each(function (applyButton) {
          Disabling.enable(applyButton);
        });
        emitWith(anyInSystem, external.formActionEvent, {
          name: external.enable(),
          value: {}
        });
      };
      var updateSrc = function (anyInSystem, src) {
        block(anyInSystem);
        return imagePanel.updateSrc(anyInSystem, src);
      };
      var blobManipulate = function (anyInSystem, blob, filter, action, swap) {
        block(anyInSystem);
        blobToImageResult(blob).then(filter).then(imageResultToBlob).then(action).then(function (url) {
          return updateSrc(anyInSystem, url);
        }).then(function () {
          updateButtonUndoStates(anyInSystem);
          swap();
          unblock(anyInSystem);
        }).catch(function (err) {
          console.log(err);
          if (anyInSystem.getSystem().isConnected()) {
            unblock(anyInSystem);
          }
        });
      };
      var manipulate = function (anyInSystem, filter, swap) {
        var blob = state.getBlobState().blob;
        var action = function (blob) {
          return state.updateTempState(blob);
        };
        blobManipulate(anyInSystem, blob, filter, action, swap);
      };
      var tempManipulate = function (anyInSystem, filter) {
        var blob = state.getTempState().blob;
        var action = function (blob) {
          return state.addTempState(blob);
        };
        blobManipulate(anyInSystem, blob, filter, action, noop);
      };
      var manipulateApply = function (anyInSystem, filter, swap) {
        var blob = state.getBlobState().blob;
        var action = function (blob) {
          var url = state.addBlobState(blob);
          destroyTempState(anyInSystem);
          return url;
        };
        blobManipulate(anyInSystem, blob, filter, action, swap);
      };
      var apply = function (anyInSystem, simulatedEvent) {
        var postApply = function () {
          destroyTempState(anyInSystem);
          var swap = simulatedEvent.event.swap;
          swap();
        };
        state.applyTempState(postApply);
      };
      var destroyTempState = function (anyInSystem) {
        var currentUrl = state.getBlobState().url;
        state.destroyTempState();
        updateButtonUndoStates(anyInSystem);
        return currentUrl;
      };
      var cancel = function (anyInSystem) {
        var currentUrl = destroyTempState(anyInSystem);
        updateSrc(anyInSystem, currentUrl).then(function (_oImg) {
          unblock(anyInSystem);
        });
      };
      var back = function (anyInSystem, simulatedEvent) {
        cancel(anyInSystem);
        var swap = simulatedEvent.event.swap;
        swap();
        imagePanel.hideCrop();
      };
      var transform = function (anyInSystem, simulatedEvent) {
        return manipulate(anyInSystem, simulatedEvent.event.transform, noop);
      };
      var tempTransform = function (anyInSystem, simulatedEvent) {
        return tempManipulate(anyInSystem, simulatedEvent.event.transform);
      };
      var transformApply = function (anyInSystem, simulatedEvent) {
        return manipulateApply(anyInSystem, simulatedEvent.event.transform, simulatedEvent.event.swap);
      };
      var imagePanel = renderImagePanel(detail.currentState.url);
      var sideBar = renderSideBar(providersBackstage);
      var editPanel = renderEditPanel(imagePanel, providersBackstage);
      var swap = function (anyInSystem, simulatedEvent) {
        disableUndoRedo(anyInSystem);
        var transform = simulatedEvent.event.transform;
        var swap = simulatedEvent.event.swap;
        transform.fold(function () {
          swap();
        }, function (transform) {
          manipulate(anyInSystem, transform, swap);
        });
      };
      return {
        dom: {
          tag: 'div',
          attributes: { role: 'presentation' }
        },
        components: [
          editPanel.memContainer.asSpec(),
          imagePanel.memContainer.asSpec(),
          sideBar.container
        ],
        behaviours: derive$1([
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function () {
                return state.getBlobState();
              }
            }
          }),
          config('image-tools-events', [
            run$1(internal.undo(), undo),
            run$1(internal.redo(), redo),
            run$1(internal.zoom(), zoom),
            run$1(internal.back(), back),
            run$1(internal.apply(), apply),
            run$1(internal.transform(), transform),
            run$1(internal.tempTransform(), tempTransform),
            run$1(internal.transformApply(), transformApply),
            run$1(internal.swap(), swap)
          ]),
          ComposingConfigs.self()
        ])
      };
    };

    var renderLabel = function (spec, backstageShared) {
      var label = {
        dom: {
          tag: 'label',
          innerHtml: backstageShared.providers.translate(spec.label),
          classes: ['tox-label']
        }
      };
      var comps = map$2(spec.items, backstageShared.interpreter);
      return {
        dom: {
          tag: 'div',
          classes: ['tox-form__group']
        },
        components: [label].concat(comps),
        behaviours: derive$1([
          ComposingConfigs.self(),
          Replacing.config({}),
          RepresentingConfigs.domHtml(Optional.none()),
          Keying.config({ mode: 'acyclic' })
        ])
      };
    };

    var isSingleListItem = function (item) {
      return !has$2(item, 'items');
    };
    var dataAttribute = 'data-value';
    var fetchItems = function (dropdownComp, name, items, selectedValue) {
      return map$2(items, function (item) {
        if (!isSingleListItem(item)) {
          return {
            type: 'nestedmenuitem',
            text: item.text,
            getSubmenuItems: function () {
              return fetchItems(dropdownComp, name, item.items, selectedValue);
            }
          };
        } else {
          return {
            type: 'togglemenuitem',
            text: item.text,
            value: item.value,
            active: item.value === selectedValue,
            onAction: function () {
              Representing.setValue(dropdownComp, item.value);
              emitWith(dropdownComp, formChangeEvent, { name: name });
              Focusing.focus(dropdownComp);
            }
          };
        }
      });
    };
    var findItemByValue = function (items, value) {
      return findMap(items, function (item) {
        if (!isSingleListItem(item)) {
          return findItemByValue(item.items, value);
        } else {
          return someIf(item.value === value, item);
        }
      });
    };
    var renderListBox = function (spec, backstage) {
      var providersBackstage = backstage.shared.providers;
      var initialItem = head(spec.items).filter(isSingleListItem);
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var pField = FormField.parts.field({
        dom: {},
        factory: {
          sketch: function (sketchSpec) {
            return renderCommonDropdown({
              uid: sketchSpec.uid,
              text: initialItem.map(function (item) {
                return item.text;
              }),
              icon: Optional.none(),
              tooltip: spec.label,
              role: Optional.none(),
              fetch: function (comp, callback) {
                var items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp));
                callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));
              },
              onSetup: constant$1(noop),
              getApi: constant$1({}),
              columns: 1,
              presets: 'normal',
              classes: [],
              dropdownBehaviours: [
                Tabstopping.config({}),
                Representing.config({
                  store: {
                    mode: 'manual',
                    initialValue: initialItem.map(function (item) {
                      return item.value;
                    }).getOr(''),
                    getValue: function (comp) {
                      return get$d(comp.element, dataAttribute);
                    },
                    setValue: function (comp, data) {
                      findItemByValue(spec.items, data).each(function (item) {
                        set$8(comp.element, dataAttribute, item.value);
                        emitWith(comp, updateMenuText, { text: item.text });
                      });
                    }
                  }
                })
              ]
            }, 'tox-listbox', backstage.shared);
          }
        }
      });
      var listBoxWrap = {
        dom: {
          tag: 'div',
          classes: ['tox-listboxfield']
        },
        components: [pField]
      };
      return FormField.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-form__group']
        },
        components: flatten([
          pLabel.toArray(),
          [listBoxWrap]
        ]),
        fieldBehaviours: derive$1([Disabling.config({
            disabled: constant$1(spec.disabled),
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
            }
          })])
      });
    };

    var renderPanel = function (spec, backstage) {
      return {
        dom: {
          tag: 'div',
          classes: spec.classes
        },
        components: map$2(spec.items, backstage.shared.interpreter)
      };
    };

    var factory$e = function (detail, _spec) {
      var options = map$2(detail.options, function (option) {
        return {
          dom: {
            tag: 'option',
            value: option.value,
            innerHtml: option.text
          }
        };
      });
      var initialValues = detail.data.map(function (v) {
        return wrap$1('initialValue', v);
      }).getOr({});
      return {
        uid: detail.uid,
        dom: {
          tag: 'select',
          classes: detail.selectClasses,
          attributes: detail.selectAttributes
        },
        components: options,
        behaviours: augment(detail.selectBehaviours, [
          Focusing.config({}),
          Representing.config({
            store: __assign({
              mode: 'manual',
              getValue: function (select) {
                return get$5(select.element);
              },
              setValue: function (select, newValue) {
                var found = find$5(detail.options, function (opt) {
                  return opt.value === newValue;
                });
                if (found.isSome()) {
                  set$4(select.element, newValue);
                }
              }
            }, initialValues)
          })
        ])
      };
    };
    var HtmlSelect = single({
      name: 'HtmlSelect',
      configFields: [
        required$1('options'),
        field('selectBehaviours', [
          Focusing,
          Representing
        ]),
        defaulted('selectClasses', []),
        defaulted('selectAttributes', {}),
        option('data')
      ],
      factory: factory$e
    });

    var renderSelectBox = function (spec, providersBackstage) {
      var translatedOptions = map$2(spec.items, function (item) {
        return {
          text: providersBackstage.translate(item.text),
          value: item.value
        };
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var pField = FormField.parts.field({
        dom: {},
        selectAttributes: { size: spec.size },
        options: translatedOptions,
        factory: HtmlSelect,
        selectBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            }
          }),
          Tabstopping.config({}),
          config('selectbox-change', [run$1(change(), function (component, _) {
              emitWith(component, formChangeEvent, { name: spec.name });
            })])
        ])
      });
      var chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3('chevron-down', {
        tag: 'div',
        classes: ['tox-selectfield__icon-js']
      }, providersBackstage.icons));
      var selectWrap = {
        dom: {
          tag: 'div',
          classes: ['tox-selectfield']
        },
        components: flatten([
          [pField],
          chevron.toArray()
        ])
      };
      return FormField.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-form__group']
        },
        components: flatten([
          pLabel.toArray(),
          [selectWrap]
        ]),
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            },
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
            }
          }),
          receivingConfig()
        ])
      });
    };

    var renderTable = function (spec, providersBackstage) {
      var renderTh = function (text) {
        return {
          dom: {
            tag: 'th',
            innerHtml: providersBackstage.translate(text)
          }
        };
      };
      var renderHeader = function (header) {
        return {
          dom: { tag: 'thead' },
          components: [{
              dom: { tag: 'tr' },
              components: map$2(header, renderTh)
            }]
        };
      };
      var renderTd = function (text) {
        return {
          dom: {
            tag: 'td',
            innerHtml: providersBackstage.translate(text)
          }
        };
      };
      var renderTr = function (row) {
        return {
          dom: { tag: 'tr' },
          components: map$2(row, renderTd)
        };
      };
      var renderRows = function (rows) {
        return {
          dom: { tag: 'tbody' },
          components: map$2(rows, renderTr)
        };
      };
      return {
        dom: {
          tag: 'table',
          classes: ['tox-dialog__table']
        },
        components: [
          renderHeader(spec.header),
          renderRows(spec.cells)
        ],
        behaviours: derive$1([
          Tabstopping.config({}),
          Focusing.config({})
        ])
      };
    };

    var renderTextField = function (spec, providersBackstage) {
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var baseInputBehaviours = [
        Disabling.config({
          disabled: function () {
            return spec.disabled || providersBackstage.isDisabled();
          }
        }),
        receivingConfig(),
        Keying.config({
          mode: 'execution',
          useEnter: spec.multiline !== true,
          useControlEnter: spec.multiline === true,
          execute: function (comp) {
            emit(comp, formSubmitEvent);
            return Optional.some(true);
          }
        }),
        config('textfield-change', [
          run$1(input(), function (component, _) {
            emitWith(component, formChangeEvent, { name: spec.name });
          }),
          run$1(postPaste(), function (component, _) {
            emitWith(component, formChangeEvent, { name: spec.name });
          })
        ]),
        Tabstopping.config({})
      ];
      var validatingBehaviours = spec.validation.map(function (vl) {
        return Invalidating.config({
          getRoot: function (input) {
            return parent(input.element);
          },
          invalidClass: 'tox-invalid',
          validator: {
            validate: function (input) {
              var v = Representing.getValue(input);
              var result = vl.validator(v);
              return Future.pure(result === true ? Result.value(v) : Result.error(result));
            },
            validateOnLoad: vl.validateOnLoad
          }
        });
      }).toArray();
      var placeholder = spec.placeholder.fold(constant$1({}), function (p) {
        return { placeholder: providersBackstage.translate(p) };
      });
      var inputMode = spec.inputMode.fold(constant$1({}), function (mode) {
        return { inputmode: mode };
      });
      var inputAttributes = __assign(__assign({}, placeholder), inputMode);
      var pField = FormField.parts.field({
        tag: spec.multiline === true ? 'textarea' : 'input',
        inputAttributes: inputAttributes,
        inputClasses: [spec.classname],
        inputBehaviours: derive$1(flatten([
          baseInputBehaviours,
          validatingBehaviours
        ])),
        selectOnFocus: false,
        factory: Input
      });
      var extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];
      var extraClasses2 = extraClasses.concat(spec.maximized ? ['tox-form-group--maximize'] : []);
      var extraBehaviours = [
        Disabling.config({
          disabled: function () {
            return spec.disabled || providersBackstage.isDisabled();
          },
          onDisabled: function (comp) {
            FormField.getField(comp).each(Disabling.disable);
          },
          onEnabled: function (comp) {
            FormField.getField(comp).each(Disabling.enable);
          }
        }),
        receivingConfig()
      ];
      return renderFormFieldWith(pLabel, pField, extraClasses2, extraBehaviours);
    };
    var renderInput = function (spec, providersBackstage) {
      return renderTextField({
        name: spec.name,
        multiline: false,
        label: spec.label,
        inputMode: spec.inputMode,
        placeholder: spec.placeholder,
        flex: false,
        disabled: spec.disabled,
        classname: 'tox-textfield',
        validation: Optional.none(),
        maximized: spec.maximized
      }, providersBackstage);
    };
    var renderTextarea = function (spec, providersBackstage) {
      return renderTextField({
        name: spec.name,
        multiline: true,
        label: spec.label,
        inputMode: Optional.none(),
        placeholder: spec.placeholder,
        flex: true,
        disabled: spec.disabled,
        classname: 'tox-textarea',
        validation: Optional.none(),
        maximized: spec.maximized
      }, providersBackstage);
    };

    var events$6 = function (streamConfig, streamState) {
      var streams = streamConfig.stream.streams;
      var processor = streams.setup(streamConfig, streamState);
      return derive$2([
        run$1(streamConfig.event, processor),
        runOnDetached(function () {
          return streamState.cancel();
        })
      ].concat(streamConfig.cancelEvent.map(function (e) {
        return [run$1(e, function () {
            return streamState.cancel();
          })];
      }).getOr([])));
    };

    var ActiveStreaming = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$6
    });

    var throttle = function (_config) {
      var state = Cell(null);
      var readState = function () {
        return { timer: state.get() !== null ? 'set' : 'unset' };
      };
      var setTimer = function (t) {
        state.set(t);
      };
      var cancel = function () {
        var t = state.get();
        if (t !== null) {
          t.cancel();
        }
      };
      return nu$8({
        readState: readState,
        setTimer: setTimer,
        cancel: cancel
      });
    };
    var init$9 = function (spec) {
      return spec.stream.streams.state(spec);
    };

    var StreamingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        throttle: throttle,
        init: init$9
    });

    var setup$c = function (streamInfo, streamState) {
      var sInfo = streamInfo.stream;
      var throttler = last(streamInfo.onStream, sInfo.delay);
      streamState.setTimer(throttler);
      return function (component, simulatedEvent) {
        throttler.throttle(component, simulatedEvent);
        if (sInfo.stopEvent) {
          simulatedEvent.stop();
        }
      };
    };
    var StreamingSchema = [
      requiredOf('stream', choose$1('mode', {
        throttle: [
          required$1('delay'),
          defaulted('stopEvent', true),
          output$1('streams', {
            setup: setup$c,
            state: throttle
          })
        ]
      })),
      defaulted('event', 'input'),
      option('cancelEvent'),
      onStrictHandler('onStream')
    ];

    var Streaming = create$7({
      fields: StreamingSchema,
      name: 'streaming',
      active: ActiveStreaming,
      state: StreamingState
    });

    var setValueFromItem = function (model, input, item) {
      var itemData = Representing.getValue(item);
      Representing.setValue(input, itemData);
      setCursorAtEnd(input);
    };
    var setSelectionOn = function (input, f) {
      var el = input.element;
      var value = get$5(el);
      var node = el.dom;
      if (get$d(el, 'type') !== 'number') {
        f(node, value);
      }
    };
    var setCursorAtEnd = function (input) {
      setSelectionOn(input, function (node, value) {
        return node.setSelectionRange(value.length, value.length);
      });
    };
    var setSelectionToEnd = function (input, startOffset) {
      setSelectionOn(input, function (node, value) {
        return node.setSelectionRange(startOffset, value.length);
      });
    };
    var attemptSelectOver = function (model, input, item) {
      if (!model.selectsOver) {
        return Optional.none();
      } else {
        var currentValue = Representing.getValue(input);
        var inputDisplay_1 = model.getDisplayText(currentValue);
        var itemValue = Representing.getValue(item);
        var itemDisplay = model.getDisplayText(itemValue);
        return itemDisplay.indexOf(inputDisplay_1) === 0 ? Optional.some(function () {
          setValueFromItem(model, input, item);
          setSelectionToEnd(input, inputDisplay_1.length);
        }) : Optional.none();
      }
    };

    var itemExecute = constant$1('alloy.typeahead.itemexecute');

    var make$3 = function (detail, components, spec, externals) {
      var navigateList = function (comp, simulatedEvent, highlighter) {
        detail.previewing.set(false);
        var sandbox = Coupling.getCoupled(comp, 'sandbox');
        if (Sandboxing.isOpen(sandbox)) {
          Composing.getCurrent(sandbox).each(function (menu) {
            Highlighting.getHighlighted(menu).fold(function () {
              highlighter(menu);
            }, function () {
              dispatchEvent(sandbox, menu.element, 'keydown', simulatedEvent);
            });
          });
        } else {
          var onOpenSync = function (sandbox) {
            Composing.getCurrent(sandbox).each(highlighter);
          };
          open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
        }
      };
      var focusBehaviours$1 = focusBehaviours(detail);
      var mapFetch = function (comp) {
        return function (tdata) {
          return tdata.map(function (data) {
            var menus = values(data.menus);
            var items = bind$3(menus, function (menu) {
              return filter$2(menu.items, function (item) {
                return item.type === 'item';
              });
            });
            var repState = Representing.getState(comp);
            repState.update(map$2(items, function (item) {
              return item.data;
            }));
            return data;
          });
        };
      };
      var behaviours = [
        Focusing.config({}),
        Representing.config({
          onSetValue: detail.onSetValue,
          store: __assign({
            mode: 'dataset',
            getDataKey: function (comp) {
              return get$5(comp.element);
            },
            getFallbackEntry: function (itemString) {
              return {
                value: itemString,
                meta: {}
              };
            },
            setValue: function (comp, data) {
              set$4(comp.element, detail.model.getDisplayText(data));
            }
          }, detail.initialData.map(function (d) {
            return wrap$1('initialValue', d);
          }).getOr({}))
        }),
        Streaming.config({
          stream: {
            mode: 'throttle',
            delay: detail.responseTime,
            stopEvent: false
          },
          onStream: function (component, _simulatedEvent) {
            var sandbox = Coupling.getCoupled(component, 'sandbox');
            var focusInInput = Focusing.isFocused(component);
            if (focusInInput) {
              if (get$5(component.element).length >= detail.minChars) {
                var previousValue_1 = Composing.getCurrent(sandbox).bind(function (menu) {
                  return Highlighting.getHighlighted(menu).map(Representing.getValue);
                });
                detail.previewing.set(true);
                var onOpenSync = function (_sandbox) {
                  Composing.getCurrent(sandbox).each(function (menu) {
                    previousValue_1.fold(function () {
                      if (detail.model.selectsOver) {
                        Highlighting.highlightFirst(menu);
                      }
                    }, function (pv) {
                      Highlighting.highlightBy(menu, function (item) {
                        var itemData = Representing.getValue(item);
                        return itemData.value === pv.value;
                      });
                      Highlighting.getHighlighted(menu).orThunk(function () {
                        Highlighting.highlightFirst(menu);
                        return Optional.none();
                      });
                    });
                  });
                };
                open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
              }
            }
          },
          cancelEvent: typeaheadCancel()
        }),
        Keying.config({
          mode: 'special',
          onDown: function (comp, simulatedEvent) {
            navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
            return Optional.some(true);
          },
          onEscape: function (comp) {
            var sandbox = Coupling.getCoupled(comp, 'sandbox');
            if (Sandboxing.isOpen(sandbox)) {
              Sandboxing.close(sandbox);
              return Optional.some(true);
            }
            return Optional.none();
          },
          onUp: function (comp, simulatedEvent) {
            navigateList(comp, simulatedEvent, Highlighting.highlightLast);
            return Optional.some(true);
          },
          onEnter: function (comp) {
            var sandbox = Coupling.getCoupled(comp, 'sandbox');
            var sandboxIsOpen = Sandboxing.isOpen(sandbox);
            if (sandboxIsOpen && !detail.previewing.get()) {
              return Composing.getCurrent(sandbox).bind(function (menu) {
                return Highlighting.getHighlighted(menu);
              }).map(function (item) {
                emitWith(comp, itemExecute(), { item: item });
                return true;
              });
            } else {
              var currentValue = Representing.getValue(comp);
              emit(comp, typeaheadCancel());
              detail.onExecute(sandbox, comp, currentValue);
              if (sandboxIsOpen) {
                Sandboxing.close(sandbox);
              }
              return Optional.some(true);
            }
          }
        }),
        Toggling.config({
          toggleClass: detail.markers.openClass,
          aria: { mode: 'expanded' }
        }),
        Coupling.config({
          others: {
            sandbox: function (hotspot) {
              return makeSandbox$1(detail, hotspot, {
                onOpen: function () {
                  return Toggling.on(hotspot);
                },
                onClose: function () {
                  return Toggling.off(hotspot);
                }
              });
            }
          }
        }),
        config('typeaheadevents', [
          runOnExecute$1(function (comp) {
            var onOpenSync = noop;
            togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
          }),
          run$1(itemExecute(), function (comp, se) {
            var sandbox = Coupling.getCoupled(comp, 'sandbox');
            setValueFromItem(detail.model, comp, se.event.item);
            emit(comp, typeaheadCancel());
            detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));
            Sandboxing.close(sandbox);
            setCursorAtEnd(comp);
          })
        ].concat(detail.dismissOnBlur ? [run$1(postBlur(), function (typeahead) {
            var sandbox = Coupling.getCoupled(typeahead, 'sandbox');
            if (search(sandbox.element).isNone()) {
              Sandboxing.close(sandbox);
            }
          })] : []))
      ];
      return {
        uid: detail.uid,
        dom: dom(deepMerge(detail, {
          inputAttributes: {
            'role': 'combobox',
            'aria-autocomplete': 'list',
            'aria-haspopup': 'true'
          }
        })),
        behaviours: __assign(__assign({}, focusBehaviours$1), augment(detail.typeaheadBehaviours, behaviours)),
        eventOrder: detail.eventOrder
      };
    };

    var schema$g = constant$1([
      option('lazySink'),
      required$1('fetch'),
      defaulted('minChars', 5),
      defaulted('responseTime', 1000),
      onHandler('onOpen'),
      defaulted('getHotspot', Optional.some),
      defaulted('getAnchorOverrides', constant$1({})),
      defaulted('layouts', Optional.none()),
      defaulted('eventOrder', {}),
      defaultedObjOf('model', {}, [
        defaulted('getDisplayText', function (itemData) {
          return itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value;
        }),
        defaulted('selectsOver', true),
        defaulted('populateFromBrowse', true)
      ]),
      onHandler('onSetValue'),
      onKeyboardHandler('onExecute'),
      onHandler('onItemExecute'),
      defaulted('inputClasses', []),
      defaulted('inputAttributes', {}),
      defaulted('inputStyles', {}),
      defaulted('matchWidth', true),
      defaulted('useMinWidth', false),
      defaulted('dismissOnBlur', true),
      markers$1(['openClass']),
      option('initialData'),
      field('typeaheadBehaviours', [
        Focusing,
        Representing,
        Streaming,
        Keying,
        Toggling,
        Coupling
      ]),
      customField('previewing', function () {
        return Cell(true);
      })
    ].concat(schema$k()).concat(sandboxFields()));
    var parts$b = constant$1([external$1({
        schema: [tieredMenuMarkers()],
        name: 'menu',
        overrides: function (detail) {
          return {
            fakeFocus: true,
            onHighlight: function (menu, item) {
              if (!detail.previewing.get()) {
                menu.getSystem().getByUid(detail.uid).each(function (input) {
                  if (detail.model.populateFromBrowse) {
                    setValueFromItem(detail.model, input, item);
                  }
                });
              } else {
                menu.getSystem().getByUid(detail.uid).each(function (input) {
                  attemptSelectOver(detail.model, input, item).fold(function () {
                    return Highlighting.dehighlight(menu, item);
                  }, function (fn) {
                    return fn();
                  });
                });
              }
              detail.previewing.set(false);
            },
            onExecute: function (menu, item) {
              return menu.getSystem().getByUid(detail.uid).toOptional().map(function (typeahead) {
                emitWith(typeahead, itemExecute(), { item: item });
                return true;
              });
            },
            onHover: function (menu, item) {
              detail.previewing.set(false);
              menu.getSystem().getByUid(detail.uid).each(function (input) {
                if (detail.model.populateFromBrowse) {
                  setValueFromItem(detail.model, input, item);
                }
              });
            }
          };
        }
      })]);

    var Typeahead = composite({
      name: 'Typeahead',
      configFields: schema$g(),
      partFields: parts$b(),
      factory: make$3
    });

    var wrap = function (delegate) {
      var toCached = function () {
        return wrap(delegate.toCached());
      };
      var bindFuture = function (f) {
        return wrap(delegate.bind(function (resA) {
          return resA.fold(function (err) {
            return Future.pure(Result.error(err));
          }, function (a) {
            return f(a);
          });
        }));
      };
      var bindResult = function (f) {
        return wrap(delegate.map(function (resA) {
          return resA.bind(f);
        }));
      };
      var mapResult = function (f) {
        return wrap(delegate.map(function (resA) {
          return resA.map(f);
        }));
      };
      var mapError = function (f) {
        return wrap(delegate.map(function (resA) {
          return resA.mapError(f);
        }));
      };
      var foldResult = function (whenError, whenValue) {
        return delegate.map(function (res) {
          return res.fold(whenError, whenValue);
        });
      };
      var withTimeout = function (timeout, errorThunk) {
        return wrap(Future.nu(function (callback) {
          var timedOut = false;
          var timer = setTimeout(function () {
            timedOut = true;
            callback(Result.error(errorThunk()));
          }, timeout);
          delegate.get(function (result) {
            if (!timedOut) {
              clearTimeout(timer);
              callback(result);
            }
          });
        }));
      };
      return __assign(__assign({}, delegate), {
        toCached: toCached,
        bindFuture: bindFuture,
        bindResult: bindResult,
        mapResult: mapResult,
        mapError: mapError,
        foldResult: foldResult,
        withTimeout: withTimeout
      });
    };
    var nu$1 = function (worker) {
      return wrap(Future.nu(worker));
    };
    var value = function (value) {
      return wrap(Future.pure(Result.value(value)));
    };
    var error = function (error) {
      return wrap(Future.pure(Result.error(error)));
    };
    var fromResult = function (result) {
      return wrap(Future.pure(result));
    };
    var fromFuture = function (future) {
      return wrap(future.map(Result.value));
    };
    var fromPromise = function (promise) {
      return nu$1(function (completer) {
        promise.then(function (value) {
          completer(Result.value(value));
        }, function (error) {
          completer(Result.error(error));
        });
      });
    };
    var FutureResult = {
      nu: nu$1,
      wrap: wrap,
      pure: value,
      value: value,
      error: error,
      fromResult: fromResult,
      fromFuture: fromFuture,
      fromPromise: fromPromise
    };

    var separator$1 = { type: 'separator' };
    var toMenuItem = function (target) {
      return {
        type: 'menuitem',
        value: target.url,
        text: target.title,
        meta: { attach: target.attach },
        onAction: noop
      };
    };
    var staticMenuItem = function (title, url) {
      return {
        type: 'menuitem',
        value: url,
        text: title,
        meta: { attach: undefined },
        onAction: noop
      };
    };
    var toMenuItems = function (targets) {
      return map$2(targets, toMenuItem);
    };
    var filterLinkTargets = function (type, targets) {
      return filter$2(targets, function (target) {
        return target.type === type;
      });
    };
    var filteredTargets = function (type, targets) {
      return toMenuItems(filterLinkTargets(type, targets));
    };
    var headerTargets = function (linkInfo) {
      return filteredTargets('header', linkInfo.targets);
    };
    var anchorTargets = function (linkInfo) {
      return filteredTargets('anchor', linkInfo.targets);
    };
    var anchorTargetTop = function (linkInfo) {
      return Optional.from(linkInfo.anchorTop).map(function (url) {
        return staticMenuItem('<top>', url);
      }).toArray();
    };
    var anchorTargetBottom = function (linkInfo) {
      return Optional.from(linkInfo.anchorBottom).map(function (url) {
        return staticMenuItem('<bottom>', url);
      }).toArray();
    };
    var historyTargets = function (history) {
      return map$2(history, function (url) {
        return staticMenuItem(url, url);
      });
    };
    var joinMenuLists = function (items) {
      return foldl(items, function (a, b) {
        var bothEmpty = a.length === 0 || b.length === 0;
        return bothEmpty ? a.concat(b) : a.concat(separator$1, b);
      }, []);
    };
    var filterByQuery = function (term, menuItems) {
      var lowerCaseTerm = term.toLowerCase();
      return filter$2(menuItems, function (item) {
        var text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;
        return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(item.value.toLowerCase(), lowerCaseTerm);
      });
    };

    var getItems = function (fileType, input, urlBackstage) {
      var urlInputValue = Representing.getValue(input);
      var term = urlInputValue.meta.text !== undefined ? urlInputValue.meta.text : urlInputValue.value;
      var info = urlBackstage.getLinkInformation();
      return info.fold(function () {
        return [];
      }, function (linkInfo) {
        var history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
        return fileType === 'file' ? joinMenuLists([
          history,
          filterByQuery(term, headerTargets(linkInfo)),
          filterByQuery(term, flatten([
            anchorTargetTop(linkInfo),
            anchorTargets(linkInfo),
            anchorTargetBottom(linkInfo)
          ]))
        ]) : history;
      });
    };
    var errorId = generate$6('aria-invalid');
    var renderUrlInput = function (spec, backstage, urlBackstage) {
      var _a;
      var providersBackstage = backstage.shared.providers;
      var updateHistory = function (component) {
        var urlEntry = Representing.getValue(component);
        urlBackstage.addToHistory(urlEntry.value, spec.filetype);
      };
      var pField = FormField.parts.field({
        factory: Typeahead,
        dismissOnBlur: true,
        inputClasses: ['tox-textfield'],
        sandboxClasses: ['tox-dialog__popups'],
        inputAttributes: {
          'aria-errormessage': errorId,
          'type': 'url'
        },
        minChars: 0,
        responseTime: 0,
        fetch: function (input) {
          var items = getItems(spec.filetype, input, urlBackstage);
          var tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, false);
          return Future.pure(tdata);
        },
        getHotspot: function (comp) {
          return memUrlBox.getOpt(comp);
        },
        onSetValue: function (comp, _newValue) {
          if (comp.hasConfigured(Invalidating)) {
            Invalidating.run(comp).get(noop);
          }
        },
        typeaheadBehaviours: derive$1(flatten([
          urlBackstage.getValidationHandler().map(function (handler) {
            return Invalidating.config({
              getRoot: function (comp) {
                return parent(comp.element);
              },
              invalidClass: 'tox-control-wrap--status-invalid',
              notify: {
                onInvalid: function (comp, err) {
                  memInvalidIcon.getOpt(comp).each(function (invalidComp) {
                    set$8(invalidComp.element, 'title', providersBackstage.translate(err));
                  });
                }
              },
              validator: {
                validate: function (input) {
                  var urlEntry = Representing.getValue(input);
                  return FutureResult.nu(function (completer) {
                    handler({
                      type: spec.filetype,
                      url: urlEntry.value
                    }, function (validation) {
                      if (validation.status === 'invalid') {
                        var err = Result.error(validation.message);
                        completer(err);
                      } else {
                        var val = Result.value(validation.message);
                        completer(val);
                      }
                    });
                  });
                },
                validateOnLoad: false
              }
            });
          }).toArray(),
          [
            Disabling.config({
              disabled: function () {
                return spec.disabled || providersBackstage.isDisabled();
              }
            }),
            Tabstopping.config({}),
            config('urlinput-events', flatten([
              spec.filetype === 'file' ? [run$1(input(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                })] : [],
              [
                run$1(change(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                  updateHistory(comp);
                }),
                run$1(postPaste(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                  updateHistory(comp);
                })
              ]
            ]))
          ]
        ])),
        eventOrder: (_a = {}, _a[input()] = [
          'streaming',
          'urlinput-events',
          'invalidating'
        ], _a),
        model: {
          getDisplayText: function (itemData) {
            return itemData.value;
          },
          selectsOver: false,
          populateFromBrowse: false
        },
        markers: { openClass: 'tox-textfield--popup-open' },
        lazySink: backstage.shared.getSink,
        parts: { menu: part(false, 1, 'normal') },
        onExecute: function (_menu, component, _entry) {
          emitWith(component, formSubmitEvent, {});
        },
        onItemExecute: function (typeahead, _sandbox, _item, _value) {
          updateHistory(typeahead);
          emitWith(typeahead, formChangeEvent, { name: spec.name });
        }
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel$2(label, providersBackstage);
      });
      var makeIcon = function (name, errId, icon, label) {
        if (icon === void 0) {
          icon = name;
        }
        if (label === void 0) {
          label = name;
        }
        return render$3(icon, {
          tag: 'div',
          classes: [
            'tox-icon',
            'tox-control-wrap__status-icon-' + name
          ],
          attributes: __assign({
            'title': providersBackstage.translate(label),
            'aria-live': 'polite'
          }, errId.fold(function () {
            return {};
          }, function (id) {
            return { id: id };
          }))
        }, providersBackstage.icons);
      };
      var memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));
      var memStatus = record({
        dom: {
          tag: 'div',
          classes: ['tox-control-wrap__status-icon-wrap']
        },
        components: [memInvalidIcon.asSpec()]
      });
      var optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
      var browseUrlEvent = generate$6('browser.url.event');
      var memUrlBox = record({
        dom: {
          tag: 'div',
          classes: ['tox-control-wrap']
        },
        components: [
          pField,
          memStatus.asSpec()
        ],
        behaviours: derive$1([Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            }
          })])
      });
      var memUrlPickerButton = record(renderButton({
        name: spec.name,
        icon: Optional.some('browse'),
        text: spec.label.getOr(''),
        disabled: spec.disabled,
        primary: false,
        borderless: true
      }, function (component) {
        return emit(component, browseUrlEvent);
      }, providersBackstage, [], ['tox-browse-url']));
      var controlHWrapper = function () {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-form__controls-h-stack']
          },
          components: flatten([
            [memUrlBox.asSpec()],
            optUrlPicker.map(function () {
              return memUrlPickerButton.asSpec();
            }).toArray()
          ])
        };
      };
      var openUrlPicker = function (comp) {
        Composing.getCurrent(comp).each(function (field) {
          var componentData = Representing.getValue(field);
          var urlData = __assign({ fieldname: spec.name }, componentData);
          optUrlPicker.each(function (picker) {
            picker(urlData).get(function (chosenData) {
              Representing.setValue(field, chosenData);
              emitWith(comp, formChangeEvent, { name: spec.name });
            });
          });
        });
      };
      return FormField.sketch({
        dom: renderFormFieldDom(),
        components: pLabel.toArray().concat([controlHWrapper()]),
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isDisabled();
            },
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
              memUrlPickerButton.getOpt(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
              memUrlPickerButton.getOpt(comp).each(Disabling.enable);
            }
          }),
          receivingConfig(),
          config('url-input-events', [run$1(browseUrlEvent, openUrlPicker)])
        ])
      });
    };

    var renderAlertBanner = function (spec, providersBackstage) {
      return Container.sketch({
        dom: {
          tag: 'div',
          attributes: { role: 'alert' },
          classes: [
            'tox-notification',
            'tox-notification--in',
            'tox-notification--' + spec.level
          ]
        },
        components: [
          {
            dom: {
              tag: 'div',
              classes: ['tox-notification__icon']
            },
            components: [Button.sketch({
                dom: {
                  tag: 'button',
                  classes: [
                    'tox-button',
                    'tox-button--naked',
                    'tox-button--icon'
                  ],
                  innerHtml: get$1(spec.icon, providersBackstage.icons),
                  attributes: { title: providersBackstage.translate(spec.iconTooltip) }
                },
                action: function (comp) {
                  emitWith(comp, formActionEvent, {
                    name: 'alert-banner',
                    value: spec.url
                  });
                },
                buttonBehaviours: derive$1([addFocusableBehaviour()])
              })]
          },
          {
            dom: {
              tag: 'div',
              classes: ['tox-notification__body'],
              innerHtml: providersBackstage.translate(spec.text)
            }
          }
        ]
      });
    };

    var renderCheckbox = function (spec, providerBackstage) {
      var repBehaviour = Representing.config({
        store: {
          mode: 'manual',
          getValue: function (comp) {
            var el = comp.element.dom;
            return el.checked;
          },
          setValue: function (comp, value) {
            var el = comp.element.dom;
            el.checked = value;
          }
        }
      });
      var toggleCheckboxHandler = function (comp) {
        comp.element.dom.click();
        return Optional.some(true);
      };
      var pField = FormField.parts.field({
        factory: { sketch: identity$1 },
        dom: {
          tag: 'input',
          classes: ['tox-checkbox__input'],
          attributes: { type: 'checkbox' }
        },
        behaviours: derive$1([
          ComposingConfigs.self(),
          Disabling.config({
            disabled: function () {
              return spec.disabled || providerBackstage.isDisabled();
            }
          }),
          Tabstopping.config({}),
          Focusing.config({}),
          repBehaviour,
          Keying.config({
            mode: 'special',
            onEnter: toggleCheckboxHandler,
            onSpace: toggleCheckboxHandler,
            stopSpaceKeyup: true
          }),
          config('checkbox-events', [run$1(change(), function (component, _) {
              emitWith(component, formChangeEvent, { name: spec.name });
            })])
        ])
      });
      var pLabel = FormField.parts.label({
        dom: {
          tag: 'span',
          classes: ['tox-checkbox__label'],
          innerHtml: providerBackstage.translate(spec.label)
        },
        behaviours: derive$1([Unselecting.config({})])
      });
      var makeIcon = function (className) {
        var iconName = className === 'checked' ? 'selected' : 'unselected';
        return render$3(iconName, {
          tag: 'span',
          classes: [
            'tox-icon',
            'tox-checkbox-icon__' + className
          ]
        }, providerBackstage.icons);
      };
      var memIcons = record({
        dom: {
          tag: 'div',
          classes: ['tox-checkbox__icons']
        },
        components: [
          makeIcon('checked'),
          makeIcon('unchecked')
        ]
      });
      return FormField.sketch({
        dom: {
          tag: 'label',
          classes: ['tox-checkbox']
        },
        components: [
          pField,
          memIcons.asSpec(),
          pLabel
        ],
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providerBackstage.isDisabled();
            },
            disableClass: 'tox-checkbox--disabled',
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
            }
          }),
          receivingConfig()
        ])
      });
    };

    var renderHtmlPanel = function (spec) {
      if (spec.presets === 'presentation') {
        return Container.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-form__group'],
            innerHtml: spec.html
          }
        });
      } else {
        return Container.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-form__group'],
            innerHtml: spec.html,
            attributes: { role: 'document' }
          },
          containerBehaviours: derive$1([
            Tabstopping.config({}),
            Focusing.config({})
          ])
        });
      }
    };

    var make$2 = function (render) {
      return function (parts, spec, backstage) {
        return get$e(spec, 'name').fold(function () {
          return render(spec, backstage);
        }, function (fieldName) {
          return parts.field(fieldName, render(spec, backstage));
        });
      };
    };
    var makeIframe = function (render) {
      return function (parts, spec, backstage) {
        var iframeSpec = deepMerge(spec, { source: 'dynamic' });
        return make$2(render)(parts, iframeSpec, backstage);
      };
    };
    var factories = {
      bar: make$2(function (spec, backstage) {
        return renderBar(spec, backstage.shared);
      }),
      collection: make$2(function (spec, backstage) {
        return renderCollection(spec, backstage.shared.providers);
      }),
      alertbanner: make$2(function (spec, backstage) {
        return renderAlertBanner(spec, backstage.shared.providers);
      }),
      input: make$2(function (spec, backstage) {
        return renderInput(spec, backstage.shared.providers);
      }),
      textarea: make$2(function (spec, backstage) {
        return renderTextarea(spec, backstage.shared.providers);
      }),
      label: make$2(function (spec, backstage) {
        return renderLabel(spec, backstage.shared);
      }),
      iframe: makeIframe(function (spec, backstage) {
        return renderIFrame(spec, backstage.shared.providers);
      }),
      button: make$2(function (spec, backstage) {
        return renderDialogButton(spec, backstage.shared.providers);
      }),
      checkbox: make$2(function (spec, backstage) {
        return renderCheckbox(spec, backstage.shared.providers);
      }),
      colorinput: make$2(function (spec, backstage) {
        return renderColorInput(spec, backstage.shared, backstage.colorinput);
      }),
      colorpicker: make$2(renderColorPicker),
      dropzone: make$2(function (spec, backstage) {
        return renderDropZone(spec, backstage.shared.providers);
      }),
      grid: make$2(function (spec, backstage) {
        return renderGrid(spec, backstage.shared);
      }),
      listbox: make$2(function (spec, backstage) {
        return renderListBox(spec, backstage);
      }),
      selectbox: make$2(function (spec, backstage) {
        return renderSelectBox(spec, backstage.shared.providers);
      }),
      sizeinput: make$2(function (spec, backstage) {
        return renderSizeInput(spec, backstage.shared.providers);
      }),
      urlinput: make$2(function (spec, backstage) {
        return renderUrlInput(spec, backstage, backstage.urlinput);
      }),
      customeditor: make$2(renderCustomEditor),
      htmlpanel: make$2(renderHtmlPanel),
      imagetools: make$2(function (spec, backstage) {
        return renderImageTools(spec, backstage.shared.providers);
      }),
      table: make$2(function (spec, backstage) {
        return renderTable(spec, backstage.shared.providers);
      }),
      panel: make$2(function (spec, backstage) {
        return renderPanel(spec, backstage);
      })
    };
    var noFormParts = {
      field: function (_name, spec) {
        return spec;
      }
    };
    var interpretInForm = function (parts, spec, oldBackstage) {
      var newBackstage = deepMerge(oldBackstage, {
        shared: {
          interpreter: function (childSpec) {
            return interpretParts(parts, childSpec, newBackstage);
          }
        }
      });
      return interpretParts(parts, spec, newBackstage);
    };
    var interpretParts = function (parts, spec, backstage) {
      return get$e(factories, spec.type).fold(function () {
        console.error('Unknown factory type "' + spec.type + '", defaulting to container: ', spec);
        return spec;
      }, function (factory) {
        return factory(parts, spec, backstage);
      });
    };
    var interpretWithoutForm = function (spec, backstage) {
      var parts = noFormParts;
      return interpretParts(parts, spec, backstage);
    };

    var bubbleAlignments$2 = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [],
      alignRight: [],
      right: [],
      left: [],
      bottom: [],
      top: []
    };
    var getInlineDialogAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {
      var bubbleSize = 12;
      var overrides = { maxHeightFunction: expandable$1() };
      var editableAreaAnchor = function () {
        return {
          type: 'node',
          root: getContentContainer(contentAreaElement()),
          node: Optional.from(contentAreaElement()),
          bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),
          layouts: {
            onRtl: function () {
              return [northeast];
            },
            onLtr: function () {
              return [northwest];
            }
          },
          overrides: overrides
        };
      };
      var standardAnchor = function () {
        return {
          type: 'hotspot',
          hotspot: lazyAnchorbar(),
          bubble: nu$5(-bubbleSize, bubbleSize, bubbleAlignments$2),
          layouts: {
            onRtl: function () {
              return [southeast$2];
            },
            onLtr: function () {
              return [southwest$2];
            }
          },
          overrides: overrides
        };
      };
      return function () {
        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
      };
    };
    var getBannerAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {
      var editableAreaAnchor = function () {
        return {
          type: 'node',
          root: getContentContainer(contentAreaElement()),
          node: Optional.from(contentAreaElement()),
          layouts: {
            onRtl: function () {
              return [north];
            },
            onLtr: function () {
              return [north];
            }
          }
        };
      };
      var standardAnchor = function () {
        return {
          type: 'hotspot',
          hotspot: lazyAnchorbar(),
          layouts: {
            onRtl: function () {
              return [south$2];
            },
            onLtr: function () {
              return [south$2];
            }
          }
        };
      };
      return function () {
        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
      };
    };
    var getCursorAnchor = function (editor, bodyElement) {
      return function () {
        return {
          type: 'selection',
          root: bodyElement(),
          getSelection: function () {
            var rng = editor.selection.getRng();
            return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
          }
        };
      };
    };
    var getNodeAnchor$1 = function (bodyElement) {
      return function (element) {
        return {
          type: 'node',
          root: bodyElement(),
          node: element
        };
      };
    };
    var getAnchors = function (editor, lazyAnchorbar, isToolbarTop) {
      var useFixedToolbarContainer = useFixedContainer(editor);
      var bodyElement = function () {
        return SugarElement.fromDom(editor.getBody());
      };
      var contentAreaElement = function () {
        return SugarElement.fromDom(editor.getContentAreaContainer());
      };
      var lazyUseEditableAreaAnchor = function () {
        return useFixedToolbarContainer || !isToolbarTop();
      };
      return {
        inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
        banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
        cursor: getCursorAnchor(editor, bodyElement),
        node: getNodeAnchor$1(bodyElement)
      };
    };

    var colorPicker = function (editor) {
      return function (callback, value) {
        var dialog = colorPickerDialog(editor);
        dialog(callback, value);
      };
    };
    var hasCustomColors = function (editor) {
      return function () {
        return hasCustomColors$1(editor);
      };
    };
    var getColors = function (editor) {
      return function () {
        return getColors$2(editor);
      };
    };
    var getColorCols = function (editor) {
      return function () {
        return getColorCols$1(editor);
      };
    };
    var ColorInputBackstage = function (editor) {
      return {
        colorPicker: colorPicker(editor),
        hasCustomColors: hasCustomColors(editor),
        getColors: getColors(editor),
        getColorCols: getColorCols(editor)
      };
    };

    var isDraggableModal = function (editor) {
      return function () {
        return isDraggableModal$1(editor);
      };
    };
    var DialogBackstage = function (editor) {
      return { isDraggableModal: isDraggableModal(editor) };
    };

    var HeaderBackstage = function (editor) {
      var mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');
      return {
        isPositionedAtTop: function () {
          return mode.get() === 'top';
        },
        getDockingMode: mode.get,
        setDockingMode: mode.set
      };
    };

    var defaultStyleFormats = [
      {
        title: 'Headings',
        items: [
          {
            title: 'Heading 1',
            format: 'h1'
          },
          {
            title: 'Heading 2',
            format: 'h2'
          },
          {
            title: 'Heading 3',
            format: 'h3'
          },
          {
            title: 'Heading 4',
            format: 'h4'
          },
          {
            title: 'Heading 5',
            format: 'h5'
          },
          {
            title: 'Heading 6',
            format: 'h6'
          }
        ]
      },
      {
        title: 'Inline',
        items: [
          {
            title: 'Bold',
            format: 'bold'
          },
          {
            title: 'Italic',
            format: 'italic'
          },
          {
            title: 'Underline',
            format: 'underline'
          },
          {
            title: 'Strikethrough',
            format: 'strikethrough'
          },
          {
            title: 'Superscript',
            format: 'superscript'
          },
          {
            title: 'Subscript',
            format: 'subscript'
          },
          {
            title: 'Code',
            format: 'code'
          }
        ]
      },
      {
        title: 'Blocks',
        items: [
          {
            title: 'Paragraph',
            format: 'p'
          },
          {
            title: 'Blockquote',
            format: 'blockquote'
          },
          {
            title: 'Div',
            format: 'div'
          },
          {
            title: 'Pre',
            format: 'pre'
          }
        ]
      },
      {
        title: 'Align',
        items: [
          {
            title: 'Left',
            format: 'alignleft'
          },
          {
            title: 'Center',
            format: 'aligncenter'
          },
          {
            title: 'Right',
            format: 'alignright'
          },
          {
            title: 'Justify',
            format: 'alignjustify'
          }
        ]
      }
    ];
    var isNestedFormat = function (format) {
      return has$2(format, 'items');
    };
    var isBlockFormat = function (format) {
      return has$2(format, 'block');
    };
    var isInlineFormat = function (format) {
      return has$2(format, 'inline');
    };
    var isSelectorFormat = function (format) {
      return has$2(format, 'selector');
    };
    var mapFormats = function (userFormats) {
      return foldl(userFormats, function (acc, fmt) {
        if (isNestedFormat(fmt)) {
          var result = mapFormats(fmt.items);
          return {
            customFormats: acc.customFormats.concat(result.customFormats),
            formats: acc.formats.concat([{
                title: fmt.title,
                items: result.formats
              }])
          };
        } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
          var formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();
          var formatNameWithPrefix = 'custom-' + formatName;
          return {
            customFormats: acc.customFormats.concat([{
                name: formatNameWithPrefix,
                format: fmt
              }]),
            formats: acc.formats.concat([{
                title: fmt.title,
                format: formatNameWithPrefix,
                icon: fmt.icon
              }])
          };
        } else {
          return __assign(__assign({}, acc), { formats: acc.formats.concat(fmt) });
        }
      }, {
        customFormats: [],
        formats: []
      });
    };
    var registerCustomFormats = function (editor, userFormats) {
      var result = mapFormats(userFormats);
      var registerFormats = function (customFormats) {
        each$1(customFormats, function (fmt) {
          if (!editor.formatter.has(fmt.name)) {
            editor.formatter.register(fmt.name, fmt.format);
          }
        });
      };
      if (editor.formatter) {
        registerFormats(result.customFormats);
      } else {
        editor.on('init', function () {
          registerFormats(result.customFormats);
        });
      }
      return result.formats;
    };
    var getStyleFormats = function (editor) {
      return getUserStyleFormats(editor).map(function (userFormats) {
        var registeredUserFormats = registerCustomFormats(editor, userFormats);
        return isMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
      }).getOr(defaultStyleFormats);
    };

    var processBasic = function (item, isSelectedFor, getPreviewFor) {
      var formatterSpec = {
        type: 'formatter',
        isSelected: isSelectedFor(item.format),
        getStylePreview: getPreviewFor(item.format)
      };
      return deepMerge(item, formatterSpec);
    };
    var register$8 = function (editor, formats, isSelectedFor, getPreviewFor) {
      var enrichSupported = function (item) {
        return processBasic(item, isSelectedFor, getPreviewFor);
      };
      var enrichMenu = function (item) {
        var submenuSpec = { type: 'submenu' };
        return deepMerge(item, submenuSpec);
      };
      var enrichCustom = function (item) {
        var formatName = isString(item.name) ? item.name : generate$6(item.title);
        var formatNameWithPrefix = 'custom-' + formatName;
        var customSpec = {
          type: 'formatter',
          format: formatNameWithPrefix,
          isSelected: isSelectedFor(formatNameWithPrefix),
          getStylePreview: getPreviewFor(formatNameWithPrefix)
        };
        var newItem = deepMerge(item, customSpec);
        editor.formatter.register(formatName, newItem);
        return newItem;
      };
      var doEnrich = function (items) {
        return map$2(items, function (item) {
          var keys$1 = keys(item);
          if (hasNonNullableKey(item, 'items')) {
            var newItems = doEnrich(item.items);
            return deepMerge(enrichMenu(item), { getStyleItems: constant$1(newItems) });
          } else if (hasNonNullableKey(item, 'format')) {
            return enrichSupported(item);
          } else if (keys$1.length === 1 && contains$2(keys$1, 'title')) {
            return deepMerge(item, { type: 'separator' });
          } else {
            return enrichCustom(item);
          }
        });
      };
      return doEnrich(formats);
    };

    var init$8 = function (editor) {
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return fmt !== undefined ? Optional.some({
            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          }) : Optional.none();
        };
      };
      var flatten = function (fmt) {
        var subs = fmt.items;
        return subs !== undefined && subs.length > 0 ? bind$3(subs, flatten) : [fmt.format];
      };
      var settingsFormats = Cell([]);
      var settingsFlattenedFormats = Cell([]);
      var eventsFormats = Cell([]);
      var eventsFlattenedFormats = Cell([]);
      var replaceSettings = Cell(false);
      editor.on('PreInit', function (_e) {
        var formats = getStyleFormats(editor);
        var enriched = register$8(editor, formats, isSelectedFor, getPreviewFor);
        settingsFormats.set(enriched);
        settingsFlattenedFormats.set(bind$3(enriched, flatten));
      });
      editor.on('addStyleModifications', function (e) {
        var modifications = register$8(editor, e.items, isSelectedFor, getPreviewFor);
        eventsFormats.set(modifications);
        replaceSettings.set(e.replace);
        eventsFlattenedFormats.set(bind$3(modifications, flatten));
      });
      var getData = function () {
        var fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
        var fromEvents = eventsFormats.get();
        return fromSettings.concat(fromEvents);
      };
      var getFlattenedKeys = function () {
        var fromSettings = replaceSettings.get() ? [] : settingsFlattenedFormats.get();
        var fromEvents = eventsFlattenedFormats.get();
        return fromSettings.concat(fromEvents);
      };
      return {
        getData: getData,
        getFlattenedKeys: getFlattenedKeys
      };
    };

    var isElement = function (node) {
      return isNonNullable(node) && node.nodeType === 1;
    };
    var trim = global$5.trim;
    var hasContentEditableState = function (value) {
      return function (node) {
        if (isElement(node)) {
          if (node.contentEditable === value) {
            return true;
          }
          if (node.getAttribute('data-mce-contenteditable') === value) {
            return true;
          }
        }
        return false;
      };
    };
    var isContentEditableTrue = hasContentEditableState('true');
    var isContentEditableFalse = hasContentEditableState('false');
    var create = function (type, title, url, level, attach) {
      return {
        type: type,
        title: title,
        url: url,
        level: level,
        attach: attach
      };
    };
    var isChildOfContentEditableTrue = function (node) {
      while (node = node.parentNode) {
        var value = node.contentEditable;
        if (value && value !== 'inherit') {
          return isContentEditableTrue(node);
        }
      }
      return false;
    };
    var select = function (selector, root) {
      return map$2(descendants(SugarElement.fromDom(root), selector), function (element) {
        return element.dom;
      });
    };
    var getElementText = function (elm) {
      return elm.innerText || elm.textContent;
    };
    var getOrGenerateId = function (elm) {
      return elm.id ? elm.id : generate$6('h');
    };
    var isAnchor = function (elm) {
      return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;
    };
    var isValidAnchor = function (elm) {
      return isAnchor(elm) && isEditable(elm);
    };
    var isHeader = function (elm) {
      return elm && /^(H[1-6])$/.test(elm.nodeName);
    };
    var isEditable = function (elm) {
      return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
    };
    var isValidHeader = function (elm) {
      return isHeader(elm) && isEditable(elm);
    };
    var getLevel = function (elm) {
      return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
    };
    var headerTarget = function (elm) {
      var headerId = getOrGenerateId(elm);
      var attach = function () {
        elm.id = headerId;
      };
      return create('header', getElementText(elm), '#' + headerId, getLevel(elm), attach);
    };
    var anchorTarget = function (elm) {
      var anchorId = elm.id || elm.name;
      var anchorText = getElementText(elm);
      return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);
    };
    var getHeaderTargets = function (elms) {
      return map$2(filter$2(elms, isValidHeader), headerTarget);
    };
    var getAnchorTargets = function (elms) {
      return map$2(filter$2(elms, isValidAnchor), anchorTarget);
    };
    var getTargetElements = function (elm) {
      var elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);
      return elms;
    };
    var hasTitle = function (target) {
      return trim(target.title).length > 0;
    };
    var find = function (elm) {
      var elms = getTargetElements(elm);
      return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
    };
    var LinkTargets = { find: find };

    var STORAGE_KEY = 'tinymce-url-history';
    var HISTORY_LENGTH = 5;
    var isHttpUrl = function (url) {
      return isString(url) && /^https?/.test(url);
    };
    var isArrayOfUrl = function (a) {
      return isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);
    };
    var isRecordOfUrlArray = function (r) {
      return isObject(r) && find$4(r, function (value) {
        return !isArrayOfUrl(value);
      }).isNone();
    };
    var getAllHistory = function () {
      var unparsedHistory = global$8.getItem(STORAGE_KEY);
      if (unparsedHistory === null) {
        return {};
      }
      var history;
      try {
        history = JSON.parse(unparsedHistory);
      } catch (e) {
        if (e instanceof SyntaxError) {
          console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);
          return {};
        }
        throw e;
      }
      if (!isRecordOfUrlArray(history)) {
        console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);
        return {};
      }
      return history;
    };
    var setAllHistory = function (history) {
      if (!isRecordOfUrlArray(history)) {
        throw new Error('Bad format for history:\n' + JSON.stringify(history));
      }
      global$8.setItem(STORAGE_KEY, JSON.stringify(history));
    };
    var getHistory = function (fileType) {
      var history = getAllHistory();
      return get$e(history, fileType).getOr([]);
    };
    var addToHistory = function (url, fileType) {
      if (!isHttpUrl(url)) {
        return;
      }
      var history = getAllHistory();
      var items = get$e(history, fileType).getOr([]);
      var itemsWithoutUrl = filter$2(items, function (item) {
        return item !== url;
      });
      history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
      setAllHistory(history);
    };

    var isTruthy = function (value) {
      return !!value;
    };
    var makeMap = function (value) {
      return map$1(global$5.makeMap(value, /[, ]/), isTruthy);
    };
    var getPicker = function (editor) {
      return Optional.from(getFilePickerCallback(editor)).filter(isFunction);
    };
    var getPickerTypes = function (editor) {
      var optFileTypes = Optional.some(getFilePickerTypes(editor)).filter(isTruthy);
      var optLegacyTypes = Optional.some(getFileBrowserCallbackTypes(editor)).filter(isTruthy);
      var optTypes = optFileTypes.or(optLegacyTypes).map(makeMap);
      return getPicker(editor).fold(never, function (_picker) {
        return optTypes.fold(always, function (types) {
          return keys(types).length > 0 ? types : false;
        });
      });
    };
    var getPickerSetting = function (editor, filetype) {
      var pickerTypes = getPickerTypes(editor);
      if (isBoolean(pickerTypes)) {
        return pickerTypes ? getPicker(editor) : Optional.none();
      } else {
        return pickerTypes[filetype] ? getPicker(editor) : Optional.none();
      }
    };
    var getUrlPicker = function (editor, filetype) {
      return getPickerSetting(editor, filetype).map(function (picker) {
        return function (entry) {
          return Future.nu(function (completer) {
            var handler = function (value, meta) {
              if (!isString(value)) {
                throw new Error('Expected value to be string');
              }
              if (meta !== undefined && !isObject(meta)) {
                throw new Error('Expected meta to be a object');
              }
              var r = {
                value: value,
                meta: meta
              };
              completer(r);
            };
            var meta = __assign({
              filetype: filetype,
              fieldname: entry.fieldname
            }, Optional.from(entry.meta).getOr({}));
            picker.call(editor, handler, entry.value, meta);
          });
        };
      });
    };
    var getTextSetting = function (value) {
      return Optional.from(value).filter(isString).getOrUndefined();
    };
    var getLinkInformation = function (editor) {
      if (noTypeaheadUrls(editor)) {
        return Optional.none();
      }
      return Optional.some({
        targets: LinkTargets.find(editor.getBody()),
        anchorTop: getTextSetting(getAnchorTop(editor)),
        anchorBottom: getTextSetting(getAnchorBottom(editor))
      });
    };
    var getValidationHandler = function (editor) {
      return Optional.from(getFilePickerValidatorHandler(editor));
    };
    var UrlInputBackstage = function (editor) {
      return {
        getHistory: getHistory,
        addToHistory: addToHistory,
        getLinkInformation: function () {
          return getLinkInformation(editor);
        },
        getValidationHandler: function () {
          return getValidationHandler(editor);
        },
        getUrlPicker: function (filetype) {
          return getUrlPicker(editor, filetype);
        }
      };
    };

    var init$7 = function (sink, editor, lazyAnchorbar) {
      var contextMenuState = Cell(false);
      var toolbar = HeaderBackstage(editor);
      var backstage = {
        shared: {
          providers: {
            icons: function () {
              return editor.ui.registry.getAll().icons;
            },
            menuItems: function () {
              return editor.ui.registry.getAll().menuItems;
            },
            translate: global$e.translate,
            isDisabled: function () {
              return editor.mode.isReadOnly() || editor.ui.isDisabled();
            },
            getSetting: editor.getParam.bind(editor)
          },
          interpreter: function (s) {
            return interpretWithoutForm(s, backstage);
          },
          anchors: getAnchors(editor, lazyAnchorbar, toolbar.isPositionedAtTop),
          header: toolbar,
          getSink: function () {
            return Result.value(sink);
          }
        },
        urlinput: UrlInputBackstage(editor),
        styleselect: init$8(editor),
        colorinput: ColorInputBackstage(editor),
        dialog: DialogBackstage(editor),
        isContextMenuOpen: function () {
          return contextMenuState.get();
        },
        setContextMenuState: function (state) {
          return contextMenuState.set(state);
        }
      };
      return backstage;
    };

    var setup$b = function (editor, mothership, uiMothership) {
      var broadcastEvent = function (name, evt) {
        each$1([
          mothership,
          uiMothership
        ], function (ship) {
          ship.broadcastEvent(name, evt);
        });
      };
      var broadcastOn = function (channel, message) {
        each$1([
          mothership,
          uiMothership
        ], function (ship) {
          ship.broadcastOn([channel], message);
        });
      };
      var fireDismissPopups = function (evt) {
        return broadcastOn(dismissPopups(), { target: evt.target });
      };
      var doc = getDocument();
      var onTouchstart = bind(doc, 'touchstart', fireDismissPopups);
      var onTouchmove = bind(doc, 'touchmove', function (evt) {
        return broadcastEvent(documentTouchmove(), evt);
      });
      var onTouchend = bind(doc, 'touchend', function (evt) {
        return broadcastEvent(documentTouchend(), evt);
      });
      var onMousedown = bind(doc, 'mousedown', fireDismissPopups);
      var onMouseup = bind(doc, 'mouseup', function (evt) {
        if (evt.raw.button === 0) {
          broadcastOn(mouseReleased(), { target: evt.target });
        }
      });
      var onContentClick = function (raw) {
        return broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });
      };
      var onContentMouseup = function (raw) {
        if (raw.button === 0) {
          broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });
        }
      };
      var onContentMousedown = function () {
        each$1(editor.editorManager.get(), function (loopEditor) {
          if (editor !== loopEditor) {
            loopEditor.fire('DismissPopups', { relatedTarget: editor });
          }
        });
      };
      var onWindowScroll = function (evt) {
        return broadcastEvent(windowScroll(), fromRawEvent(evt));
      };
      var onWindowResize = function (evt) {
        broadcastOn(repositionPopups(), {});
        broadcastEvent(windowResize(), fromRawEvent(evt));
      };
      var onEditorResize = function () {
        return broadcastOn(repositionPopups(), {});
      };
      var onEditorProgress = function (evt) {
        if (evt.state) {
          broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });
        }
      };
      var onDismissPopups = function (event) {
        broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });
      };
      editor.on('PostRender', function () {
        editor.on('click', onContentClick);
        editor.on('tap', onContentClick);
        editor.on('mouseup', onContentMouseup);
        editor.on('mousedown', onContentMousedown);
        editor.on('ScrollWindow', onWindowScroll);
        editor.on('ResizeWindow', onWindowResize);
        editor.on('ResizeEditor', onEditorResize);
        editor.on('AfterProgressState', onEditorProgress);
        editor.on('DismissPopups', onDismissPopups);
      });
      editor.on('remove', function () {
        editor.off('click', onContentClick);
        editor.off('tap', onContentClick);
        editor.off('mouseup', onContentMouseup);
        editor.off('mousedown', onContentMousedown);
        editor.off('ScrollWindow', onWindowScroll);
        editor.off('ResizeWindow', onWindowResize);
        editor.off('ResizeEditor', onEditorResize);
        editor.off('AfterProgressState', onEditorProgress);
        editor.off('DismissPopups', onDismissPopups);
        onMousedown.unbind();
        onTouchstart.unbind();
        onTouchmove.unbind();
        onTouchend.unbind();
        onMouseup.unbind();
      });
      editor.on('detach', function () {
        detachSystem(mothership);
        detachSystem(uiMothership);
        mothership.destroy();
        uiMothership.destroy();
      });
    };

    var parts$a = AlloyParts;
    var partType = PartType;

    var schema$f = constant$1([
      defaulted('shell', false),
      required$1('makeItem'),
      defaulted('setupItem', noop),
      SketchBehaviours.field('listBehaviours', [Replacing])
    ]);
    var customListDetail = function () {
      return { behaviours: derive$1([Replacing.config({})]) };
    };
    var itemsPart = optional({
      name: 'items',
      overrides: customListDetail
    });
    var parts$9 = constant$1([itemsPart]);
    var name = constant$1('CustomList');

    var factory$d = function (detail, components, _spec, _external) {
      var setItems = function (list, items) {
        getListContainer(list).fold(function () {
          console.error('Custom List was defined to not be a shell, but no item container was specified in components');
          throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');
        }, function (container) {
          var itemComps = Replacing.contents(container);
          var numListsRequired = items.length;
          var numListsToAdd = numListsRequired - itemComps.length;
          var itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, function () {
            return detail.makeItem();
          }) : [];
          var itemsToRemove = itemComps.slice(numListsRequired);
          each$1(itemsToRemove, function (item) {
            return Replacing.remove(container, item);
          });
          each$1(itemsToAdd, function (item) {
            return Replacing.append(container, item);
          });
          var builtLists = Replacing.contents(container);
          each$1(builtLists, function (item, i) {
            detail.setupItem(list, item, items[i], i);
          });
        });
      };
      var extra = detail.shell ? {
        behaviours: [Replacing.config({})],
        components: []
      } : {
        behaviours: [],
        components: components
      };
      var getListContainer = function (component) {
        return detail.shell ? Optional.some(component) : getPart(component, detail, 'items');
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: extra.components,
        behaviours: augment(detail.listBehaviours, extra.behaviours),
        apis: { setItems: setItems }
      };
    };
    var CustomList = composite({
      name: name(),
      configFields: schema$f(),
      partFields: parts$9(),
      factory: factory$d,
      apis: {
        setItems: function (apis, list, items) {
          apis.setItems(list, items);
        }
      }
    });

    var schema$e = constant$1([
      required$1('dom'),
      defaulted('shell', true),
      field('toolbarBehaviours', [Replacing])
    ]);
    var enhanceGroups = function () {
      return { behaviours: derive$1([Replacing.config({})]) };
    };
    var parts$8 = constant$1([optional({
        name: 'groups',
        overrides: enhanceGroups
      })]);

    var factory$c = function (detail, components, _spec, _externals) {
      var setGroups = function (toolbar, groups) {
        getGroupContainer(toolbar).fold(function () {
          console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');
          throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');
        }, function (container) {
          Replacing.set(container, groups);
        });
      };
      var getGroupContainer = function (component) {
        return detail.shell ? Optional.some(component) : getPart(component, detail, 'groups');
      };
      var extra = detail.shell ? {
        behaviours: [Replacing.config({})],
        components: []
      } : {
        behaviours: [],
        components: components
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: extra.components,
        behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
        apis: { setGroups: setGroups },
        domModification: { attributes: { role: 'group' } }
      };
    };
    var Toolbar = composite({
      name: 'Toolbar',
      configFields: schema$e(),
      partFields: parts$8(),
      factory: factory$c,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        }
      }
    });

    var setup$a = noop;
    var isDocked$2 = never;
    var getBehaviours$1 = constant$1([]);

    var StaticHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$a,
        isDocked: isDocked$2,
        getBehaviours: getBehaviours$1
    });

    var getOffsetParent = function (element) {
      var isFixed = is$1(getRaw(element, 'position'), 'fixed');
      var offsetParent$1 = isFixed ? Optional.none() : offsetParent(element);
      return offsetParent$1.orThunk(function () {
        var marker = SugarElement.fromTag('span');
        return parent(element).bind(function (parent) {
          append$2(parent, marker);
          var offsetParent$1 = offsetParent(marker);
          remove$5(marker);
          return offsetParent$1;
        });
      });
    };
    var getOrigin = function (element) {
      return getOffsetParent(element).map(absolute$3).getOrThunk(function () {
        return SugarPosition(0, 0);
      });
    };

    var morphAdt = Adt.generate([
      { static: [] },
      { absolute: ['positionCss'] },
      { fixed: ['positionCss'] }
    ]);
    var appear = function (component, contextualInfo) {
      var elem = component.element;
      add$2(elem, contextualInfo.transitionClass);
      remove$2(elem, contextualInfo.fadeOutClass);
      add$2(elem, contextualInfo.fadeInClass);
      contextualInfo.onShow(component);
    };
    var disappear = function (component, contextualInfo) {
      var elem = component.element;
      add$2(elem, contextualInfo.transitionClass);
      remove$2(elem, contextualInfo.fadeInClass);
      add$2(elem, contextualInfo.fadeOutClass);
      contextualInfo.onHide(component);
    };
    var isPartiallyVisible = function (box, viewport) {
      return box.y < viewport.bottom && box.bottom > viewport.y;
    };
    var isTopCompletelyVisible = function (box, viewport) {
      return box.y >= viewport.y;
    };
    var isBottomCompletelyVisible = function (box, viewport) {
      return box.bottom <= viewport.bottom;
    };
    var isVisibleForModes = function (modes, box, viewport) {
      return forall(modes, function (mode) {
        switch (mode) {
        case 'bottom':
          return isBottomCompletelyVisible(box, viewport);
        case 'top':
          return isTopCompletelyVisible(box, viewport);
        }
      });
    };
    var getPrior = function (elem, state) {
      return state.getInitialPos().map(function (pos) {
        return bounds(pos.bounds.x, pos.bounds.y, get$a(elem), get$b(elem));
      });
    };
    var storePrior = function (elem, box, state) {
      state.setInitialPos({
        style: getAllRaw(elem),
        position: get$c(elem, 'position') || 'static',
        bounds: box
      });
    };
    var revertToOriginal = function (elem, box, state) {
      return state.getInitialPos().bind(function (position) {
        state.clearInitialPos();
        switch (position.position) {
        case 'static':
          return Optional.some(morphAdt.static());
        case 'absolute':
          var offsetBox_1 = getOffsetParent(elem).map(box$1).getOrThunk(function () {
            return box$1(body());
          });
          return Optional.some(morphAdt.absolute(NuPositionCss('absolute', get$e(position.style, 'left').map(function (_left) {
            return box.x - offsetBox_1.x;
          }), get$e(position.style, 'top').map(function (_top) {
            return box.y - offsetBox_1.y;
          }), get$e(position.style, 'right').map(function (_right) {
            return offsetBox_1.right - box.right;
          }), get$e(position.style, 'bottom').map(function (_bottom) {
            return offsetBox_1.bottom - box.bottom;
          }))));
        default:
          return Optional.none();
        }
      });
    };
    var morphToOriginal = function (elem, viewport, state) {
      return getPrior(elem, state).filter(function (box) {
        return isVisibleForModes(state.getModes(), box, viewport);
      }).bind(function (box) {
        return revertToOriginal(elem, box, state);
      });
    };
    var morphToFixed = function (elem, viewport, state) {
      var box = box$1(elem);
      if (!isVisibleForModes(state.getModes(), box, viewport)) {
        storePrior(elem, box, state);
        var winBox = win();
        var left = box.x - winBox.x;
        var top_1 = viewport.y - winBox.y;
        var bottom = winBox.bottom - viewport.bottom;
        var isTop = box.y <= viewport.y;
        return Optional.some(morphAdt.fixed(NuPositionCss('fixed', Optional.some(left), isTop ? Optional.some(top_1) : Optional.none(), Optional.none(), !isTop ? Optional.some(bottom) : Optional.none())));
      } else {
        return Optional.none();
      }
    };
    var getMorph = function (component, viewport, state) {
      var elem = component.element;
      var isDocked = is$1(getRaw(elem, 'position'), 'fixed');
      return isDocked ? morphToOriginal(elem, viewport, state) : morphToFixed(elem, viewport, state);
    };
    var getMorphToOriginal = function (component, state) {
      var elem = component.element;
      return getPrior(elem, state).bind(function (box) {
        return revertToOriginal(elem, box, state);
      });
    };

    var morphToStatic = function (component, config, state) {
      state.setDocked(false);
      each$1([
        'left',
        'right',
        'top',
        'bottom',
        'position'
      ], function (prop) {
        return remove$6(component.element, prop);
      });
      config.onUndocked(component);
    };
    var morphToCoord = function (component, config, state, position) {
      var isDocked = position.position === 'fixed';
      state.setDocked(isDocked);
      applyPositionCss(component.element, position);
      var method = isDocked ? config.onDocked : config.onUndocked;
      method(component);
    };
    var updateVisibility = function (component, config, state, viewport, morphToDocked) {
      if (morphToDocked === void 0) {
        morphToDocked = false;
      }
      config.contextual.each(function (contextInfo) {
        contextInfo.lazyContext(component).each(function (box) {
          var isVisible = isPartiallyVisible(box, viewport);
          if (isVisible !== state.isVisible()) {
            state.setVisible(isVisible);
            if (morphToDocked && !isVisible) {
              add$1(component.element, [contextInfo.fadeOutClass]);
              contextInfo.onHide(component);
            } else {
              var method = isVisible ? appear : disappear;
              method(component, contextInfo);
            }
          }
        });
      });
    };
    var refreshInternal = function (component, config, state) {
      var viewport = config.lazyViewport(component);
      var isDocked = state.isDocked();
      if (isDocked) {
        updateVisibility(component, config, state, viewport);
      }
      getMorph(component, viewport, state).each(function (morph) {
        morph.fold(function () {
          return morphToStatic(component, config, state);
        }, function (position) {
          return morphToCoord(component, config, state, position);
        }, function (position) {
          updateVisibility(component, config, state, viewport, true);
          morphToCoord(component, config, state, position);
        });
      });
    };
    var resetInternal = function (component, config, state) {
      var elem = component.element;
      state.setDocked(false);
      getMorphToOriginal(component, state).each(function (morph) {
        morph.fold(function () {
          return morphToStatic(component, config, state);
        }, function (position) {
          return morphToCoord(component, config, state, position);
        }, noop);
      });
      state.setVisible(true);
      config.contextual.each(function (contextInfo) {
        remove$1(elem, [
          contextInfo.fadeInClass,
          contextInfo.fadeOutClass,
          contextInfo.transitionClass
        ]);
        contextInfo.onShow(component);
      });
      refresh$4(component, config, state);
    };
    var refresh$4 = function (component, config, state) {
      if (component.getSystem().isConnected()) {
        refreshInternal(component, config, state);
      }
    };
    var reset = function (component, config, state) {
      if (state.isDocked()) {
        resetInternal(component, config, state);
      }
    };
    var isDocked$1 = function (component, config, state) {
      return state.isDocked();
    };
    var setModes = function (component, config, state, modes) {
      return state.setModes(modes);
    };
    var getModes = function (component, config, state) {
      return state.getModes();
    };

    var DockingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$4,
        reset: reset,
        isDocked: isDocked$1,
        getModes: getModes,
        setModes: setModes
    });

    var events$5 = function (dockInfo, dockState) {
      return derive$2([
        runOnSource(transitionend(), function (component, simulatedEvent) {
          dockInfo.contextual.each(function (contextInfo) {
            if (has(component.element, contextInfo.transitionClass)) {
              remove$1(component.element, [
                contextInfo.transitionClass,
                contextInfo.fadeInClass
              ]);
              var notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;
              notify(component);
            }
            simulatedEvent.stop();
          });
        }),
        run$1(windowScroll(), function (component, _) {
          refresh$4(component, dockInfo, dockState);
        }),
        run$1(windowResize(), function (component, _) {
          reset(component, dockInfo, dockState);
        })
      ]);
    };

    var ActiveDocking = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$5
    });

    var DockingSchema = [
      optionObjOf('contextual', [
        requiredString('fadeInClass'),
        requiredString('fadeOutClass'),
        requiredString('transitionClass'),
        requiredFunction('lazyContext'),
        onHandler('onShow'),
        onHandler('onShown'),
        onHandler('onHide'),
        onHandler('onHidden')
      ]),
      defaultedFunction('lazyViewport', win),
      defaultedArrayOf('modes', [
        'top',
        'bottom'
      ], string),
      onHandler('onDocked'),
      onHandler('onUndocked')
    ];

    var init$6 = function (spec) {
      var docked = Cell(false);
      var visible = Cell(true);
      var initialBounds = value$1();
      var modes = Cell(spec.modes);
      var readState = function () {
        return 'docked:  ' + docked.get() + ', visible: ' + visible.get() + ', modes: ' + modes.get().join(',');
      };
      return nu$8({
        isDocked: docked.get,
        setDocked: docked.set,
        getInitialPos: initialBounds.get,
        setInitialPos: initialBounds.set,
        clearInitialPos: initialBounds.clear,
        isVisible: visible.get,
        setVisible: visible.set,
        getModes: modes.get,
        setModes: modes.set,
        readState: readState
      });
    };

    var DockingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$6
    });

    var Docking = create$7({
      fields: DockingSchema,
      name: 'docking',
      active: ActiveDocking,
      apis: DockingApis,
      state: DockingState
    });

    var toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));

    var visibility = {
      fadeInClass: 'tox-editor-dock-fadein',
      fadeOutClass: 'tox-editor-dock-fadeout',
      transitionClass: 'tox-editor-dock-transition'
    };
    var editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';
    var editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';
    var scrollFromBehindHeader = function (e, containerHeader) {
      var doc = owner$4(containerHeader);
      var viewHeight = doc.dom.defaultView.innerHeight;
      var scrollPos = get$9(doc);
      var markerElement = SugarElement.fromDom(e.elm);
      var markerPos = absolute$2(markerElement);
      var markerHeight = get$b(markerElement);
      var markerTop = markerPos.y;
      var markerBottom = markerTop + markerHeight;
      var editorHeaderPos = absolute$3(containerHeader);
      var editorHeaderHeight = get$b(containerHeader);
      var editorHeaderTop = editorHeaderPos.top;
      var editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
      var editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;
      var editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;
      if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {
        to(scrollPos.left, markerTop - editorHeaderHeight, doc);
      } else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {
        var y = markerTop - viewHeight + markerHeight + editorHeaderHeight;
        to(scrollPos.left, y, doc);
      }
    };
    var isDockedMode = function (header, mode) {
      return contains$2(Docking.getModes(header), mode);
    };
    var updateIframeContentFlow = function (header) {
      var getOccupiedHeight = function (elm) {
        return getOuter$2(elm) + (parseInt(get$c(elm, 'margin-top'), 10) || 0) + (parseInt(get$c(elm, 'margin-bottom'), 10) || 0);
      };
      var elm = header.element;
      parent(elm).each(function (parentElem) {
        var padding = 'padding-' + Docking.getModes(header)[0];
        if (Docking.isDocked(header)) {
          var parentWidth = get$a(parentElem);
          set$7(elm, 'width', parentWidth + 'px');
          set$7(parentElem, padding, getOccupiedHeight(elm) + 'px');
        } else {
          remove$6(elm, 'width');
          remove$6(parentElem, padding);
        }
      });
    };
    var updateSinkVisibility = function (sinkElem, visible) {
      if (visible) {
        remove$2(sinkElem, visibility.fadeOutClass);
        add$1(sinkElem, [
          visibility.transitionClass,
          visibility.fadeInClass
        ]);
      } else {
        remove$2(sinkElem, visibility.fadeInClass);
        add$1(sinkElem, [
          visibility.fadeOutClass,
          visibility.transitionClass
        ]);
      }
    };
    var updateEditorClasses = function (editor, docked) {
      var editorContainer = SugarElement.fromDom(editor.getContainer());
      if (docked) {
        add$2(editorContainer, editorStickyOnClass);
        remove$2(editorContainer, editorStickyOffClass);
      } else {
        add$2(editorContainer, editorStickyOffClass);
        remove$2(editorContainer, editorStickyOnClass);
      }
    };
    var restoreFocus = function (headerElem, focusedElem) {
      var ownerDoc = owner$4(focusedElem);
      active(ownerDoc).filter(function (activeElm) {
        return !eq(focusedElem, activeElm);
      }).filter(function (activeElm) {
        return eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm);
      }).each(function () {
        return focus$3(focusedElem);
      });
    };
    var findFocusedElem = function (rootElm, lazySink) {
      return search(rootElm).orThunk(function () {
        return lazySink().toOptional().bind(function (sink) {
          return search(sink.element);
        });
      });
    };
    var setup$9 = function (editor, sharedBackstage, lazyHeader) {
      if (!editor.inline) {
        if (!sharedBackstage.header.isPositionedAtTop()) {
          editor.on('ResizeEditor', function () {
            lazyHeader().each(Docking.reset);
          });
        }
        editor.on('ResizeWindow ResizeEditor', function () {
          lazyHeader().each(updateIframeContentFlow);
        });
        editor.on('SkinLoaded', function () {
          lazyHeader().each(function (comp) {
            Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
          });
        });
        editor.on('FullscreenStateChanged', function () {
          lazyHeader().each(Docking.reset);
        });
      }
      editor.on('AfterScrollIntoView', function (e) {
        lazyHeader().each(function (header) {
          Docking.refresh(header);
          var headerElem = header.element;
          if (isVisible(headerElem)) {
            scrollFromBehindHeader(e, headerElem);
          }
        });
      });
      editor.on('PostRender', function () {
        updateEditorClasses(editor, false);
      });
    };
    var isDocked = function (lazyHeader) {
      return lazyHeader().map(Docking.isDocked).getOr(false);
    };
    var getIframeBehaviours = function () {
      var _a;
      return [Receiving.config({ channels: (_a = {}, _a[toolbarHeightChange()] = { onReceive: updateIframeContentFlow }, _a) })];
    };
    var getBehaviours = function (editor, sharedBackstage) {
      var focusedElm = value$1();
      var lazySink = sharedBackstage.getSink;
      var runOnSinkElement = function (f) {
        lazySink().each(function (sink) {
          return f(sink.element);
        });
      };
      var onDockingSwitch = function (comp) {
        if (!editor.inline) {
          updateIframeContentFlow(comp);
        }
        updateEditorClasses(editor, Docking.isDocked(comp));
        comp.getSystem().broadcastOn([repositionPopups()], {});
        lazySink().each(function (sink) {
          return sink.getSystem().broadcastOn([repositionPopups()], {});
        });
      };
      var additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
      return __spreadArray([
        Focusing.config({}),
        Docking.config({
          contextual: __assign({
            lazyContext: function (comp) {
              var headerHeight = getOuter$2(comp.element);
              var container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
              var box = box$1(SugarElement.fromDom(container));
              var boxHeight = box.height - headerHeight;
              var topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);
              return Optional.some(bounds(box.x, topBound, box.width, boxHeight));
            },
            onShow: function () {
              runOnSinkElement(function (elem) {
                return updateSinkVisibility(elem, true);
              });
            },
            onShown: function (comp) {
              runOnSinkElement(function (elem) {
                return remove$1(elem, [
                  visibility.transitionClass,
                  visibility.fadeInClass
                ]);
              });
              focusedElm.get().each(function (elem) {
                restoreFocus(comp.element, elem);
                focusedElm.clear();
              });
            },
            onHide: function (comp) {
              findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);
              runOnSinkElement(function (elem) {
                return updateSinkVisibility(elem, false);
              });
            },
            onHidden: function () {
              runOnSinkElement(function (elem) {
                return remove$1(elem, [visibility.transitionClass]);
              });
            }
          }, visibility),
          lazyViewport: function (comp) {
            var win$1 = win();
            var offset = getStickyToolbarOffset(editor);
            var top = win$1.y + (isDockedMode(comp, 'top') ? offset : 0);
            var height = win$1.height - (isDockedMode(comp, 'bottom') ? offset : 0);
            return bounds(win$1.x, top, win$1.width, height);
          },
          modes: [sharedBackstage.header.getDockingMode()],
          onDocked: onDockingSwitch,
          onUndocked: onDockingSwitch
        })
      ], additionalBehaviours, true);
    };

    var StickyHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$9,
        isDocked: isDocked,
        getBehaviours: getBehaviours
    });

    var renderHeader = function (spec) {
      var editor = spec.editor;
      var getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;
      return {
        uid: spec.uid,
        dom: spec.dom,
        components: spec.components,
        behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))
      };
    };

    var groupToolbarButtonSchema = objOf([
      requiredString('type'),
      requiredOf('items', oneOf([
        arrOfObj([
          requiredString('name'),
          requiredArrayOf('items', string)
        ]),
        string
      ]))
    ].concat(baseToolbarButtonFields));
    var createGroupToolbarButton = function (spec) {
      return asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec);
    };

    var baseMenuButtonFields = [
      optionString('text'),
      optionString('tooltip'),
      optionString('icon'),
      requiredFunction('fetch'),
      defaultedFunction('onSetup', function () {
        return noop;
      })
    ];

    var MenuButtonSchema = objOf(__spreadArray([requiredString('type')], baseMenuButtonFields, true));
    var createMenuButton = function (spec) {
      return asRaw('menubutton', MenuButtonSchema, spec);
    };

    var splitButtonSchema = objOf([
      requiredString('type'),
      optionString('tooltip'),
      optionString('icon'),
      optionString('text'),
      optionFunction('select'),
      requiredFunction('fetch'),
      defaultedFunction('onSetup', function () {
        return noop;
      }),
      defaultedStringEnum('presets', 'normal', [
        'normal',
        'color',
        'listpreview'
      ]),
      defaulted('columns', 1),
      requiredFunction('onAction'),
      requiredFunction('onItemAction')
    ]);
    var createSplitButton = function (spec) {
      return asRaw('SplitButton', splitButtonSchema, spec);
    };

    var factory$b = function (detail, spec) {
      var setMenus = function (comp, menus) {
        var newMenus = map$2(menus, function (m) {
          var buttonSpec = {
            type: 'menubutton',
            text: m.text,
            fetch: function (callback) {
              callback(m.getItems());
            }
          };
          var internal = createMenuButton(buttonSpec).mapError(function (errInfo) {
            return formatError(errInfo);
          }).getOrDie();
          return renderMenuButton(internal, 'tox-mbtn', spec.backstage, Optional.some('menuitem'));
        });
        Replacing.set(comp, newMenus);
      };
      var apis = {
        focus: Keying.focusIn,
        setMenus: setMenus
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: [],
        behaviours: derive$1([
          Replacing.config({}),
          config('menubar-events', [
            runOnAttached(function (component) {
              detail.onSetup(component);
            }),
            run$1(mouseover(), function (comp, se) {
              descendant(comp.element, '.' + 'tox-mbtn--active').each(function (activeButton) {
                closest$1(se.event.target, '.' + 'tox-mbtn').each(function (hoveredButton) {
                  if (!eq(activeButton, hoveredButton)) {
                    comp.getSystem().getByDom(activeButton).each(function (activeComp) {
                      comp.getSystem().getByDom(hoveredButton).each(function (hoveredComp) {
                        Dropdown.expand(hoveredComp);
                        Dropdown.close(activeComp);
                        Focusing.focus(hoveredComp);
                      });
                    });
                  }
                });
              });
            }),
            run$1(focusShifted(), function (comp, se) {
              se.event.prevFocus.bind(function (prev) {
                return comp.getSystem().getByDom(prev).toOptional();
              }).each(function (prev) {
                se.event.newFocus.bind(function (nu) {
                  return comp.getSystem().getByDom(nu).toOptional();
                }).each(function (nu) {
                  if (Dropdown.isOpen(prev)) {
                    Dropdown.expand(nu);
                    Dropdown.close(prev);
                  }
                });
              });
            })
          ]),
          Keying.config({
            mode: 'flow',
            selector: '.' + 'tox-mbtn',
            onEscape: function (comp) {
              detail.onEscape(comp);
              return Optional.some(true);
            }
          }),
          Tabstopping.config({})
        ]),
        apis: apis,
        domModification: { attributes: { role: 'menubar' } }
      };
    };
    var SilverMenubar = single({
      factory: factory$b,
      name: 'silver.Menubar',
      configFields: [
        required$1('dom'),
        required$1('uid'),
        required$1('onEscape'),
        required$1('backstage'),
        defaulted('onSetup', noop)
      ],
      apis: {
        focus: function (apis, comp) {
          apis.focus(comp);
        },
        setMenus: function (apis, comp, menus) {
          apis.setMenus(comp, menus);
        }
      }
    });

    var getAnimationRoot = function (component, slideConfig) {
      return slideConfig.getAnimationRoot.fold(function () {
        return component.element;
      }, function (get) {
        return get(component);
      });
    };

    var getDimensionProperty = function (slideConfig) {
      return slideConfig.dimension.property;
    };
    var getDimension = function (slideConfig, elem) {
      return slideConfig.dimension.getDimension(elem);
    };
    var disableTransitions = function (component, slideConfig) {
      var root = getAnimationRoot(component, slideConfig);
      remove$1(root, [
        slideConfig.shrinkingClass,
        slideConfig.growingClass
      ]);
    };
    var setShrunk = function (component, slideConfig) {
      remove$2(component.element, slideConfig.openClass);
      add$2(component.element, slideConfig.closedClass);
      set$7(component.element, getDimensionProperty(slideConfig), '0px');
      reflow(component.element);
    };
    var setGrown = function (component, slideConfig) {
      remove$2(component.element, slideConfig.closedClass);
      add$2(component.element, slideConfig.openClass);
      remove$6(component.element, getDimensionProperty(slideConfig));
    };
    var doImmediateShrink = function (component, slideConfig, slideState, _calculatedSize) {
      slideState.setCollapsed();
      set$7(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
      reflow(component.element);
      disableTransitions(component, slideConfig);
      setShrunk(component, slideConfig);
      slideConfig.onStartShrink(component);
      slideConfig.onShrunk(component);
    };
    var doStartShrink = function (component, slideConfig, slideState, calculatedSize) {
      var size = calculatedSize.getOrThunk(function () {
        return getDimension(slideConfig, component.element);
      });
      slideState.setCollapsed();
      set$7(component.element, getDimensionProperty(slideConfig), size);
      reflow(component.element);
      var root = getAnimationRoot(component, slideConfig);
      remove$2(root, slideConfig.growingClass);
      add$2(root, slideConfig.shrinkingClass);
      setShrunk(component, slideConfig);
      slideConfig.onStartShrink(component);
    };
    var doStartSmartShrink = function (component, slideConfig, slideState) {
      var size = getDimension(slideConfig, component.element);
      var shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
      shrinker(component, slideConfig, slideState, Optional.some(size));
    };
    var doStartGrow = function (component, slideConfig, slideState) {
      var root = getAnimationRoot(component, slideConfig);
      var wasShrinking = has(root, slideConfig.shrinkingClass);
      var beforeSize = getDimension(slideConfig, component.element);
      setGrown(component, slideConfig);
      var fullSize = getDimension(slideConfig, component.element);
      var startPartialGrow = function () {
        set$7(component.element, getDimensionProperty(slideConfig), beforeSize);
        reflow(component.element);
      };
      var startCompleteGrow = function () {
        setShrunk(component, slideConfig);
      };
      var setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
      setStartSize();
      remove$2(root, slideConfig.shrinkingClass);
      add$2(root, slideConfig.growingClass);
      setGrown(component, slideConfig);
      set$7(component.element, getDimensionProperty(slideConfig), fullSize);
      slideState.setExpanded();
      slideConfig.onStartGrow(component);
    };
    var refresh$3 = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        remove$6(component.element, getDimensionProperty(slideConfig));
        var fullSize = getDimension(slideConfig, component.element);
        set$7(component.element, getDimensionProperty(slideConfig), fullSize);
      }
    };
    var grow = function (component, slideConfig, slideState) {
      if (!slideState.isExpanded()) {
        doStartGrow(component, slideConfig, slideState);
      }
    };
    var shrink = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        doStartSmartShrink(component, slideConfig, slideState);
      }
    };
    var immediateShrink = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        doImmediateShrink(component, slideConfig, slideState);
      }
    };
    var hasGrown = function (component, slideConfig, slideState) {
      return slideState.isExpanded();
    };
    var hasShrunk = function (component, slideConfig, slideState) {
      return slideState.isCollapsed();
    };
    var isGrowing = function (component, slideConfig, _slideState) {
      var root = getAnimationRoot(component, slideConfig);
      return has(root, slideConfig.growingClass) === true;
    };
    var isShrinking = function (component, slideConfig, _slideState) {
      var root = getAnimationRoot(component, slideConfig);
      return has(root, slideConfig.shrinkingClass) === true;
    };
    var isTransitioning = function (component, slideConfig, slideState) {
      return isGrowing(component, slideConfig) || isShrinking(component, slideConfig);
    };
    var toggleGrow = function (component, slideConfig, slideState) {
      var f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
      f(component, slideConfig, slideState);
    };

    var SlidingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$3,
        grow: grow,
        shrink: shrink,
        immediateShrink: immediateShrink,
        hasGrown: hasGrown,
        hasShrunk: hasShrunk,
        isGrowing: isGrowing,
        isShrinking: isShrinking,
        isTransitioning: isTransitioning,
        toggleGrow: toggleGrow,
        disableTransitions: disableTransitions
    });

    var exhibit = function (base, slideConfig, _slideState) {
      var expanded = slideConfig.expanded;
      return expanded ? nu$7({
        classes: [slideConfig.openClass],
        styles: {}
      }) : nu$7({
        classes: [slideConfig.closedClass],
        styles: wrap$1(slideConfig.dimension.property, '0px')
      });
    };
    var events$4 = function (slideConfig, slideState) {
      return derive$2([runOnSource(transitionend(), function (component, simulatedEvent) {
          var raw = simulatedEvent.event.raw;
          if (raw.propertyName === slideConfig.dimension.property) {
            disableTransitions(component, slideConfig);
            if (slideState.isExpanded()) {
              remove$6(component.element, slideConfig.dimension.property);
            }
            var notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;
            notify(component);
          }
        })]);
    };

    var ActiveSliding = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit,
        events: events$4
    });

    var SlidingSchema = [
      required$1('closedClass'),
      required$1('openClass'),
      required$1('shrinkingClass'),
      required$1('growingClass'),
      option('getAnimationRoot'),
      onHandler('onShrunk'),
      onHandler('onStartShrink'),
      onHandler('onGrown'),
      onHandler('onStartGrow'),
      defaulted('expanded', false),
      requiredOf('dimension', choose$1('property', {
        width: [
          output$1('property', 'width'),
          output$1('getDimension', function (elem) {
            return get$a(elem) + 'px';
          })
        ],
        height: [
          output$1('property', 'height'),
          output$1('getDimension', function (elem) {
            return get$b(elem) + 'px';
          })
        ]
      }))
    ];

    var init$5 = function (spec) {
      var state = Cell(spec.expanded);
      var readState = function () {
        return 'expanded: ' + state.get();
      };
      return nu$8({
        isExpanded: function () {
          return state.get() === true;
        },
        isCollapsed: function () {
          return state.get() === false;
        },
        setCollapsed: curry(state.set, false),
        setExpanded: curry(state.set, true),
        readState: readState
      });
    };

    var SlidingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$5
    });

    var Sliding = create$7({
      fields: SlidingSchema,
      name: 'sliding',
      active: ActiveSliding,
      apis: SlidingApis,
      state: SlidingState
    });

    var owner = 'container';
    var schema$d = [field('slotBehaviours', [])];
    var getPartName = function (name) {
      return '<alloy.field.' + name + '>';
    };
    var sketch = function (sSpec) {
      var parts = function () {
        var record = [];
        var slot = function (name, config) {
          record.push(name);
          return generateOne$1(owner, getPartName(name), config);
        };
        return {
          slot: slot,
          record: constant$1(record)
        };
      }();
      var spec = sSpec(parts);
      var partNames = parts.record();
      var fieldParts = map$2(partNames, function (n) {
        return required({
          name: n,
          pname: getPartName(n)
        });
      });
      return composite$1(owner, schema$d, fieldParts, make$1, spec);
    };
    var make$1 = function (detail, components) {
      var getSlotNames = function (_) {
        return getAllPartNames(detail);
      };
      var getSlot = function (container, key) {
        return getPart(container, detail, key);
      };
      var onSlot = function (f, def) {
        return function (container, key) {
          return getPart(container, detail, key).map(function (slot) {
            return f(slot, key);
          }).getOr(def);
        };
      };
      var onSlots = function (f) {
        return function (container, keys) {
          each$1(keys, function (key) {
            return f(container, key);
          });
        };
      };
      var doShowing = function (comp, _key) {
        return get$d(comp.element, 'aria-hidden') !== 'true';
      };
      var doShow = function (comp, key) {
        if (!doShowing(comp)) {
          var element = comp.element;
          remove$6(element, 'display');
          remove$7(element, 'aria-hidden');
          emitWith(comp, slotVisibility(), {
            name: key,
            visible: true
          });
        }
      };
      var doHide = function (comp, key) {
        if (doShowing(comp)) {
          var element = comp.element;
          set$7(element, 'display', 'none');
          set$8(element, 'aria-hidden', 'true');
          emitWith(comp, slotVisibility(), {
            name: key,
            visible: false
          });
        }
      };
      var isShowing = onSlot(doShowing, false);
      var hideSlot = onSlot(doHide);
      var hideSlots = onSlots(hideSlot);
      var hideAllSlots = function (container) {
        return hideSlots(container, getSlotNames());
      };
      var showSlot = onSlot(doShow);
      var apis = {
        getSlotNames: getSlotNames,
        getSlot: getSlot,
        isShowing: isShowing,
        hideSlot: hideSlot,
        hideAllSlots: hideAllSlots,
        showSlot: showSlot
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: get$2(detail.slotBehaviours),
        apis: apis
      };
    };
    var slotApis = map$1({
      getSlotNames: function (apis, c) {
        return apis.getSlotNames(c);
      },
      getSlot: function (apis, c, key) {
        return apis.getSlot(c, key);
      },
      isShowing: function (apis, c, key) {
        return apis.isShowing(c, key);
      },
      hideSlot: function (apis, c, key) {
        return apis.hideSlot(c, key);
      },
      hideAllSlots: function (apis, c) {
        return apis.hideAllSlots(c);
      },
      showSlot: function (apis, c, key) {
        return apis.showSlot(c, key);
      }
    }, function (value) {
      return makeApi(value);
    });
    var SlotContainer = __assign(__assign({}, slotApis), { sketch: sketch });

    var sidebarSchema = objOf([
      optionString('icon'),
      optionString('tooltip'),
      defaultedFunction('onShow', noop),
      defaultedFunction('onHide', noop),
      defaultedFunction('onSetup', function () {
        return noop;
      })
    ]);
    var createSidebar = function (spec) {
      return asRaw('sidebar', sidebarSchema, spec);
    };

    var setup$8 = function (editor) {
      var sidebars = editor.ui.registry.getAll().sidebars;
      each$1(keys(sidebars), function (name) {
        var spec = sidebars[name];
        var isActive = function () {
          return is$1(Optional.from(editor.queryCommandValue('ToggleSidebar')), name);
        };
        editor.ui.registry.addToggleButton(name, {
          icon: spec.icon,
          tooltip: spec.tooltip,
          onAction: function (buttonApi) {
            editor.execCommand('ToggleSidebar', false, name);
            buttonApi.setActive(isActive());
          },
          onSetup: function (buttonApi) {
            var handleToggle = function () {
              return buttonApi.setActive(isActive());
            };
            editor.on('ToggleSidebar', handleToggle);
            return function () {
              editor.off('ToggleSidebar', handleToggle);
            };
          }
        });
      });
    };
    var getApi = function (comp) {
      return {
        element: function () {
          return comp.element.dom;
        }
      };
    };
    var makePanels = function (parts, panelConfigs) {
      var specs = map$2(keys(panelConfigs), function (name) {
        var spec = panelConfigs[name];
        var bridged = getOrDie(createSidebar(spec));
        return {
          name: name,
          getApi: getApi,
          onSetup: bridged.onSetup,
          onShow: bridged.onShow,
          onHide: bridged.onHide
        };
      });
      return map$2(specs, function (spec) {
        var editorOffCell = Cell(noop);
        return parts.slot(spec.name, {
          dom: {
            tag: 'div',
            classes: ['tox-sidebar__pane']
          },
          behaviours: SimpleBehaviours.unnamedEvents([
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell),
            run$1(slotVisibility(), function (sidepanel, se) {
              var data = se.event;
              var optSidePanelSpec = find$5(specs, function (config) {
                return config.name === data.name;
              });
              optSidePanelSpec.each(function (sidePanelSpec) {
                var handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;
                handler(sidePanelSpec.getApi(sidepanel));
              });
            })
          ])
        });
      });
    };
    var makeSidebar = function (panelConfigs) {
      return SlotContainer.sketch(function (parts) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-sidebar__pane-container']
          },
          components: makePanels(parts, panelConfigs),
          slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(function (slotContainer) {
              return SlotContainer.hideAllSlots(slotContainer);
            })])
        };
      });
    };
    var setSidebar = function (sidebar, panelConfigs) {
      var optSlider = Composing.getCurrent(sidebar);
      optSlider.each(function (slider) {
        return Replacing.set(slider, [makeSidebar(panelConfigs)]);
      });
    };
    var toggleSidebar = function (sidebar, name) {
      var optSlider = Composing.getCurrent(sidebar);
      optSlider.each(function (slider) {
        var optSlotContainer = Composing.getCurrent(slider);
        optSlotContainer.each(function (slotContainer) {
          if (Sliding.hasGrown(slider)) {
            if (SlotContainer.isShowing(slotContainer, name)) {
              Sliding.shrink(slider);
            } else {
              SlotContainer.hideAllSlots(slotContainer);
              SlotContainer.showSlot(slotContainer, name);
            }
          } else {
            SlotContainer.hideAllSlots(slotContainer);
            SlotContainer.showSlot(slotContainer, name);
            Sliding.grow(slider);
          }
        });
      });
    };
    var whichSidebar = function (sidebar) {
      var optSlider = Composing.getCurrent(sidebar);
      return optSlider.bind(function (slider) {
        var sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
        if (sidebarOpen) {
          var optSlotContainer = Composing.getCurrent(slider);
          return optSlotContainer.bind(function (slotContainer) {
            return find$5(SlotContainer.getSlotNames(slotContainer), function (name) {
              return SlotContainer.isShowing(slotContainer, name);
            });
          });
        } else {
          return Optional.none();
        }
      });
    };
    var fixSize = generate$6('FixSizeEvent');
    var autoSize = generate$6('AutoSizeEvent');
    var renderSidebar = function (spec) {
      return {
        uid: spec.uid,
        dom: {
          tag: 'div',
          classes: ['tox-sidebar'],
          attributes: { role: 'complementary' }
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-sidebar__slider']
            },
            components: [],
            behaviours: derive$1([
              Tabstopping.config({}),
              Focusing.config({}),
              Sliding.config({
                dimension: { property: 'width' },
                closedClass: 'tox-sidebar--sliding-closed',
                openClass: 'tox-sidebar--sliding-open',
                shrinkingClass: 'tox-sidebar--sliding-shrinking',
                growingClass: 'tox-sidebar--sliding-growing',
                onShrunk: function (slider) {
                  var optSlotContainer = Composing.getCurrent(slider);
                  optSlotContainer.each(SlotContainer.hideAllSlots);
                  emit(slider, autoSize);
                },
                onGrown: function (slider) {
                  emit(slider, autoSize);
                },
                onStartGrow: function (slider) {
                  emitWith(slider, fixSize, { width: getRaw(slider.element, 'width').getOr('') });
                },
                onStartShrink: function (slider) {
                  emitWith(slider, fixSize, { width: get$a(slider.element) + 'px' });
                }
              }),
              Replacing.config({}),
              Composing.config({
                find: function (comp) {
                  var children = Replacing.contents(comp);
                  return head(children);
                }
              })
            ])
          }],
        behaviours: derive$1([
          ComposingConfigs.childAt(0),
          config('sidebar-sliding-events', [
            run$1(fixSize, function (comp, se) {
              set$7(comp.element, 'width', se.event.width);
            }),
            run$1(autoSize, function (comp, _se) {
              remove$6(comp.element, 'width');
            })
          ])
        ])
      };
    };

    var block = function (component, config, state, getBusySpec) {
      set$8(component.element, 'aria-busy', true);
      var root = config.getRoot(component).getOr(component);
      var blockerBehaviours = derive$1([
        Keying.config({
          mode: 'special',
          onTab: function () {
            return Optional.some(true);
          },
          onShiftTab: function () {
            return Optional.some(true);
          }
        }),
        Focusing.config({})
      ]);
      var blockSpec = getBusySpec(root, blockerBehaviours);
      var blocker = root.getSystem().build(blockSpec);
      Replacing.append(root, premade(blocker));
      if (blocker.hasConfigured(Keying) && config.focus) {
        Keying.focusIn(blocker);
      }
      if (!state.isBlocked()) {
        config.onBlock(component);
      }
      state.blockWith(function () {
        return Replacing.remove(root, blocker);
      });
    };
    var unblock = function (component, config, state) {
      remove$7(component.element, 'aria-busy');
      if (state.isBlocked()) {
        config.onUnblock(component);
      }
      state.clear();
    };

    var BlockingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        block: block,
        unblock: unblock
    });

    var BlockingSchema = [
      defaultedFunction('getRoot', Optional.none),
      defaultedBoolean('focus', true),
      onHandler('onBlock'),
      onHandler('onUnblock')
    ];

    var init$4 = function () {
      var blocker = destroyable();
      var blockWith = function (destroy) {
        blocker.set({ destroy: destroy });
      };
      return nu$8({
        readState: blocker.isSet,
        blockWith: blockWith,
        clear: blocker.clear,
        isBlocked: blocker.isSet
      });
    };

    var BlockingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$4
    });

    var Blocking = create$7({
      fields: BlockingSchema,
      name: 'blocking',
      apis: BlockingApis,
      state: BlockingState
    });

    var getAttrs = function (elem) {
      var attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];
      return foldl(attributes, function (b, attr) {
        var _a;
        if (attr.name === 'class') {
          return b;
        } else {
          return __assign(__assign({}, b), (_a = {}, _a[attr.name] = attr.value, _a));
        }
      }, {});
    };
    var getClasses = function (elem) {
      return Array.prototype.slice.call(elem.dom.classList, 0);
    };
    var fromHtml = function (html) {
      var elem = SugarElement.fromHtml(html);
      var children$1 = children(elem);
      var attrs = getAttrs(elem);
      var classes = getClasses(elem);
      var contents = children$1.length === 0 ? {} : { innerHtml: get$7(elem) };
      return __assign({
        tag: name$2(elem),
        classes: classes,
        attributes: attrs
      }, contents);
    };

    var getBusySpec$1 = function (providerBackstage) {
      return function (_root, _behaviours) {
        return {
          dom: {
            tag: 'div',
            attributes: {
              'aria-label': providerBackstage.translate('Loading...'),
              'tabindex': '0'
            },
            classes: ['tox-throbber__busy-spinner']
          },
          components: [{ dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
        };
      };
    };
    var focusBusyComponent = function (throbber) {
      return Composing.getCurrent(throbber).each(function (comp) {
        return focus$3(comp.element);
      });
    };
    var toggleEditorTabIndex = function (editor, state) {
      var tabIndexAttr = 'tabindex';
      var dataTabIndexAttr = 'data-mce-' + tabIndexAttr;
      Optional.from(editor.iframeElement).map(SugarElement.fromDom).each(function (iframe) {
        if (state) {
          getOpt(iframe, tabIndexAttr).each(function (tabIndex) {
            return set$8(iframe, dataTabIndexAttr, tabIndex);
          });
          set$8(iframe, tabIndexAttr, -1);
        } else {
          remove$7(iframe, tabIndexAttr);
          getOpt(iframe, dataTabIndexAttr).each(function (tabIndex) {
            set$8(iframe, tabIndexAttr, tabIndex);
            remove$7(iframe, dataTabIndexAttr);
          });
        }
      });
    };
    var toggleThrobber = function (editor, comp, state, providerBackstage) {
      var element = comp.element;
      toggleEditorTabIndex(editor, state);
      if (state) {
        Blocking.block(comp, getBusySpec$1(providerBackstage));
        remove$6(element, 'display');
        remove$7(element, 'aria-hidden');
        if (editor.hasFocus()) {
          focusBusyComponent(comp);
        }
      } else {
        var throbberFocus = Composing.getCurrent(comp).exists(function (busyComp) {
          return hasFocus(busyComp.element);
        });
        Blocking.unblock(comp);
        set$7(element, 'display', 'none');
        set$8(element, 'aria-hidden', 'true');
        if (throbberFocus) {
          editor.focus();
        }
      }
    };
    var renderThrobber = function (spec) {
      return {
        uid: spec.uid,
        dom: {
          tag: 'div',
          attributes: { 'aria-hidden': 'true' },
          classes: ['tox-throbber'],
          styles: { display: 'none' }
        },
        behaviours: derive$1([
          Replacing.config({}),
          Blocking.config({ focus: false }),
          Composing.config({
            find: function (comp) {
              return head(comp.components());
            }
          })
        ]),
        components: []
      };
    };
    var isFocusEvent = function (event) {
      return event.type === 'focusin';
    };
    var isPasteBinTarget = function (event) {
      if (isFocusEvent(event)) {
        var node = event.composed ? head(event.composedPath()) : Optional.from(event.target);
        return node.map(SugarElement.fromDom).filter(isElement$2).exists(function (targetElm) {
          return has(targetElm, 'mce-pastebin');
        });
      } else {
        return false;
      }
    };
    var setup$7 = function (editor, lazyThrobber, sharedBackstage) {
      var throbberState = Cell(false);
      var timer = value$1();
      var stealFocus = function (e) {
        if (throbberState.get() && !isPasteBinTarget(e)) {
          e.preventDefault();
          focusBusyComponent(lazyThrobber());
          editor.editorManager.setActive(editor);
        }
      };
      if (!editor.inline) {
        editor.on('PreInit', function () {
          editor.dom.bind(editor.getWin(), 'focusin', stealFocus);
          editor.on('BeforeExecCommand', function (e) {
            if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) {
              stealFocus(e);
            }
          });
        });
      }
      var toggle = function (state) {
        if (state !== throbberState.get()) {
          throbberState.set(state);
          toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);
          editor.fire('AfterProgressState', { state: state });
        }
      };
      editor.on('ProgressState', function (e) {
        timer.on(global$f.clearTimeout);
        if (isNumber(e.time)) {
          var timerId = global$f.setEditorTimeout(editor, function () {
            return toggle(e.state);
          }, e.time);
          timer.set(timerId);
        } else {
          toggle(e.state);
          timer.clear();
        }
      });
    };

    var generate$1 = function (xs, f) {
      var init = {
        len: 0,
        list: []
      };
      var r = foldl(xs, function (b, a) {
        var value = f(a, b.len);
        return value.fold(constant$1(b), function (v) {
          return {
            len: v.finish,
            list: b.list.concat([v])
          };
        });
      }, init);
      return r.list;
    };

    var output = function (within, extra, withinWidth) {
      return {
        within: within,
        extra: extra,
        withinWidth: withinWidth
      };
    };
    var apportion = function (units, total, len) {
      var parray = generate$1(units, function (unit, current) {
        var width = len(unit);
        return Optional.some({
          element: unit,
          start: current,
          finish: current + width,
          width: width
        });
      });
      var within = filter$2(parray, function (unit) {
        return unit.finish <= total;
      });
      var withinWidth = foldr(within, function (acc, el) {
        return acc + el.width;
      }, 0);
      var extra = parray.slice(within.length);
      return {
        within: within,
        extra: extra,
        withinWidth: withinWidth
      };
    };
    var toUnit = function (parray) {
      return map$2(parray, function (unit) {
        return unit.element;
      });
    };
    var fitLast = function (within, extra, withinWidth) {
      var fits = toUnit(within.concat(extra));
      return output(fits, [], withinWidth);
    };
    var overflow = function (within, extra, overflower, withinWidth) {
      var fits = toUnit(within).concat([overflower]);
      return output(fits, toUnit(extra), withinWidth);
    };
    var fitAll = function (within, extra, withinWidth) {
      return output(toUnit(within), [], withinWidth);
    };
    var tryFit = function (total, units, len) {
      var divide = apportion(units, total, len);
      return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();
    };
    var partition = function (total, units, len, overflower) {
      var divide = tryFit(total, units, len).getOrThunk(function () {
        return apportion(units, total - len(overflower), len);
      });
      var within = divide.within;
      var extra = divide.extra;
      var withinWidth = divide.withinWidth;
      if (extra.length === 1 && extra[0].width <= len(overflower)) {
        return fitLast(within, extra, withinWidth);
      } else if (extra.length >= 1) {
        return overflow(within, extra, overflower, withinWidth);
      } else {
        return fitAll(within, extra, withinWidth);
      }
    };

    var setGroups$1 = function (toolbar, storedGroups) {
      var bGroups = map$2(storedGroups, function (g) {
        return premade(g);
      });
      Toolbar.setGroups(toolbar, bGroups);
    };
    var findFocusedComp = function (comps) {
      return findMap(comps, function (comp) {
        return search(comp.element).bind(function (focusedElm) {
          return comp.getSystem().getByDom(focusedElm).toOptional();
        });
      });
    };
    var refresh$2 = function (toolbar, detail, setOverflow) {
      var builtGroups = detail.builtGroups.get();
      if (builtGroups.length === 0) {
        return;
      }
      var primary = getPartOrDie(toolbar, detail, 'primary');
      var overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');
      set$7(primary.element, 'visibility', 'hidden');
      var groups = builtGroups.concat([overflowGroup]);
      var focusedComp = findFocusedComp(groups);
      setOverflow([]);
      setGroups$1(primary, groups);
      var availableWidth = get$a(primary.element);
      var overflows = partition(availableWidth, detail.builtGroups.get(), function (comp) {
        return get$a(comp.element);
      }, overflowGroup);
      if (overflows.extra.length === 0) {
        Replacing.remove(primary, overflowGroup);
        setOverflow([]);
      } else {
        setGroups$1(primary, overflows.within);
        setOverflow(overflows.extra);
      }
      remove$6(primary.element, 'visibility');
      reflow(primary.element);
      focusedComp.each(Focusing.focus);
    };

    var schema$c = constant$1([
      field('splitToolbarBehaviours', [Coupling]),
      customField('builtGroups', function () {
        return Cell([]);
      })
    ]);

    var schema$b = constant$1([
      markers$1(['overflowToggledClass']),
      optionFunction('getOverflowBounds'),
      required$1('lazySink'),
      customField('overflowGroups', function () {
        return Cell([]);
      })
    ].concat(schema$c()));
    var parts$7 = constant$1([
      required({
        factory: Toolbar,
        schema: schema$e(),
        name: 'primary'
      }),
      external$1({
        schema: schema$e(),
        name: 'overflow'
      }),
      external$1({ name: 'overflow-button' }),
      external$1({ name: 'overflow-group' })
    ]);

    var expandable = constant$1(function (element, available) {
      setMax(element, Math.floor(available));
    });

    var schema$a = constant$1([
      markers$1(['toggledClass']),
      required$1('lazySink'),
      requiredFunction('fetch'),
      optionFunction('getBounds'),
      optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),
      schema$y()
    ]);
    var parts$6 = constant$1([
      external$1({
        name: 'button',
        overrides: function (detail) {
          return {
            dom: { attributes: { 'aria-haspopup': 'true' } },
            buttonBehaviours: derive$1([Toggling.config({
                toggleClass: detail.markers.toggledClass,
                aria: { mode: 'expanded' },
                toggleOnExecute: false
              })])
          };
        }
      }),
      external$1({
        factory: Toolbar,
        schema: schema$e(),
        name: 'toolbar',
        overrides: function (detail) {
          return {
            toolbarBehaviours: derive$1([Keying.config({
                mode: 'cyclic',
                onEscape: function (comp) {
                  getPart(comp, detail, 'button').each(Focusing.focus);
                  return Optional.none();
                }
              })])
          };
        }
      })
    ]);

    var toggle = function (button, externals) {
      var toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');
      if (Sandboxing.isOpen(toolbarSandbox)) {
        Sandboxing.close(toolbarSandbox);
      } else {
        Sandboxing.open(toolbarSandbox, externals.toolbar());
      }
    };
    var position = function (button, toolbar, detail, layouts) {
      var bounds = detail.getBounds.map(function (bounder) {
        return bounder();
      });
      var sink = detail.lazySink(button).getOrDie();
      Positioning.positionWithinBounds(sink, toolbar, {
        anchor: {
          type: 'hotspot',
          hotspot: button,
          layouts: layouts,
          overrides: { maxWidthFunction: expandable() }
        }
      }, bounds);
    };
    var setGroups = function (button, toolbar, detail, layouts, groups) {
      Toolbar.setGroups(toolbar, groups);
      position(button, toolbar, detail, layouts);
      Toggling.on(button);
    };
    var makeSandbox = function (button, spec, detail) {
      var ariaOwner = manager();
      var onOpen = function (sandbox, toolbar) {
        detail.fetch().get(function (groups) {
          setGroups(button, toolbar, detail, spec.layouts, groups);
          ariaOwner.link(button.element);
          Keying.focusIn(toolbar);
        });
      };
      var onClose = function () {
        Toggling.off(button);
        Focusing.focus(button);
        ariaOwner.unlink(button.element);
      };
      return {
        dom: {
          tag: 'div',
          attributes: { id: ariaOwner.id }
        },
        behaviours: derive$1([
          Keying.config({
            mode: 'special',
            onEscape: function (comp) {
              Sandboxing.close(comp);
              return Optional.some(true);
            }
          }),
          Sandboxing.config({
            onOpen: onOpen,
            onClose: onClose,
            isPartOf: function (container, data, queryElem) {
              return isPartOf$1(data, queryElem) || isPartOf$1(button, queryElem);
            },
            getAttachPoint: function () {
              return detail.lazySink(button).getOrDie();
            }
          }),
          Receiving.config({
            channels: __assign(__assign({}, receivingChannel$1(__assign({ isExtraPart: never }, detail.fireDismissalEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})))), receivingChannel({
              doReposition: function () {
                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {
                  position(button, toolbar, detail, spec.layouts);
                });
              }
            }))
          })
        ])
      };
    };
    var factory$a = function (detail, components, spec, externals) {
      return __assign(__assign({}, Button.sketch(__assign(__assign({}, externals.button()), {
        action: function (button) {
          toggle(button, externals);
        },
        buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({
            others: {
              toolbarSandbox: function (button) {
                return makeSandbox(button, spec, detail);
              }
            }
          })])
      }))), {
        apis: {
          setGroups: function (button, groups) {
            Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {
              setGroups(button, toolbar, detail, spec.layouts, groups);
            });
          },
          reposition: function (button) {
            Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {
              position(button, toolbar, detail, spec.layouts);
            });
          },
          toggle: function (button) {
            toggle(button, externals);
          },
          getToolbar: function (button) {
            return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));
          },
          isOpen: function (button) {
            return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));
          }
        }
      });
    };
    var FloatingToolbarButton = composite({
      name: 'FloatingToolbarButton',
      factory: factory$a,
      configFields: schema$a(),
      partFields: parts$6(),
      apis: {
        setGroups: function (apis, button, groups) {
          apis.setGroups(button, groups);
        },
        reposition: function (apis, button) {
          apis.reposition(button);
        },
        toggle: function (apis, button) {
          apis.toggle(button);
        },
        getToolbar: function (apis, button) {
          return apis.getToolbar(button);
        },
        isOpen: function (apis, button) {
          return apis.isOpen(button);
        }
      }
    });

    var schema$9 = constant$1([
      required$1('items'),
      markers$1(['itemSelector']),
      field('tgroupBehaviours', [Keying])
    ]);
    var parts$5 = constant$1([group({
        name: 'items',
        unit: 'item'
      })]);

    var factory$9 = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.tgroupBehaviours, [Keying.config({
            mode: 'flow',
            selector: detail.markers.itemSelector
          })]),
        domModification: { attributes: { role: 'toolbar' } }
      };
    };
    var ToolbarGroup = composite({
      name: 'ToolbarGroup',
      configFields: schema$9(),
      partFields: parts$5(),
      factory: factory$9
    });

    var buildGroups = function (comps) {
      return map$2(comps, function (g) {
        return premade(g);
      });
    };
    var refresh$1 = function (toolbar, memFloatingToolbarButton, detail) {
      refresh$2(toolbar, detail, function (overflowGroups) {
        detail.overflowGroups.set(overflowGroups);
        memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
          FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
        });
      });
    };
    var factory$8 = function (detail, components, spec, externals) {
      var memFloatingToolbarButton = record(FloatingToolbarButton.sketch({
        fetch: function () {
          return Future.nu(function (resolve) {
            resolve(buildGroups(detail.overflowGroups.get()));
          });
        },
        layouts: {
          onLtr: function () {
            return [
              southwest$2,
              southeast$2
            ];
          },
          onRtl: function () {
            return [
              southeast$2,
              southwest$2
            ];
          },
          onBottomLtr: function () {
            return [
              northwest$2,
              northeast$2
            ];
          },
          onBottomRtl: function () {
            return [
              northeast$2,
              northwest$2
            ];
          }
        },
        getBounds: spec.getOverflowBounds,
        lazySink: detail.lazySink,
        fireDismissalEventInstead: {},
        markers: { toggledClass: detail.markers.overflowToggledClass },
        parts: {
          button: externals['overflow-button'](),
          toolbar: externals.overflow()
        }
      }));
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({
            others: {
              overflowGroup: function () {
                return ToolbarGroup.sketch(__assign(__assign({}, externals['overflow-group']()), { items: [memFloatingToolbarButton.asSpec()] }));
              }
            }
          })]),
        apis: {
          setGroups: function (toolbar, groups) {
            detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));
            refresh$1(toolbar, memFloatingToolbarButton, detail);
          },
          refresh: function (toolbar) {
            return refresh$1(toolbar, memFloatingToolbarButton, detail);
          },
          toggle: function (toolbar) {
            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
              FloatingToolbarButton.toggle(floatingToolbarButton);
            });
          },
          isOpen: function (toolbar) {
            return memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false);
          },
          reposition: function (toolbar) {
            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
              FloatingToolbarButton.reposition(floatingToolbarButton);
            });
          },
          getOverflow: function (toolbar) {
            return memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar);
          }
        },
        domModification: { attributes: { role: 'group' } }
      };
    };
    var SplitFloatingToolbar = composite({
      name: 'SplitFloatingToolbar',
      configFields: schema$b(),
      partFields: parts$7(),
      factory: factory$8,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        },
        refresh: function (apis, toolbar) {
          apis.refresh(toolbar);
        },
        reposition: function (apis, toolbar) {
          apis.reposition(toolbar);
        },
        toggle: function (apis, toolbar) {
          apis.toggle(toolbar);
        },
        isOpen: function (apis, toolbar) {
          return apis.isOpen(toolbar);
        },
        getOverflow: function (apis, toolbar) {
          return apis.getOverflow(toolbar);
        }
      }
    });

    var schema$8 = constant$1([
      markers$1([
        'closedClass',
        'openClass',
        'shrinkingClass',
        'growingClass',
        'overflowToggledClass'
      ]),
      onHandler('onOpened'),
      onHandler('onClosed')
    ].concat(schema$c()));
    var parts$4 = constant$1([
      required({
        factory: Toolbar,
        schema: schema$e(),
        name: 'primary'
      }),
      required({
        factory: Toolbar,
        schema: schema$e(),
        name: 'overflow',
        overrides: function (detail) {
          return {
            toolbarBehaviours: derive$1([
              Sliding.config({
                dimension: { property: 'height' },
                closedClass: detail.markers.closedClass,
                openClass: detail.markers.openClass,
                shrinkingClass: detail.markers.shrinkingClass,
                growingClass: detail.markers.growingClass,
                onShrunk: function (comp) {
                  getPart(comp, detail, 'overflow-button').each(function (button) {
                    Toggling.off(button);
                    Focusing.focus(button);
                  });
                  detail.onClosed(comp);
                },
                onGrown: function (comp) {
                  Keying.focusIn(comp);
                  detail.onOpened(comp);
                },
                onStartGrow: function (comp) {
                  getPart(comp, detail, 'overflow-button').each(Toggling.on);
                }
              }),
              Keying.config({
                mode: 'acyclic',
                onEscape: function (comp) {
                  getPart(comp, detail, 'overflow-button').each(Focusing.focus);
                  return Optional.some(true);
                }
              })
            ])
          };
        }
      }),
      external$1({
        name: 'overflow-button',
        overrides: function (detail) {
          return {
            buttonBehaviours: derive$1([Toggling.config({
                toggleClass: detail.markers.overflowToggledClass,
                aria: { mode: 'pressed' },
                toggleOnExecute: false
              })])
          };
        }
      }),
      external$1({ name: 'overflow-group' })
    ]);

    var isOpen = function (toolbar, detail) {
      return getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false);
    };
    var toggleToolbar = function (toolbar, detail) {
      getPart(toolbar, detail, 'overflow-button').bind(function () {
        return getPart(toolbar, detail, 'overflow');
      }).each(function (overf) {
        refresh(toolbar, detail);
        Sliding.toggleGrow(overf);
      });
    };
    var refresh = function (toolbar, detail) {
      getPart(toolbar, detail, 'overflow').each(function (overflow) {
        refresh$2(toolbar, detail, function (groups) {
          var builtGroups = map$2(groups, function (g) {
            return premade(g);
          });
          Toolbar.setGroups(overflow, builtGroups);
        });
        getPart(toolbar, detail, 'overflow-button').each(function (button) {
          if (Sliding.hasGrown(overflow)) {
            Toggling.on(button);
          }
        });
        Sliding.refresh(overflow);
      });
    };
    var factory$7 = function (detail, components, spec, externals) {
      var toolbarToggleEvent = 'alloy.toolbar.toggle';
      var doSetGroups = function (toolbar, groups) {
        var built = map$2(groups, toolbar.getSystem().build);
        detail.builtGroups.set(built);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.splitToolbarBehaviours, [
          Coupling.config({
            others: {
              overflowGroup: function (toolbar) {
                return ToolbarGroup.sketch(__assign(__assign({}, externals['overflow-group']()), {
                  items: [Button.sketch(__assign(__assign({}, externals['overflow-button']()), {
                      action: function (_button) {
                        emit(toolbar, toolbarToggleEvent);
                      }
                    }))]
                }));
              }
            }
          }),
          config('toolbar-toggle-events', [run$1(toolbarToggleEvent, function (toolbar) {
              toggleToolbar(toolbar, detail);
            })])
        ]),
        apis: {
          setGroups: function (toolbar, groups) {
            doSetGroups(toolbar, groups);
            refresh(toolbar, detail);
          },
          refresh: function (toolbar) {
            return refresh(toolbar, detail);
          },
          toggle: function (toolbar) {
            return toggleToolbar(toolbar, detail);
          },
          isOpen: function (toolbar) {
            return isOpen(toolbar, detail);
          }
        },
        domModification: { attributes: { role: 'group' } }
      };
    };
    var SplitSlidingToolbar = composite({
      name: 'SplitSlidingToolbar',
      configFields: schema$8(),
      partFields: parts$4(),
      factory: factory$7,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        },
        refresh: function (apis, toolbar) {
          apis.refresh(toolbar);
        },
        toggle: function (apis, toolbar) {
          apis.toggle(toolbar);
        },
        isOpen: function (apis, toolbar) {
          return apis.isOpen(toolbar);
        }
      }
    });

    var renderToolbarGroupCommon = function (toolbarGroup) {
      var attributes = toolbarGroup.title.fold(function () {
        return {};
      }, function (title) {
        return { attributes: { title: title } };
      });
      return {
        dom: __assign({
          tag: 'div',
          classes: ['tox-toolbar__group']
        }, attributes),
        components: [ToolbarGroup.parts.items({})],
        items: toolbarGroup.items,
        markers: { itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), ' + '.tox-split-button:not([disabled]), ' + '.tox-toolbar-nav-js:not([disabled])' },
        tgroupBehaviours: derive$1([
          Tabstopping.config({}),
          Focusing.config({})
        ])
      };
    };
    var renderToolbarGroup = function (toolbarGroup) {
      return ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
    };
    var getToolbarbehaviours = function (toolbarSpec, modeName) {
      var onAttached = runOnAttached(function (component) {
        var groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);
        Toolbar.setGroups(component, groups);
      });
      return derive$1([
        DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),
        receivingConfig(),
        Keying.config({
          mode: modeName,
          onEscape: toolbarSpec.onEscape,
          selector: '.tox-toolbar__group'
        }),
        config('toolbar-events', [onAttached])
      ]);
    };
    var renderMoreToolbarCommon = function (toolbarSpec) {
      var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
      return {
        uid: toolbarSpec.uid,
        dom: {
          tag: 'div',
          classes: ['tox-toolbar-overlord']
        },
        parts: {
          'overflow-group': renderToolbarGroupCommon({
            title: Optional.none(),
            items: []
          }),
          'overflow-button': renderIconButtonSpec({
            name: 'more',
            icon: Optional.some('more-drawer'),
            disabled: false,
            tooltip: Optional.some('More...'),
            primary: false,
            borderless: false
          }, Optional.none(), toolbarSpec.providers)
        },
        splitToolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
      };
    };
    var renderFloatingMoreToolbar = function (toolbarSpec) {
      var baseSpec = renderMoreToolbarCommon(toolbarSpec);
      var overflowXOffset = 4;
      var primary = SplitFloatingToolbar.parts.primary({
        dom: {
          tag: 'div',
          classes: ['tox-toolbar__primary']
        }
      });
      return SplitFloatingToolbar.sketch(__assign(__assign({}, baseSpec), {
        lazySink: toolbarSpec.getSink,
        getOverflowBounds: function () {
          var headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;
          var headerBounds = absolute$2(headerElem);
          var docElem = documentElement(headerElem);
          var docBounds = absolute$2(docElem);
          var height = Math.max(docElem.dom.scrollHeight, docBounds.height);
          return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);
        },
        parts: __assign(__assign({}, baseSpec.parts), {
          overflow: {
            dom: {
              tag: 'div',
              classes: ['tox-toolbar__overflow'],
              attributes: toolbarSpec.attributes
            }
          }
        }),
        components: [primary],
        markers: { overflowToggledClass: 'tox-tbtn--enabled' }
      }));
    };
    var renderSlidingMoreToolbar = function (toolbarSpec) {
      var primary = SplitSlidingToolbar.parts.primary({
        dom: {
          tag: 'div',
          classes: ['tox-toolbar__primary']
        }
      });
      var overflow = SplitSlidingToolbar.parts.overflow({
        dom: {
          tag: 'div',
          classes: ['tox-toolbar__overflow']
        }
      });
      var baseSpec = renderMoreToolbarCommon(toolbarSpec);
      return SplitSlidingToolbar.sketch(__assign(__assign({}, baseSpec), {
        components: [
          primary,
          overflow
        ],
        markers: {
          openClass: 'tox-toolbar__overflow--open',
          closedClass: 'tox-toolbar__overflow--closed',
          growingClass: 'tox-toolbar__overflow--growing',
          shrinkingClass: 'tox-toolbar__overflow--shrinking',
          overflowToggledClass: 'tox-tbtn--enabled'
        },
        onOpened: function (comp) {
          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'opened' });
        },
        onClosed: function (comp) {
          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'closed' });
        }
      }));
    };
    var renderToolbar = function (toolbarSpec) {
      var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';
      return Toolbar.sketch({
        uid: toolbarSpec.uid,
        dom: {
          tag: 'div',
          classes: ['tox-toolbar'].concat(toolbarSpec.type === ToolbarMode.scrolling ? ['tox-toolbar--scrolling'] : [])
        },
        components: [Toolbar.parts.groups({})],
        toolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
      });
    };

    var factory$6 = function (detail, components, _spec) {
      var apis = {
        getSocket: function (comp) {
          return parts$a.getPart(comp, detail, 'socket');
        },
        setSidebar: function (comp, panelConfigs) {
          parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {
            return setSidebar(sidebar, panelConfigs);
          });
        },
        toggleSidebar: function (comp, name) {
          parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {
            return toggleSidebar(sidebar, name);
          });
        },
        whichSidebar: function (comp) {
          return parts$a.getPart(comp, detail, 'sidebar').bind(whichSidebar).getOrNull();
        },
        getHeader: function (comp) {
          return parts$a.getPart(comp, detail, 'header');
        },
        getToolbar: function (comp) {
          return parts$a.getPart(comp, detail, 'toolbar');
        },
        setToolbar: function (comp, groups) {
          parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {
            toolbar.getApis().setGroups(toolbar, groups);
          });
        },
        setToolbars: function (comp, toolbars) {
          parts$a.getPart(comp, detail, 'multiple-toolbar').each(function (mToolbar) {
            CustomList.setItems(mToolbar, toolbars);
          });
        },
        refreshToolbar: function (comp) {
          var toolbar = parts$a.getPart(comp, detail, 'toolbar');
          toolbar.each(function (toolbar) {
            return toolbar.getApis().refresh(toolbar);
          });
        },
        toggleToolbarDrawer: function (comp) {
          parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {
            mapFrom(toolbar.getApis().toggle, function (toggle) {
              return toggle(toolbar);
            });
          });
        },
        isToolbarDrawerToggled: function (comp) {
          return parts$a.getPart(comp, detail, 'toolbar').bind(function (toolbar) {
            return Optional.from(toolbar.getApis().isOpen).map(function (isOpen) {
              return isOpen(toolbar);
            });
          }).getOr(false);
        },
        getThrobber: function (comp) {
          return parts$a.getPart(comp, detail, 'throbber');
        },
        focusToolbar: function (comp) {
          var optToolbar = parts$a.getPart(comp, detail, 'toolbar').orThunk(function () {
            return parts$a.getPart(comp, detail, 'multiple-toolbar');
          });
          optToolbar.each(function (toolbar) {
            Keying.focusIn(toolbar);
          });
        },
        setMenubar: function (comp, menus) {
          parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {
            SilverMenubar.setMenus(menubar, menus);
          });
        },
        focusMenubar: function (comp) {
          parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {
            SilverMenubar.focus(menubar);
          });
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: apis,
        behaviours: detail.behaviours
      };
    };
    var partMenubar = partType.optional({
      factory: SilverMenubar,
      name: 'menubar',
      schema: [required$1('backstage')]
    });
    var toolbarFactory = function (spec) {
      if (spec.type === ToolbarMode.sliding) {
        return renderSlidingMoreToolbar;
      } else if (spec.type === ToolbarMode.floating) {
        return renderFloatingMoreToolbar;
      } else {
        return renderToolbar;
      }
    };
    var partMultipleToolbar = partType.optional({
      factory: {
        sketch: function (spec) {
          return CustomList.sketch({
            uid: spec.uid,
            dom: spec.dom,
            listBehaviours: derive$1([Keying.config({
                mode: 'acyclic',
                selector: '.tox-toolbar'
              })]),
            makeItem: function () {
              return renderToolbar({
                type: spec.type,
                uid: generate$6('multiple-toolbar-item'),
                cyclicKeying: false,
                initGroups: [],
                providers: spec.providers,
                onEscape: function () {
                  spec.onEscape();
                  return Optional.some(true);
                }
              });
            },
            setupItem: function (_mToolbar, tc, data, _index) {
              Toolbar.setGroups(tc, data);
            },
            shell: true
          });
        }
      },
      name: 'multiple-toolbar',
      schema: [
        required$1('dom'),
        required$1('onEscape')
      ]
    });
    var partToolbar = partType.optional({
      factory: {
        sketch: function (spec) {
          var renderer = toolbarFactory(spec);
          var toolbarSpec = {
            type: spec.type,
            uid: spec.uid,
            onEscape: function () {
              spec.onEscape();
              return Optional.some(true);
            },
            cyclicKeying: false,
            initGroups: [],
            getSink: spec.getSink,
            providers: spec.providers,
            moreDrawerData: {
              lazyToolbar: spec.lazyToolbar,
              lazyMoreButton: spec.lazyMoreButton,
              lazyHeader: spec.lazyHeader
            },
            attributes: spec.attributes
          };
          return renderer(toolbarSpec);
        }
      },
      name: 'toolbar',
      schema: [
        required$1('dom'),
        required$1('onEscape'),
        required$1('getSink')
      ]
    });
    var partHeader = partType.optional({
      factory: { sketch: renderHeader },
      name: 'header',
      schema: [required$1('dom')]
    });
    var partSocket = partType.optional({
      name: 'socket',
      schema: [required$1('dom')]
    });
    var partSidebar = partType.optional({
      factory: { sketch: renderSidebar },
      name: 'sidebar',
      schema: [required$1('dom')]
    });
    var partThrobber = partType.optional({
      factory: { sketch: renderThrobber },
      name: 'throbber',
      schema: [required$1('dom')]
    });
    var OuterContainer = composite({
      name: 'OuterContainer',
      factory: factory$6,
      configFields: [
        required$1('dom'),
        required$1('behaviours')
      ],
      partFields: [
        partHeader,
        partMenubar,
        partToolbar,
        partMultipleToolbar,
        partSocket,
        partSidebar,
        partThrobber
      ],
      apis: {
        getSocket: function (apis, comp) {
          return apis.getSocket(comp);
        },
        setSidebar: function (apis, comp, panelConfigs) {
          apis.setSidebar(comp, panelConfigs);
        },
        toggleSidebar: function (apis, comp, name) {
          apis.toggleSidebar(comp, name);
        },
        whichSidebar: function (apis, comp) {
          return apis.whichSidebar(comp);
        },
        getHeader: function (apis, comp) {
          return apis.getHeader(comp);
        },
        getToolbar: function (apis, comp) {
          return apis.getToolbar(comp);
        },
        setToolbar: function (apis, comp, grps) {
          var groups = map$2(grps, function (grp) {
            return renderToolbarGroup(grp);
          });
          apis.setToolbar(comp, groups);
        },
        setToolbars: function (apis, comp, ts) {
          var renderedToolbars = map$2(ts, function (g) {
            return map$2(g, renderToolbarGroup);
          });
          apis.setToolbars(comp, renderedToolbars);
        },
        refreshToolbar: function (apis, comp) {
          return apis.refreshToolbar(comp);
        },
        toggleToolbarDrawer: function (apis, comp) {
          apis.toggleToolbarDrawer(comp);
        },
        isToolbarDrawerToggled: function (apis, comp) {
          return apis.isToolbarDrawerToggled(comp);
        },
        getThrobber: function (apis, comp) {
          return apis.getThrobber(comp);
        },
        setMenubar: function (apis, comp, menus) {
          apis.setMenubar(comp, menus);
        },
        focusMenubar: function (apis, comp) {
          apis.focusMenubar(comp);
        },
        focusToolbar: function (apis, comp) {
          apis.focusToolbar(comp);
        }
      }
    });

    var defaultMenubar = 'file edit view insert format tools table help';
    var defaultMenus = {
      file: {
        title: 'File',
        items: 'newdocument restoredraft | preview | export print | deleteallconversations'
      },
      edit: {
        title: 'Edit',
        items: 'undo redo | cut copy paste pastetext | selectall | searchreplace'
      },
      view: {
        title: 'View',
        items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments'
      },
      insert: {
        title: 'Insert',
        items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime'
      },
      format: {
        title: 'Format',
        items: 'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align lineheight | forecolor backcolor | language | removeformat'
      },
      tools: {
        title: 'Tools',
        items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount'
      },
      table: {
        title: 'Table',
        items: 'inserttable | cell row column | advtablesort | tableprops deletetable'
      },
      help: {
        title: 'Help',
        items: 'help'
      }
    };
    var make = function (menu, registry, editor) {
      var removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
      return {
        text: menu.title,
        getItems: function () {
          return bind$3(menu.items, function (i) {
            var itemName = i.toLowerCase();
            if (itemName.trim().length === 0) {
              return [];
            } else if (exists(removedMenuItems, function (removedMenuItem) {
                return removedMenuItem === itemName;
              })) {
              return [];
            } else if (itemName === 'separator' || itemName === '|') {
              return [{ type: 'separator' }];
            } else if (registry.menuItems[itemName]) {
              return [registry.menuItems[itemName]];
            } else {
              return [];
            }
          });
        }
      };
    };
    var parseItemsString = function (items) {
      if (typeof items === 'string') {
        return items.split(' ');
      }
      return items;
    };
    var identifyMenus = function (editor, registry) {
      var rawMenuData = __assign(__assign({}, defaultMenus), registry.menus);
      var userDefinedMenus = keys(registry.menus).length > 0;
      var menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);
      var validMenus = filter$2(menubar, function (menuName) {
        var isDefaultMenu = has$2(defaultMenus, menuName);
        if (userDefinedMenus) {
          return isDefaultMenu || get$e(registry.menus, menuName).exists(function (menu) {
            return has$2(menu, 'items');
          });
        } else {
          return isDefaultMenu;
        }
      });
      var menus = map$2(validMenus, function (menuName) {
        var menuData = rawMenuData[menuName];
        return make({
          title: menuData.title,
          items: parseItemsString(menuData.items)
        }, registry, editor);
      });
      return filter$2(menus, function (menu) {
        var isNotSeparator = function (item) {
          return item.type !== 'separator';
        };
        return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);
      });
    };

    var fireSkinLoaded = function (editor) {
      var done = function () {
        editor._skinLoaded = true;
        fireSkinLoaded$1(editor);
      };
      return function () {
        if (editor.initialized) {
          done();
        } else {
          editor.on('init', done);
        }
      };
    };
    var fireSkinLoadError = function (editor, err) {
      return function () {
        return fireSkinLoadError$1(editor, { message: err });
      };
    };

    var loadStylesheet = function (editor, stylesheetUrl, styleSheetLoader) {
      return new global$c(function (resolve, reject) {
        styleSheetLoader.load(stylesheetUrl, resolve, reject);
        editor.on('remove', function () {
          return styleSheetLoader.unload(stylesheetUrl);
        });
      });
    };
    var loadUiSkins = function (editor, skinUrl) {
      var skinUiCss = skinUrl + '/skin.min.css';
      return loadStylesheet(editor, skinUiCss, editor.ui.styleSheetLoader);
    };
    var loadShadowDomUiSkins = function (editor, skinUrl) {
      var isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));
      if (isInShadowRoot$1) {
        var shadowDomSkinCss = skinUrl + '/skin.shadowdom.min.css';
        return loadStylesheet(editor, shadowDomSkinCss, global$b.DOM.styleSheetLoader);
      } else {
        return global$c.resolve();
      }
    };
    var loadSkin = function (isInline, editor) {
      var skinUrl = getSkinUrl(editor);
      if (skinUrl) {
        editor.contentCSS.push(skinUrl + (isInline ? '/content.inline' : '/content') + '.min.css');
      }
      if (isSkinDisabled(editor) === false && isString(skinUrl)) {
        global$c.all([
          loadUiSkins(editor, skinUrl),
          loadShadowDomUiSkins(editor, skinUrl)
        ]).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));
      } else {
        fireSkinLoaded(editor)();
      }
    };
    var iframe = curry(loadSkin, false);
    var inline = curry(loadSkin, true);

    var onSetupFormatToggle = function (editor, name) {
      return function (api) {
        var boundCallback = unbindable();
        var init = function () {
          api.setActive(editor.formatter.match(name));
          var binding = editor.formatter.formatChanged(name, api.setActive);
          boundCallback.set(binding);
        };
        editor.initialized ? init() : editor.once('init', init);
        return function () {
          editor.off('init', init);
          boundCallback.clear();
        };
      };
    };
    var onSetupEvent = function (editor, event, f) {
      return function (api) {
        var handleEvent = function () {
          return f(api);
        };
        var init = function () {
          f(api);
          editor.on(event, handleEvent);
        };
        editor.initialized ? init() : editor.once('init', init);
        return function () {
          editor.off('init', init);
          editor.off(event, handleEvent);
        };
      };
    };
    var onActionToggleFormat$1 = function (editor) {
      return function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand('mceToggleFormat', false, rawItem.format);
          });
        };
      };
    };
    var onActionExecCommand = function (editor, command) {
      return function () {
        return editor.execCommand(command);
      };
    };

    var generateSelectItems = function (_editor, backstage, spec) {
      var generateItem = function (rawItem, response, disabled, value) {
        var translatedText = backstage.shared.providers.translate(rawItem.title);
        if (rawItem.type === 'separator') {
          return Optional.some({
            type: 'separator',
            text: translatedText
          });
        } else if (rawItem.type === 'submenu') {
          var items = bind$3(rawItem.getStyleItems(), function (si) {
            return validate(si, response, value);
          });
          if (response === 0 && items.length <= 0) {
            return Optional.none();
          } else {
            return Optional.some({
              type: 'nestedmenuitem',
              text: translatedText,
              disabled: items.length <= 0,
              getSubmenuItems: function () {
                return bind$3(rawItem.getStyleItems(), function (si) {
                  return validate(si, response, value);
                });
              }
            });
          }
        } else {
          return Optional.some(__assign({
            type: 'togglemenuitem',
            text: translatedText,
            icon: rawItem.icon,
            active: rawItem.isSelected(value),
            disabled: disabled,
            onAction: spec.onAction(rawItem)
          }, rawItem.getStylePreview().fold(function () {
            return {};
          }, function (preview) {
            return { meta: { style: preview } };
          })));
        }
      };
      var validate = function (item, response, value) {
        var invalid = item.type === 'formatter' && spec.isInvalid(item);
        if (response === 0) {
          return invalid ? [] : generateItem(item, response, false, value).toArray();
        } else {
          return generateItem(item, response, invalid, value).toArray();
        }
      };
      var validateItems = function (preItems) {
        var value = spec.getCurrentValue();
        var response = spec.shouldHide ? 0 : 1;
        return bind$3(preItems, function (item) {
          return validate(item, response, value);
        });
      };
      var getFetch = function (backstage, getStyleItems) {
        return function (comp, callback) {
          var preItems = getStyleItems();
          var items = validateItems(preItems);
          var menu = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false);
          callback(menu);
        };
      };
      return {
        validateItems: validateItems,
        getFetch: getFetch
      };
    };
    var createMenuItems = function (editor, backstage, spec) {
      var dataset = spec.dataset;
      var getStyleItems = dataset.type === 'basic' ? function () {
        return map$2(dataset.data, function (d) {
          return processBasic(d, spec.isSelectedFor, spec.getPreviewFor);
        });
      } : dataset.getData;
      return {
        items: generateSelectItems(editor, backstage, spec),
        getStyleItems: getStyleItems
      };
    };
    var createSelectButton = function (editor, backstage, spec) {
      var _a = createMenuItems(editor, backstage, spec), items = _a.items, getStyleItems = _a.getStyleItems;
      var getApi = function (comp) {
        return { getComponent: constant$1(comp) };
      };
      var onSetup = onSetupEvent(editor, 'NodeChange', function (api) {
        var comp = api.getComponent();
        spec.updateText(comp);
      });
      return renderCommonDropdown({
        text: spec.icon.isSome() ? Optional.none() : spec.text,
        icon: spec.icon,
        tooltip: Optional.from(spec.tooltip),
        role: Optional.none(),
        fetch: items.getFetch(backstage, getStyleItems),
        onSetup: onSetup,
        getApi: getApi,
        columns: 1,
        presets: 'normal',
        classes: spec.icon.isSome() ? [] : ['bespoke'],
        dropdownBehaviours: []
      }, 'tox-tbtn', backstage.shared);
    };

    var process = function (rawFormats) {
      return map$2(rawFormats, function (item) {
        var title = item, format = item;
        var values = item.split('=');
        if (values.length > 1) {
          title = values[0];
          format = values[1];
        }
        return {
          title: title,
          format: format
        };
      });
    };
    var buildBasicStaticDataset = function (data) {
      return {
        type: 'basic',
        data: data
      };
    };
    var Delimiter;
    (function (Delimiter) {
      Delimiter[Delimiter['SemiColon'] = 0] = 'SemiColon';
      Delimiter[Delimiter['Space'] = 1] = 'Space';
    }(Delimiter || (Delimiter = {})));
    var split = function (rawFormats, delimiter) {
      if (delimiter === Delimiter.SemiColon) {
        return rawFormats.replace(/;$/, '').split(';');
      } else {
        return rawFormats.split(' ');
      }
    };
    var buildBasicSettingsDataset = function (editor, settingName, defaults, delimiter) {
      var rawFormats = editor.getParam(settingName, defaults, 'string');
      var data = process(split(rawFormats, delimiter));
      return {
        type: 'basic',
        data: data
      };
    };

    var alignMenuItems = [
      {
        title: 'Left',
        icon: 'align-left',
        format: 'alignleft',
        command: 'JustifyLeft'
      },
      {
        title: 'Center',
        icon: 'align-center',
        format: 'aligncenter',
        command: 'JustifyCenter'
      },
      {
        title: 'Right',
        icon: 'align-right',
        format: 'alignright',
        command: 'JustifyRight'
      },
      {
        title: 'Justify',
        icon: 'align-justify',
        format: 'alignjustify',
        command: 'JustifyFull'
      }
    ];
    var getSpec$4 = function (editor) {
      var getMatchingValue = function () {
        return find$5(alignMenuItems, function (item) {
          return editor.formatter.match(item.format);
        });
      };
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (_format) {
        return Optional.none;
      };
      var updateSelectMenuIcon = function (comp) {
        var match = getMatchingValue();
        var alignment = match.fold(constant$1('left'), function (item) {
          return item.title.toLowerCase();
        });
        emitWith(comp, updateMenuIcon, { icon: 'align-' + alignment });
      };
      var dataset = buildBasicStaticDataset(alignMenuItems);
      var onAction = function (rawItem) {
        return function () {
          return find$5(alignMenuItems, function (item) {
            return item.format === rawItem.format;
          }).each(function (item) {
            return editor.execCommand(item.command);
          });
        };
      };
      return {
        tooltip: 'Align',
        text: Optional.none(),
        icon: Optional.some('align-left'),
        isSelectedFor: isSelectedFor,
        getCurrentValue: Optional.none,
        getPreviewFor: getPreviewFor,
        onAction: onAction,
        updateText: updateSelectMenuIcon,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        }
      };
    };
    var createAlignSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$4(editor));
    };
    var alignSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$4(editor));
      editor.ui.registry.addNestedMenuItem('align', {
        text: backstage.shared.providers.translate('Align'),
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var defaultFontsFormats = 'Andale Mono=andale mono,monospace;' + 'Arial=arial,helvetica,sans-serif;' + 'Arial Black=arial black,sans-serif;' + 'Book Antiqua=book antiqua,palatino,serif;' + 'Comic Sans MS=comic sans ms,sans-serif;' + 'Courier New=courier new,courier,monospace;' + 'Georgia=georgia,palatino,serif;' + 'Helvetica=helvetica,arial,sans-serif;' + 'Impact=impact,sans-serif;' + 'Symbol=symbol;' + 'Tahoma=tahoma,arial,helvetica,sans-serif;' + 'Terminal=terminal,monaco,monospace;' + 'Times New Roman=times new roman,times,serif;' + 'Trebuchet MS=trebuchet ms,geneva,sans-serif;' + 'Verdana=verdana,geneva,sans-serif;' + 'Webdings=webdings;' + 'Wingdings=wingdings,zapf dingbats';
    var systemStackFonts = [
      '-apple-system',
      'Segoe UI',
      'Roboto',
      'Helvetica Neue',
      'sans-serif'
    ];
    var splitFonts = function (fontFamily) {
      var fonts = fontFamily.split(/\s*,\s*/);
      return map$2(fonts, function (font) {
        return font.replace(/^['"]+|['"]+$/g, '');
      });
    };
    var isSystemFontStack = function (fontFamily) {
      var matchesSystemStack = function () {
        var fonts = splitFonts(fontFamily.toLowerCase());
        return forall(systemStackFonts, function (font) {
          return fonts.indexOf(font.toLowerCase()) > -1;
        });
      };
      return fontFamily.indexOf('-apple-system') === 0 && matchesSystemStack();
    };
    var getSpec$3 = function (editor) {
      var systemFont = 'System Font';
      var getMatchingValue = function () {
        var getFirstFont = function (fontFamily) {
          return fontFamily ? splitFonts(fontFamily)[0] : '';
        };
        var fontFamily = editor.queryCommandValue('FontName');
        var items = dataset.data;
        var font = fontFamily ? fontFamily.toLowerCase() : '';
        var matchOpt = find$5(items, function (item) {
          var format = item.format;
          return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();
        }).orThunk(function () {
          return someIf(isSystemFontStack(font), {
            title: systemFont,
            format: font
          });
        });
        return {
          matchOpt: matchOpt,
          font: fontFamily
        };
      };
      var isSelectedFor = function (item) {
        return function (valueOpt) {
          return valueOpt.exists(function (value) {
            return value.format === item;
          });
        };
      };
      var getCurrentValue = function () {
        var matchOpt = getMatchingValue().matchOpt;
        return matchOpt;
      };
      var getPreviewFor = function (item) {
        return function () {
          return Optional.some({
            tag: 'div',
            styles: item.indexOf('dings') === -1 ? { 'font-family': item } : {}
          });
        };
      };
      var onAction = function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand('FontName', false, rawItem.format);
          });
        };
      };
      var updateSelectMenuText = function (comp) {
        var _a = getMatchingValue(), matchOpt = _a.matchOpt, font = _a.font;
        var text = matchOpt.fold(constant$1(font), function (item) {
          return item.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var dataset = buildBasicSettingsDataset(editor, 'font_formats', defaultFontsFormats, Delimiter.SemiColon);
      return {
        tooltip: 'Fonts',
        text: Optional.some(systemFont),
        icon: Optional.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: getCurrentValue,
        getPreviewFor: getPreviewFor,
        onAction: onAction,
        updateText: updateSelectMenuText,
        dataset: dataset,
        shouldHide: false,
        isInvalid: never
      };
    };
    var createFontSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$3(editor));
    };
    var fontSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
      editor.ui.registry.addNestedMenuItem('fontformats', {
        text: backstage.shared.providers.translate('Fonts'),
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var defaultFontsizeFormats = '8pt 10pt 12pt 14pt 18pt 24pt 36pt';
    var legacyFontSizes = {
      '8pt': '1',
      '10pt': '2',
      '12pt': '3',
      '14pt': '4',
      '18pt': '5',
      '24pt': '6',
      '36pt': '7'
    };
    var keywordFontSizes = {
      'xx-small': '7pt',
      'x-small': '8pt',
      'small': '10pt',
      'medium': '12pt',
      'large': '14pt',
      'x-large': '18pt',
      'xx-large': '24pt'
    };
    var round = function (number, precision) {
      var factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var toPt = function (fontSize, precision) {
      if (/[0-9.]+px$/.test(fontSize)) {
        return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';
      } else {
        return get$e(keywordFontSizes, fontSize).getOr(fontSize);
      }
    };
    var toLegacy = function (fontSize) {
      return get$e(legacyFontSizes, fontSize).getOr('');
    };
    var getSpec$2 = function (editor) {
      var getMatchingValue = function () {
        var matchOpt = Optional.none();
        var items = dataset.data;
        var fontSize = editor.queryCommandValue('FontSize');
        if (fontSize) {
          var _loop_1 = function (precision) {
            var pt = toPt(fontSize, precision);
            var legacy = toLegacy(pt);
            matchOpt = find$5(items, function (item) {
              return item.format === fontSize || item.format === pt || item.format === legacy;
            });
          };
          for (var precision = 3; matchOpt.isNone() && precision >= 0; precision--) {
            _loop_1(precision);
          }
        }
        return {
          matchOpt: matchOpt,
          size: fontSize
        };
      };
      var isSelectedFor = function (item) {
        return function (valueOpt) {
          return valueOpt.exists(function (value) {
            return value.format === item;
          });
        };
      };
      var getCurrentValue = function () {
        var matchOpt = getMatchingValue().matchOpt;
        return matchOpt;
      };
      var getPreviewFor = constant$1(Optional.none);
      var onAction = function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand('FontSize', false, rawItem.format);
          });
        };
      };
      var updateSelectMenuText = function (comp) {
        var _a = getMatchingValue(), matchOpt = _a.matchOpt, size = _a.size;
        var text = matchOpt.fold(constant$1(size), function (match) {
          return match.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var dataset = buildBasicSettingsDataset(editor, 'fontsize_formats', defaultFontsizeFormats, Delimiter.Space);
      return {
        tooltip: 'Font sizes',
        text: Optional.some('12pt'),
        icon: Optional.none(),
        isSelectedFor: isSelectedFor,
        getPreviewFor: getPreviewFor,
        getCurrentValue: getCurrentValue,
        onAction: onAction,
        updateText: updateSelectMenuText,
        dataset: dataset,
        shouldHide: false,
        isInvalid: never
      };
    };
    var createFontsizeSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$2(editor));
    };
    var fontsizeSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
      editor.ui.registry.addNestedMenuItem('fontsizes', {
        text: 'Font sizes',
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var findNearest = function (editor, getStyles) {
      var styles = getStyles();
      var formats = map$2(styles, function (style) {
        return style.format;
      });
      return Optional.from(editor.formatter.closest(formats)).bind(function (fmt) {
        return find$5(styles, function (data) {
          return data.format === fmt;
        });
      }).orThunk(function () {
        return someIf(editor.formatter.match('p'), {
          title: 'Paragraph',
          format: 'p'
        });
      });
    };

    var defaultBlocks = 'Paragraph=p;' + 'Heading 1=h1;' + 'Heading 2=h2;' + 'Heading 3=h3;' + 'Heading 4=h4;' + 'Heading 5=h5;' + 'Heading 6=h6;' + 'Preformatted=pre';
    var getSpec$1 = function (editor) {
      var fallbackFormat = 'Paragraph';
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return Optional.some({
            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          });
        };
      };
      var updateSelectMenuText = function (comp) {
        var detectedFormat = findNearest(editor, function () {
          return dataset.data;
        });
        var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {
          return fmt.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var dataset = buildBasicSettingsDataset(editor, 'block_formats', defaultBlocks, Delimiter.SemiColon);
      return {
        tooltip: 'Blocks',
        text: Optional.some(fallbackFormat),
        icon: Optional.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: Optional.none,
        getPreviewFor: getPreviewFor,
        onAction: onActionToggleFormat$1(editor),
        updateText: updateSelectMenuText,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        }
      };
    };
    var createFormatSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$1(editor));
    };
    var formatSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
      editor.ui.registry.addNestedMenuItem('blockformats', {
        text: 'Blocks',
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var getSpec = function (editor, dataset) {
      var fallbackFormat = 'Paragraph';
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return fmt !== undefined ? Optional.some({
            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          }) : Optional.none();
        };
      };
      var updateSelectMenuText = function (comp) {
        var getFormatItems = function (fmt) {
          var subs = fmt.items;
          return subs !== undefined && subs.length > 0 ? bind$3(subs, getFormatItems) : [{
              title: fmt.title,
              format: fmt.format
            }];
        };
        var flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);
        var detectedFormat = findNearest(editor, constant$1(flattenedItems));
        var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {
          return fmt.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      return {
        tooltip: 'Formats',
        text: Optional.some(fallbackFormat),
        icon: Optional.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: Optional.none,
        getPreviewFor: getPreviewFor,
        onAction: onActionToggleFormat$1(editor),
        updateText: updateSelectMenuText,
        shouldHide: editor.getParam('style_formats_autohide', false, 'boolean'),
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        },
        dataset: dataset
      };
    };
    var createStyleSelect = function (editor, backstage) {
      var dataset = __assign({ type: 'advanced' }, backstage.styleselect);
      return createSelectButton(editor, backstage, getSpec(editor, dataset));
    };
    var styleSelectMenu = function (editor, backstage) {
      var dataset = __assign({ type: 'advanced' }, backstage.styleselect);
      var menuItems = createMenuItems(editor, backstage, getSpec(editor, dataset));
      editor.ui.registry.addNestedMenuItem('formats', {
        text: 'Formats',
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var events$3 = function (reflectingConfig, reflectingState) {
      var update = function (component, data) {
        reflectingConfig.updateState.each(function (updateState) {
          var newState = updateState(component, data);
          reflectingState.set(newState);
        });
        reflectingConfig.renderComponents.each(function (renderComponents) {
          var newComponents = renderComponents(data, reflectingState.get());
          var newChildren = map$2(newComponents, component.getSystem().build);
          replaceChildren(component, newChildren);
        });
      };
      return derive$2([
        run$1(receive(), function (component, message) {
          var receivingData = message;
          if (!receivingData.universal) {
            var channel = reflectingConfig.channel;
            if (contains$2(receivingData.channels, channel)) {
              update(component, receivingData.data);
            }
          }
        }),
        runOnAttached(function (comp, _se) {
          reflectingConfig.initialData.each(function (rawData) {
            update(comp, rawData);
          });
        })
      ]);
    };

    var ActiveReflecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$3
    });

    var getState = function (component, replaceConfig, reflectState) {
      return reflectState;
    };

    var ReflectingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getState: getState
    });

    var ReflectingSchema = [
      required$1('channel'),
      option('renderComponents'),
      option('updateState'),
      option('initialData')
    ];

    var init$3 = function () {
      var cell = Cell(Optional.none());
      var clear = function () {
        return cell.set(Optional.none());
      };
      var readState = function () {
        return cell.get().getOr('none');
      };
      return {
        readState: readState,
        get: cell.get,
        set: cell.set,
        clear: clear
      };
    };

    var ReflectingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$3
    });

    var Reflecting = create$7({
      fields: ReflectingSchema,
      name: 'reflecting',
      active: ActiveReflecting,
      apis: ReflectingApis,
      state: ReflectingState
    });

    var schema$7 = constant$1([
      required$1('toggleClass'),
      required$1('fetch'),
      onStrictHandler('onExecute'),
      defaulted('getHotspot', Optional.some),
      defaulted('getAnchorOverrides', constant$1({})),
      schema$y(),
      onStrictHandler('onItemExecute'),
      option('lazySink'),
      required$1('dom'),
      onHandler('onOpen'),
      field('splitDropdownBehaviours', [
        Coupling,
        Keying,
        Focusing
      ]),
      defaulted('matchWidth', false),
      defaulted('useMinWidth', false),
      defaulted('eventOrder', {}),
      option('role')
    ].concat(sandboxFields()));
    var arrowPart = required({
      factory: Button,
      schema: [required$1('dom')],
      name: 'arrow',
      defaults: function () {
        return { buttonBehaviours: derive$1([Focusing.revoke()]) };
      },
      overrides: function (detail) {
        return {
          dom: {
            tag: 'span',
            attributes: { role: 'presentation' }
          },
          action: function (arrow) {
            arrow.getSystem().getByUid(detail.uid).each(emitExecute);
          },
          buttonBehaviours: derive$1([Toggling.config({
              toggleOnExecute: false,
              toggleClass: detail.toggleClass
            })])
        };
      }
    });
    var buttonPart = required({
      factory: Button,
      schema: [required$1('dom')],
      name: 'button',
      defaults: function () {
        return { buttonBehaviours: derive$1([Focusing.revoke()]) };
      },
      overrides: function (detail) {
        return {
          dom: {
            tag: 'span',
            attributes: { role: 'presentation' }
          },
          action: function (btn) {
            btn.getSystem().getByUid(detail.uid).each(function (splitDropdown) {
              detail.onExecute(splitDropdown, btn);
            });
          }
        };
      }
    });
    var parts$3 = constant$1([
      arrowPart,
      buttonPart,
      optional({
        factory: {
          sketch: function (spec) {
            return {
              uid: spec.uid,
              dom: {
                tag: 'span',
                styles: { display: 'none' },
                attributes: { 'aria-hidden': 'true' },
                innerHtml: spec.text
              }
            };
          }
        },
        schema: [required$1('text')],
        name: 'aria-descriptor'
      }),
      external$1({
        schema: [tieredMenuMarkers()],
        name: 'menu',
        defaults: function (detail) {
          return {
            onExecute: function (tmenu, item) {
              tmenu.getSystem().getByUid(detail.uid).each(function (splitDropdown) {
                detail.onItemExecute(splitDropdown, tmenu, item);
              });
            }
          };
        }
      }),
      partType$1()
    ]);

    var factory$5 = function (detail, components, spec, externals) {
      var _a;
      var switchToMenu = function (sandbox) {
        Composing.getCurrent(sandbox).each(function (current) {
          Highlighting.highlightFirst(current);
          Keying.focusIn(current);
        });
      };
      var action = function (component) {
        var onOpenSync = switchToMenu;
        togglePopup(detail, identity$1, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
      };
      var openMenu = function (comp) {
        action(comp);
        return Optional.some(true);
      };
      var executeOnButton = function (comp) {
        var button = getPartOrDie(comp, detail, 'button');
        emitExecute(button);
        return Optional.some(true);
      };
      var buttonEvents = __assign(__assign({}, derive$2([runOnAttached(function (component, _simulatedEvent) {
          var ariaDescriptor = getPart(component, detail, 'aria-descriptor');
          ariaDescriptor.each(function (descriptor) {
            var descriptorId = generate$6('aria');
            set$8(descriptor.element, 'id', descriptorId);
            set$8(component.element, 'aria-describedby', descriptorId);
          });
        })])), events$a(Optional.some(action)));
      var apis = {
        repositionMenus: function (comp) {
          if (Toggling.isOn(comp)) {
            repositionMenus(comp);
          }
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: apis,
        eventOrder: __assign(__assign({}, detail.eventOrder), (_a = {}, _a[execute$5()] = [
          'disabling',
          'toggling',
          'alloy.base.behaviour'
        ], _a)),
        events: buttonEvents,
        behaviours: augment(detail.splitDropdownBehaviours, [
          Coupling.config({
            others: {
              sandbox: function (hotspot) {
                var arrow = getPartOrDie(hotspot, detail, 'arrow');
                var extras = {
                  onOpen: function () {
                    Toggling.on(arrow);
                    Toggling.on(hotspot);
                  },
                  onClose: function () {
                    Toggling.off(arrow);
                    Toggling.off(hotspot);
                  }
                };
                return makeSandbox$1(detail, hotspot, extras);
              }
            }
          }),
          Keying.config({
            mode: 'special',
            onSpace: executeOnButton,
            onEnter: executeOnButton,
            onDown: openMenu
          }),
          Focusing.config({}),
          Toggling.config({
            toggleOnExecute: false,
            aria: { mode: 'expanded' }
          })
        ]),
        domModification: {
          attributes: {
            'role': detail.role.getOr('button'),
            'aria-haspopup': true
          }
        }
      };
    };
    var SplitDropdown = composite({
      name: 'SplitDropdown',
      configFields: schema$7(),
      partFields: parts$3(),
      factory: factory$5,
      apis: {
        repositionMenus: function (apis, comp) {
          return apis.repositionMenus(comp);
        }
      }
    });

    var getButtonApi = function (component) {
      return {
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        }
      };
    };
    var getToggleApi = function (component) {
      return {
        setActive: function (state) {
          Toggling.set(component, state);
        },
        isActive: function () {
          return Toggling.isOn(component);
        },
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        }
      };
    };
    var getTooltipAttributes = function (tooltip, providersBackstage) {
      return tooltip.map(function (tooltip) {
        return {
          'aria-label': providersBackstage.translate(tooltip),
          'title': providersBackstage.translate(tooltip)
        };
      }).getOr({});
    };
    var focusButtonEvent = generate$6('focus-button');
    var renderCommonStructure = function (icon, text, tooltip, receiver, behaviours, providersBackstage) {
      var _d;
      return {
        dom: {
          tag: 'button',
          classes: ['tox-tbtn'].concat(text.isSome() ? ['tox-tbtn--select'] : []),
          attributes: getTooltipAttributes(tooltip, providersBackstage)
        },
        components: componentRenderPipeline([
          icon.map(function (iconName) {
            return renderIconFromPack(iconName, providersBackstage.icons);
          }),
          text.map(function (text) {
            return renderLabel$1(text, 'tox-tbtn', providersBackstage);
          })
        ]),
        eventOrder: (_d = {}, _d[mousedown()] = [
          'focusing',
          'alloy.base.behaviour',
          'common-button-display-events'
        ], _d),
        buttonBehaviours: derive$1([
          DisablingConfigs.toolbarButton(providersBackstage.isDisabled),
          receivingConfig(),
          config('common-button-display-events', [run$1(mousedown(), function (button, se) {
              se.event.prevent();
              emit(button, focusButtonEvent);
            })])
        ].concat(receiver.map(function (r) {
          return Reflecting.config({
            channel: r,
            initialData: {
              icon: icon,
              text: text
            },
            renderComponents: function (data, _state) {
              return componentRenderPipeline([
                data.icon.map(function (iconName) {
                  return renderIconFromPack(iconName, providersBackstage.icons);
                }),
                data.text.map(function (text) {
                  return renderLabel$1(text, 'tox-tbtn', providersBackstage);
                })
              ]);
            }
          });
        }).toArray()).concat(behaviours.getOr([])))
      };
    };
    var renderFloatingToolbarButton = function (spec, backstage, identifyButtons, attributes) {
      var sharedBackstage = backstage.shared;
      return FloatingToolbarButton.sketch({
        lazySink: sharedBackstage.getSink,
        fetch: function () {
          return Future.nu(function (resolve) {
            resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));
          });
        },
        markers: { toggledClass: 'tox-tbtn--enabled' },
        parts: {
          button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), sharedBackstage.providers),
          toolbar: {
            dom: {
              tag: 'div',
              classes: ['tox-toolbar__overflow'],
              attributes: attributes
            }
          }
        }
      });
    };
    var renderCommonToolbarButton = function (spec, specialisation, providersBackstage) {
      var editorOffCell = Cell(noop);
      var structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), providersBackstage);
      return Button.sketch({
        dom: structure.dom,
        components: structure.components,
        eventOrder: toolbarButtonEventOrder,
        buttonBehaviours: derive$1([
          config('toolbar-button-events', [
            onToolbarButtonExecute({
              onAction: spec.onAction,
              getApi: specialisation.getApi
            }),
            onControlAttached(specialisation, editorOffCell),
            onControlDetached(specialisation, editorOffCell)
          ]),
          DisablingConfigs.toolbarButton(function () {
            return spec.disabled || providersBackstage.isDisabled();
          }),
          receivingConfig()
        ].concat(specialisation.toolbarButtonBehaviours))
      });
    };
    var renderToolbarButton = function (spec, providersBackstage) {
      return renderToolbarButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarButtonWith = function (spec, providersBackstage, bonusEvents) {
      return renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: [].concat(bonusEvents.length > 0 ? [config('toolbarButtonWith', bonusEvents)] : []),
        getApi: getButtonApi,
        onSetup: spec.onSetup
      }, providersBackstage);
    };
    var renderToolbarToggleButton = function (spec, providersBackstage) {
      return renderToolbarToggleButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarToggleButtonWith = function (spec, providersBackstage, bonusEvents) {
      return deepMerge(renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: [
          Replacing.config({}),
          Toggling.config({
            toggleClass: 'tox-tbtn--enabled',
            aria: { mode: 'pressed' },
            toggleOnExecute: false
          })
        ].concat(bonusEvents.length > 0 ? [config('toolbarToggleButtonWith', bonusEvents)] : []),
        getApi: getToggleApi,
        onSetup: spec.onSetup
      }, providersBackstage));
    };
    var fetchChoices = function (getApi, spec, providersBackstage) {
      return function (comp) {
        return Future.nu(function (callback) {
          return spec.fetch(callback);
        }).map(function (items) {
          return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {
            spec.onItemAction(getApi(comp), value);
          }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {
            movement: deriveMenuMovement(spec.columns, spec.presets),
            menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {
                detectSize(comp, 4, classForPreset(spec.presets)).each(function (_d) {
                  var numRows = _d.numRows, numColumns = _d.numColumns;
                  Keying.setGridSize(comp, numRows, numColumns);
                });
              })])
          })));
        });
      };
    };
    var renderSplitButton = function (spec, sharedBackstage) {
      var _d;
      var displayChannel = generate$6('channel-update-split-dropdown-display');
      var getApi = function (comp) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(comp);
          },
          setDisabled: function (state) {
            return Disabling.set(comp, state);
          },
          setIconFill: function (id, value) {
            descendant(comp.element, 'svg path[id="' + id + '"], rect[id="' + id + '"]').each(function (underlinePath) {
              set$8(underlinePath, 'fill', value);
            });
          },
          setIconStroke: function (id, value) {
            descendant(comp.element, 'svg path[id="' + id + '"], rect[id="' + id + '"]').each(function (underlinePath) {
              set$8(underlinePath, 'stroke', value);
            });
          },
          setActive: function (state) {
            set$8(comp.element, 'aria-pressed', state);
            descendant(comp.element, 'span').each(function (button) {
              comp.getSystem().getByDom(button).each(function (buttonComp) {
                return Toggling.set(buttonComp, state);
              });
            });
          },
          isActive: function () {
            return descendant(comp.element, 'span').exists(function (button) {
              return comp.getSystem().getByDom(button).exists(Toggling.isOn);
            });
          }
        };
      };
      var editorOffCell = Cell(noop);
      var specialisation = {
        getApi: getApi,
        onSetup: spec.onSetup
      };
      return SplitDropdown.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-split-button'],
          attributes: __assign({ 'aria-pressed': false }, getTooltipAttributes(spec.tooltip, sharedBackstage.providers))
        },
        onExecute: function (button) {
          spec.onAction(getApi(button));
        },
        onItemExecute: function (_a, _b, _c) {
        },
        splitDropdownBehaviours: derive$1([
          DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
          receivingConfig(),
          config('split-dropdown-events', [
            run$1(focusButtonEvent, Focusing.focus),
            onControlAttached(specialisation, editorOffCell),
            onControlDetached(specialisation, editorOffCell)
          ]),
          Unselecting.config({})
        ]),
        eventOrder: (_d = {}, _d[attachedToDom()] = [
          'alloy.base.behaviour',
          'split-dropdown-events'
        ], _d),
        toggleClass: 'tox-tbtn--enabled',
        lazySink: sharedBackstage.getSink,
        fetch: fetchChoices(getApi, spec, sharedBackstage.providers),
        parts: { menu: part(false, spec.columns, spec.presets) },
        components: [
          SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some(displayChannel), Optional.some([Toggling.config({
              toggleClass: 'tox-tbtn--enabled',
              toggleOnExecute: false
            })]), sharedBackstage.providers)),
          SplitDropdown.parts.arrow({
            dom: {
              tag: 'button',
              classes: [
                'tox-tbtn',
                'tox-split-button__chevron'
              ],
              innerHtml: get$1('chevron-down', sharedBackstage.providers.icons)
            },
            buttonBehaviours: derive$1([
              DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
              receivingConfig(),
              addFocusableBehaviour()
            ])
          }),
          SplitDropdown.parts['aria-descriptor']({ text: sharedBackstage.providers.translate('To open the popup, press Shift+Enter') })
        ]
      });
    };

    var defaultToolbar = [
      {
        name: 'history',
        items: [
          'undo',
          'redo'
        ]
      },
      {
        name: 'styles',
        items: ['styleselect']
      },
      {
        name: 'formatting',
        items: [
          'bold',
          'italic'
        ]
      },
      {
        name: 'alignment',
        items: [
          'alignleft',
          'aligncenter',
          'alignright',
          'alignjustify'
        ]
      },
      {
        name: 'indentation',
        items: [
          'outdent',
          'indent'
        ]
      },
      {
        name: 'permanent pen',
        items: ['permanentpen']
      },
      {
        name: 'comments',
        items: ['addcomment']
      }
    ];
    var renderFromBridge = function (bridgeBuilder, render) {
      return function (spec, extras, editor) {
        var internal = bridgeBuilder(spec).mapError(function (errInfo) {
          return formatError(errInfo);
        }).getOrDie();
        return render(internal, extras, editor);
      };
    };
    var types = {
      button: renderFromBridge(createToolbarButton, function (s, extras) {
        return renderToolbarButton(s, extras.backstage.shared.providers);
      }),
      togglebutton: renderFromBridge(createToggleButton, function (s, extras) {
        return renderToolbarToggleButton(s, extras.backstage.shared.providers);
      }),
      menubutton: renderFromBridge(createMenuButton, function (s, extras) {
        return renderMenuButton(s, 'tox-tbtn', extras.backstage, Optional.none());
      }),
      splitbutton: renderFromBridge(createSplitButton, function (s, extras) {
        return renderSplitButton(s, extras.backstage.shared);
      }),
      grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, function (s, extras, editor) {
        var _a;
        var buttons = editor.ui.registry.getAll().buttons;
        var identify = function (toolbar) {
          return identifyButtons(editor, {
            buttons: buttons,
            toolbar: toolbar,
            allowToolbarGroups: false
          }, extras, Optional.none());
        };
        var attributes = (_a = {}, _a[Attribute] = extras.backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop, _a);
        switch (getToolbarMode(editor)) {
        case ToolbarMode.floating:
          return renderFloatingToolbarButton(s, extras.backstage, identify, attributes);
        default:
          throw new Error('Toolbar groups are only supported when using floating toolbar mode');
        }
      }),
      styleSelectButton: function (editor, extras) {
        return createStyleSelect(editor, extras.backstage);
      },
      fontsizeSelectButton: function (editor, extras) {
        return createFontsizeSelect(editor, extras.backstage);
      },
      fontSelectButton: function (editor, extras) {
        return createFontSelect(editor, extras.backstage);
      },
      formatButton: function (editor, extras) {
        return createFormatSelect(editor, extras.backstage);
      },
      alignMenuButton: function (editor, extras) {
        return createAlignSelect(editor, extras.backstage);
      }
    };
    var extractFrom = function (spec, extras, editor) {
      return get$e(types, spec.type).fold(function () {
        console.error('skipping button defined by', spec);
        return Optional.none();
      }, function (render) {
        return Optional.some(render(spec, extras, editor));
      });
    };
    var bespokeButtons = {
      styleselect: types.styleSelectButton,
      fontsizeselect: types.fontsizeSelectButton,
      fontselect: types.fontSelectButton,
      formatselect: types.formatButton,
      align: types.alignMenuButton
    };
    var removeUnusedDefaults = function (buttons) {
      var filteredItemGroups = map$2(defaultToolbar, function (group) {
        var items = filter$2(group.items, function (subItem) {
          return has$2(buttons, subItem) || has$2(bespokeButtons, subItem);
        });
        return {
          name: group.name,
          items: items
        };
      });
      return filter$2(filteredItemGroups, function (group) {
        return group.items.length > 0;
      });
    };
    var convertStringToolbar = function (strToolbar) {
      var groupsStrings = strToolbar.split('|');
      return map$2(groupsStrings, function (g) {
        return { items: g.trim().split(' ') };
      });
    };
    var isToolbarGroupSettingArray = function (toolbar) {
      return isArrayOf(toolbar, function (t) {
        return has$2(t, 'name') && has$2(t, 'items');
      });
    };
    var createToolbar = function (toolbarConfig) {
      var toolbar = toolbarConfig.toolbar;
      var buttons = toolbarConfig.buttons;
      if (toolbar === false) {
        return [];
      } else if (toolbar === undefined || toolbar === true) {
        return removeUnusedDefaults(buttons);
      } else if (isString(toolbar)) {
        return convertStringToolbar(toolbar);
      } else if (isToolbarGroupSettingArray(toolbar)) {
        return toolbar;
      } else {
        console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');
        return [];
      }
    };
    var lookupButton = function (editor, buttons, toolbarItem, allowToolbarGroups, extras, prefixes) {
      return get$e(buttons, toolbarItem.toLowerCase()).orThunk(function () {
        return prefixes.bind(function (ps) {
          return findMap(ps, function (prefix) {
            return get$e(buttons, prefix + toolbarItem.toLowerCase());
          });
        });
      }).fold(function () {
        return get$e(bespokeButtons, toolbarItem.toLowerCase()).map(function (r) {
          return r(editor, extras);
        }).orThunk(function () {
          return Optional.none();
        });
      }, function (spec) {
        if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {
          console.warn('Ignoring the \'' + toolbarItem + '\' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.');
          return Optional.none();
        } else {
          return extractFrom(spec, extras, editor);
        }
      });
    };
    var identifyButtons = function (editor, toolbarConfig, extras, prefixes) {
      var toolbarGroups = createToolbar(toolbarConfig);
      var groups = map$2(toolbarGroups, function (group) {
        var items = bind$3(group.items, function (toolbarItem) {
          return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, extras, prefixes).toArray();
        });
        return {
          title: Optional.from(editor.translate(group.name)),
          items: items
        };
      });
      return filter$2(groups, function (group) {
        return group.items.length > 0;
      });
    };

    var setToolbar = function (editor, uiComponents, rawUiConfig, backstage) {
      var comp = uiComponents.outerContainer;
      var toolbarConfig = rawUiConfig.toolbar;
      var toolbarButtonsConfig = rawUiConfig.buttons;
      if (isArrayOf(toolbarConfig, isString)) {
        var toolbars = toolbarConfig.map(function (t) {
          var config = {
            toolbar: t,
            buttons: toolbarButtonsConfig,
            allowToolbarGroups: rawUiConfig.allowToolbarGroups
          };
          return identifyButtons(editor, config, { backstage: backstage }, Optional.none());
        });
        OuterContainer.setToolbars(comp, toolbars);
      } else {
        OuterContainer.setToolbar(comp, identifyButtons(editor, rawUiConfig, { backstage: backstage }, Optional.none()));
      }
    };

    var detection = detect$1();
    var isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;
    var setupEvents$1 = function (editor, uiComponents) {
      var dom = editor.dom;
      var contentWindow = editor.getWin();
      var initialDocEle = editor.getDoc().documentElement;
      var lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
      var lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
      var resizeWindow = function () {
        var outer = lastWindowDimensions.get();
        if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {
          lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
          fireResizeContent(editor);
        }
      };
      var resizeDocument = function () {
        var docEle = editor.getDoc().documentElement;
        var inner = lastDocumentDimensions.get();
        if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {
          lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));
          fireResizeContent(editor);
        }
      };
      var scroll = function (e) {
        return fireScrollContent(editor, e);
      };
      dom.bind(contentWindow, 'resize', resizeWindow);
      dom.bind(contentWindow, 'scroll', scroll);
      var elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);
      var mothership = uiComponents.uiMothership.element;
      editor.on('hide', function () {
        set$7(mothership, 'display', 'none');
      });
      editor.on('show', function () {
        remove$6(mothership, 'display');
      });
      editor.on('NodeChange', resizeDocument);
      editor.on('remove', function () {
        elementLoad.unbind();
        dom.unbind(contentWindow, 'resize', resizeWindow);
        dom.unbind(contentWindow, 'scroll', scroll);
        contentWindow = null;
      });
    };
    var render$1 = function (editor, uiComponents, rawUiConfig, backstage, args) {
      var lastToolbarWidth = Cell(0);
      var outerContainer = uiComponents.outerContainer;
      iframe(editor);
      var eTargetNode = SugarElement.fromDom(args.targetNode);
      var uiRoot = getContentContainer(getRootNode(eTargetNode));
      attachSystemAfter(eTargetNode, uiComponents.mothership);
      attachSystem(uiRoot, uiComponents.uiMothership);
      editor.on('PostRender', function () {
        setToolbar(editor, uiComponents, rawUiConfig, backstage);
        lastToolbarWidth.set(editor.getWin().innerWidth);
        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
        OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar);
        setupEvents$1(editor, uiComponents);
      });
      var socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');
      if (isiOS12) {
        setAll(socket.element, {
          'overflow': 'scroll',
          '-webkit-overflow-scrolling': 'touch'
        });
        var limit = first(function () {
          editor.fire('ScrollContent');
        }, 20);
        var unbinder = bind(socket.element, 'scroll', limit.throttle);
        editor.on('remove', unbinder.unbind);
      }
      setupReadonlyModeSwitch(editor, uiComponents);
      editor.addCommand('ToggleSidebar', function (_ui, value) {
        OuterContainer.toggleSidebar(outerContainer, value);
        editor.fire('ToggleSidebar');
      });
      editor.addQueryValueHandler('ToggleSidebar', function () {
        return OuterContainer.whichSidebar(outerContainer);
      });
      var toolbarMode = getToolbarMode(editor);
      var refreshDrawer = function () {
        OuterContainer.refreshToolbar(uiComponents.outerContainer);
      };
      if (toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating) {
        editor.on('ResizeWindow ResizeEditor ResizeContent', function () {
          var width = editor.getWin().innerWidth;
          if (width !== lastToolbarWidth.get()) {
            refreshDrawer();
            lastToolbarWidth.set(width);
          }
        });
      }
      var api = {
        enable: function () {
          broadcastReadonly(uiComponents, false);
        },
        disable: function () {
          broadcastReadonly(uiComponents, true);
        },
        isDisabled: function () {
          return Disabling.isDisabled(outerContainer);
        }
      };
      return {
        iframeContainer: socket.element.dom,
        editorContainer: outerContainer.element.dom,
        api: api
      };
    };

    var Iframe = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render$1
    });

    var parseToInt = function (val) {
      var re = /^[0-9\.]+(|px)$/i;
      if (re.test('' + val)) {
        return Optional.some(parseInt('' + val, 10));
      }
      return Optional.none();
    };
    var numToPx = function (val) {
      return isNumber(val) ? val + 'px' : val;
    };
    var calcCappedSize = function (size, minSize, maxSize) {
      var minOverride = minSize.filter(function (min) {
        return size < min;
      });
      var maxOverride = maxSize.filter(function (max) {
        return size > max;
      });
      return minOverride.or(maxOverride).getOr(size);
    };

    var getHeight = function (editor) {
      var baseHeight = getHeightSetting(editor);
      var minHeight = getMinHeightSetting(editor);
      var maxHeight = getMaxHeightSetting(editor);
      return parseToInt(baseHeight).map(function (height) {
        return calcCappedSize(height, minHeight, maxHeight);
      });
    };
    var getHeightWithFallback = function (editor) {
      var height = getHeight(editor);
      return height.getOr(getHeightSetting(editor));
    };
    var getWidth = function (editor) {
      var baseWidth = getWidthSetting(editor);
      var minWidth = getMinWidthSetting(editor);
      var maxWidth = getMaxWidthSetting(editor);
      return parseToInt(baseWidth).map(function (width) {
        return calcCappedSize(width, minWidth, maxWidth);
      });
    };
    var getWidthWithFallback = function (editor) {
      var width = getWidth(editor);
      return width.getOr(getWidthSetting(editor));
    };

    var InlineHeader = function (editor, targetElm, uiComponents, backstage, floatContainer) {
      var uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;
      var DOM = global$b.DOM;
      var useFixedToolbarContainer = useFixedContainer(editor);
      var isSticky = isStickyToolbar(editor);
      var editorMaxWidthOpt = getMaxWidthSetting(editor).or(getWidth(editor));
      var headerBackstage = backstage.shared.header;
      var isPositionedAtTop = headerBackstage.isPositionedAtTop;
      var toolbarMode = getToolbarMode(editor);
      var isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;
      var visible = Cell(false);
      var isVisible = function () {
        return visible.get() && !editor.removed;
      };
      var calcToolbarOffset = function (toolbar) {
        return isSplitToolbar ? toolbar.fold(constant$1(0), function (tbar) {
          return tbar.components().length > 1 ? get$b(tbar.components()[1].element) : 0;
        }) : 0;
      };
      var calcMode = function (container) {
        switch (getToolbarLocation(editor)) {
        case ToolbarLocation.auto:
          var toolbar_1 = OuterContainer.getToolbar(outerContainer);
          var offset = calcToolbarOffset(toolbar_1);
          var toolbarHeight = get$b(container.element) - offset;
          var targetBounds = box$1(targetElm);
          var roomAtTop = targetBounds.y > toolbarHeight;
          if (roomAtTop) {
            return 'top';
          } else {
            var doc = documentElement(targetElm);
            var docHeight = Math.max(doc.dom.scrollHeight, get$b(doc));
            var roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;
            if (roomAtBottom) {
              return 'bottom';
            } else {
              var winBounds = win();
              var isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;
              return isRoomAtBottomViewport ? 'bottom' : 'top';
            }
          }
        case ToolbarLocation.bottom:
          return 'bottom';
        case ToolbarLocation.top:
        default:
          return 'top';
        }
      };
      var setupMode = function (mode) {
        var container = floatContainer.get();
        Docking.setModes(container, [mode]);
        headerBackstage.setDockingMode(mode);
        var verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;
        set$8(container.element, Attribute, verticalDir);
      };
      var updateChromeWidth = function () {
        var maxWidth = editorMaxWidthOpt.getOrThunk(function () {
          var bodyMargin = parseToInt(get$c(body(), 'margin-left')).getOr(0);
          return get$a(body()) - absolute$3(targetElm).left + bodyMargin;
        });
        set$7(floatContainer.get().element, 'max-width', maxWidth + 'px');
      };
      var updateChromePosition = function () {
        var toolbar = OuterContainer.getToolbar(outerContainer);
        var offset = calcToolbarOffset(toolbar);
        var targetBounds = box$1(targetElm);
        var top = isPositionedAtTop() ? Math.max(targetBounds.y - get$b(floatContainer.get().element) + offset, 0) : targetBounds.bottom;
        setAll(outerContainer.element, {
          position: 'absolute',
          top: Math.round(top) + 'px',
          left: Math.round(targetBounds.x) + 'px'
        });
      };
      var repositionPopups$1 = function () {
        uiMothership.broadcastOn([repositionPopups()], {});
      };
      var updateChromeUi = function (resetDocking) {
        if (resetDocking === void 0) {
          resetDocking = false;
        }
        if (!isVisible()) {
          return;
        }
        if (!useFixedToolbarContainer) {
          updateChromeWidth();
        }
        if (isSplitToolbar) {
          OuterContainer.refreshToolbar(outerContainer);
        }
        if (!useFixedToolbarContainer) {
          updateChromePosition();
        }
        if (isSticky) {
          var floatContainerComp = floatContainer.get();
          resetDocking ? Docking.reset(floatContainerComp) : Docking.refresh(floatContainerComp);
        }
        repositionPopups$1();
      };
      var updateMode = function (updateUi) {
        if (updateUi === void 0) {
          updateUi = true;
        }
        if (useFixedToolbarContainer || !isSticky || !isVisible()) {
          return;
        }
        var currentMode = headerBackstage.getDockingMode();
        var newMode = calcMode(floatContainer.get());
        if (newMode !== currentMode) {
          setupMode(newMode);
          if (updateUi) {
            updateChromeUi(true);
          }
        }
      };
      var show = function () {
        visible.set(true);
        set$7(outerContainer.element, 'display', 'flex');
        DOM.addClass(editor.getBody(), 'mce-edit-focus');
        remove$6(uiMothership.element, 'display');
        updateMode(false);
        updateChromeUi();
      };
      var hide = function () {
        visible.set(false);
        if (uiComponents.outerContainer) {
          set$7(outerContainer.element, 'display', 'none');
          DOM.removeClass(editor.getBody(), 'mce-edit-focus');
        }
        set$7(uiMothership.element, 'display', 'none');
      };
      return {
        isVisible: isVisible,
        isPositionedAtTop: isPositionedAtTop,
        show: show,
        hide: hide,
        update: updateChromeUi,
        updateMode: updateMode,
        repositionPopups: repositionPopups$1
      };
    };

    var getTargetPosAndBounds = function (targetElm, isToolbarTop) {
      var bounds = box$1(targetElm);
      return {
        pos: isToolbarTop ? bounds.y : bounds.bottom,
        bounds: bounds
      };
    };
    var setupEvents = function (editor, targetElm, ui, toolbarPersist) {
      var prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
      var resizeContent = function (e) {
        var _a = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()), pos = _a.pos, bounds = _a.bounds;
        var _b = prevPosAndBounds.get(), prevPos = _b.pos, prevBounds = _b.bounds;
        var hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;
        prevPosAndBounds.set({
          pos: pos,
          bounds: bounds
        });
        if (hasResized) {
          fireResizeContent(editor, e);
        }
        if (ui.isVisible()) {
          if (prevPos !== pos) {
            ui.update(true);
          } else if (hasResized) {
            ui.updateMode();
            ui.repositionPopups();
          }
        }
      };
      if (!toolbarPersist) {
        editor.on('activate', ui.show);
        editor.on('deactivate', ui.hide);
      }
      editor.on('SkinLoaded ResizeWindow', function () {
        return ui.update(true);
      });
      editor.on('NodeChange keydown', function (e) {
        global$f.requestAnimationFrame(function () {
          return resizeContent(e);
        });
      });
      editor.on('ScrollWindow', function () {
        return ui.updateMode();
      });
      var elementLoad = unbindable();
      elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', resizeContent));
      editor.on('remove', function () {
        elementLoad.clear();
      });
    };
    var render = function (editor, uiComponents, rawUiConfig, backstage, args) {
      var mothership = uiComponents.mothership, uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;
      var floatContainer = Cell(null);
      var targetElm = SugarElement.fromDom(args.targetNode);
      var ui = InlineHeader(editor, targetElm, uiComponents, backstage, floatContainer);
      var toolbarPersist = isToolbarPersist(editor);
      inline(editor);
      var render = function () {
        if (floatContainer.get()) {
          ui.show();
          return;
        }
        floatContainer.set(OuterContainer.getHeader(outerContainer).getOrDie());
        var uiContainer = getUiContainer(editor);
        attachSystem(uiContainer, mothership);
        attachSystem(uiContainer, uiMothership);
        setToolbar(editor, uiComponents, rawUiConfig, backstage);
        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
        ui.show();
        setupEvents(editor, targetElm, ui, toolbarPersist);
        editor.nodeChanged();
      };
      var delayedRender = function () {
        return global$f.setEditorTimeout(editor, render, 0);
      };
      editor.on('show', render);
      editor.on('hide', ui.hide);
      if (!toolbarPersist) {
        editor.on('focus', delayedRender);
        editor.on('blur', ui.hide);
      }
      editor.on('init', function () {
        if (editor.hasFocus() || toolbarPersist) {
          delayedRender();
        }
      });
      setupReadonlyModeSwitch(editor, uiComponents);
      var api = {
        show: function () {
          ui.show();
        },
        hide: function () {
          ui.hide();
        },
        enable: function () {
          broadcastReadonly(uiComponents, false);
        },
        disable: function () {
          broadcastReadonly(uiComponents, true);
        },
        isDisabled: function () {
          return Disabling.isDisabled(outerContainer);
        }
      };
      return {
        editorContainer: outerContainer.element.dom,
        api: api
      };
    };

    var Inline = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render
    });

    var showContextToolbarEvent = 'contexttoolbar-show';
    var hideContextToolbarEvent = 'contexttoolbar-hide';

    var getFormApi = function (input) {
      return {
        hide: function () {
          return emit(input, sandboxClose());
        },
        getValue: function () {
          return Representing.getValue(input);
        }
      };
    };
    var runOnExecute = function (memInput, original) {
      return run$1(internalToolbarButtonExecute, function (comp, se) {
        var input = memInput.get(comp);
        var formApi = getFormApi(input);
        original.onAction(formApi, se.event.buttonApi);
      });
    };
    var renderContextButton = function (memInput, button, extras) {
      var _a = button.original; _a.primary; var rest = __rest(_a, ['primary']);
      var bridged = getOrDie(createToolbarButton(__assign(__assign({}, rest), {
        type: 'button',
        onAction: noop
      })));
      return renderToolbarButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute(memInput, button)]);
    };
    var renderContextToggleButton = function (memInput, button, extras) {
      var _a = button.original; _a.primary; var rest = __rest(_a, ['primary']);
      var bridged = getOrDie(createToggleButton(__assign(__assign({}, rest), {
        type: 'togglebutton',
        onAction: noop
      })));
      return renderToolbarToggleButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute(memInput, button)]);
    };
    var generateOne = function (memInput, button, providersBackstage) {
      var extras = { backstage: { shared: { providers: providersBackstage } } };
      if (button.type === 'contextformtogglebutton') {
        return renderContextToggleButton(memInput, button, extras);
      } else {
        return renderContextButton(memInput, button, extras);
      }
    };
    var generate = function (memInput, buttons, providersBackstage) {
      var mementos = map$2(buttons, function (button) {
        return record(generateOne(memInput, button, providersBackstage));
      });
      var asSpecs = function () {
        return map$2(mementos, function (mem) {
          return mem.asSpec();
        });
      };
      var findPrimary = function (compInSystem) {
        return findMap(buttons, function (button, i) {
          if (button.primary) {
            return Optional.from(mementos[i]).bind(function (mem) {
              return mem.getOpt(compInSystem);
            }).filter(not(Disabling.isDisabled));
          } else {
            return Optional.none();
          }
        });
      };
      return {
        asSpecs: asSpecs,
        findPrimary: findPrimary
      };
    };

    var buildInitGroups = function (ctx, providers) {
      var inputAttributes = ctx.label.fold(function () {
        return {};
      }, function (label) {
        return { 'aria-label': label };
      });
      var memInput = record(Input.sketch({
        inputClasses: [
          'tox-toolbar-textfield',
          'tox-toolbar-nav-js'
        ],
        data: ctx.initValue(),
        inputAttributes: inputAttributes,
        selectOnFocus: true,
        inputBehaviours: derive$1([Keying.config({
            mode: 'special',
            onEnter: function (input) {
              return commands.findPrimary(input).map(function (primary) {
                emitExecute(primary);
                return true;
              });
            },
            onLeft: function (comp, se) {
              se.cut();
              return Optional.none();
            },
            onRight: function (comp, se) {
              se.cut();
              return Optional.none();
            }
          })])
      }));
      var commands = generate(memInput, ctx.commands, providers);
      return [
        {
          title: Optional.none(),
          items: [memInput.asSpec()]
        },
        {
          title: Optional.none(),
          items: commands.asSpecs()
        }
      ];
    };
    var renderContextForm = function (toolbarType, ctx, providers) {
      return renderToolbar({
        type: toolbarType,
        uid: generate$6('context-toolbar'),
        initGroups: buildInitGroups(ctx, providers),
        onEscape: Optional.none,
        cyclicKeying: true,
        providers: providers
      });
    };
    var ContextForm = {
      renderContextForm: renderContextForm,
      buildInitGroups: buildInitGroups
    };

    var isVerticalOverlap = function (a, b, threshold) {
      if (threshold === void 0) {
        threshold = 0.01;
      }
      return b.bottom - a.y >= threshold && a.bottom - b.y >= threshold;
    };
    var getRangeRect = function (rng) {
      var rect = rng.getBoundingClientRect();
      if (rect.height <= 0 && rect.width <= 0) {
        var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;
        var elm = isText$1(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);
        return elm.filter(isElement$2).map(function (e) {
          return e.dom.getBoundingClientRect();
        }).getOr(rect);
      } else {
        return rect;
      }
    };
    var getSelectionBounds = function (editor) {
      var rng = editor.selection.getRng();
      var rect = getRangeRect(rng);
      if (editor.inline) {
        var scroll_1 = get$9();
        return bounds(scroll_1.left + rect.left, scroll_1.top + rect.top, rect.width, rect.height);
      } else {
        var bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));
        return bounds(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);
      }
    };
    var getAnchorElementBounds = function (editor, lastElement) {
      return lastElement.filter(inBody).map(absolute$2).getOrThunk(function () {
        return getSelectionBounds(editor);
      });
    };
    var getHorizontalBounds = function (contentAreaBox, viewportBounds, margin) {
      var x = Math.max(contentAreaBox.x + margin, viewportBounds.x);
      var right = Math.min(contentAreaBox.right - margin, viewportBounds.right);
      return {
        x: x,
        width: right - x
      };
    };
    var getVerticalBounds = function (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) {
      var container = SugarElement.fromDom(editor.getContainer());
      var header = descendant(container, '.tox-editor-header').getOr(container);
      var headerBox = box$1(header);
      var isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;
      var isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;
      if (editor.inline && isToolbarAbove) {
        return {
          y: Math.max(headerBox.bottom + margin, viewportBounds.y),
          bottom: viewportBounds.bottom
        };
      }
      if (editor.inline && !isToolbarAbove) {
        return {
          y: viewportBounds.y,
          bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
        };
      }
      var containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;
      if (isToolbarAbove) {
        return {
          y: Math.max(headerBox.bottom + margin, viewportBounds.y),
          bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)
        };
      }
      return {
        y: Math.max(containerBounds.y + margin, viewportBounds.y),
        bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
      };
    };
    var getContextToolbarBounds = function (editor, sharedBackstage, toolbarType, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      var viewportBounds = getBounds$3(window);
      var contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
      var toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
      var _a = getHorizontalBounds(contentAreaBox, viewportBounds, margin), x = _a.x, width = _a.width;
      if (editor.inline && !toolbarOrMenubarEnabled) {
        return bounds(x, viewportBounds.y, width, viewportBounds.height);
      } else {
        var isToolbarTop = sharedBackstage.header.isPositionedAtTop();
        var _b = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin), y = _b.y, bottom = _b.bottom;
        return bounds(x, y, width, bottom - y);
      }
    };

    var bubbleSize$1 = 12;
    var bubbleAlignments$1 = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ['tox-pop--align-left'],
      alignRight: ['tox-pop--align-right'],
      right: ['tox-pop--right'],
      left: ['tox-pop--left'],
      bottom: ['tox-pop--bottom'],
      top: ['tox-pop--top'],
      inset: ['tox-pop--inset']
    };
    var anchorOverrides = {
      maxHeightFunction: expandable$1(),
      maxWidthFunction: expandable()
    };
    var isEntireElementSelected = function (editor, elem) {
      var rng = editor.selection.getRng();
      var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);
    };
    var preservePosition = function (elem, position, f) {
      var currentPosition = getRaw(elem, 'position');
      set$7(elem, 'position', position);
      var result = f(elem);
      currentPosition.each(function (pos) {
        return set$7(elem, 'position', pos);
      });
      return result;
    };
    var shouldUseInsetLayouts = function (position) {
      return position === 'node';
    };
    var determineInsetLayout = function (editor, contextbar, elem, data, bounds) {
      var selectionBounds = getSelectionBounds(editor);
      var isSameAnchorElement = data.lastElement().exists(function (prev) {
        return eq(elem, prev);
      });
      if (isEntireElementSelected(editor, elem)) {
        return isSameAnchorElement ? preserve : north;
      } else if (isSameAnchorElement) {
        return preservePosition(contextbar, data.getMode(), function () {
          var isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar));
          return isOverlapping && !data.isReposition() ? flip$2 : preserve;
        });
      } else {
        var yBounds = data.getMode() === 'fixed' ? bounds.y + get$9().top : bounds.y;
        var contextbarHeight = get$b(contextbar) + bubbleSize$1;
        return yBounds + contextbarHeight <= selectionBounds.y ? north : south;
      }
    };
    var getAnchorSpec$2 = function (editor, mobile, data, position) {
      var smartInsetLayout = function (elem) {
        return function (anchor, element, bubbles, placee, bounds) {
          var layout = determineInsetLayout(editor, placee, elem, data, bounds);
          var newAnchor = __assign(__assign({}, anchor), {
            y: bounds.y,
            height: bounds.height
          });
          return __assign(__assign({}, layout(newAnchor, element, bubbles, placee, bounds)), { alwaysFit: true });
        };
      };
      var getInsetLayouts = function (elem) {
        return shouldUseInsetLayouts(position) ? [smartInsetLayout(elem)] : [];
      };
      var desktopAnchorSpecLayouts = {
        onLtr: function (elem) {
          return [
            north$2,
            south$2,
            northeast$2,
            southeast$2,
            northwest$2,
            southwest$2
          ].concat(getInsetLayouts(elem));
        },
        onRtl: function (elem) {
          return [
            north$2,
            south$2,
            northwest$2,
            southwest$2,
            northeast$2,
            southeast$2
          ].concat(getInsetLayouts(elem));
        }
      };
      var mobileAnchorSpecLayouts = {
        onLtr: function (elem) {
          return [
            south$2,
            southeast$2,
            southwest$2,
            northeast$2,
            northwest$2,
            north$2
          ].concat(getInsetLayouts(elem));
        },
        onRtl: function (elem) {
          return [
            south$2,
            southwest$2,
            southeast$2,
            northwest$2,
            northeast$2,
            north$2
          ].concat(getInsetLayouts(elem));
        }
      };
      return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;
    };
    var getAnchorLayout = function (editor, position, isTouch, data) {
      if (position === 'line') {
        return {
          bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),
          layouts: {
            onLtr: function () {
              return [east$2];
            },
            onRtl: function () {
              return [west$2];
            }
          },
          overrides: anchorOverrides
        };
      } else {
        return {
          bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),
          layouts: getAnchorSpec$2(editor, isTouch, data, position),
          overrides: anchorOverrides
        };
      }
    };

    var matchTargetWith = function (elem, candidates) {
      var ctxs = filter$2(candidates, function (toolbarApi) {
        return toolbarApi.predicate(elem.dom);
      });
      var _a = partition$3(ctxs, function (t) {
          return t.type === 'contexttoolbar';
        }), pass = _a.pass, fail = _a.fail;
      return {
        contextToolbars: pass,
        contextForms: fail
      };
    };
    var filterByPositionForStartNode = function (toolbars) {
      if (toolbars.length <= 1) {
        return toolbars;
      } else {
        var doesPositionExist = function (value) {
          return exists(toolbars, function (t) {
            return t.position === value;
          });
        };
        var filterToolbarsByPosition = function (value) {
          return filter$2(toolbars, function (t) {
            return t.position === value;
          });
        };
        var hasSelectionToolbars = doesPositionExist('selection');
        var hasNodeToolbars = doesPositionExist('node');
        if (hasSelectionToolbars || hasNodeToolbars) {
          if (hasNodeToolbars && hasSelectionToolbars) {
            var nodeToolbars = filterToolbarsByPosition('node');
            var selectionToolbars = map$2(filterToolbarsByPosition('selection'), function (t) {
              return __assign(__assign({}, t), { position: 'node' });
            });
            return nodeToolbars.concat(selectionToolbars);
          } else {
            return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');
          }
        } else {
          return filterToolbarsByPosition('line');
        }
      }
    };
    var filterByPositionForAncestorNode = function (toolbars) {
      if (toolbars.length <= 1) {
        return toolbars;
      } else {
        var findPosition_1 = function (value) {
          return find$5(toolbars, function (t) {
            return t.position === value;
          });
        };
        var basePosition = findPosition_1('selection').orThunk(function () {
          return findPosition_1('node');
        }).orThunk(function () {
          return findPosition_1('line');
        }).map(function (t) {
          return t.position;
        });
        return basePosition.fold(function () {
          return [];
        }, function (pos) {
          return filter$2(toolbars, function (t) {
            return t.position === pos;
          });
        });
      }
    };
    var matchStartNode = function (elem, nodeCandidates, editorCandidates) {
      var nodeMatches = matchTargetWith(elem, nodeCandidates);
      if (nodeMatches.contextForms.length > 0) {
        return Optional.some({
          elem: elem,
          toolbars: [nodeMatches.contextForms[0]]
        });
      } else {
        var editorMatches = matchTargetWith(elem, editorCandidates);
        if (editorMatches.contextForms.length > 0) {
          return Optional.some({
            elem: elem,
            toolbars: [editorMatches.contextForms[0]]
          });
        } else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {
          var toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
          return Optional.some({
            elem: elem,
            toolbars: toolbars
          });
        } else {
          return Optional.none();
        }
      }
    };
    var matchAncestor = function (isRoot, startNode, scopes) {
      if (isRoot(startNode)) {
        return Optional.none();
      } else {
        return ancestor$2(startNode, function (ancestorElem) {
          if (isElement$2(ancestorElem)) {
            var _a = matchTargetWith(ancestorElem, scopes.inNodeScope), contextToolbars = _a.contextToolbars, contextForms = _a.contextForms;
            var toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
            return toolbars.length > 0 ? Optional.some({
              elem: ancestorElem,
              toolbars: toolbars
            }) : Optional.none();
          } else {
            return Optional.none();
          }
        }, isRoot);
      }
    };
    var lookup$1 = function (scopes, editor) {
      var rootElem = SugarElement.fromDom(editor.getBody());
      var isRoot = function (elem) {
        return eq(elem, rootElem);
      };
      var isOutsideRoot = function (startNode) {
        return !isRoot(startNode) && !contains(rootElem, startNode);
      };
      var startNode = SugarElement.fromDom(editor.selection.getNode());
      if (isOutsideRoot(startNode)) {
        return Optional.none();
      }
      return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(function () {
        return matchAncestor(isRoot, startNode, scopes);
      });
    };

    var categorise = function (contextToolbars, navigate) {
      var forms = {};
      var inNodeScope = [];
      var inEditorScope = [];
      var formNavigators = {};
      var lookupTable = {};
      var registerForm = function (key, toolbarSpec) {
        var contextForm = getOrDie(createContextForm(toolbarSpec));
        forms[key] = contextForm;
        contextForm.launch.map(function (launch) {
          formNavigators['form:' + key + ''] = __assign(__assign({}, toolbarSpec.launch), {
            type: launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button',
            onAction: function () {
              navigate(contextForm);
            }
          });
        });
        if (contextForm.scope === 'editor') {
          inEditorScope.push(contextForm);
        } else {
          inNodeScope.push(contextForm);
        }
        lookupTable[key] = contextForm;
      };
      var registerToolbar = function (key, toolbarSpec) {
        createContextToolbar(toolbarSpec).each(function (contextToolbar) {
          if (toolbarSpec.scope === 'editor') {
            inEditorScope.push(contextToolbar);
          } else {
            inNodeScope.push(contextToolbar);
          }
          lookupTable[key] = contextToolbar;
        });
      };
      var keys$1 = keys(contextToolbars);
      each$1(keys$1, function (key) {
        var toolbarApi = contextToolbars[key];
        if (toolbarApi.type === 'contextform') {
          registerForm(key, toolbarApi);
        } else if (toolbarApi.type === 'contexttoolbar') {
          registerToolbar(key, toolbarApi);
        }
      });
      return {
        forms: forms,
        inNodeScope: inNodeScope,
        inEditorScope: inEditorScope,
        lookupTable: lookupTable,
        formNavigators: formNavigators
      };
    };

    var forwardSlideEvent = generate$6('forward-slide');
    var backSlideEvent = generate$6('backward-slide');
    var changeSlideEvent = generate$6('change-slide-event');
    var resizingClass = 'tox-pop--resizing';
    var renderContextToolbar = function (spec) {
      var stack = Cell([]);
      return InlineView.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-pop']
        },
        fireDismissalEventInstead: { event: 'doNotDismissYet' },
        onShow: function (comp) {
          stack.set([]);
          InlineView.getContent(comp).each(function (c) {
            remove$6(c.element, 'visibility');
          });
          remove$2(comp.element, resizingClass);
          remove$6(comp.element, 'width');
        },
        inlineBehaviours: derive$1([
          config('context-toolbar-events', [
            runOnSource(transitionend(), function (comp, se) {
              if (se.event.raw.propertyName === 'width') {
                remove$2(comp.element, resizingClass);
                remove$6(comp.element, 'width');
              }
            }),
            run$1(changeSlideEvent, function (comp, se) {
              var elem = comp.element;
              remove$6(elem, 'width');
              var currentWidth = get$a(elem);
              InlineView.setContent(comp, se.event.contents);
              add$2(elem, resizingClass);
              var newWidth = get$a(elem);
              set$7(elem, 'width', currentWidth + 'px');
              InlineView.getContent(comp).each(function (newContents) {
                se.event.focus.bind(function (f) {
                  focus$3(f);
                  return search(elem);
                }).orThunk(function () {
                  Keying.focusIn(newContents);
                  return active(getRootNode(elem));
                });
              });
              global$f.setTimeout(function () {
                set$7(comp.element, 'width', newWidth + 'px');
              }, 0);
            }),
            run$1(forwardSlideEvent, function (comp, se) {
              InlineView.getContent(comp).each(function (oldContents) {
                stack.set(stack.get().concat([{
                    bar: oldContents,
                    focus: active(getRootNode(comp.element))
                  }]));
              });
              emitWith(comp, changeSlideEvent, {
                contents: se.event.forwardContents,
                focus: Optional.none()
              });
            }),
            run$1(backSlideEvent, function (comp, _se) {
              last$2(stack.get()).each(function (last) {
                stack.set(stack.get().slice(0, stack.get().length - 1));
                emitWith(comp, changeSlideEvent, {
                  contents: premade(last.bar),
                  focus: last.focus
                });
              });
            })
          ]),
          Keying.config({
            mode: 'special',
            onEscape: function (comp) {
              return last$2(stack.get()).fold(function () {
                return spec.onEscape();
              }, function (_) {
                emit(comp, backSlideEvent);
                return Optional.some(true);
              });
            }
          })
        ]),
        lazySink: function () {
          return Result.value(spec.sink);
        }
      });
    };

    var transitionClass = 'tox-pop--transition';
    var register$7 = function (editor, registryContextToolbars, sink, extras) {
      var backstage = extras.backstage;
      var sharedBackstage = backstage.shared;
      var isTouch = detect$1().deviceType.isTouch;
      var lastElement = value$1();
      var lastTrigger = value$1();
      var lastContextPosition = value$1();
      var contextbar = build$1(renderContextToolbar({
        sink: sink,
        onEscape: function () {
          editor.focus();
          return Optional.some(true);
        }
      }));
      var getBounds = function () {
        var position = lastContextPosition.get().getOr('node');
        var margin = shouldUseInsetLayouts(position) ? 1 : 0;
        return getContextToolbarBounds(editor, sharedBackstage, position, margin);
      };
      var canLaunchToolbar = function () {
        return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());
      };
      var isSameLaunchElement = function (elem) {
        return is$1(lift2(elem, lastElement.get(), eq), true);
      };
      var shouldContextToolbarHide = function () {
        if (!canLaunchToolbar()) {
          return true;
        } else {
          var contextToolbarBounds = getBounds();
          var anchorBounds = is$1(lastContextPosition.get(), 'node') ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);
          return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds);
        }
      };
      var close = function () {
        lastElement.clear();
        lastTrigger.clear();
        lastContextPosition.clear();
        InlineView.hide(contextbar);
      };
      var hideOrRepositionIfNecessary = function () {
        if (InlineView.isOpen(contextbar)) {
          var contextBarEle = contextbar.element;
          remove$6(contextBarEle, 'display');
          if (shouldContextToolbarHide()) {
            set$7(contextBarEle, 'display', 'none');
          } else {
            lastTrigger.set(0);
            InlineView.reposition(contextbar);
          }
        }
      };
      var wrapInPopDialog = function (toolbarSpec) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-pop__dialog']
          },
          components: [toolbarSpec],
          behaviours: derive$1([
            Keying.config({ mode: 'acyclic' }),
            config('pop-dialog-wrap-events', [
              runOnAttached(function (comp) {
                editor.shortcuts.add('ctrl+F9', 'focus statusbar', function () {
                  return Keying.focusIn(comp);
                });
              }),
              runOnDetached(function (_comp) {
                editor.shortcuts.remove('ctrl+F9');
              })
            ])
          ])
        };
      };
      var getScopes = cached(function () {
        return categorise(registryContextToolbars, function (toolbarApi) {
          var alloySpec = buildToolbar([toolbarApi]);
          emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(alloySpec) });
        });
      });
      var buildContextToolbarGroups = function (allButtons, ctx) {
        return identifyButtons(editor, {
          buttons: allButtons,
          toolbar: ctx.items,
          allowToolbarGroups: false
        }, extras, Optional.some(['form:']));
      };
      var buildContextFormGroups = function (ctx, providers) {
        return ContextForm.buildInitGroups(ctx, providers);
      };
      var buildToolbar = function (toolbars) {
        var buttons = editor.ui.registry.getAll().buttons;
        var scopes = getScopes();
        var allButtons = __assign(__assign({}, buttons), scopes.formNavigators);
        var toolbarType = getToolbarMode(editor) === ToolbarMode.scrolling ? ToolbarMode.scrolling : ToolbarMode.default;
        var initGroups = flatten(map$2(toolbars, function (ctx) {
          return ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers);
        }));
        return renderToolbar({
          type: toolbarType,
          uid: generate$6('context-toolbar'),
          initGroups: initGroups,
          onEscape: Optional.none,
          cyclicKeying: true,
          providers: sharedBackstage.providers
        });
      };
      var getAnchor = function (position, element) {
        var anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();
        var anchorLayout = getAnchorLayout(editor, position, isTouch(), {
          lastElement: lastElement.get,
          isReposition: function () {
            return is$1(lastTrigger.get(), 0);
          },
          getMode: function () {
            return Positioning.getMode(sink);
          }
        });
        return deepMerge(anchorage, anchorLayout);
      };
      var launchContext = function (toolbarApi, elem) {
        launchContextToolbar.cancel();
        if (!canLaunchToolbar()) {
          return;
        }
        var toolbarSpec = buildToolbar(toolbarApi);
        var position = toolbarApi[0].position;
        var anchor = getAnchor(position, elem);
        lastContextPosition.set(position);
        lastTrigger.set(1);
        var contextBarEle = contextbar.element;
        remove$6(contextBarEle, 'display');
        if (!isSameLaunchElement(elem)) {
          remove$2(contextBarEle, transitionClass);
          Positioning.reset(sink, contextbar);
        }
        InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {
          anchor: anchor,
          transition: {
            classes: [transitionClass],
            mode: 'placement'
          }
        }, function () {
          return Optional.some(getBounds());
        });
        elem.fold(lastElement.clear, lastElement.set);
        if (shouldContextToolbarHide()) {
          set$7(contextBarEle, 'display', 'none');
        }
      };
      var launchContextToolbar = last(function () {
        if (!editor.hasFocus() || editor.removed) {
          return;
        }
        if (has(contextbar.element, transitionClass)) {
          launchContextToolbar.throttle();
        } else {
          var scopes = getScopes();
          lookup$1(scopes, editor).fold(close, function (info) {
            launchContext(info.toolbars, Optional.some(info.elem));
          });
        }
      }, 17);
      editor.on('init', function () {
        editor.on('remove', close);
        editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);
        editor.on('click keyup focus SetContent', launchContextToolbar.throttle);
        editor.on(hideContextToolbarEvent, close);
        editor.on(showContextToolbarEvent, function (e) {
          var scopes = getScopes();
          get$e(scopes.lookupTable, e.toolbarKey).each(function (ctx) {
            launchContext([ctx], someIf(e.target !== editor, e.target));
            InlineView.getContent(contextbar).each(Keying.focusIn);
          });
        });
        editor.on('focusout', function (_e) {
          global$f.setEditorTimeout(editor, function () {
            if (search(sink.element).isNone() && search(contextbar.element).isNone()) {
              close();
            }
          }, 0);
        });
        editor.on('SwitchMode', function () {
          if (editor.mode.isReadOnly()) {
            close();
          }
        });
        editor.on('AfterProgressState', function (event) {
          if (event.state) {
            close();
          } else if (editor.hasFocus()) {
            launchContextToolbar.throttle();
          }
        });
        editor.on('NodeChange', function (_e) {
          search(contextbar.element).fold(launchContextToolbar.throttle, noop);
        });
      });
    };

    var register$6 = function (editor) {
      var alignToolbarButtons = [
        {
          name: 'alignleft',
          text: 'Align left',
          cmd: 'JustifyLeft',
          icon: 'align-left'
        },
        {
          name: 'aligncenter',
          text: 'Align center',
          cmd: 'JustifyCenter',
          icon: 'align-center'
        },
        {
          name: 'alignright',
          text: 'Align right',
          cmd: 'JustifyRight',
          icon: 'align-right'
        },
        {
          name: 'alignjustify',
          text: 'Justify',
          cmd: 'JustifyFull',
          icon: 'align-justify'
        }
      ];
      each$1(alignToolbarButtons, function (item) {
        editor.ui.registry.addToggleButton(item.name, {
          tooltip: item.text,
          icon: item.icon,
          onAction: onActionExecCommand(editor, item.cmd),
          onSetup: onSetupFormatToggle(editor, item.name)
        });
      });
      editor.ui.registry.addButton('alignnone', {
        tooltip: 'No alignment',
        icon: 'align-none',
        onAction: onActionExecCommand(editor, 'JustifyNone')
      });
    };

    var units = {
      unsupportedLength: [
        'em',
        'ex',
        'cap',
        'ch',
        'ic',
        'rem',
        'lh',
        'rlh',
        'vw',
        'vh',
        'vi',
        'vb',
        'vmin',
        'vmax',
        'cm',
        'mm',
        'Q',
        'in',
        'pc',
        'pt',
        'px'
      ],
      fixed: [
        'px',
        'pt'
      ],
      relative: ['%'],
      empty: ['']
    };
    var pattern = function () {
      var decimalDigits = '[0-9]+';
      var signedInteger = '[+-]?' + decimalDigits;
      var exponentPart = '[eE]' + signedInteger;
      var dot = '\\.';
      var opt = function (input) {
        return '(?:' + input + ')?';
      };
      var unsignedDecimalLiteral = [
        'Infinity',
        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
        dot + decimalDigits + opt(exponentPart),
        decimalDigits + opt(exponentPart)
      ].join('|');
      var float = '[+-]?(?:' + unsignedDecimalLiteral + ')';
      return new RegExp('^(' + float + ')(.*)$');
    }();
    var isUnit = function (unit, accepted) {
      return exists(accepted, function (acc) {
        return exists(units[acc], function (check) {
          return unit === check;
        });
      });
    };
    var parse = function (input, accepted) {
      var match = Optional.from(pattern.exec(input));
      return match.bind(function (array) {
        var value = Number(array[1]);
        var unitRaw = array[2];
        if (isUnit(unitRaw, accepted)) {
          return Optional.some({
            value: value,
            unit: unitRaw
          });
        } else {
          return Optional.none();
        }
      });
    };
    var normalise = function (input, accepted) {
      return parse(input, accepted).map(function (_a) {
        var value = _a.value, unit = _a.unit;
        return value + unit;
      });
    };

    var registerController = function (editor, spec) {
      var getMenuItems = function () {
        var options = spec.getOptions(editor);
        var initial = spec.getCurrent(editor).map(spec.hash);
        var current = value$1();
        return map$2(options, function (value) {
          return {
            type: 'togglemenuitem',
            text: spec.display(value),
            onSetup: function (api) {
              var setActive = function (active) {
                if (active) {
                  current.on(function (oldApi) {
                    return oldApi.setActive(false);
                  });
                  current.set(api);
                }
                api.setActive(active);
              };
              setActive(is$1(initial, spec.hash(value)));
              var unbindWatcher = spec.watcher(editor, value, setActive);
              return function () {
                current.clear();
                unbindWatcher();
              };
            },
            onAction: function () {
              return spec.setCurrent(editor, value);
            }
          };
        });
      };
      editor.ui.registry.addMenuButton(spec.name, {
        tooltip: spec.text,
        icon: spec.icon,
        fetch: function (callback) {
          return callback(getMenuItems());
        },
        onSetup: spec.onToolbarSetup
      });
      editor.ui.registry.addNestedMenuItem(spec.name, {
        type: 'nestedmenuitem',
        text: spec.text,
        getSubmenuItems: getMenuItems,
        onSetup: spec.onMenuSetup
      });
    };
    var lineHeightSpec = {
      name: 'lineheight',
      text: 'Line height',
      icon: 'line-height',
      getOptions: getLineHeightFormats,
      hash: function (input) {
        return normalise(input, [
          'fixed',
          'relative',
          'empty'
        ]).getOr(input);
      },
      display: identity$1,
      watcher: function (editor, value, callback) {
        return editor.formatter.formatChanged('lineheight', callback, false, { value: value }).unbind;
      },
      getCurrent: function (editor) {
        return Optional.from(editor.queryCommandValue('LineHeight'));
      },
      setCurrent: function (editor, value) {
        return editor.execCommand('LineHeight', false, value);
      }
    };
    var languageSpec = function (editor) {
      var settingsOpt = Optional.from(getContentLanguages(editor));
      return settingsOpt.map(function (settings) {
        return {
          name: 'language',
          text: 'Language',
          icon: 'language',
          getOptions: constant$1(settings),
          hash: function (input) {
            return isUndefined(input.customCode) ? input.code : input.code + '/' + input.customCode;
          },
          display: function (input) {
            return input.title;
          },
          watcher: function (editor, value, callback) {
            return editor.formatter.formatChanged('lang', callback, false, {
              value: value.code,
              customValue: value.customCode
            }).unbind;
          },
          getCurrent: function (editor) {
            var node = SugarElement.fromDom(editor.selection.getNode());
            return closest$4(node, function (n) {
              return Optional.some(n).filter(isElement$2).bind(function (ele) {
                var codeOpt = getOpt(ele, 'lang');
                return codeOpt.map(function (code) {
                  var customCode = getOpt(ele, 'data-mce-lang').getOrUndefined();
                  return {
                    code: code,
                    customCode: customCode,
                    title: ''
                  };
                });
              });
            });
          },
          setCurrent: function (editor, lang) {
            return editor.execCommand('Lang', false, lang);
          },
          onToolbarSetup: function (api) {
            var unbinder = unbindable();
            api.setActive(editor.formatter.match('lang', {}, undefined, true));
            unbinder.set(editor.formatter.formatChanged('lang', api.setActive, true));
            return unbinder.clear;
          }
        };
      });
    };
    var register$5 = function (editor) {
      registerController(editor, lineHeightSpec);
      languageSpec(editor).each(function (spec) {
        return registerController(editor, spec);
      });
    };

    var register$4 = function (editor, backstage) {
      alignSelectMenu(editor, backstage);
      fontSelectMenu(editor, backstage);
      styleSelectMenu(editor, backstage);
      formatSelectMenu(editor, backstage);
      fontsizeSelectMenu(editor, backstage);
    };

    var onSetupOutdentState = function (editor) {
      return onSetupEvent(editor, 'NodeChange', function (api) {
        api.setDisabled(!editor.queryCommandState('outdent'));
      });
    };
    var registerButtons$2 = function (editor) {
      editor.ui.registry.addButton('outdent', {
        tooltip: 'Decrease indent',
        icon: 'outdent',
        onSetup: onSetupOutdentState(editor),
        onAction: onActionExecCommand(editor, 'outdent')
      });
      editor.ui.registry.addButton('indent', {
        tooltip: 'Increase indent',
        icon: 'indent',
        onAction: onActionExecCommand(editor, 'indent')
      });
    };
    var register$3 = function (editor) {
      registerButtons$2(editor);
    };

    var onActionToggleFormat = function (editor, fmt) {
      return function () {
        editor.execCommand('mceToggleFormat', false, fmt);
      };
    };
    var registerFormatButtons = function (editor) {
      global$5.each([
        {
          name: 'bold',
          text: 'Bold',
          icon: 'bold'
        },
        {
          name: 'italic',
          text: 'Italic',
          icon: 'italic'
        },
        {
          name: 'underline',
          text: 'Underline',
          icon: 'underline'
        },
        {
          name: 'strikethrough',
          text: 'Strikethrough',
          icon: 'strike-through'
        },
        {
          name: 'subscript',
          text: 'Subscript',
          icon: 'subscript'
        },
        {
          name: 'superscript',
          text: 'Superscript',
          icon: 'superscript'
        }
      ], function (btn, _idx) {
        editor.ui.registry.addToggleButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onSetup: onSetupFormatToggle(editor, btn.name),
          onAction: onActionToggleFormat(editor, btn.name)
        });
      });
      for (var i = 1; i <= 6; i++) {
        var name_1 = 'h' + i;
        editor.ui.registry.addToggleButton(name_1, {
          text: name_1.toUpperCase(),
          tooltip: 'Heading ' + i,
          onSetup: onSetupFormatToggle(editor, name_1),
          onAction: onActionToggleFormat(editor, name_1)
        });
      }
    };
    var registerCommandButtons = function (editor) {
      global$5.each([
        {
          name: 'cut',
          text: 'Cut',
          action: 'Cut',
          icon: 'cut'
        },
        {
          name: 'copy',
          text: 'Copy',
          action: 'Copy',
          icon: 'copy'
        },
        {
          name: 'paste',
          text: 'Paste',
          action: 'Paste',
          icon: 'paste'
        },
        {
          name: 'help',
          text: 'Help',
          action: 'mceHelp',
          icon: 'help'
        },
        {
          name: 'selectall',
          text: 'Select all',
          action: 'SelectAll',
          icon: 'select-all'
        },
        {
          name: 'newdocument',
          text: 'New document',
          action: 'mceNewDocument',
          icon: 'new-document'
        },
        {
          name: 'removeformat',
          text: 'Clear formatting',
          action: 'RemoveFormat',
          icon: 'remove-formatting'
        },
        {
          name: 'remove',
          text: 'Remove',
          action: 'Delete',
          icon: 'remove'
        }
      ], function (btn) {
        editor.ui.registry.addButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onAction: onActionExecCommand(editor, btn.action)
        });
      });
    };
    var registerCommandToggleButtons = function (editor) {
      global$5.each([{
          name: 'blockquote',
          text: 'Blockquote',
          action: 'mceBlockQuote',
          icon: 'quote'
        }], function (btn) {
        editor.ui.registry.addToggleButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onAction: onActionExecCommand(editor, btn.action),
          onSetup: onSetupFormatToggle(editor, btn.name)
        });
      });
    };
    var registerButtons$1 = function (editor) {
      registerFormatButtons(editor);
      registerCommandButtons(editor);
      registerCommandToggleButtons(editor);
    };
    var registerMenuItems$2 = function (editor) {
      global$5.each([
        {
          name: 'bold',
          text: 'Bold',
          action: 'Bold',
          icon: 'bold',
          shortcut: 'Meta+B'
        },
        {
          name: 'italic',
          text: 'Italic',
          action: 'Italic',
          icon: 'italic',
          shortcut: 'Meta+I'
        },
        {
          name: 'underline',
          text: 'Underline',
          action: 'Underline',
          icon: 'underline',
          shortcut: 'Meta+U'
        },
        {
          name: 'strikethrough',
          text: 'Strikethrough',
          action: 'Strikethrough',
          icon: 'strike-through',
          shortcut: ''
        },
        {
          name: 'subscript',
          text: 'Subscript',
          action: 'Subscript',
          icon: 'subscript',
          shortcut: ''
        },
        {
          name: 'superscript',
          text: 'Superscript',
          action: 'Superscript',
          icon: 'superscript',
          shortcut: ''
        },
        {
          name: 'removeformat',
          text: 'Clear formatting',
          action: 'RemoveFormat',
          icon: 'remove-formatting',
          shortcut: ''
        },
        {
          name: 'newdocument',
          text: 'New document',
          action: 'mceNewDocument',
          icon: 'new-document',
          shortcut: ''
        },
        {
          name: 'cut',
          text: 'Cut',
          action: 'Cut',
          icon: 'cut',
          shortcut: 'Meta+X'
        },
        {
          name: 'copy',
          text: 'Copy',
          action: 'Copy',
          icon: 'copy',
          shortcut: 'Meta+C'
        },
        {
          name: 'paste',
          text: 'Paste',
          action: 'Paste',
          icon: 'paste',
          shortcut: 'Meta+V'
        },
        {
          name: 'selectall',
          text: 'Select all',
          action: 'SelectAll',
          icon: 'select-all',
          shortcut: 'Meta+A'
        }
      ], function (btn) {
        editor.ui.registry.addMenuItem(btn.name, {
          text: btn.text,
          icon: btn.icon,
          shortcut: btn.shortcut,
          onAction: onActionExecCommand(editor, btn.action)
        });
      });
      editor.ui.registry.addMenuItem('codeformat', {
        text: 'Code',
        icon: 'sourcecode',
        onAction: onActionToggleFormat(editor, 'code')
      });
    };
    var register$2 = function (editor) {
      registerButtons$1(editor);
      registerMenuItems$2(editor);
    };

    var onSetupUndoRedoState = function (editor, type) {
      return onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', function (api) {
        api.setDisabled(editor.mode.isReadOnly() || !editor.undoManager[type]());
      });
    };
    var registerMenuItems$1 = function (editor) {
      editor.ui.registry.addMenuItem('undo', {
        text: 'Undo',
        icon: 'undo',
        shortcut: 'Meta+Z',
        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
        onAction: onActionExecCommand(editor, 'undo')
      });
      editor.ui.registry.addMenuItem('redo', {
        text: 'Redo',
        icon: 'redo',
        shortcut: 'Meta+Y',
        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
        onAction: onActionExecCommand(editor, 'redo')
      });
    };
    var registerButtons = function (editor) {
      editor.ui.registry.addButton('undo', {
        tooltip: 'Undo',
        icon: 'undo',
        disabled: true,
        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),
        onAction: onActionExecCommand(editor, 'undo')
      });
      editor.ui.registry.addButton('redo', {
        tooltip: 'Redo',
        icon: 'redo',
        disabled: true,
        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),
        onAction: onActionExecCommand(editor, 'redo')
      });
    };
    var register$1 = function (editor) {
      registerMenuItems$1(editor);
      registerButtons(editor);
    };

    var onSetupVisualAidState = function (editor) {
      return onSetupEvent(editor, 'VisualAid', function (api) {
        api.setActive(editor.hasVisual);
      });
    };
    var registerMenuItems = function (editor) {
      editor.ui.registry.addToggleMenuItem('visualaid', {
        text: 'Visual aids',
        onSetup: onSetupVisualAidState(editor),
        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')
      });
    };
    var registerToolbarButton = function (editor) {
      editor.ui.registry.addButton('visualaid', {
        tooltip: 'Visual aids',
        text: 'Visual aids',
        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')
      });
    };
    var register = function (editor) {
      registerToolbarButton(editor);
      registerMenuItems(editor);
    };

    var setup$6 = function (editor, backstage) {
      register$6(editor);
      register$2(editor);
      register$4(editor, backstage);
      register$1(editor);
      register$a(editor);
      register(editor);
      register$3(editor);
      register$5(editor);
    };

    var nu = function (x, y) {
      return {
        type: 'makeshift',
        x: x,
        y: y
      };
    };
    var transpose = function (pos, dx, dy) {
      return nu(pos.x + dx, pos.y + dy);
    };
    var isTouchEvent = function (e) {
      return e.type === 'longpress' || e.type.indexOf('touch') === 0;
    };
    var fromPageXY = function (e) {
      if (isTouchEvent(e)) {
        var touch = e.touches[0];
        return nu(touch.pageX, touch.pageY);
      } else {
        return nu(e.pageX, e.pageY);
      }
    };
    var fromClientXY = function (e) {
      if (isTouchEvent(e)) {
        var touch = e.touches[0];
        return nu(touch.clientX, touch.clientY);
      } else {
        return nu(e.clientX, e.clientY);
      }
    };
    var transposeContentAreaContainer = function (element, pos) {
      var containerPos = global$b.DOM.getPos(element);
      return transpose(pos, containerPos.x, containerPos.y);
    };
    var getPointAnchor = function (editor, e) {
      if (e.type === 'contextmenu' || e.type === 'longpress') {
        if (editor.inline) {
          return fromPageXY(e);
        } else {
          return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
        }
      } else {
        return getSelectionAnchor(editor);
      }
    };
    var getSelectionAnchor = function (editor) {
      return {
        type: 'selection',
        root: SugarElement.fromDom(editor.selection.getNode())
      };
    };
    var getNodeAnchor = function (editor) {
      return {
        type: 'node',
        node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),
        root: SugarElement.fromDom(editor.getBody())
      };
    };
    var getAnchorSpec$1 = function (editor, e, anchorType) {
      switch (anchorType) {
      case 'node':
        return getNodeAnchor(editor);
      case 'point':
        return getPointAnchor(editor, e);
      case 'selection':
        return getSelectionAnchor(editor);
      }
    };

    var initAndShow$1 = function (editor, e, buildMenu, backstage, contextmenu, anchorType) {
      var items = buildMenu();
      var anchorSpec = getAnchorSpec$1(editor, e, anchorType);
      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false).map(function (menuData) {
        e.preventDefault();
        InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {
          menu: { markers: markers('normal') },
          data: menuData
        });
      });
    };

    var layouts = {
      onLtr: function () {
        return [
          south$2,
          southeast$2,
          southwest$2,
          northeast$2,
          northwest$2,
          north$2,
          north,
          south,
          northeast,
          southeast,
          northwest,
          southwest
        ];
      },
      onRtl: function () {
        return [
          south$2,
          southwest$2,
          southeast$2,
          northwest$2,
          northeast$2,
          north$2,
          north,
          south,
          northwest,
          southwest,
          northeast,
          southeast
        ];
      }
    };
    var bubbleSize = 12;
    var bubbleAlignments = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ['tox-pop--align-left'],
      alignRight: ['tox-pop--align-right'],
      right: ['tox-pop--right'],
      left: ['tox-pop--left'],
      bottom: ['tox-pop--bottom'],
      top: ['tox-pop--top']
    };
    var isTouchWithinSelection = function (editor, e) {
      var selection = editor.selection;
      if (selection.isCollapsed() || e.touches.length < 1) {
        return false;
      } else {
        var touch_1 = e.touches[0];
        var rng = selection.getRng();
        var rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));
        return rngRectOpt.exists(function (rngRect) {
          return rngRect.left <= touch_1.clientX && rngRect.right >= touch_1.clientX && rngRect.top <= touch_1.clientY && rngRect.bottom >= touch_1.clientY;
        });
      }
    };
    var setupiOSOverrides = function (editor) {
      var originalSelection = editor.selection.getRng();
      var selectionReset = function () {
        global$f.setEditorTimeout(editor, function () {
          editor.selection.setRng(originalSelection);
        }, 10);
        unbindEventListeners();
      };
      editor.once('touchend', selectionReset);
      var preventMousedown = function (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      editor.on('mousedown', preventMousedown, true);
      var clearSelectionReset = function () {
        return unbindEventListeners();
      };
      editor.once('longpresscancel', clearSelectionReset);
      var unbindEventListeners = function () {
        editor.off('touchend', selectionReset);
        editor.off('longpresscancel', clearSelectionReset);
        editor.off('mousedown', preventMousedown);
      };
    };
    var getAnchorSpec = function (editor, e, anchorType) {
      var anchorSpec = getAnchorSpec$1(editor, e, anchorType);
      var bubbleYOffset = anchorType === 'point' ? bubbleSize : 0;
      return __assign({
        bubble: nu$5(0, bubbleYOffset, bubbleAlignments),
        layouts: layouts,
        overrides: {
          maxWidthFunction: expandable(),
          maxHeightFunction: expandable$1()
        }
      }, anchorSpec);
    };
    var show = function (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) {
      var anchorSpec = getAnchorSpec(editor, e, anchorType);
      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, true).map(function (menuData) {
        e.preventDefault();
        InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {
          menu: {
            markers: markers('normal'),
            highlightImmediately: highlightImmediately
          },
          data: menuData,
          type: 'horizontal'
        }, function () {
          return Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection'));
        });
        editor.fire(hideContextToolbarEvent);
      });
    };
    var initAndShow = function (editor, e, buildMenu, backstage, contextmenu, anchorType) {
      var detection = detect$1();
      var isiOS = detection.os.isiOS();
      var isOSX = detection.os.isOSX();
      var isAndroid = detection.os.isAndroid();
      var isTouch = detection.deviceType.isTouch();
      var shouldHighlightImmediately = function () {
        return !(isAndroid || isiOS || isOSX && isTouch);
      };
      var open = function () {
        var items = buildMenu();
        show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());
      };
      if ((isOSX || isiOS) && anchorType !== 'node') {
        var openiOS_1 = function () {
          setupiOSOverrides(editor);
          open();
        };
        if (isTouchWithinSelection(editor, e)) {
          openiOS_1();
        } else {
          editor.once('selectionchange', openiOS_1);
          editor.once('touchend', function () {
            return editor.off('selectionchange', openiOS_1);
          });
        }
      } else {
        open();
      }
    };

    var patchPipeConfig = function (config) {
      return typeof config === 'string' ? config.split(/[ ,]/) : config;
    };
    var shouldNeverUseNative = function (editor) {
      return editor.getParam('contextmenu_never_use_native', false, 'boolean');
    };
    var getMenuItems = function (editor, name, defaultItems) {
      var contextMenus = editor.ui.registry.getAll().contextMenus;
      return Optional.from(editor.getParam(name)).map(patchPipeConfig).getOrThunk(function () {
        return filter$2(patchPipeConfig(defaultItems), function (item) {
          return has$2(contextMenus, item);
        });
      });
    };
    var isContextMenuDisabled = function (editor) {
      return editor.getParam('contextmenu') === false;
    };
    var getContextMenu = function (editor) {
      return getMenuItems(editor, 'contextmenu', 'link linkchecker image imagetools table spellchecker configurepermanentpen');
    };
    var getAvoidOverlapSelector = function (editor) {
      return editor.getParam('contextmenu_avoid_overlap', '', 'string');
    };

    var isSeparator = function (item) {
      return isString(item) ? item === '|' : item.type === 'separator';
    };
    var separator = { type: 'separator' };
    var makeContextItem = function (item) {
      var commonMenuItem = function (item) {
        return {
          text: item.text,
          icon: item.icon,
          disabled: item.disabled,
          shortcut: item.shortcut
        };
      };
      if (isString(item)) {
        return item;
      } else {
        switch (item.type) {
        case 'separator':
          return separator;
        case 'submenu':
          return __assign(__assign({ type: 'nestedmenuitem' }, commonMenuItem(item)), {
            getSubmenuItems: function () {
              var items = item.getSubmenuItems();
              if (isString(items)) {
                return items;
              } else {
                return map$2(items, makeContextItem);
              }
            }
          });
        default:
          return __assign(__assign({ type: 'menuitem' }, commonMenuItem(item)), { onAction: noarg(item.onAction) });
        }
      }
    };
    var addContextMenuGroup = function (xs, groupItems) {
      if (groupItems.length === 0) {
        return xs;
      }
      var lastMenuItem = last$2(xs).filter(function (item) {
        return !isSeparator(item);
      });
      var before = lastMenuItem.fold(function () {
        return [];
      }, function (_) {
        return [separator];
      });
      return xs.concat(before).concat(groupItems).concat([separator]);
    };
    var generateContextMenu = function (contextMenus, menuConfig, selectedElement) {
      var sections = foldl(menuConfig, function (acc, name) {
        return get$e(contextMenus, name.toLowerCase()).map(function (menu) {
          var items = menu.update(selectedElement);
          if (isString(items)) {
            return addContextMenuGroup(acc, items.split(' '));
          } else if (items.length > 0) {
            var allItems = map$2(items, makeContextItem);
            return addContextMenuGroup(acc, allItems);
          } else {
            return acc;
          }
        }).getOrThunk(function () {
          return acc.concat([name]);
        });
      }, []);
      if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {
        sections.pop();
      }
      return sections;
    };
    var isNativeOverrideKeyEvent = function (editor, e) {
      return e.ctrlKey && !shouldNeverUseNative(editor);
    };
    var isTriggeredByKeyboard = function (editor, e) {
      return e.type !== 'longpress' && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '');
    };
    var getSelectedElement = function (editor, e) {
      return isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;
    };
    var getAnchorType = function (editor, e) {
      var selector = getAvoidOverlapSelector(editor);
      var anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';
      if (isNotEmpty(selector)) {
        var target = getSelectedElement(editor, e);
        var selectorExists = closest(SugarElement.fromDom(target), selector);
        return selectorExists ? 'node' : anchorType;
      } else {
        return anchorType;
      }
    };
    var setup$5 = function (editor, lazySink, backstage) {
      var detection = detect$1();
      var isTouch = detection.deviceType.isTouch;
      var contextmenu = build$1(InlineView.sketch({
        dom: { tag: 'div' },
        lazySink: lazySink,
        onEscape: function () {
          return editor.focus();
        },
        onShow: function () {
          return backstage.setContextMenuState(true);
        },
        onHide: function () {
          return backstage.setContextMenuState(false);
        },
        fireDismissalEventInstead: {},
        inlineBehaviours: derive$1([config('dismissContextMenu', [run$1(dismissRequested(), function (comp, _se) {
              Sandboxing.close(comp);
              editor.focus();
            })])])
      }));
      var hideContextMenu = function (_e) {
        return InlineView.hide(contextmenu);
      };
      var showContextMenu = function (e) {
        if (shouldNeverUseNative(editor)) {
          e.preventDefault();
        }
        if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {
          return;
        }
        var anchorType = getAnchorType(editor, e);
        var buildMenu = function () {
          var selectedElement = getSelectedElement(editor, e);
          var registry = editor.ui.registry.getAll();
          var menuConfig = getContextMenu(editor);
          return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
        };
        var initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;
        initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);
      };
      editor.on('init', function () {
        var hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');
        editor.on(hideEvents, hideContextMenu);
        editor.on('longpress contextmenu', showContextMenu);
      });
    };

    var adt = Adt.generate([
      {
        offset: [
          'x',
          'y'
        ]
      },
      {
        absolute: [
          'x',
          'y'
        ]
      },
      {
        fixed: [
          'x',
          'y'
        ]
      }
    ]);
    var subtract = function (change) {
      return function (point) {
        return point.translate(-change.left, -change.top);
      };
    };
    var add = function (change) {
      return function (point) {
        return point.translate(change.left, change.top);
      };
    };
    var transform = function (changes) {
      return function (x, y) {
        return foldl(changes, function (rest, f) {
          return f(rest);
        }, SugarPosition(x, y));
      };
    };
    var asFixed = function (coord, scroll, origin) {
      return coord.fold(transform([
        add(origin),
        subtract(scroll)
      ]), transform([subtract(scroll)]), transform([]));
    };
    var asAbsolute = function (coord, scroll, origin) {
      return coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));
    };
    var asOffset = function (coord, scroll, origin) {
      return coord.fold(transform([]), transform([subtract(origin)]), transform([
        add(scroll),
        subtract(origin)
      ]));
    };
    var withinRange = function (coord1, coord2, xRange, yRange, scroll, origin) {
      var a1 = asAbsolute(coord1, scroll, origin);
      var a2 = asAbsolute(coord2, scroll, origin);
      return Math.abs(a1.left - a2.left) <= xRange && Math.abs(a1.top - a2.top) <= yRange;
    };
    var getDeltas = function (coord1, coord2, xRange, yRange, scroll, origin) {
      var a1 = asAbsolute(coord1, scroll, origin);
      var a2 = asAbsolute(coord2, scroll, origin);
      var left = Math.abs(a1.left - a2.left);
      var top = Math.abs(a1.top - a2.top);
      return SugarPosition(left, top);
    };
    var toStyles = function (coord, scroll, origin) {
      var stylesOpt = coord.fold(function (x, y) {
        return {
          position: Optional.some('absolute'),
          left: Optional.some(x + 'px'),
          top: Optional.some(y + 'px')
        };
      }, function (x, y) {
        return {
          position: Optional.some('absolute'),
          left: Optional.some(x - origin.left + 'px'),
          top: Optional.some(y - origin.top + 'px')
        };
      }, function (x, y) {
        return {
          position: Optional.some('fixed'),
          left: Optional.some(x + 'px'),
          top: Optional.some(y + 'px')
        };
      });
      return __assign({
        right: Optional.none(),
        bottom: Optional.none()
      }, stylesOpt);
    };
    var translate = function (coord, deltaX, deltaY) {
      return coord.fold(function (x, y) {
        return offset(x + deltaX, y + deltaY);
      }, function (x, y) {
        return absolute(x + deltaX, y + deltaY);
      }, function (x, y) {
        return fixed(x + deltaX, y + deltaY);
      });
    };
    var absorb = function (partialCoord, originalCoord, scroll, origin) {
      var absorbOne = function (stencil, nu) {
        return function (optX, optY) {
          var original = stencil(originalCoord, scroll, origin);
          return nu(optX.getOr(original.left), optY.getOr(original.top));
        };
      };
      return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));
    };
    var offset = adt.offset;
    var absolute = adt.absolute;
    var fixed = adt.fixed;

    var parseAttrToInt = function (element, name) {
      var value = get$d(element, name);
      return isUndefined(value) ? NaN : parseInt(value, 10);
    };
    var get = function (component, snapsInfo) {
      var element = component.element;
      var x = parseAttrToInt(element, snapsInfo.leftAttr);
      var y = parseAttrToInt(element, snapsInfo.topAttr);
      return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));
    };
    var set = function (component, snapsInfo, pt) {
      var element = component.element;
      set$8(element, snapsInfo.leftAttr, pt.left + 'px');
      set$8(element, snapsInfo.topAttr, pt.top + 'px');
    };
    var clear = function (component, snapsInfo) {
      var element = component.element;
      remove$7(element, snapsInfo.leftAttr);
      remove$7(element, snapsInfo.topAttr);
    };

    var getCoords = function (component, snapInfo, coord, delta) {
      return get(component, snapInfo).fold(function () {
        return coord;
      }, function (fixed$1) {
        return fixed(fixed$1.left + delta.left, fixed$1.top + delta.top);
      });
    };
    var moveOrSnap = function (component, snapInfo, coord, delta, scroll, origin) {
      var newCoord = getCoords(component, snapInfo, coord, delta);
      var snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);
      var fixedCoord = asFixed(newCoord, scroll, origin);
      set(component, snapInfo, fixedCoord);
      return snap.fold(function () {
        return {
          coord: fixed(fixedCoord.left, fixedCoord.top),
          extra: Optional.none()
        };
      }, function (spanned) {
        return {
          coord: spanned.output,
          extra: spanned.extra
        };
      });
    };
    var stopDrag = function (component, snapInfo) {
      clear(component, snapInfo);
    };
    var findMatchingSnap = function (snaps, newCoord, scroll, origin) {
      return findMap(snaps, function (snap) {
        var sensor = snap.sensor;
        var inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
        return inRange ? Optional.some({
          output: absorb(snap.output, newCoord, scroll, origin),
          extra: snap.extra
        }) : Optional.none();
      });
    };
    var findClosestSnap = function (component, snapInfo, newCoord, scroll, origin) {
      var snaps = snapInfo.getSnapPoints(component);
      var matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
      return matchSnap.orThunk(function () {
        var bestSnap = foldl(snaps, function (acc, snap) {
          var sensor = snap.sensor;
          var deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);
          return acc.deltas.fold(function () {
            return {
              deltas: Optional.some(deltas),
              snap: Optional.some(snap)
            };
          }, function (bestDeltas) {
            var currAvg = (deltas.left + deltas.top) / 2;
            var bestAvg = (bestDeltas.left + bestDeltas.top) / 2;
            if (currAvg <= bestAvg) {
              return {
                deltas: Optional.some(deltas),
                snap: Optional.some(snap)
              };
            } else {
              return acc;
            }
          });
        }, {
          deltas: Optional.none(),
          snap: Optional.none()
        });
        return bestSnap.snap.map(function (snap) {
          return {
            output: absorb(snap.output, newCoord, scroll, origin),
            extra: snap.extra
          };
        });
      });
    };
    var findSnap = function (component, snapInfo, newCoord, scroll, origin) {
      var snaps = snapInfo.getSnapPoints(component);
      return findMatchingSnap(snaps, newCoord, scroll, origin);
    };
    var snapTo$1 = function (snap, scroll, origin) {
      return {
        coord: absorb(snap.output, snap.output, scroll, origin),
        extra: snap.extra
      };
    };

    var snapTo = function (component, dragConfig, _state, snap) {
      var target = dragConfig.getTarget(component.element);
      if (dragConfig.repositionTarget) {
        var doc = owner$4(component.element);
        var scroll_1 = get$9(doc);
        var origin_1 = getOrigin(target);
        var snapPin = snapTo$1(snap, scroll_1, origin_1);
        var styles = toStyles(snapPin.coord, scroll_1, origin_1);
        setOptions(target, styles);
      }
    };

    var DraggingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        snapTo: snapTo
    });

    var initialAttribute = 'data-initial-z-index';
    var resetZIndex = function (blocker) {
      parent(blocker.element).filter(isElement$2).each(function (root) {
        getOpt(root, initialAttribute).fold(function () {
          return remove$6(root, 'z-index');
        }, function (zIndex) {
          return set$7(root, 'z-index', zIndex);
        });
        remove$7(root, initialAttribute);
      });
    };
    var changeZIndex = function (blocker) {
      parent(blocker.element).filter(isElement$2).each(function (root) {
        getRaw(root, 'z-index').each(function (zindex) {
          set$8(root, initialAttribute, zindex);
        });
        set$7(root, 'z-index', get$c(blocker.element, 'z-index'));
      });
    };
    var instigate = function (anyComponent, blocker) {
      anyComponent.getSystem().addToGui(blocker);
      changeZIndex(blocker);
    };
    var discard = function (blocker) {
      resetZIndex(blocker);
      blocker.getSystem().removeFromGui(blocker);
    };
    var createComponent = function (component, blockerClass, blockerEvents) {
      return component.getSystem().build(Container.sketch({
        dom: {
          styles: {
            'left': '0px',
            'top': '0px',
            'width': '100%',
            'height': '100%',
            'position': 'fixed',
            'z-index': '1000000000000000'
          },
          classes: [blockerClass]
        },
        events: blockerEvents
      }));
    };

    var SnapSchema = optionObjOf('snaps', [
      required$1('getSnapPoints'),
      onHandler('onSensor'),
      required$1('leftAttr'),
      required$1('topAttr'),
      defaulted('lazyViewport', win),
      defaulted('mustSnap', false)
    ]);

    var schema$6 = [
      defaulted('useFixed', never),
      required$1('blockerClass'),
      defaulted('getTarget', identity$1),
      defaulted('onDrag', noop),
      defaulted('repositionTarget', true),
      defaulted('onDrop', noop),
      defaultedFunction('getBounds', win),
      SnapSchema
    ];

    var getCurrentCoord = function (target) {
      return lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), function (left, top, position) {
        var nu = position === 'fixed' ? fixed : offset;
        return nu(parseInt(left, 10), parseInt(top, 10));
      }).getOrThunk(function () {
        var location = absolute$3(target);
        return absolute(location.left, location.top);
      });
    };
    var clampCoords = function (component, coords, scroll, origin, startData) {
      var bounds = startData.bounds;
      var absoluteCoord = asAbsolute(coords, scroll, origin);
      var newX = clamp$1(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);
      var newY = clamp$1(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);
      var newCoords = absolute(newX, newY);
      return coords.fold(function () {
        var offset$1 = asOffset(newCoords, scroll, origin);
        return offset(offset$1.left, offset$1.top);
      }, constant$1(newCoords), function () {
        var fixed$1 = asFixed(newCoords, scroll, origin);
        return fixed(fixed$1.left, fixed$1.top);
      });
    };
    var calcNewCoord = function (component, optSnaps, currentCoord, scroll, origin, delta, startData) {
      var newCoord = optSnaps.fold(function () {
        var translated = translate(currentCoord, delta.left, delta.top);
        var fixedCoord = asFixed(translated, scroll, origin);
        return fixed(fixedCoord.left, fixedCoord.top);
      }, function (snapInfo) {
        var snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
        snapping.extra.each(function (extra) {
          snapInfo.onSensor(component, extra);
        });
        return snapping.coord;
      });
      return clampCoords(component, newCoord, scroll, origin, startData);
    };
    var dragBy = function (component, dragConfig, startData, delta) {
      var target = dragConfig.getTarget(component.element);
      if (dragConfig.repositionTarget) {
        var doc = owner$4(component.element);
        var scroll_1 = get$9(doc);
        var origin_1 = getOrigin(target);
        var currentCoord = getCurrentCoord(target);
        var newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll_1, origin_1, delta, startData);
        var styles = toStyles(newCoord, scroll_1, origin_1);
        setOptions(target, styles);
      }
      dragConfig.onDrag(component, target, delta);
    };

    var calcStartData = function (dragConfig, comp) {
      return {
        bounds: dragConfig.getBounds(),
        height: getOuter$2(comp.element),
        width: getOuter$1(comp.element)
      };
    };
    var move = function (component, dragConfig, dragState, dragMode, event) {
      var delta = dragState.update(dragMode, event);
      var dragStartData = dragState.getStartData().getOrThunk(function () {
        return calcStartData(dragConfig, component);
      });
      delta.each(function (dlt) {
        dragBy(component, dragConfig, dragStartData, dlt);
      });
    };
    var stop = function (component, blocker, dragConfig, dragState) {
      blocker.each(discard);
      dragConfig.snaps.each(function (snapInfo) {
        stopDrag(component, snapInfo);
      });
      var target = dragConfig.getTarget(component.element);
      dragState.reset();
      dragConfig.onDrop(component, target);
    };
    var handlers = function (events) {
      return function (dragConfig, dragState) {
        var updateStartState = function (comp) {
          dragState.setStartData(calcStartData(dragConfig, comp));
        };
        return derive$2(__spreadArray([run$1(windowScroll(), function (comp) {
            dragState.getStartData().each(function () {
              return updateStartState(comp);
            });
          })], events(dragConfig, dragState, updateStartState), true));
      };
    };

    var init$2 = function (dragApi) {
      return derive$2([
        run$1(mousedown(), dragApi.forceDrop),
        run$1(mouseup(), dragApi.drop),
        run$1(mousemove(), function (comp, simulatedEvent) {
          dragApi.move(simulatedEvent.event);
        }),
        run$1(mouseout(), dragApi.delayDrop)
      ]);
    };

    var getData$1 = function (event) {
      return Optional.from(SugarPosition(event.x, event.y));
    };
    var getDelta$1 = function (old, nu) {
      return SugarPosition(nu.left - old.left, nu.top - old.top);
    };

    var MouseData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData$1,
        getDelta: getDelta$1
    });

    var events$2 = function (dragConfig, dragState, updateStartState) {
      return [run$1(mousedown(), function (component, simulatedEvent) {
          var raw = simulatedEvent.event.raw;
          if (raw.button !== 0) {
            return;
          }
          simulatedEvent.stop();
          var stop$1 = function () {
            return stop(component, Optional.some(blocker), dragConfig, dragState);
          };
          var delayDrop = DelayedFunction(stop$1, 200);
          var dragApi = {
            drop: stop$1,
            delayDrop: delayDrop.schedule,
            forceDrop: stop$1,
            move: function (event) {
              delayDrop.cancel();
              move(component, dragConfig, dragState, MouseData, event);
            }
          };
          var blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));
          var start = function () {
            updateStartState(component);
            instigate(component, blocker);
          };
          start();
        })];
    };
    var schema$5 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events$2) })], false);

    var init$1 = function (dragApi) {
      return derive$2([
        run$1(touchstart(), dragApi.forceDrop),
        run$1(touchend(), dragApi.drop),
        run$1(touchcancel(), dragApi.drop),
        run$1(touchmove(), function (comp, simulatedEvent) {
          dragApi.move(simulatedEvent.event);
        })
      ]);
    };

    var getDataFrom = function (touches) {
      var touch = touches[0];
      return Optional.some(SugarPosition(touch.clientX, touch.clientY));
    };
    var getData = function (event) {
      var raw = event.raw;
      var touches = raw.touches;
      return touches.length === 1 ? getDataFrom(touches) : Optional.none();
    };
    var getDelta = function (old, nu) {
      return SugarPosition(nu.left - old.left, nu.top - old.top);
    };

    var TouchData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData,
        getDelta: getDelta
    });

    var events$1 = function (dragConfig, dragState, updateStartState) {
      var blockerSingleton = value$1();
      var stopBlocking = function (component) {
        stop(component, blockerSingleton.get(), dragConfig, dragState);
        blockerSingleton.clear();
      };
      return [
        run$1(touchstart(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          var stop = function () {
            return stopBlocking(component);
          };
          var dragApi = {
            drop: stop,
            delayDrop: noop,
            forceDrop: stop,
            move: function (event) {
              move(component, dragConfig, dragState, TouchData, event);
            }
          };
          var blocker = createComponent(component, dragConfig.blockerClass, init$1(dragApi));
          blockerSingleton.set(blocker);
          var start = function () {
            updateStartState(component);
            instigate(component, blocker);
          };
          start();
        }),
        run$1(touchmove(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          move(component, dragConfig, dragState, TouchData, simulatedEvent.event);
        }),
        run$1(touchend(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          stopBlocking(component);
        }),
        run$1(touchcancel(), stopBlocking)
      ];
    };
    var schema$4 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events$1) })], false);

    var events = function (dragConfig, dragState, updateStartState) {
      return __spreadArray(__spreadArray([], events$2(dragConfig, dragState, updateStartState), true), events$1(dragConfig, dragState, updateStartState), true);
    };
    var schema$3 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events) })], false);

    var mouse = schema$5;
    var touch = schema$4;
    var mouseOrTouch = schema$3;

    var DraggingBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mouse: mouse,
        touch: touch,
        mouseOrTouch: mouseOrTouch
    });

    var init = function () {
      var previous = Optional.none();
      var startData = Optional.none();
      var reset = function () {
        previous = Optional.none();
        startData = Optional.none();
      };
      var calculateDelta = function (mode, nu) {
        var result = previous.map(function (old) {
          return mode.getDelta(old, nu);
        });
        previous = Optional.some(nu);
        return result;
      };
      var update = function (mode, dragEvent) {
        return mode.getData(dragEvent).bind(function (nuData) {
          return calculateDelta(mode, nuData);
        });
      };
      var setStartData = function (data) {
        startData = Optional.some(data);
      };
      var getStartData = function () {
        return startData;
      };
      var readState = constant$1({});
      return nu$8({
        readState: readState,
        reset: reset,
        update: update,
        getStartData: getStartData,
        setStartData: setStartData
      });
    };

    var DragState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init
    });

    var Dragging = createModes({
      branchKey: 'mode',
      branches: DraggingBranches,
      name: 'dragging',
      active: {
        events: function (dragConfig, dragState) {
          var dragger = dragConfig.dragger;
          return dragger.handlers(dragConfig, dragState);
        }
      },
      extra: {
        snap: function (sConfig) {
          return {
            sensor: sConfig.sensor,
            range: sConfig.range,
            output: sConfig.output,
            extra: Optional.from(sConfig.extra)
          };
        }
      },
      state: DragState,
      apis: DraggingApis
    });

    var snapWidth = 40;
    var snapOffset = snapWidth / 2;
    var calcSnap = function (selectorOpt, td, x, y, width, height) {
      return selectorOpt.fold(function () {
        return Dragging.snap({
          sensor: absolute(x - snapOffset, y - snapOffset),
          range: SugarPosition(width, height),
          output: absolute(Optional.some(x), Optional.some(y)),
          extra: { td: td }
        });
      }, function (selectorHandle) {
        var sensorLeft = x - snapOffset;
        var sensorTop = y - snapOffset;
        var sensorWidth = snapWidth;
        var sensorHeight = snapWidth;
        var rect = selectorHandle.element.dom.getBoundingClientRect();
        return Dragging.snap({
          sensor: absolute(sensorLeft, sensorTop),
          range: SugarPosition(sensorWidth, sensorHeight),
          output: absolute(Optional.some(x - rect.width / 2), Optional.some(y - rect.height / 2)),
          extra: { td: td }
        });
      });
    };
    var getSnapsConfig = function (getSnapPoints, cell, onChange) {
      var isSameCell = function (cellOpt, td) {
        return cellOpt.exists(function (currentTd) {
          return eq(currentTd, td);
        });
      };
      return {
        getSnapPoints: getSnapPoints,
        leftAttr: 'data-drag-left',
        topAttr: 'data-drag-top',
        onSensor: function (component, extra) {
          var td = extra.td;
          if (!isSameCell(cell.get(), td)) {
            cell.set(td);
            onChange(td);
          }
        },
        mustSnap: true
      };
    };
    var createSelector = function (snaps) {
      return record(Button.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-selector']
        },
        buttonBehaviours: derive$1([
          Dragging.config({
            mode: 'mouseOrTouch',
            blockerClass: 'blocker',
            snaps: snaps
          }),
          Unselecting.config({})
        ]),
        eventOrder: {
          mousedown: [
            'dragging',
            'alloy.base.behaviour'
          ],
          touchstart: [
            'dragging',
            'alloy.base.behaviour'
          ]
        }
      }));
    };
    var setup$4 = function (editor, sink) {
      var tlTds = Cell([]);
      var brTds = Cell([]);
      var isVisible = Cell(false);
      var startCell = value$1();
      var finishCell = value$1();
      var getTopLeftSnap = function (td) {
        var box = absolute$2(td);
        return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);
      };
      var getTopLeftSnaps = function () {
        return map$2(tlTds.get(), function (td) {
          return getTopLeftSnap(td);
        });
      };
      var getBottomRightSnap = function (td) {
        var box = absolute$2(td);
        return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);
      };
      var getBottomRightSnaps = function () {
        return map$2(brTds.get(), function (td) {
          return getBottomRightSnap(td);
        });
      };
      var topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, function (start) {
        finishCell.get().each(function (finish) {
          editor.fire('TableSelectorChange', {
            start: start,
            finish: finish
          });
        });
      });
      var bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, function (finish) {
        startCell.get().each(function (start) {
          editor.fire('TableSelectorChange', {
            start: start,
            finish: finish
          });
        });
      });
      var memTopLeft = createSelector(topLeftSnaps);
      var memBottomRight = createSelector(bottomRightSnaps);
      var topLeft = build$1(memTopLeft.asSpec());
      var bottomRight = build$1(memBottomRight.asSpec());
      var showOrHideHandle = function (selector, cell, isAbove, isBelow) {
        var cellRect = cell.dom.getBoundingClientRect();
        remove$6(selector.element, 'display');
        var viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;
        var aboveViewport = isAbove(cellRect);
        var belowViewport = isBelow(cellRect, viewportHeight);
        if (aboveViewport || belowViewport) {
          set$7(selector.element, 'display', 'none');
        }
      };
      var snapTo = function (selector, cell, getSnapConfig, pos) {
        var snap = getSnapConfig(cell);
        Dragging.snapTo(selector, snap);
        var isAbove = function (rect) {
          return rect[pos] < 0;
        };
        var isBelow = function (rect, viewportHeight) {
          return rect[pos] > viewportHeight;
        };
        showOrHideHandle(selector, cell, isAbove, isBelow);
      };
      var snapTopLeft = function (cell) {
        return snapTo(topLeft, cell, getTopLeftSnap, 'top');
      };
      var snapLastTopLeft = function () {
        return startCell.get().each(snapTopLeft);
      };
      var snapBottomRight = function (cell) {
        return snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');
      };
      var snapLastBottomRight = function () {
        return finishCell.get().each(snapBottomRight);
      };
      if (detect$1().deviceType.isTouch()) {
        editor.on('TableSelectionChange', function (e) {
          if (!isVisible.get()) {
            attach(sink, topLeft);
            attach(sink, bottomRight);
            isVisible.set(true);
          }
          startCell.set(e.start);
          finishCell.set(e.finish);
          e.otherCells.each(function (otherCells) {
            tlTds.set(otherCells.upOrLeftCells);
            brTds.set(otherCells.downOrRightCells);
            snapTopLeft(e.start);
            snapBottomRight(e.finish);
          });
        });
        editor.on('ResizeEditor ResizeWindow ScrollContent', function () {
          snapLastTopLeft();
          snapLastBottomRight();
        });
        editor.on('TableSelectionClear', function () {
          if (isVisible.get()) {
            detach(topLeft);
            detach(bottomRight);
            isVisible.set(false);
          }
          startCell.clear();
          finishCell.clear();
        });
      }
    };

    var isHidden = function (elm) {
      if (elm.nodeType === 1) {
        if (elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus')) {
          return true;
        }
        if (elm.getAttribute('data-mce-type') === 'bookmark') {
          return true;
        }
      }
      return false;
    };
    var renderElementPath = function (editor, settings, providersBackstage) {
      if (!settings.delimiter) {
        settings.delimiter = '\xBB';
      }
      var getDataPath = function (data) {
        var parts = data || [];
        var newPathElements = map$2(parts, function (part, index) {
          return Button.sketch({
            dom: {
              tag: 'div',
              classes: ['tox-statusbar__path-item'],
              attributes: {
                'role': 'button',
                'data-index': index,
                'tab-index': -1,
                'aria-level': index + 1
              },
              innerHtml: part.name
            },
            action: function (_btn) {
              editor.focus();
              editor.selection.select(part.element);
              editor.nodeChanged();
            },
            buttonBehaviours: derive$1([
              DisablingConfigs.button(providersBackstage.isDisabled),
              receivingConfig()
            ])
          });
        });
        var divider = {
          dom: {
            tag: 'div',
            classes: ['tox-statusbar__path-divider'],
            attributes: { 'aria-hidden': true },
            innerHtml: ' ' + settings.delimiter + ' '
          }
        };
        return foldl(newPathElements.slice(1), function (acc, element) {
          var newAcc = acc;
          newAcc.push(divider);
          newAcc.push(element);
          return newAcc;
        }, [newPathElements[0]]);
      };
      var updatePath = function (parents) {
        var newPath = [];
        var i = parents.length;
        while (i-- > 0) {
          var parent_1 = parents[i];
          if (parent_1.nodeType === 1 && !isHidden(parent_1)) {
            var args = editor.fire('ResolveName', {
              name: parent_1.nodeName.toLowerCase(),
              target: parent_1
            });
            if (!args.isDefaultPrevented()) {
              newPath.push({
                name: args.name,
                element: parent_1
              });
            }
            if (args.isPropagationStopped()) {
              break;
            }
          }
        }
        return newPath;
      };
      return {
        dom: {
          tag: 'div',
          classes: ['tox-statusbar__path'],
          attributes: { role: 'navigation' }
        },
        behaviours: derive$1([
          Keying.config({
            mode: 'flow',
            selector: 'div[role=button]'
          }),
          Disabling.config({ disabled: providersBackstage.isDisabled }),
          receivingConfig(),
          Tabstopping.config({}),
          Replacing.config({}),
          config('elementPathEvents', [runOnAttached(function (comp, _e) {
              editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', function () {
                return Keying.focusIn(comp);
              });
              editor.on('NodeChange', function (e) {
                var newPath = updatePath(e.parents);
                if (newPath.length > 0) {
                  Replacing.set(comp, getDataPath(newPath));
                } else {
                  Replacing.set(comp, []);
                }
              });
            })])
        ]),
        components: []
      };
    };

    var ResizeTypes;
    (function (ResizeTypes) {
      ResizeTypes[ResizeTypes['None'] = 0] = 'None';
      ResizeTypes[ResizeTypes['Both'] = 1] = 'Both';
      ResizeTypes[ResizeTypes['Vertical'] = 2] = 'Vertical';
    }(ResizeTypes || (ResizeTypes = {})));
    var getDimensions = function (editor, deltas, resizeType, originalHeight, originalWidth) {
      var dimensions = {};
      dimensions.height = calcCappedSize(originalHeight + deltas.top, getMinHeightSetting(editor), getMaxHeightSetting(editor));
      if (resizeType === ResizeTypes.Both) {
        dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthSetting(editor), getMaxWidthSetting(editor));
      }
      return dimensions;
    };
    var resize = function (editor, deltas, resizeType) {
      var container = SugarElement.fromDom(editor.getContainer());
      var dimensions = getDimensions(editor, deltas, resizeType, get$b(container), get$a(container));
      each(dimensions, function (val, dim) {
        return set$7(container, dim, numToPx(val));
      });
      fireResizeEditor(editor);
    };

    var getResizeType = function (editor) {
      var fallback = !editor.hasPlugin('autoresize');
      var resize = editor.getParam('resize', fallback);
      if (resize === false) {
        return ResizeTypes.None;
      } else if (resize === 'both') {
        return ResizeTypes.Both;
      } else {
        return ResizeTypes.Vertical;
      }
    };
    var keyboardHandler = function (editor, resizeType, x, y) {
      var scale = 20;
      var delta = SugarPosition(x * scale, y * scale);
      resize(editor, delta, resizeType);
      return Optional.some(true);
    };
    var renderResizeHandler = function (editor, providersBackstage) {
      var resizeType = getResizeType(editor);
      if (resizeType === ResizeTypes.None) {
        return Optional.none();
      }
      return Optional.some(render$3('resize-handle', {
        tag: 'div',
        classes: ['tox-statusbar__resize-handle'],
        attributes: { title: providersBackstage.translate('Resize') },
        behaviours: [
          Dragging.config({
            mode: 'mouse',
            repositionTarget: false,
            onDrag: function (_comp, _target, delta) {
              return resize(editor, delta, resizeType);
            },
            blockerClass: 'tox-blocker'
          }),
          Keying.config({
            mode: 'special',
            onLeft: function () {
              return keyboardHandler(editor, resizeType, -1, 0);
            },
            onRight: function () {
              return keyboardHandler(editor, resizeType, 1, 0);
            },
            onUp: function () {
              return keyboardHandler(editor, resizeType, 0, -1);
            },
            onDown: function () {
              return keyboardHandler(editor, resizeType, 0, 1);
            }
          }),
          Tabstopping.config({}),
          Focusing.config({})
        ]
      }, providersBackstage.icons));
    };

    var renderWordCount = function (editor, providersBackstage) {
      var _a;
      var replaceCountText = function (comp, count, mode) {
        return Replacing.set(comp, [text(providersBackstage.translate([
            '{0} ' + mode,
            count[mode]
          ]))]);
      };
      return Button.sketch({
        dom: {
          tag: 'button',
          classes: ['tox-statusbar__wordcount']
        },
        components: [],
        buttonBehaviours: derive$1([
          DisablingConfigs.button(providersBackstage.isDisabled),
          receivingConfig(),
          Tabstopping.config({}),
          Replacing.config({}),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: {
                mode: 'words',
                count: {
                  words: 0,
                  characters: 0
                }
              }
            }
          }),
          config('wordcount-events', [
            runOnExecute$1(function (comp) {
              var currentVal = Representing.getValue(comp);
              var newMode = currentVal.mode === 'words' ? 'characters' : 'words';
              Representing.setValue(comp, {
                mode: newMode,
                count: currentVal.count
              });
              replaceCountText(comp, currentVal.count, newMode);
            }),
            runOnAttached(function (comp) {
              editor.on('wordCountUpdate', function (e) {
                var mode = Representing.getValue(comp).mode;
                Representing.setValue(comp, {
                  mode: mode,
                  count: e.wordCount
                });
                replaceCountText(comp, e.wordCount, mode);
              });
            })
          ])
        ]),
        eventOrder: (_a = {}, _a[execute$5()] = [
          'disabling',
          'alloy.base.behaviour',
          'wordcount-events'
        ], _a)
      });
    };

    var renderStatusbar = function (editor, providersBackstage) {
      var renderBranding = function () {
        var label = global$e.translate([
          'Powered by {0}',
          'Tiny'
        ]);
        var linkHtml = '<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5" rel="noopener" target="_blank" tabindex="-1" aria-label="' + label + '">' + label + '</a>';
        return {
          dom: {
            tag: 'span',
            classes: ['tox-statusbar__branding'],
            innerHtml: linkHtml
          }
        };
      };
      var getTextComponents = function () {
        var components = [];
        if (editor.getParam('elementpath', true, 'boolean')) {
          components.push(renderElementPath(editor, {}, providersBackstage));
        }
        if (editor.hasPlugin('wordcount')) {
          components.push(renderWordCount(editor, providersBackstage));
        }
        if (editor.getParam('branding', true, 'boolean')) {
          components.push(renderBranding());
        }
        if (components.length > 0) {
          return [{
              dom: {
                tag: 'div',
                classes: ['tox-statusbar__text-container']
              },
              components: components
            }];
        }
        return [];
      };
      var getComponents = function () {
        var components = getTextComponents();
        var resizeHandler = renderResizeHandler(editor, providersBackstage);
        return components.concat(resizeHandler.toArray());
      };
      return {
        dom: {
          tag: 'div',
          classes: ['tox-statusbar']
        },
        components: getComponents()
      };
    };

    var setup$3 = function (editor) {
      var _a;
      var isInline = editor.inline;
      var mode = isInline ? Inline : Iframe;
      var header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
      var lazyOuterContainer = Optional.none();
      var platform = detect$1();
      var isIE = platform.browser.isIE();
      var platformClasses = isIE ? ['tox-platform-ie'] : [];
      var isTouch = platform.deviceType.isTouch();
      var touchPlatformClass = 'tox-platform-touch';
      var deviceClasses = isTouch ? [touchPlatformClass] : [];
      var isToolbarBottom = isToolbarLocationBottom(editor);
      var uiContainer = getUiContainer(editor);
      var dirAttributes = global$e.isRtl() ? { attributes: { dir: 'rtl' } } : {};
      var verticalDirAttributes = { attributes: (_a = {}, _a[Attribute] = isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom, _a) };
      var lazyHeader = function () {
        return lazyOuterContainer.bind(OuterContainer.getHeader);
      };
      var isHeaderDocked = function () {
        return header.isDocked(lazyHeader);
      };
      var resizeUiMothership = function () {
        set$7(uiMothership.element, 'width', document.body.clientWidth + 'px');
      };
      var makeSinkDefinition = function () {
        var isGridUiContainer = eq(body(), uiContainer) && get$c(uiContainer, 'display') === 'grid';
        var sinkSpec = {
          dom: __assign({
            tag: 'div',
            classes: [
              'tox',
              'tox-silver-sink',
              'tox-tinymce-aux'
            ].concat(platformClasses).concat(deviceClasses)
          }, dirAttributes),
          behaviours: derive$1([Positioning.config({
              useFixed: function () {
                return isHeaderDocked();
              }
            })])
        };
        var reactiveWidthSpec = {
          dom: { styles: { width: document.body.clientWidth + 'px' } },
          events: derive$2([run$1(windowResize(), resizeUiMothership)])
        };
        return deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {});
      };
      var sink = build$1(makeSinkDefinition());
      var lazySink = function () {
        return Result.value(sink);
      };
      var memAnchorBar = record({
        dom: {
          tag: 'div',
          classes: ['tox-anchorbar']
        }
      });
      var lazyAnchorBar = function () {
        return lazyOuterContainer.bind(function (container) {
          return memAnchorBar.getOpt(container);
        }).getOrDie('Could not find a anchor bar element');
      };
      var lazyToolbar = function () {
        return lazyOuterContainer.bind(function (container) {
          return OuterContainer.getToolbar(container);
        }).getOrDie('Could not find more toolbar element');
      };
      var lazyThrobber = function () {
        return lazyOuterContainer.bind(function (container) {
          return OuterContainer.getThrobber(container);
        }).getOrDie('Could not find throbber element');
      };
      var backstage = init$7(sink, editor, lazyAnchorBar);
      var partMenubar = OuterContainer.parts.menubar({
        dom: {
          tag: 'div',
          classes: ['tox-menubar']
        },
        backstage: backstage,
        onEscape: function () {
          editor.focus();
        }
      });
      var toolbarMode = getToolbarMode(editor);
      var partToolbar = OuterContainer.parts.toolbar(__assign({
        dom: {
          tag: 'div',
          classes: ['tox-toolbar']
        },
        getSink: lazySink,
        providers: backstage.shared.providers,
        onEscape: function () {
          editor.focus();
        },
        type: toolbarMode,
        lazyToolbar: lazyToolbar,
        lazyHeader: function () {
          return lazyHeader().getOrDie('Could not find header element');
        }
      }, verticalDirAttributes));
      var partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({
        dom: {
          tag: 'div',
          classes: ['tox-toolbar-overlord']
        },
        providers: backstage.shared.providers,
        onEscape: function () {
          editor.focus();
        },
        type: toolbarMode
      });
      var partSocket = OuterContainer.parts.socket({
        dom: {
          tag: 'div',
          classes: ['tox-edit-area']
        }
      });
      var partSidebar = OuterContainer.parts.sidebar({
        dom: {
          tag: 'div',
          classes: ['tox-sidebar']
        }
      });
      var partThrobber = OuterContainer.parts.throbber({
        dom: {
          tag: 'div',
          classes: ['tox-throbber']
        },
        backstage: backstage
      });
      var sb = editor.getParam('statusbar', true, 'boolean');
      var statusbar = sb && !isInline ? Optional.some(renderStatusbar(editor, backstage.shared.providers)) : Optional.none();
      var socketSidebarContainer = {
        dom: {
          tag: 'div',
          classes: ['tox-sidebar-wrap']
        },
        components: [
          partSocket,
          partSidebar
        ]
      };
      var hasMultipleToolbar = isMultipleToolbars(editor);
      var hasToolbar = isToolbarEnabled(editor);
      var hasMenubar = isMenubarEnabled(editor);
      var getPartToolbar = function () {
        if (hasMultipleToolbar) {
          return [partMultipleToolbar];
        } else if (hasToolbar) {
          return [partToolbar];
        } else {
          return [];
        }
      };
      var partHeader = OuterContainer.parts.header({
        dom: __assign({
          tag: 'div',
          classes: ['tox-editor-header']
        }, verticalDirAttributes),
        components: flatten([
          hasMenubar ? [partMenubar] : [],
          getPartToolbar(),
          useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]
        ]),
        sticky: isStickyToolbar(editor),
        editor: editor,
        sharedBackstage: backstage.shared
      });
      var editorComponents = flatten([
        isToolbarBottom ? [] : [partHeader],
        isInline ? [] : [socketSidebarContainer],
        isToolbarBottom ? [partHeader] : []
      ]);
      var editorContainer = {
        dom: {
          tag: 'div',
          classes: ['tox-editor-container']
        },
        components: editorComponents
      };
      var containerComponents = flatten([
        [editorContainer],
        isInline ? [] : statusbar.toArray(),
        [partThrobber]
      ]);
      var isHidden = isDistractionFree(editor);
      var attributes = __assign(__assign({ role: 'application' }, global$e.isRtl() ? { dir: 'rtl' } : {}), isHidden ? { 'aria-hidden': 'true' } : {});
      var outerContainer = build$1(OuterContainer.sketch({
        dom: {
          tag: 'div',
          classes: [
            'tox',
            'tox-tinymce'
          ].concat(isInline ? ['tox-tinymce-inline'] : []).concat(isToolbarBottom ? ['tox-tinymce--toolbar-bottom'] : []).concat(deviceClasses).concat(platformClasses),
          styles: __assign({ visibility: 'hidden' }, isHidden ? {
            opacity: '0',
            border: '0'
          } : {}),
          attributes: attributes
        },
        components: containerComponents,
        behaviours: derive$1([
          receivingConfig(),
          Disabling.config({ disableClass: 'tox-tinymce--disabled' }),
          Keying.config({
            mode: 'cyclic',
            selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'
          })
        ])
      }));
      lazyOuterContainer = Optional.some(outerContainer);
      editor.shortcuts.add('alt+F9', 'focus menubar', function () {
        OuterContainer.focusMenubar(outerContainer);
      });
      editor.shortcuts.add('alt+F10', 'focus toolbar', function () {
        OuterContainer.focusToolbar(outerContainer);
      });
      editor.addCommand('ToggleToolbarDrawer', function () {
        OuterContainer.toggleToolbarDrawer(outerContainer);
      });
      editor.addQueryStateHandler('ToggleToolbarDrawer', function () {
        return OuterContainer.isToolbarDrawerToggled(outerContainer);
      });
      var mothership = takeover(outerContainer);
      var uiMothership = takeover(sink);
      setup$b(editor, mothership, uiMothership);
      var getUi = function () {
        var channels = {
          broadcastAll: uiMothership.broadcast,
          broadcastOn: uiMothership.broadcastOn,
          register: noop
        };
        return { channels: channels };
      };
      var setEditorSize = function () {
        var parsedHeight = numToPx(getHeightWithFallback(editor));
        var parsedWidth = numToPx(getWidthWithFallback(editor));
        if (!editor.inline) {
          if (isValidValue('div', 'width', parsedWidth)) {
            set$7(outerContainer.element, 'width', parsedWidth);
          }
          if (isValidValue('div', 'height', parsedHeight)) {
            set$7(outerContainer.element, 'height', parsedHeight);
          } else {
            set$7(outerContainer.element, 'height', '200px');
          }
        }
        return parsedHeight;
      };
      var renderUI = function () {
        header.setup(editor, backstage.shared, lazyHeader);
        setup$6(editor, backstage);
        setup$5(editor, lazySink, backstage);
        setup$8(editor);
        setup$7(editor, lazyThrobber, backstage.shared);
        map$1(getToolbarGroups(editor), function (toolbarGroupButtonConfig, name) {
          editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);
        });
        var _a = editor.ui.registry.getAll(), buttons = _a.buttons, menuItems = _a.menuItems, contextToolbars = _a.contextToolbars, sidebars = _a.sidebars;
        var toolbarOpt = getMultipleToolbarsSetting(editor);
        var rawUiConfig = {
          menuItems: menuItems,
          menus: getMenus(editor),
          menubar: getMenubar(editor),
          toolbar: toolbarOpt.getOrThunk(function () {
            return getToolbar(editor);
          }),
          allowToolbarGroups: toolbarMode === ToolbarMode.floating,
          buttons: buttons,
          sidebar: sidebars
        };
        register$7(editor, contextToolbars, sink, { backstage: backstage });
        setup$4(editor, sink);
        var elm = editor.getElement();
        var height = setEditorSize();
        var uiComponents = {
          mothership: mothership,
          uiMothership: uiMothership,
          outerContainer: outerContainer
        };
        var args = {
          targetNode: elm,
          height: height
        };
        return mode.render(editor, uiComponents, rawUiConfig, backstage, args);
      };
      return {
        mothership: mothership,
        uiMothership: uiMothership,
        backstage: backstage,
        renderUI: renderUI,
        getUi: getUi
      };
    };

    var describedBy = function (describedElement, describeElement) {
      var describeId = Optional.from(get$d(describedElement, 'id')).fold(function () {
        var id = generate$6('dialog-describe');
        set$8(describeElement, 'id', id);
        return id;
      }, identity$1);
      set$8(describedElement, 'aria-describedby', describeId);
    };

    var labelledBy = function (labelledElement, labelElement) {
      var labelId = getOpt(labelledElement, 'id').fold(function () {
        var id = generate$6('dialog-label');
        set$8(labelElement, 'id', id);
        return id;
      }, identity$1);
      set$8(labelledElement, 'aria-labelledby', labelId);
    };

    var schema$2 = constant$1([
      required$1('lazySink'),
      option('dragBlockClass'),
      defaultedFunction('getBounds', win),
      defaulted('useTabstopAt', always),
      defaulted('eventOrder', {}),
      field('modalBehaviours', [Keying]),
      onKeyboardHandler('onExecute'),
      onStrictKeyboardHandler('onEscape')
    ]);
    var basic = { sketch: identity$1 };
    var parts$2 = constant$1([
      optional({
        name: 'draghandle',
        overrides: function (detail, spec) {
          return {
            behaviours: derive$1([Dragging.config({
                mode: 'mouse',
                getTarget: function (handle) {
                  return ancestor(handle, '[role="dialog"]').getOr(handle);
                },
                blockerClass: detail.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \n' + JSON.stringify(spec, null, 2)).message),
                getBounds: detail.getDragBounds
              })])
          };
        }
      }),
      required({
        schema: [required$1('dom')],
        name: 'title'
      }),
      required({
        factory: basic,
        schema: [required$1('dom')],
        name: 'close'
      }),
      required({
        factory: basic,
        schema: [required$1('dom')],
        name: 'body'
      }),
      optional({
        factory: basic,
        schema: [required$1('dom')],
        name: 'footer'
      }),
      external$1({
        factory: {
          sketch: function (spec, detail) {
            return __assign(__assign({}, spec), {
              dom: detail.dom,
              components: detail.components
            });
          }
        },
        schema: [
          defaulted('dom', {
            tag: 'div',
            styles: {
              position: 'fixed',
              left: '0px',
              top: '0px',
              right: '0px',
              bottom: '0px'
            }
          }),
          defaulted('components', [])
        ],
        name: 'blocker'
      })
    ]);

    var factory$4 = function (detail, components, spec, externals) {
      var _a;
      var dialogComp = value$1();
      var showDialog = function (dialog) {
        dialogComp.set(dialog);
        var sink = detail.lazySink(dialog).getOrDie();
        var externalBlocker = externals.blocker();
        var blocker = sink.getSystem().build(__assign(__assign({}, externalBlocker), {
          components: externalBlocker.components.concat([premade(dialog)]),
          behaviours: derive$1([
            Focusing.config({}),
            config('dialog-blocker-events', [runOnSource(focusin(), function () {
                Keying.focusIn(dialog);
              })])
          ])
        }));
        attach(sink, blocker);
        Keying.focusIn(dialog);
      };
      var hideDialog = function (dialog) {
        dialogComp.clear();
        parent(dialog.element).each(function (blockerDom) {
          dialog.getSystem().getByDom(blockerDom).each(function (blocker) {
            detach(blocker);
          });
        });
      };
      var getDialogBody = function (dialog) {
        return getPartOrDie(dialog, detail, 'body');
      };
      var getDialogFooter = function (dialog) {
        return getPartOrDie(dialog, detail, 'footer');
      };
      var setBusy = function (dialog, getBusySpec) {
        Blocking.block(dialog, getBusySpec);
      };
      var setIdle = function (dialog) {
        Blocking.unblock(dialog);
      };
      var modalEventsId = generate$6('modal-events');
      var eventOrder = __assign(__assign({}, detail.eventOrder), (_a = {}, _a[attachedToDom()] = [modalEventsId].concat(detail.eventOrder['alloy.system.attached'] || []), _a));
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: {
          show: showDialog,
          hide: hideDialog,
          getBody: getDialogBody,
          getFooter: getDialogFooter,
          setIdle: setIdle,
          setBusy: setBusy
        },
        eventOrder: eventOrder,
        domModification: {
          attributes: {
            'role': 'dialog',
            'aria-modal': 'true'
          }
        },
        behaviours: augment(detail.modalBehaviours, [
          Replacing.config({}),
          Keying.config({
            mode: 'cyclic',
            onEnter: detail.onExecute,
            onEscape: detail.onEscape,
            useTabstopAt: detail.useTabstopAt
          }),
          Blocking.config({ getRoot: dialogComp.get }),
          config(modalEventsId, [runOnAttached(function (c) {
              labelledBy(c.element, getPartOrDie(c, detail, 'title').element);
              describedBy(c.element, getPartOrDie(c, detail, 'body').element);
            })])
        ])
      };
    };
    var ModalDialog = composite({
      name: 'ModalDialog',
      configFields: schema$2(),
      partFields: parts$2(),
      factory: factory$4,
      apis: {
        show: function (apis, dialog) {
          apis.show(dialog);
        },
        hide: function (apis, dialog) {
          apis.hide(dialog);
        },
        getBody: function (apis, dialog) {
          return apis.getBody(dialog);
        },
        getFooter: function (apis, dialog) {
          return apis.getFooter(dialog);
        },
        setBusy: function (apis, dialog, getBusySpec) {
          apis.setBusy(dialog, getBusySpec);
        },
        setIdle: function (apis, dialog) {
          apis.setIdle(dialog);
        }
      }
    });

    var dialogToggleMenuItemSchema = objOf([
      requiredString('type'),
      requiredString('name')
    ].concat(commonMenuItemFields));
    var dialogToggleMenuItemDataProcessor = boolean;

    var baseFooterButtonFields = [
      field$1('name', 'name', defaultedThunk(function () {
        return generate$6('button-name');
      }), string),
      optionString('icon'),
      defaultedStringEnum('align', 'end', [
        'start',
        'end'
      ]),
      defaultedBoolean('primary', false),
      defaultedBoolean('disabled', false)
    ];
    var dialogFooterButtonFields = __spreadArray(__spreadArray([], baseFooterButtonFields, true), [requiredString('text')], false);
    var normalFooterButtonFields = __spreadArray([requiredStringEnum('type', [
        'submit',
        'cancel',
        'custom'
      ])], dialogFooterButtonFields, true);
    var menuFooterButtonFields = __spreadArray([
      requiredStringEnum('type', ['menu']),
      optionString('text'),
      optionString('tooltip'),
      optionString('icon'),
      requiredArrayOf('items', dialogToggleMenuItemSchema)
    ], baseFooterButtonFields, true);
    var dialogFooterButtonSchema = choose$1('type', {
      submit: normalFooterButtonFields,
      cancel: normalFooterButtonFields,
      custom: normalFooterButtonFields,
      menu: menuFooterButtonFields
    });

    var alertBannerFields = [
      requiredString('type'),
      requiredString('text'),
      requiredStringEnum('level', [
        'info',
        'warn',
        'error',
        'success'
      ]),
      requiredString('icon'),
      defaulted('url', '')
    ];
    var alertBannerSchema = objOf(alertBannerFields);

    var createBarFields = function (itemsField) {
      return [
        requiredString('type'),
        itemsField
      ];
    };

    var buttonFields = [
      requiredString('type'),
      requiredString('text'),
      defaultedBoolean('disabled', false),
      defaultedBoolean('primary', false),
      field$1('name', 'name', defaultedThunk(function () {
        return generate$6('button-name');
      }), string),
      optionString('icon'),
      defaultedBoolean('borderless', false)
    ];
    var buttonSchema = objOf(buttonFields);

    var checkboxFields = [
      requiredString('type'),
      requiredString('name'),
      requiredString('label'),
      defaultedBoolean('disabled', false)
    ];
    var checkboxSchema = objOf(checkboxFields);
    var checkboxDataProcessor = boolean;

    var formComponentFields = [
      requiredString('type'),
      requiredString('name')
    ];
    var formComponentWithLabelFields = formComponentFields.concat([optionString('label')]);

    var collectionFields = formComponentWithLabelFields.concat([defaulted('columns', 'auto')]);
    var collectionSchema = objOf(collectionFields);
    var collectionDataProcessor = arrOfObj([
      requiredString('value'),
      requiredString('text'),
      requiredString('icon')
    ]);

    var colorInputFields = formComponentWithLabelFields;
    var colorInputSchema = objOf(colorInputFields);
    var colorInputDataProcessor = string;

    var colorPickerFields = formComponentWithLabelFields;
    var colorPickerSchema = objOf(colorPickerFields);
    var colorPickerDataProcessor = string;

    var customEditorFields = formComponentFields.concat([
      defaultedString('tag', 'textarea'),
      requiredString('scriptId'),
      requiredString('scriptUrl'),
      defaultedPostMsg('settings', undefined)
    ]);
    var customEditorFieldsOld = formComponentFields.concat([
      defaultedString('tag', 'textarea'),
      requiredFunction('init')
    ]);
    var customEditorSchema = valueOf(function (v) {
      return asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(function () {
        return asRaw('customeditor.new', objOfOnly(customEditorFields), v);
      });
    });
    var customEditorDataProcessor = string;

    var dropZoneFields = formComponentWithLabelFields;
    var dropZoneSchema = objOf(dropZoneFields);
    var dropZoneDataProcessor = arrOfVal();

    var createGridFields = function (itemsField) {
      return [
        requiredString('type'),
        requiredNumber('columns'),
        itemsField
      ];
    };

    var htmlPanelFields = [
      requiredString('type'),
      requiredString('html'),
      defaultedStringEnum('presets', 'presentation', [
        'presentation',
        'document'
      ])
    ];
    var htmlPanelSchema = objOf(htmlPanelFields);

    var iframeFields = formComponentWithLabelFields.concat([defaultedBoolean('sandboxed', true)]);
    var iframeSchema = objOf(iframeFields);
    var iframeDataProcessor = string;

    var imageToolsFields = formComponentWithLabelFields.concat([requiredOf('currentState', objOf([
        required$1('blob'),
        requiredString('url')
      ]))]);
    var imageToolsSchema = objOf(imageToolsFields);

    var inputFields = formComponentWithLabelFields.concat([
      optionString('inputMode'),
      optionString('placeholder'),
      defaultedBoolean('maximized', false),
      defaultedBoolean('disabled', false)
    ]);
    var inputSchema = objOf(inputFields);
    var inputDataProcessor = string;

    var createLabelFields = function (itemsField) {
      return [
        requiredString('type'),
        requiredString('label'),
        itemsField
      ];
    };

    var listBoxSingleItemFields = [
      requiredString('text'),
      requiredString('value')
    ];
    var listBoxNestedItemFields = [
      requiredString('text'),
      requiredArrayOf('items', thunkOf('items', function () {
        return listBoxItemSchema;
      }))
    ];
    var listBoxItemSchema = oneOf([
      objOf(listBoxSingleItemFields),
      objOf(listBoxNestedItemFields)
    ]);
    var listBoxFields = formComponentWithLabelFields.concat([
      requiredArrayOf('items', listBoxItemSchema),
      defaultedBoolean('disabled', false)
    ]);
    var listBoxSchema = objOf(listBoxFields);
    var listBoxDataProcessor = string;

    var selectBoxFields = formComponentWithLabelFields.concat([
      requiredArrayOfObj('items', [
        requiredString('text'),
        requiredString('value')
      ]),
      defaultedNumber('size', 1),
      defaultedBoolean('disabled', false)
    ]);
    var selectBoxSchema = objOf(selectBoxFields);
    var selectBoxDataProcessor = string;

    var sizeInputFields = formComponentWithLabelFields.concat([
      defaultedBoolean('constrain', true),
      defaultedBoolean('disabled', false)
    ]);
    var sizeInputSchema = objOf(sizeInputFields);
    var sizeInputDataProcessor = objOf([
      requiredString('width'),
      requiredString('height')
    ]);

    var tableFields = [
      requiredString('type'),
      requiredArrayOf('header', string),
      requiredArrayOf('cells', arrOf(string))
    ];
    var tableSchema = objOf(tableFields);

    var textAreaFields = formComponentWithLabelFields.concat([
      optionString('placeholder'),
      defaultedBoolean('maximized', false),
      defaultedBoolean('disabled', false)
    ]);
    var textAreaSchema = objOf(textAreaFields);
    var textAreaDataProcessor = string;

    var urlInputFields = formComponentWithLabelFields.concat([
      defaultedStringEnum('filetype', 'file', [
        'image',
        'media',
        'file'
      ]),
      defaulted('disabled', false)
    ]);
    var urlInputSchema = objOf(urlInputFields);
    var urlInputDataProcessor = objOf([
      requiredString('value'),
      defaulted('meta', {})
    ]);

    var createItemsField = function (name) {
      return field$1('items', 'items', required$2(), arrOf(valueOf(function (v) {
        return asRaw('Checking item of ' + name, itemSchema, v).fold(function (sErr) {
          return Result.error(formatError(sErr));
        }, function (passValue) {
          return Result.value(passValue);
        });
      })));
    };
    var itemSchema = valueThunk(function () {
      return choose$2('type', {
        alertbanner: alertBannerSchema,
        bar: objOf(createBarFields(createItemsField('bar'))),
        button: buttonSchema,
        checkbox: checkboxSchema,
        colorinput: colorInputSchema,
        colorpicker: colorPickerSchema,
        dropzone: dropZoneSchema,
        grid: objOf(createGridFields(createItemsField('grid'))),
        iframe: iframeSchema,
        input: inputSchema,
        listbox: listBoxSchema,
        selectbox: selectBoxSchema,
        sizeinput: sizeInputSchema,
        textarea: textAreaSchema,
        urlinput: urlInputSchema,
        customeditor: customEditorSchema,
        htmlpanel: htmlPanelSchema,
        imagetools: imageToolsSchema,
        collection: collectionSchema,
        label: objOf(createLabelFields(createItemsField('label'))),
        table: tableSchema,
        panel: panelSchema
      });
    });
    var panelFields = [
      requiredString('type'),
      defaulted('classes', []),
      requiredArrayOf('items', itemSchema)
    ];
    var panelSchema = objOf(panelFields);

    var tabFields = [
      field$1('name', 'name', defaultedThunk(function () {
        return generate$6('tab-name');
      }), string),
      requiredString('title'),
      requiredArrayOf('items', itemSchema)
    ];
    var tabPanelFields = [
      requiredString('type'),
      requiredArrayOfObj('tabs', tabFields)
    ];
    var tabPanelSchema = objOf(tabPanelFields);

    var dialogButtonFields = dialogFooterButtonFields;
    var dialogButtonSchema = dialogFooterButtonSchema;
    var dialogSchema = objOf([
      requiredString('title'),
      requiredOf('body', choose$2('type', {
        panel: panelSchema,
        tabpanel: tabPanelSchema
      })),
      defaultedString('size', 'normal'),
      requiredArrayOf('buttons', dialogButtonSchema),
      defaulted('initialData', {}),
      defaultedFunction('onAction', noop),
      defaultedFunction('onChange', noop),
      defaultedFunction('onSubmit', noop),
      defaultedFunction('onClose', noop),
      defaultedFunction('onCancel', noop),
      defaulted('onTabChange', noop)
    ]);
    var createDialog = function (spec) {
      return asRaw('dialog', dialogSchema, spec);
    };

    var urlDialogButtonSchema = objOf(__spreadArray([requiredStringEnum('type', [
        'cancel',
        'custom'
      ])], dialogButtonFields, true));
    var urlDialogSchema = objOf([
      requiredString('title'),
      requiredString('url'),
      optionNumber('height'),
      optionNumber('width'),
      optionArrayOf('buttons', urlDialogButtonSchema),
      defaultedFunction('onAction', noop),
      defaultedFunction('onCancel', noop),
      defaultedFunction('onClose', noop),
      defaultedFunction('onMessage', noop)
    ]);
    var createUrlDialog = function (spec) {
      return asRaw('dialog', urlDialogSchema, spec);
    };

    var getAllObjects = function (obj) {
      if (isObject(obj)) {
        return [obj].concat(bind$3(values(obj), getAllObjects));
      } else if (isArray(obj)) {
        return bind$3(obj, getAllObjects);
      } else {
        return [];
      }
    };

    var isNamedItem = function (obj) {
      return isString(obj.type) && isString(obj.name);
    };
    var dataProcessors = {
      checkbox: checkboxDataProcessor,
      colorinput: colorInputDataProcessor,
      colorpicker: colorPickerDataProcessor,
      dropzone: dropZoneDataProcessor,
      input: inputDataProcessor,
      iframe: iframeDataProcessor,
      sizeinput: sizeInputDataProcessor,
      selectbox: selectBoxDataProcessor,
      listbox: listBoxDataProcessor,
      size: sizeInputDataProcessor,
      textarea: textAreaDataProcessor,
      urlinput: urlInputDataProcessor,
      customeditor: customEditorDataProcessor,
      collection: collectionDataProcessor,
      togglemenuitem: dialogToggleMenuItemDataProcessor
    };
    var getDataProcessor = function (item) {
      return Optional.from(dataProcessors[item.type]);
    };
    var getNamedItems = function (structure) {
      return filter$2(getAllObjects(structure), isNamedItem);
    };

    var createDataValidator = function (structure) {
      var namedItems = getNamedItems(structure);
      var fields = bind$3(namedItems, function (item) {
        return getDataProcessor(item).fold(function () {
          return [];
        }, function (schema) {
          return [requiredOf(item.name, schema)];
        });
      });
      return objOf(fields);
    };

    var extract = function (structure) {
      var internalDialog = getOrDie(createDialog(structure));
      var dataValidator = createDataValidator(structure);
      var initialData = structure.initialData;
      return {
        internalDialog: internalDialog,
        dataValidator: dataValidator,
        initialData: initialData
      };
    };
    var DialogManager = {
      open: function (factory, structure) {
        var extraction = extract(structure);
        return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
      },
      openUrl: function (factory, structure) {
        var internalDialog = getOrDie(createUrlDialog(structure));
        return factory(internalDialog);
      },
      redial: function (structure) {
        return extract(structure);
      }
    };

    var toValidValues = function (values) {
      var errors = [];
      var result = {};
      each(values, function (value, name) {
        value.fold(function () {
          errors.push(name);
        }, function (v) {
          result[name] = v;
        });
      });
      return errors.length > 0 ? Result.error(errors) : Result.value(result);
    };

    var renderBodyPanel = function (spec, backstage) {
      var memForm = record(Form.sketch(function (parts) {
        return {
          dom: {
            tag: 'div',
            classes: ['tox-form'].concat(spec.classes)
          },
          components: map$2(spec.items, function (item) {
            return interpretInForm(parts, item, backstage);
          })
        };
      }));
      return {
        dom: {
          tag: 'div',
          classes: ['tox-dialog__body']
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-dialog__body-content']
            },
            components: [memForm.asSpec()]
          }],
        behaviours: derive$1([
          Keying.config({
            mode: 'acyclic',
            useTabstopAt: not(isPseudoStop)
          }),
          ComposingConfigs.memento(memForm),
          RepresentingConfigs.memento(memForm, {
            postprocess: function (formValue) {
              return toValidValues(formValue).fold(function (err) {
                console.error(err);
                return {};
              }, identity$1);
            }
          })
        ])
      };
    };

    var factory$3 = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: detail.components,
        events: events$a(detail.action),
        behaviours: augment(detail.tabButtonBehaviours, [
          Focusing.config({}),
          Keying.config({
            mode: 'execution',
            useSpace: true,
            useEnter: true
          }),
          Representing.config({
            store: {
              mode: 'memory',
              initialValue: detail.value
            }
          })
        ]),
        domModification: detail.domModification
      };
    };
    var TabButton = single({
      name: 'TabButton',
      configFields: [
        defaulted('uid', undefined),
        required$1('value'),
        field$1('dom', 'dom', mergeWithThunk(function () {
          return {
            attributes: {
              'role': 'tab',
              'id': generate$6('aria'),
              'aria-selected': 'false'
            }
          };
        }), anyValue()),
        option('action'),
        defaulted('domModification', {}),
        field('tabButtonBehaviours', [
          Focusing,
          Keying,
          Representing
        ]),
        required$1('view')
      ],
      factory: factory$3
    });

    var schema$1 = constant$1([
      required$1('tabs'),
      required$1('dom'),
      defaulted('clickToDismiss', false),
      field('tabbarBehaviours', [
        Highlighting,
        Keying
      ]),
      markers$1([
        'tabClass',
        'selectedClass'
      ])
    ]);
    var tabsPart = group({
      factory: TabButton,
      name: 'tabs',
      unit: 'tab',
      overrides: function (barDetail) {
        var dismissTab$1 = function (tabbar, button) {
          Highlighting.dehighlight(tabbar, button);
          emitWith(tabbar, dismissTab(), {
            tabbar: tabbar,
            button: button
          });
        };
        var changeTab$1 = function (tabbar, button) {
          Highlighting.highlight(tabbar, button);
          emitWith(tabbar, changeTab(), {
            tabbar: tabbar,
            button: button
          });
        };
        return {
          action: function (button) {
            var tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();
            var activeButton = Highlighting.isHighlighted(tabbar, button);
            var response = function () {
              if (activeButton && barDetail.clickToDismiss) {
                return dismissTab$1;
              } else if (!activeButton) {
                return changeTab$1;
              } else {
                return noop;
              }
            }();
            response(tabbar, button);
          },
          domModification: { classes: [barDetail.markers.tabClass] }
        };
      }
    });
    var parts$1 = constant$1([tabsPart]);

    var factory$2 = function (detail, components, _spec, _externals) {
      return {
        'uid': detail.uid,
        'dom': detail.dom,
        components: components,
        'debug.sketcher': 'Tabbar',
        'domModification': { attributes: { role: 'tablist' } },
        'behaviours': augment(detail.tabbarBehaviours, [
          Highlighting.config({
            highlightClass: detail.markers.selectedClass,
            itemClass: detail.markers.tabClass,
            onHighlight: function (tabbar, tab) {
              set$8(tab.element, 'aria-selected', 'true');
            },
            onDehighlight: function (tabbar, tab) {
              set$8(tab.element, 'aria-selected', 'false');
            }
          }),
          Keying.config({
            mode: 'flow',
            getInitial: function (tabbar) {
              return Highlighting.getHighlighted(tabbar).map(function (tab) {
                return tab.element;
              });
            },
            selector: '.' + detail.markers.tabClass,
            executeOnMove: true
          })
        ])
      };
    };
    var Tabbar = composite({
      name: 'Tabbar',
      configFields: schema$1(),
      partFields: parts$1(),
      factory: factory$2
    });

    var factory$1 = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),
        domModification: { attributes: { role: 'tabpanel' } }
      };
    };
    var Tabview = single({
      name: 'Tabview',
      configFields: [field('tabviewBehaviours', [Replacing])],
      factory: factory$1
    });

    var schema = constant$1([
      defaulted('selectFirst', true),
      onHandler('onChangeTab'),
      onHandler('onDismissTab'),
      defaulted('tabs', []),
      field('tabSectionBehaviours', [])
    ]);
    var barPart = required({
      factory: Tabbar,
      schema: [
        required$1('dom'),
        requiredObjOf('markers', [
          required$1('tabClass'),
          required$1('selectedClass')
        ])
      ],
      name: 'tabbar',
      defaults: function (detail) {
        return { tabs: detail.tabs };
      }
    });
    var viewPart = required({
      factory: Tabview,
      name: 'tabview'
    });
    var parts = constant$1([
      barPart,
      viewPart
    ]);

    var factory = function (detail, components, _spec, _externals) {
      var changeTab$1 = function (button) {
        var tabValue = Representing.getValue(button);
        getPart(button, detail, 'tabview').each(function (tabview) {
          var tabWithValue = find$5(detail.tabs, function (t) {
            return t.value === tabValue;
          });
          tabWithValue.each(function (tabData) {
            var panel = tabData.view();
            getOpt(button.element, 'id').each(function (id) {
              set$8(tabview.element, 'aria-labelledby', id);
            });
            Replacing.set(tabview, panel);
            detail.onChangeTab(tabview, button, panel);
          });
        });
      };
      var changeTabBy = function (section, byPred) {
        getPart(section, detail, 'tabbar').each(function (tabbar) {
          byPred(tabbar).each(emitExecute);
        });
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: get$2(detail.tabSectionBehaviours),
        events: derive$2(flatten([
          detail.selectFirst ? [runOnAttached(function (section, _simulatedEvent) {
              changeTabBy(section, Highlighting.getFirst);
            })] : [],
          [
            run$1(changeTab(), function (section, simulatedEvent) {
              var button = simulatedEvent.event.button;
              changeTab$1(button);
            }),
            run$1(dismissTab(), function (section, simulatedEvent) {
              var button = simulatedEvent.event.button;
              detail.onDismissTab(section, button);
            })
          ]
        ])),
        apis: {
          getViewItems: function (section) {
            return getPart(section, detail, 'tabview').map(function (tabview) {
              return Replacing.contents(tabview);
            }).getOr([]);
          },
          showTab: function (section, tabKey) {
            var getTabIfNotActive = function (tabbar) {
              var candidates = Highlighting.getCandidates(tabbar);
              var optTab = find$5(candidates, function (c) {
                return Representing.getValue(c) === tabKey;
              });
              return optTab.filter(function (tab) {
                return !Highlighting.isHighlighted(tabbar, tab);
              });
            };
            changeTabBy(section, getTabIfNotActive);
          }
        }
      };
    };
    var TabSection = composite({
      name: 'TabSection',
      configFields: schema(),
      partFields: parts(),
      factory: factory,
      apis: {
        getViewItems: function (apis, component) {
          return apis.getViewItems(component);
        },
        showTab: function (apis, component, tabKey) {
          apis.showTab(component, tabKey);
        }
      }
    });

    var measureHeights = function (allTabs, tabview, tabviewComp) {
      return map$2(allTabs, function (_tab, i) {
        Replacing.set(tabviewComp, allTabs[i].view());
        var rect = tabview.dom.getBoundingClientRect();
        Replacing.set(tabviewComp, []);
        return rect.height;
      });
    };
    var getMaxHeight = function (heights) {
      return head(sort(heights, function (a, b) {
        if (a > b) {
          return -1;
        } else if (a < b) {
          return +1;
        } else {
          return 0;
        }
      }));
    };
    var getMaxTabviewHeight = function (dialog, tabview, tablist) {
      var documentElement$1 = documentElement(dialog).dom;
      var rootElm = ancestor(dialog, '.tox-dialog-wrap').getOr(dialog);
      var isFixed = get$c(rootElm, 'position') === 'fixed';
      var maxHeight;
      if (isFixed) {
        maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);
      } else {
        maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
      }
      var tabviewHeight = get$b(tabview);
      var isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$a(tablist);
      var currentTabHeight = isTabListBeside ? Math.max(get$b(tablist), tabviewHeight) : tabviewHeight;
      var dialogTopMargin = parseInt(get$c(dialog, 'margin-top'), 10) || 0;
      var dialogBottomMargin = parseInt(get$c(dialog, 'margin-bottom'), 10) || 0;
      var dialogHeight = get$b(dialog) + dialogTopMargin + dialogBottomMargin;
      var chromeHeight = dialogHeight - currentTabHeight;
      return maxHeight - chromeHeight;
    };
    var showTab = function (allTabs, comp) {
      head(allTabs).each(function (tab) {
        return TabSection.showTab(comp, tab.value);
      });
    };
    var setTabviewHeight = function (tabview, height) {
      set$7(tabview, 'height', height + 'px');
      if (!detect$1().browser.isIE()) {
        set$7(tabview, 'flex-basis', height + 'px');
      } else {
        remove$6(tabview, 'flex-basis');
      }
    };
    var updateTabviewHeight = function (dialogBody, tabview, maxTabHeight) {
      ancestor(dialogBody, '[role="dialog"]').each(function (dialog) {
        descendant(dialog, '[role="tablist"]').each(function (tablist) {
          maxTabHeight.get().map(function (height) {
            set$7(tabview, 'height', '0');
            set$7(tabview, 'flex-basis', '0');
            return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));
          }).each(function (height) {
            setTabviewHeight(tabview, height);
          });
        });
      });
    };
    var getTabview = function (dialog) {
      return descendant(dialog, '[role="tabpanel"]');
    };
    var setMode = function (allTabs) {
      var smartTabHeight = function () {
        var maxTabHeight = value$1();
        var extraEvents = [
          runOnAttached(function (comp) {
            var dialog = comp.element;
            getTabview(dialog).each(function (tabview) {
              set$7(tabview, 'visibility', 'hidden');
              comp.getSystem().getByDom(tabview).toOptional().each(function (tabviewComp) {
                var heights = measureHeights(allTabs, tabview, tabviewComp);
                var maxTabHeightOpt = getMaxHeight(heights);
                maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);
              });
              updateTabviewHeight(dialog, tabview, maxTabHeight);
              remove$6(tabview, 'visibility');
              showTab(allTabs, comp);
              global$f.requestAnimationFrame(function () {
                updateTabviewHeight(dialog, tabview, maxTabHeight);
              });
            });
          }),
          run$1(windowResize(), function (comp) {
            var dialog = comp.element;
            getTabview(dialog).each(function (tabview) {
              updateTabviewHeight(dialog, tabview, maxTabHeight);
            });
          }),
          run$1(formResizeEvent, function (comp, _se) {
            var dialog = comp.element;
            getTabview(dialog).each(function (tabview) {
              var oldFocus = active(getRootNode(tabview));
              set$7(tabview, 'visibility', 'hidden');
              var oldHeight = getRaw(tabview, 'height').map(function (h) {
                return parseInt(h, 10);
              });
              remove$6(tabview, 'height');
              remove$6(tabview, 'flex-basis');
              var newHeight = tabview.dom.getBoundingClientRect().height;
              var hasGrown = oldHeight.forall(function (h) {
                return newHeight > h;
              });
              if (hasGrown) {
                maxTabHeight.set(newHeight);
                updateTabviewHeight(dialog, tabview, maxTabHeight);
              } else {
                oldHeight.each(function (h) {
                  setTabviewHeight(tabview, h);
                });
              }
              remove$6(tabview, 'visibility');
              oldFocus.each(focus$3);
            });
          })
        ];
        var selectFirst = false;
        return {
          extraEvents: extraEvents,
          selectFirst: selectFirst
        };
      }();
      var naiveTabHeight = function () {
        var extraEvents = [];
        var selectFirst = true;
        return {
          extraEvents: extraEvents,
          selectFirst: selectFirst
        };
      }();
      return {
        smartTabHeight: smartTabHeight,
        naiveTabHeight: naiveTabHeight
      };
    };

    var SendDataToSectionChannel = 'send-data-to-section';
    var SendDataToViewChannel = 'send-data-to-view';
    var renderTabPanel = function (spec, backstage) {
      var storedValue = Cell({});
      var updateDataWithForm = function (form) {
        var formData = Representing.getValue(form);
        var validData = toValidValues(formData).getOr({});
        var currentData = storedValue.get();
        var newData = deepMerge(currentData, validData);
        storedValue.set(newData);
      };
      var setDataOnForm = function (form) {
        var tabData = storedValue.get();
        Representing.setValue(form, tabData);
      };
      var oldTab = Cell(null);
      var allTabs = map$2(spec.tabs, function (tab) {
        return {
          value: tab.name,
          dom: {
            tag: 'div',
            classes: ['tox-dialog__body-nav-item'],
            innerHtml: backstage.shared.providers.translate(tab.title)
          },
          view: function () {
            return [Form.sketch(function (parts) {
                return {
                  dom: {
                    tag: 'div',
                    classes: ['tox-form']
                  },
                  components: map$2(tab.items, function (item) {
                    return interpretInForm(parts, item, backstage);
                  }),
                  formBehaviours: derive$1([
                    Keying.config({
                      mode: 'acyclic',
                      useTabstopAt: not(isPseudoStop)
                    }),
                    config('TabView.form.events', [
                      runOnAttached(setDataOnForm),
                      runOnDetached(updateDataWithForm)
                    ]),
                    Receiving.config({
                      channels: wrapAll([
                        {
                          key: SendDataToSectionChannel,
                          value: { onReceive: updateDataWithForm }
                        },
                        {
                          key: SendDataToViewChannel,
                          value: { onReceive: setDataOnForm }
                        }
                      ])
                    })
                  ])
                };
              })];
          }
        };
      });
      var tabMode = setMode(allTabs).smartTabHeight;
      return TabSection.sketch({
        dom: {
          tag: 'div',
          classes: ['tox-dialog__body']
        },
        onChangeTab: function (section, button, _viewItems) {
          var name = Representing.getValue(button);
          emitWith(section, formTabChangeEvent, {
            name: name,
            oldName: oldTab.get()
          });
          oldTab.set(name);
        },
        tabs: allTabs,
        components: [
          TabSection.parts.tabbar({
            dom: {
              tag: 'div',
              classes: ['tox-dialog__body-nav']
            },
            components: [Tabbar.parts.tabs({})],
            markers: {
              tabClass: 'tox-tab',
              selectedClass: 'tox-dialog__body-nav-item--active'
            },
            tabbarBehaviours: derive$1([Tabstopping.config({})])
          }),
          TabSection.parts.tabview({
            dom: {
              tag: 'div',
              classes: ['tox-dialog__body-content']
            }
          })
        ],
        selectFirst: tabMode.selectFirst,
        tabSectionBehaviours: derive$1([
          config('tabpanel', tabMode.extraEvents),
          Keying.config({ mode: 'acyclic' }),
          Composing.config({
            find: function (comp) {
              return head(TabSection.getViewItems(comp));
            }
          }),
          Representing.config({
            store: {
              mode: 'manual',
              getValue: function (tsection) {
                tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});
                return storedValue.get();
              },
              setValue: function (tsection, value) {
                storedValue.set(value);
                tsection.getSystem().broadcastOn([SendDataToViewChannel], {});
              }
            }
          })
        ])
      });
    };

    var dialogChannel = generate$6('update-dialog');
    var titleChannel = generate$6('update-title');
    var bodyChannel = generate$6('update-body');
    var footerChannel = generate$6('update-footer');
    var bodySendMessageChannel = generate$6('body-send-message');

    var renderBody = function (spec, id, backstage, ariaAttrs) {
      var renderComponents = function (incoming) {
        switch (incoming.body.type) {
        case 'tabpanel': {
            return [renderTabPanel(incoming.body, backstage)];
          }
        default: {
            return [renderBodyPanel(incoming.body, backstage)];
          }
        }
      };
      var updateState = function (_comp, incoming) {
        return Optional.some({
          isTabPanel: function () {
            return incoming.body.type === 'tabpanel';
          }
        });
      };
      var ariaAttributes = { 'aria-live': 'polite' };
      return {
        dom: {
          tag: 'div',
          classes: ['tox-dialog__content-js'],
          attributes: __assign(__assign({}, id.map(function (x) {
            return { id: x };
          }).getOr({})), ariaAttrs ? ariaAttributes : {})
        },
        components: [],
        behaviours: derive$1([
          ComposingConfigs.childAt(0),
          Reflecting.config({
            channel: bodyChannel,
            updateState: updateState,
            renderComponents: renderComponents,
            initialData: spec
          })
        ])
      };
    };
    var renderInlineBody = function (spec, contentId, backstage, ariaAttrs) {
      return renderBody(spec, Optional.some(contentId), backstage, ariaAttrs);
    };
    var renderModalBody = function (spec, backstage) {
      var bodySpec = renderBody(spec, Optional.none(), backstage, false);
      return ModalDialog.parts.body(bodySpec);
    };
    var renderIframeBody = function (spec) {
      var bodySpec = {
        dom: {
          tag: 'div',
          classes: ['tox-dialog__content-js']
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-dialog__body-iframe']
            },
            components: [craft({
                dom: {
                  tag: 'iframe',
                  attributes: { src: spec.url }
                },
                behaviours: derive$1([
                  Tabstopping.config({}),
                  Focusing.config({})
                ])
              })]
          }],
        behaviours: derive$1([Keying.config({
            mode: 'acyclic',
            useTabstopAt: not(isPseudoStop)
          })])
      };
      return ModalDialog.parts.body(bodySpec);
    };

    var isTouch = global$9.deviceType.isTouch();
    var hiddenHeader = function (title, close) {
      return {
        dom: {
          tag: 'div',
          styles: { display: 'none' },
          classes: ['tox-dialog__header']
        },
        components: [
          title,
          close
        ]
      };
    };
    var pClose = function (onClose, providersBackstage) {
      return ModalDialog.parts.close(Button.sketch({
        dom: {
          tag: 'button',
          classes: [
            'tox-button',
            'tox-button--icon',
            'tox-button--naked'
          ],
          attributes: {
            'type': 'button',
            'aria-label': providersBackstage.translate('Close')
          }
        },
        action: onClose,
        buttonBehaviours: derive$1([Tabstopping.config({})])
      }));
    };
    var pUntitled = function () {
      return ModalDialog.parts.title({
        dom: {
          tag: 'div',
          classes: ['tox-dialog__title'],
          innerHtml: '',
          styles: { display: 'none' }
        }
      });
    };
    var pBodyMessage = function (message, providersBackstage) {
      return ModalDialog.parts.body({
        dom: {
          tag: 'div',
          classes: ['tox-dialog__body']
        },
        components: [{
            dom: {
              tag: 'div',
              classes: ['tox-dialog__body-content']
            },
            components: [{ dom: fromHtml('<p>' + providersBackstage.translate(message) + '</p>') }]
          }]
      });
    };
    var pFooter = function (buttons) {
      return ModalDialog.parts.footer({
        dom: {
          tag: 'div',
          classes: ['tox-dialog__footer']
        },
        components: buttons
      });
    };
    var pFooterGroup = function (startButtons, endButtons) {
      return [
        Container.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-dialog__footer-start']
          },
          components: startButtons
        }),
        Container.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-dialog__footer-end']
          },
          components: endButtons
        })
      ];
    };
    var renderDialog$1 = function (spec) {
      var _a;
      var dialogClass = 'tox-dialog';
      var blockerClass = dialogClass + '-wrap';
      var blockerBackdropClass = blockerClass + '__backdrop';
      var scrollLockClass = dialogClass + '__disable-scroll';
      return ModalDialog.sketch({
        lazySink: spec.lazySink,
        onEscape: function (comp) {
          spec.onEscape(comp);
          return Optional.some(true);
        },
        useTabstopAt: function (elem) {
          return !isPseudoStop(elem);
        },
        dom: {
          tag: 'div',
          classes: [dialogClass].concat(spec.extraClasses),
          styles: __assign({ position: 'relative' }, spec.extraStyles)
        },
        components: __spreadArray([
          spec.header,
          spec.body
        ], spec.footer.toArray(), true),
        parts: {
          blocker: {
            dom: fromHtml('<div class="' + blockerClass + '"></div>'),
            components: [{
                dom: {
                  tag: 'div',
                  classes: isTouch ? [
                    blockerBackdropClass,
                    blockerBackdropClass + '--opaque'
                  ] : [blockerBackdropClass]
                }
              }]
          }
        },
        dragBlockClass: blockerClass,
        modalBehaviours: derive$1(__spreadArray([
          Focusing.config({}),
          config('dialog-events', spec.dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {
              Keying.focusIn(comp);
            })])),
          config('scroll-lock', [
            runOnAttached(function () {
              add$2(body(), scrollLockClass);
            }),
            runOnDetached(function () {
              remove$2(body(), scrollLockClass);
            })
          ])
        ], spec.extraBehaviours, true)),
        eventOrder: __assign((_a = {}, _a[execute$5()] = ['dialog-events'], _a[attachedToDom()] = [
          'scroll-lock',
          'dialog-events',
          'alloy.base.behaviour'
        ], _a[detachedFromDom()] = [
          'alloy.base.behaviour',
          'dialog-events',
          'scroll-lock'
        ], _a), spec.eventOrder)
      });
    };

    var renderClose = function (providersBackstage) {
      return Button.sketch({
        dom: {
          tag: 'button',
          classes: [
            'tox-button',
            'tox-button--icon',
            'tox-button--naked'
          ],
          attributes: {
            'type': 'button',
            'aria-label': providersBackstage.translate('Close'),
            'title': providersBackstage.translate('Close')
          }
        },
        components: [render$3('close', {
            tag: 'div',
            classes: ['tox-icon']
          }, providersBackstage.icons)],
        action: function (comp) {
          emit(comp, formCancelEvent);
        }
      });
    };
    var renderTitle = function (spec, id, providersBackstage) {
      var renderComponents = function (data) {
        return [text(providersBackstage.translate(data.title))];
      };
      return {
        dom: {
          tag: 'div',
          classes: ['tox-dialog__title'],
          attributes: __assign({}, id.map(function (x) {
            return { id: x };
          }).getOr({}))
        },
        components: renderComponents(spec),
        behaviours: derive$1([Reflecting.config({
            channel: titleChannel,
            renderComponents: renderComponents
          })])
      };
    };
    var renderDragHandle = function () {
      return { dom: fromHtml('<div class="tox-dialog__draghandle"></div>') };
    };
    var renderInlineHeader = function (spec, titleId, providersBackstage) {
      return Container.sketch({
        dom: fromHtml('<div class="tox-dialog__header"></div>'),
        components: [
          renderTitle(spec, Optional.some(titleId), providersBackstage),
          renderDragHandle(),
          renderClose(providersBackstage)
        ],
        containerBehaviours: derive$1([Dragging.config({
            mode: 'mouse',
            blockerClass: 'blocker',
            getTarget: function (handle) {
              return closest$1(handle, '[role="dialog"]').getOrDie();
            },
            snaps: {
              getSnapPoints: function () {
                return [];
              },
              leftAttr: 'data-drag-left',
              topAttr: 'data-drag-top'
            }
          })])
      });
    };
    var renderModalHeader = function (spec, providersBackstage) {
      var pTitle = ModalDialog.parts.title(renderTitle(spec, Optional.none(), providersBackstage));
      var pHandle = ModalDialog.parts.draghandle(renderDragHandle());
      var pClose = ModalDialog.parts.close(renderClose(providersBackstage));
      var components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);
      return Container.sketch({
        dom: fromHtml('<div class="tox-dialog__header"></div>'),
        components: components
      });
    };

    var getHeader = function (title, backstage) {
      return renderModalHeader({
        title: backstage.shared.providers.translate(title),
        draggable: backstage.dialog.isDraggableModal()
      }, backstage.shared.providers);
    };
    var getBusySpec = function (message, bs, providers) {
      return {
        dom: {
          tag: 'div',
          classes: ['tox-dialog__busy-spinner'],
          attributes: { 'aria-label': providers.translate(message) },
          styles: {
            left: '0px',
            right: '0px',
            bottom: '0px',
            top: '0px',
            position: 'absolute'
          }
        },
        behaviours: bs,
        components: [{ dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
      };
    };
    var getEventExtras = function (lazyDialog, providers, extra) {
      return {
        onClose: function () {
          return extra.closeWindow();
        },
        onBlock: function (blockEvent) {
          ModalDialog.setBusy(lazyDialog(), function (_comp, bs) {
            return getBusySpec(blockEvent.message, bs, providers);
          });
        },
        onUnblock: function () {
          ModalDialog.setIdle(lazyDialog());
        }
      };
    };
    var renderModalDialog = function (spec, initialData, dialogEvents, backstage) {
      var _a;
      var updateState = function (_comp, incoming) {
        return Optional.some(incoming);
      };
      return build$1(renderDialog$1(__assign(__assign({}, spec), {
        lazySink: backstage.shared.getSink,
        extraBehaviours: __spreadArray([
          Reflecting.config({
            channel: dialogChannel,
            updateState: updateState,
            initialData: initialData
          }),
          RepresentingConfigs.memory({})
        ], spec.extraBehaviours, true),
        onEscape: function (comp) {
          emit(comp, formCancelEvent);
        },
        dialogEvents: dialogEvents,
        eventOrder: (_a = {}, _a[receive()] = [
          Reflecting.name(),
          Receiving.name()
        ], _a[attachedToDom()] = [
          'scroll-lock',
          Reflecting.name(),
          'messages',
          'dialog-events',
          'alloy.base.behaviour'
        ], _a[detachedFromDom()] = [
          'alloy.base.behaviour',
          'dialog-events',
          'messages',
          Reflecting.name(),
          'scroll-lock'
        ], _a)
      })));
    };
    var mapMenuButtons = function (buttons) {
      var mapItems = function (button) {
        var items = map$2(button.items, function (item) {
          var cell = Cell(false);
          return __assign(__assign({}, item), { storage: cell });
        });
        return __assign(__assign({}, button), { items: items });
      };
      return map$2(buttons, function (button) {
        if (button.type === 'menu') {
          return mapItems(button);
        }
        return button;
      });
    };
    var extractCellsToObject = function (buttons) {
      return foldl(buttons, function (acc, button) {
        if (button.type === 'menu') {
          var menuButton = button;
          return foldl(menuButton.items, function (innerAcc, item) {
            innerAcc[item.name] = item.storage;
            return innerAcc;
          }, acc);
        }
        return acc;
      }, {});
    };

    var initCommonEvents = function (fireApiEvent, extras) {
      return [
        runWithTarget(focusin(), onFocus),
        fireApiEvent(formCloseEvent, function (_api, spec) {
          extras.onClose();
          spec.onClose();
        }),
        fireApiEvent(formCancelEvent, function (api, spec, _event, self) {
          spec.onCancel(api);
          emit(self, formCloseEvent);
        }),
        run$1(formUnblockEvent, function (_c, _se) {
          return extras.onUnblock();
        }),
        run$1(formBlockEvent, function (_c, se) {
          return extras.onBlock(se.event);
        })
      ];
    };
    var initUrlDialog = function (getInstanceApi, extras) {
      var fireApiEvent = function (eventName, f) {
        return run$1(eventName, function (c, se) {
          withSpec(c, function (spec, _c) {
            f(getInstanceApi(), spec, se.event, c);
          });
        });
      };
      var withSpec = function (c, f) {
        Reflecting.getState(c).get().each(function (currentDialog) {
          f(currentDialog, c);
        });
      };
      return __spreadArray(__spreadArray([], initCommonEvents(fireApiEvent, extras), true), [fireApiEvent(formActionEvent, function (api, spec, event) {
          spec.onAction(api, { name: event.name });
        })], false);
    };
    var initDialog = function (getInstanceApi, extras, getSink) {
      var fireApiEvent = function (eventName, f) {
        return run$1(eventName, function (c, se) {
          withSpec(c, function (spec, _c) {
            f(getInstanceApi(), spec, se.event, c);
          });
        });
      };
      var withSpec = function (c, f) {
        Reflecting.getState(c).get().each(function (currentDialogInit) {
          f(currentDialogInit.internalDialog, c);
        });
      };
      return __spreadArray(__spreadArray([], initCommonEvents(fireApiEvent, extras), true), [
        fireApiEvent(formSubmitEvent, function (api, spec) {
          return spec.onSubmit(api);
        }),
        fireApiEvent(formChangeEvent, function (api, spec, event) {
          spec.onChange(api, { name: event.name });
        }),
        fireApiEvent(formActionEvent, function (api, spec, event, component) {
          var focusIn = function () {
            return Keying.focusIn(component);
          };
          var isDisabled = function (focused) {
            return has$1(focused, 'disabled') || getOpt(focused, 'aria-disabled').exists(function (val) {
              return val === 'true';
            });
          };
          var rootNode = getRootNode(component.element);
          var current = active(rootNode);
          spec.onAction(api, {
            name: event.name,
            value: event.value
          });
          active(rootNode).fold(focusIn, function (focused) {
            if (isDisabled(focused)) {
              focusIn();
            } else if (current.exists(function (cur) {
                return contains(focused, cur) && isDisabled(cur);
              })) {
              focusIn();
            } else {
              getSink().toOptional().filter(function (sink) {
                return !contains(sink.element, focused);
              }).each(focusIn);
            }
          });
        }),
        fireApiEvent(formTabChangeEvent, function (api, spec, event) {
          spec.onTabChange(api, {
            newTabName: event.name,
            oldTabName: event.oldName
          });
        }),
        runOnDetached(function (component) {
          var api = getInstanceApi();
          Representing.setValue(component, api.getData());
        })
      ], false);
    };
    var SilverDialogEvents = {
      initUrlDialog: initUrlDialog,
      initDialog: initDialog
    };

    var makeButton = function (button, backstage) {
      return renderFooterButton(button, button.type, backstage);
    };
    var lookup = function (compInSystem, footerButtons, buttonName) {
      return find$5(footerButtons, function (button) {
        return button.name === buttonName;
      }).bind(function (memButton) {
        return memButton.memento.getOpt(compInSystem);
      });
    };
    var renderComponents = function (_data, state) {
      var footerButtons = state.map(function (s) {
        return s.footerButtons;
      }).getOr([]);
      var buttonGroups = partition$3(footerButtons, function (button) {
        return button.align === 'start';
      });
      var makeGroup = function (edge, buttons) {
        return Container.sketch({
          dom: {
            tag: 'div',
            classes: ['tox-dialog__footer-' + edge]
          },
          components: map$2(buttons, function (button) {
            return button.memento.asSpec();
          })
        });
      };
      var startButtons = makeGroup('start', buttonGroups.pass);
      var endButtons = makeGroup('end', buttonGroups.fail);
      return [
        startButtons,
        endButtons
      ];
    };
    var renderFooter = function (initSpec, backstage) {
      var updateState = function (_comp, data) {
        var footerButtons = map$2(data.buttons, function (button) {
          var memButton = record(makeButton(button, backstage));
          return {
            name: button.name,
            align: button.align,
            memento: memButton
          };
        });
        var lookupByName = function (compInSystem, buttonName) {
          return lookup(compInSystem, footerButtons, buttonName);
        };
        return Optional.some({
          lookupByName: lookupByName,
          footerButtons: footerButtons
        });
      };
      return {
        dom: fromHtml('<div class="tox-dialog__footer"></div>'),
        components: [],
        behaviours: derive$1([Reflecting.config({
            channel: footerChannel,
            initialData: initSpec,
            updateState: updateState,
            renderComponents: renderComponents
          })])
      };
    };
    var renderInlineFooter = function (initSpec, backstage) {
      return renderFooter(initSpec, backstage);
    };
    var renderModalFooter = function (initSpec, backstage) {
      return ModalDialog.parts.footer(renderFooter(initSpec, backstage));
    };

    var getCompByName = function (access, name) {
      var root = access.getRoot();
      if (root.getSystem().isConnected()) {
        var form_1 = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
        return Form.getField(form_1, name).fold(function () {
          var footer = access.getFooter();
          var footerState = Reflecting.getState(footer);
          return footerState.get().bind(function (f) {
            return f.lookupByName(form_1, name);
          });
        }, function (comp) {
          return Optional.some(comp);
        });
      } else {
        return Optional.none();
      }
    };
    var validateData$1 = function (access, data) {
      var root = access.getRoot();
      return Reflecting.getState(root).get().map(function (dialogState) {
        return getOrDie(asRaw('data', dialogState.dataValidator, data));
      }).getOr(data);
    };
    var getDialogApi = function (access, doRedial, menuItemStates) {
      var withRoot = function (f) {
        var root = access.getRoot();
        if (root.getSystem().isConnected()) {
          f(root);
        }
      };
      var getData = function () {
        var root = access.getRoot();
        var valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;
        var representedValues = Representing.getValue(valueComp);
        var menuItemCurrentState = map$1(menuItemStates, function (cell) {
          return cell.get();
        });
        return __assign(__assign({}, representedValues), menuItemCurrentState);
      };
      var setData = function (newData) {
        withRoot(function (_) {
          var prevData = instanceApi.getData();
          var mergedData = __assign(__assign({}, prevData), newData);
          var newInternalData = validateData$1(access, mergedData);
          var form = access.getFormWrapper();
          Representing.setValue(form, newInternalData);
          each(menuItemStates, function (v, k) {
            if (has$2(mergedData, k)) {
              v.set(mergedData[k]);
            }
          });
        });
      };
      var disable = function (name) {
        getCompByName(access, name).each(Disabling.disable);
      };
      var enable = function (name) {
        getCompByName(access, name).each(Disabling.enable);
      };
      var focus = function (name) {
        getCompByName(access, name).each(Focusing.focus);
      };
      var block = function (message) {
        if (!isString(message)) {
          throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
        }
        withRoot(function (root) {
          emitWith(root, formBlockEvent, { message: message });
        });
      };
      var unblock = function () {
        withRoot(function (root) {
          emit(root, formUnblockEvent);
        });
      };
      var showTab = function (name) {
        withRoot(function (_) {
          var body = access.getBody();
          var bodyState = Reflecting.getState(body);
          if (bodyState.get().exists(function (b) {
              return b.isTabPanel();
            })) {
            Composing.getCurrent(body).each(function (tabSection) {
              TabSection.showTab(tabSection, name);
            });
          }
        });
      };
      var redial = function (d) {
        withRoot(function (root) {
          var dialogInit = doRedial(d);
          root.getSystem().broadcastOn([dialogChannel], dialogInit);
          root.getSystem().broadcastOn([titleChannel], dialogInit.internalDialog);
          root.getSystem().broadcastOn([bodyChannel], dialogInit.internalDialog);
          root.getSystem().broadcastOn([footerChannel], dialogInit.internalDialog);
          instanceApi.setData(dialogInit.initialData);
        });
      };
      var close = function () {
        withRoot(function (root) {
          emit(root, formCloseEvent);
        });
      };
      var instanceApi = {
        getData: getData,
        setData: setData,
        disable: disable,
        enable: enable,
        focus: focus,
        block: block,
        unblock: unblock,
        showTab: showTab,
        redial: redial,
        close: close
      };
      return instanceApi;
    };

    var getDialogSizeClasses = function (size) {
      switch (size) {
      case 'large':
        return ['tox-dialog--width-lg'];
      case 'medium':
        return ['tox-dialog--width-md'];
      default:
        return [];
      }
    };
    var renderDialog = function (dialogInit, extra, backstage) {
      var header = getHeader(dialogInit.internalDialog.title, backstage);
      var body = renderModalBody({ body: dialogInit.internalDialog.body }, backstage);
      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);
      var objOfCells = extractCellsToObject(storagedMenuButtons);
      var footer = renderModalFooter({ buttons: storagedMenuButtons }, backstage);
      var dialogEvents = SilverDialogEvents.initDialog(function () {
        return instanceApi;
      }, getEventExtras(function () {
        return dialog;
      }, backstage.shared.providers, extra), backstage.shared.getSink);
      var dialogSize = getDialogSizeClasses(dialogInit.internalDialog.size);
      var spec = {
        header: header,
        body: body,
        footer: Optional.some(footer),
        extraClasses: dialogSize,
        extraBehaviours: [],
        extraStyles: {}
      };
      var dialog = renderModalDialog(spec, dialogInit, dialogEvents, backstage);
      var modalAccess = function () {
        var getForm = function () {
          var outerForm = ModalDialog.getBody(dialog);
          return Composing.getCurrent(outerForm).getOr(outerForm);
        };
        return {
          getRoot: constant$1(dialog),
          getBody: function () {
            return ModalDialog.getBody(dialog);
          },
          getFooter: function () {
            return ModalDialog.getFooter(dialog);
          },
          getFormWrapper: getForm
        };
      }();
      var instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var renderInlineDialog = function (dialogInit, extra, backstage, ariaAttrs) {
      var _a, _b;
      var dialogLabelId = generate$6('dialog-label');
      var dialogContentId = generate$6('dialog-content');
      var updateState = function (_comp, incoming) {
        return Optional.some(incoming);
      };
      var memHeader = record(renderInlineHeader({
        title: dialogInit.internalDialog.title,
        draggable: true
      }, dialogLabelId, backstage.shared.providers));
      var memBody = record(renderInlineBody({ body: dialogInit.internalDialog.body }, dialogContentId, backstage, ariaAttrs));
      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);
      var objOfCells = extractCellsToObject(storagedMenuButtons);
      var memFooter = record(renderInlineFooter({ buttons: storagedMenuButtons }, backstage));
      var dialogEvents = SilverDialogEvents.initDialog(function () {
        return instanceApi;
      }, {
        onBlock: function (event) {
          Blocking.block(dialog, function (_comp, bs) {
            return getBusySpec(event.message, bs, backstage.shared.providers);
          });
        },
        onUnblock: function () {
          Blocking.unblock(dialog);
        },
        onClose: function () {
          return extra.closeWindow();
        }
      }, backstage.shared.getSink);
      var dialog = build$1({
        dom: {
          tag: 'div',
          classes: [
            'tox-dialog',
            'tox-dialog-inline'
          ],
          attributes: (_a = { role: 'dialog' }, _a['aria-labelledby'] = dialogLabelId, _a['aria-describedby'] = dialogContentId, _a)
        },
        eventOrder: (_b = {}, _b[receive()] = [
          Reflecting.name(),
          Receiving.name()
        ], _b[execute$5()] = ['execute-on-form'], _b[attachedToDom()] = [
          'reflecting',
          'execute-on-form'
        ], _b),
        behaviours: derive$1([
          Keying.config({
            mode: 'cyclic',
            onEscape: function (c) {
              emit(c, formCloseEvent);
              return Optional.some(true);
            },
            useTabstopAt: function (elem) {
              return !isPseudoStop(elem) && (name$2(elem) !== 'button' || get$d(elem, 'disabled') !== 'disabled');
            }
          }),
          Reflecting.config({
            channel: dialogChannel,
            updateState: updateState,
            initialData: dialogInit
          }),
          Focusing.config({}),
          config('execute-on-form', dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {
              Keying.focusIn(comp);
            })])),
          Blocking.config({
            getRoot: function () {
              return Optional.some(dialog);
            }
          }),
          Replacing.config({}),
          RepresentingConfigs.memory({})
        ]),
        components: [
          memHeader.asSpec(),
          memBody.asSpec(),
          memFooter.asSpec()
        ]
      });
      var instanceApi = getDialogApi({
        getRoot: constant$1(dialog),
        getFooter: function () {
          return memFooter.get(dialog);
        },
        getBody: function () {
          return memBody.get(dialog);
        },
        getFormWrapper: function () {
          var body = memBody.get(dialog);
          return Composing.getCurrent(body).getOr(body);
        }
      }, extra.redial, objOfCells);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.URI');

    var getUrlDialogApi = function (root) {
      var withRoot = function (f) {
        if (root.getSystem().isConnected()) {
          f(root);
        }
      };
      var block = function (message) {
        if (!isString(message)) {
          throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');
        }
        withRoot(function (root) {
          emitWith(root, formBlockEvent, { message: message });
        });
      };
      var unblock = function () {
        withRoot(function (root) {
          emit(root, formUnblockEvent);
        });
      };
      var close = function () {
        withRoot(function (root) {
          emit(root, formCloseEvent);
        });
      };
      var sendMessage = function (data) {
        withRoot(function (root) {
          root.getSystem().broadcastOn([bodySendMessageChannel], data);
        });
      };
      return {
        block: block,
        unblock: unblock,
        close: close,
        sendMessage: sendMessage
      };
    };

    var SUPPORTED_MESSAGE_ACTIONS = [
      'insertContent',
      'setContent',
      'execCommand',
      'close',
      'block',
      'unblock'
    ];
    var isSupportedMessage = function (data) {
      return isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;
    };
    var isCustomMessage = function (data) {
      return !isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction');
    };
    var handleMessage = function (editor, api, data) {
      switch (data.mceAction) {
      case 'insertContent':
        editor.insertContent(data.content);
        break;
      case 'setContent':
        editor.setContent(data.content);
        break;
      case 'execCommand':
        var ui = isBoolean(data.ui) ? data.ui : false;
        editor.execCommand(data.cmd, ui, data.value);
        break;
      case 'close':
        api.close();
        break;
      case 'block':
        api.block(data.message);
        break;
      case 'unblock':
        api.unblock();
        break;
      }
    };
    var renderUrlDialog = function (internalDialog, extra, editor, backstage) {
      var _a;
      var header = getHeader(internalDialog.title, backstage);
      var body = renderIframeBody(internalDialog);
      var footer = internalDialog.buttons.bind(function (buttons) {
        if (buttons.length === 0) {
          return Optional.none();
        } else {
          return Optional.some(renderModalFooter({ buttons: buttons }, backstage));
        }
      });
      var dialogEvents = SilverDialogEvents.initUrlDialog(function () {
        return instanceApi;
      }, getEventExtras(function () {
        return dialog;
      }, backstage.shared.providers, extra));
      var styles = __assign(__assign({}, internalDialog.height.fold(function () {
        return {};
      }, function (height) {
        return {
          'height': height + 'px',
          'max-height': height + 'px'
        };
      })), internalDialog.width.fold(function () {
        return {};
      }, function (width) {
        return {
          'width': width + 'px',
          'max-width': width + 'px'
        };
      }));
      var classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? ['tox-dialog--width-lg'] : [];
      var iframeUri = new global$1(internalDialog.url, { base_uri: new global$1(window.location.href) });
      var iframeDomain = iframeUri.protocol + '://' + iframeUri.host + (iframeUri.port ? ':' + iframeUri.port : '');
      var messageHandlerUnbinder = unbindable();
      var extraBehaviours = [
        config('messages', [
          runOnAttached(function () {
            var unbind = bind(SugarElement.fromDom(window), 'message', function (e) {
              if (iframeUri.isSameOrigin(new global$1(e.raw.origin))) {
                var data = e.raw.data;
                if (isSupportedMessage(data)) {
                  handleMessage(editor, instanceApi, data);
                } else if (isCustomMessage(data)) {
                  internalDialog.onMessage(instanceApi, data);
                }
              }
            });
            messageHandlerUnbinder.set(unbind);
          }),
          runOnDetached(messageHandlerUnbinder.clear)
        ]),
        Receiving.config({
          channels: (_a = {}, _a[bodySendMessageChannel] = {
            onReceive: function (comp, data) {
              descendant(comp.element, 'iframe').each(function (iframeEle) {
                var iframeWin = iframeEle.dom.contentWindow;
                iframeWin.postMessage(data, iframeDomain);
              });
            }
          }, _a)
        })
      ];
      var spec = {
        header: header,
        body: body,
        footer: footer,
        extraClasses: classes,
        extraBehaviours: extraBehaviours,
        extraStyles: styles
      };
      var dialog = renderModalDialog(spec, internalDialog, dialogEvents, backstage);
      var instanceApi = getUrlDialogApi(dialog);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var setup$2 = function (extras) {
      var sharedBackstage = extras.backstage.shared;
      var open = function (message, callback) {
        var closeDialog = function () {
          ModalDialog.hide(alertDialog);
          callback();
        };
        var memFooterClose = record(renderFooterButton({
          name: 'close-alert',
          text: 'OK',
          primary: true,
          align: 'end',
          disabled: false,
          icon: Optional.none()
        }, 'cancel', extras.backstage));
        var titleSpec = pUntitled();
        var closeSpec = pClose(closeDialog, sharedBackstage.providers);
        var alertDialog = build$1(renderDialog$1({
          lazySink: function () {
            return sharedBackstage.getSink();
          },
          header: hiddenHeader(titleSpec, closeSpec),
          body: pBodyMessage(message, sharedBackstage.providers),
          footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),
          onEscape: closeDialog,
          extraClasses: ['tox-alert-dialog'],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [run$1(formCancelEvent, closeDialog)],
          eventOrder: {}
        }));
        ModalDialog.show(alertDialog);
        var footerCloseButton = memFooterClose.get(alertDialog);
        Focusing.focus(footerCloseButton);
      };
      return { open: open };
    };

    var setup$1 = function (extras) {
      var sharedBackstage = extras.backstage.shared;
      var open = function (message, callback) {
        var closeDialog = function (state) {
          ModalDialog.hide(confirmDialog);
          callback(state);
        };
        var memFooterYes = record(renderFooterButton({
          name: 'yes',
          text: 'Yes',
          primary: true,
          align: 'end',
          disabled: false,
          icon: Optional.none()
        }, 'submit', extras.backstage));
        var footerNo = renderFooterButton({
          name: 'no',
          text: 'No',
          primary: false,
          align: 'end',
          disabled: false,
          icon: Optional.none()
        }, 'cancel', extras.backstage);
        var titleSpec = pUntitled();
        var closeSpec = pClose(function () {
          return closeDialog(false);
        }, sharedBackstage.providers);
        var confirmDialog = build$1(renderDialog$1({
          lazySink: function () {
            return sharedBackstage.getSink();
          },
          header: hiddenHeader(titleSpec, closeSpec),
          body: pBodyMessage(message, sharedBackstage.providers),
          footer: Optional.some(pFooter(pFooterGroup([], [
            footerNo,
            memFooterYes.asSpec()
          ]))),
          onEscape: function () {
            return closeDialog(false);
          },
          extraClasses: ['tox-confirm-dialog'],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [
            run$1(formCancelEvent, function () {
              return closeDialog(false);
            }),
            run$1(formSubmitEvent, function () {
              return closeDialog(true);
            })
          ],
          eventOrder: {}
        }));
        ModalDialog.show(confirmDialog);
        var footerYesButton = memFooterYes.get(confirmDialog);
        Focusing.focus(footerYesButton);
      };
      return { open: open };
    };

    var validateData = function (data, validator) {
      return getOrDie(asRaw('data', validator, data));
    };
    var isAlertOrConfirmDialog = function (target) {
      return closest(target, '.tox-alert-dialog') || closest(target, '.tox-confirm-dialog');
    };
    var inlineAdditionalBehaviours = function (editor, isStickyToolbar, isToolbarLocationTop) {
      if (isStickyToolbar && isToolbarLocationTop) {
        return [];
      } else {
        return [Docking.config({
            contextual: {
              lazyContext: function () {
                return Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer())));
              },
              fadeInClass: 'tox-dialog-dock-fadein',
              fadeOutClass: 'tox-dialog-dock-fadeout',
              transitionClass: 'tox-dialog-dock-transition'
            },
            modes: ['top']
          })];
      }
    };
    var setup = function (extras) {
      var backstage = extras.backstage;
      var editor = extras.editor;
      var isStickyToolbar$1 = isStickyToolbar(editor);
      var alertDialog = setup$2(extras);
      var confirmDialog = setup$1(extras);
      var open = function (config, params, closeWindow) {
        if (params !== undefined && params.inline === 'toolbar') {
          return openInlineDialog(config, backstage.shared.anchors.inlineDialog(), closeWindow, params.ariaAttrs);
        } else if (params !== undefined && params.inline === 'cursor') {
          return openInlineDialog(config, backstage.shared.anchors.cursor(), closeWindow, params.ariaAttrs);
        } else {
          return openModalDialog(config, closeWindow);
        }
      };
      var openUrl = function (config, closeWindow) {
        return openModalUrlDialog(config, closeWindow);
      };
      var openModalUrlDialog = function (config, closeWindow) {
        var factory = function (contents) {
          var dialog = renderUrlDialog(contents, {
            closeWindow: function () {
              ModalDialog.hide(dialog.dialog);
              closeWindow(dialog.instanceApi);
            }
          }, editor, backstage);
          ModalDialog.show(dialog.dialog);
          return dialog.instanceApi;
        };
        return DialogManager.openUrl(factory, config);
      };
      var openModalDialog = function (config, closeWindow) {
        var factory = function (contents, internalInitialData, dataValidator) {
          var initialData = internalInitialData;
          var dialogInit = {
            dataValidator: dataValidator,
            initialData: initialData,
            internalDialog: contents
          };
          var dialog = renderDialog(dialogInit, {
            redial: DialogManager.redial,
            closeWindow: function () {
              ModalDialog.hide(dialog.dialog);
              closeWindow(dialog.instanceApi);
            }
          }, backstage);
          ModalDialog.show(dialog.dialog);
          dialog.instanceApi.setData(initialData);
          return dialog.instanceApi;
        };
        return DialogManager.open(factory, config);
      };
      var openInlineDialog = function (config$1, anchor, closeWindow, ariaAttrs) {
        var factory = function (contents, internalInitialData, dataValidator) {
          var initialData = validateData(internalInitialData, dataValidator);
          var inlineDialog = value$1();
          var isToolbarLocationTop = backstage.shared.header.isPositionedAtTop();
          var dialogInit = {
            dataValidator: dataValidator,
            initialData: initialData,
            internalDialog: contents
          };
          var refreshDocking = function () {
            return inlineDialog.on(function (dialog) {
              InlineView.reposition(dialog);
              Docking.refresh(dialog);
            });
          };
          var dialogUi = renderInlineDialog(dialogInit, {
            redial: DialogManager.redial,
            closeWindow: function () {
              inlineDialog.on(InlineView.hide);
              editor.off('ResizeEditor', refreshDocking);
              inlineDialog.clear();
              closeWindow(dialogUi.instanceApi);
            }
          }, backstage, ariaAttrs);
          var inlineDialogComp = build$1(InlineView.sketch(__assign(__assign({
            lazySink: backstage.shared.getSink,
            dom: {
              tag: 'div',
              classes: []
            },
            fireDismissalEventInstead: {}
          }, isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} }), {
            inlineBehaviours: derive$1(__spreadArray([config('window-manager-inline-events', [run$1(dismissRequested(), function (_comp, _se) {
                  emit(dialogUi.dialog, formCancelEvent);
                })])], inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop), true)),
            isExtraPart: function (_comp, target) {
              return isAlertOrConfirmDialog(target);
            }
          })));
          inlineDialog.set(inlineDialogComp);
          InlineView.showWithin(inlineDialogComp, premade(dialogUi.dialog), { anchor: anchor }, Optional.some(body()));
          if (!isStickyToolbar$1 || !isToolbarLocationTop) {
            Docking.refresh(inlineDialogComp);
            editor.on('ResizeEditor', refreshDocking);
          }
          dialogUi.instanceApi.setData(initialData);
          Keying.focusIn(dialogUi.dialog);
          return dialogUi.instanceApi;
        };
        return DialogManager.open(factory, config$1);
      };
      var confirm = function (message, callback) {
        confirmDialog.open(message, function (state) {
          callback(state);
        });
      };
      var alert = function (message, callback) {
        alertDialog.open(message, function () {
          callback();
        });
      };
      var close = function (instanceApi) {
        instanceApi.close();
      };
      return {
        open: open,
        openUrl: openUrl,
        alert: alert,
        close: close,
        confirm: confirm
      };
    };

    function Theme () {
      global$g.add('silver', function (editor) {
        var _a = setup$3(editor), uiMothership = _a.uiMothership, backstage = _a.backstage, renderUI = _a.renderUI, getUi = _a.getUi;
        Autocompleter.register(editor, backstage.shared);
        var windowMgr = setup({
          editor: editor,
          backstage: backstage
        });
        return {
          renderUI: renderUI,
          getWindowManagerImpl: constant$1(windowMgr),
          getNotificationManagerImpl: function () {
            return NotificationManagerImpl(editor, { backstage: backstage }, uiMothership);
          },
          ui: getUi()
        };
      });
    }

    Theme();

}());

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("d8fc")))

/***/ }),

/***/ "75b5":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "lists" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/lists')
//   ES2015:
//     import 'tinymce/plugins/lists'
__webpack_require__("9623");

/***/ }),

/***/ "75d5":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "template" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/template')
//   ES2015:
//     import 'tinymce/plugins/template'
__webpack_require__("f2a5");

/***/ }),

/***/ "7fa5":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$6 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString = isType('string');
    var isObject = isType('object');
    var isArray = isType('array');
    var isNull = eq(null);
    var isBoolean = isSimpleType('boolean');
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };

    var nativePush = Array.prototype.push;
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var get = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get(xs, 0);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var remove = function (element, key) {
      element.dom.removeAttribute(key);
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$4 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var global$3 = tinymce.util.Tools.resolve('tinymce.util.URI');

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.XHR');

    var hasDimensions = function (editor) {
      return editor.getParam('image_dimensions', true, 'boolean');
    };
    var hasAdvTab = function (editor) {
      return editor.getParam('image_advtab', false, 'boolean');
    };
    var hasUploadTab = function (editor) {
      return editor.getParam('image_uploadtab', true, 'boolean');
    };
    var getPrependUrl = function (editor) {
      return editor.getParam('image_prepend_url', '', 'string');
    };
    var getClassList = function (editor) {
      return editor.getParam('image_class_list');
    };
    var hasDescription = function (editor) {
      return editor.getParam('image_description', true, 'boolean');
    };
    var hasImageTitle = function (editor) {
      return editor.getParam('image_title', false, 'boolean');
    };
    var hasImageCaption = function (editor) {
      return editor.getParam('image_caption', false, 'boolean');
    };
    var getImageList = function (editor) {
      return editor.getParam('image_list', false);
    };
    var hasUploadUrl = function (editor) {
      return isNonNullable(editor.getParam('images_upload_url'));
    };
    var hasUploadHandler = function (editor) {
      return isNonNullable(editor.getParam('images_upload_handler'));
    };
    var showAccessibilityOptions = function (editor) {
      return editor.getParam('a11y_advanced_options', false, 'boolean');
    };
    var isAutomaticUploadsEnabled = function (editor) {
      return editor.getParam('automatic_uploads', true, 'boolean');
    };

    var parseIntAndGetMax = function (val1, val2) {
      return Math.max(parseInt(val1, 10), parseInt(val2, 10));
    };
    var getImageSize = function (url) {
      return new global$4(function (callback) {
        var img = document.createElement('img');
        var done = function (dimensions) {
          img.onload = img.onerror = null;
          if (img.parentNode) {
            img.parentNode.removeChild(img);
          }
          callback(dimensions);
        };
        img.onload = function () {
          var width = parseIntAndGetMax(img.width, img.clientWidth);
          var height = parseIntAndGetMax(img.height, img.clientHeight);
          var dimensions = {
            width: width,
            height: height
          };
          done(global$4.resolve(dimensions));
        };
        img.onerror = function () {
          done(global$4.reject('Failed to get image dimensions for: ' + url));
        };
        var style = img.style;
        style.visibility = 'hidden';
        style.position = 'fixed';
        style.bottom = style.left = '0px';
        style.width = style.height = 'auto';
        document.body.appendChild(img);
        img.src = url;
      });
    };
    var removePixelSuffix = function (value) {
      if (value) {
        value = value.replace(/px$/, '');
      }
      return value;
    };
    var addPixelSuffix = function (value) {
      if (value.length > 0 && /^[0-9]+$/.test(value)) {
        value += 'px';
      }
      return value;
    };
    var mergeMargins = function (css) {
      if (css.margin) {
        var splitMargin = String(css.margin).split(' ');
        switch (splitMargin.length) {
        case 1:
          css['margin-top'] = css['margin-top'] || splitMargin[0];
          css['margin-right'] = css['margin-right'] || splitMargin[0];
          css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
          css['margin-left'] = css['margin-left'] || splitMargin[0];
          break;
        case 2:
          css['margin-top'] = css['margin-top'] || splitMargin[0];
          css['margin-right'] = css['margin-right'] || splitMargin[1];
          css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
          css['margin-left'] = css['margin-left'] || splitMargin[1];
          break;
        case 3:
          css['margin-top'] = css['margin-top'] || splitMargin[0];
          css['margin-right'] = css['margin-right'] || splitMargin[1];
          css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
          css['margin-left'] = css['margin-left'] || splitMargin[1];
          break;
        case 4:
          css['margin-top'] = css['margin-top'] || splitMargin[0];
          css['margin-right'] = css['margin-right'] || splitMargin[1];
          css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
          css['margin-left'] = css['margin-left'] || splitMargin[3];
        }
        delete css.margin;
      }
      return css;
    };
    var createImageList = function (editor, callback) {
      var imageList = getImageList(editor);
      if (isString(imageList)) {
        global$2.send({
          url: imageList,
          success: function (text) {
            callback(JSON.parse(text));
          }
        });
      } else if (isFunction(imageList)) {
        imageList(callback);
      } else {
        callback(imageList);
      }
    };
    var waitLoadImage = function (editor, data, imgElm) {
      var selectImage = function () {
        imgElm.onload = imgElm.onerror = null;
        if (editor.selection) {
          editor.selection.select(imgElm);
          editor.nodeChanged();
        }
      };
      imgElm.onload = function () {
        if (!data.width && !data.height && hasDimensions(editor)) {
          editor.dom.setAttribs(imgElm, {
            width: String(imgElm.clientWidth),
            height: String(imgElm.clientHeight)
          });
        }
        selectImage();
      };
      imgElm.onerror = selectImage;
    };
    var blobToDataUri = function (blob) {
      return new global$4(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function () {
          resolve(reader.result);
        };
        reader.onerror = function () {
          reject(reader.error.message);
        };
        reader.readAsDataURL(blob);
      });
    };
    var isPlaceholderImage = function (imgElm) {
      return imgElm.nodeName === 'IMG' && (imgElm.hasAttribute('data-mce-object') || imgElm.hasAttribute('data-mce-placeholder'));
    };
    var isSafeImageUrl = function (editor, src) {
      return global$3.isDomSafe(src, 'img', editor.settings);
    };

    var DOM = global$5.DOM;
    var getHspace = function (image) {
      if (image.style.marginLeft && image.style.marginRight && image.style.marginLeft === image.style.marginRight) {
        return removePixelSuffix(image.style.marginLeft);
      } else {
        return '';
      }
    };
    var getVspace = function (image) {
      if (image.style.marginTop && image.style.marginBottom && image.style.marginTop === image.style.marginBottom) {
        return removePixelSuffix(image.style.marginTop);
      } else {
        return '';
      }
    };
    var getBorder = function (image) {
      if (image.style.borderWidth) {
        return removePixelSuffix(image.style.borderWidth);
      } else {
        return '';
      }
    };
    var getAttrib = function (image, name) {
      if (image.hasAttribute(name)) {
        return image.getAttribute(name);
      } else {
        return '';
      }
    };
    var getStyle = function (image, name) {
      return image.style[name] ? image.style[name] : '';
    };
    var hasCaption = function (image) {
      return image.parentNode !== null && image.parentNode.nodeName === 'FIGURE';
    };
    var updateAttrib = function (image, name, value) {
      if (value === '') {
        image.removeAttribute(name);
      } else {
        image.setAttribute(name, value);
      }
    };
    var wrapInFigure = function (image) {
      var figureElm = DOM.create('figure', { class: 'image' });
      DOM.insertAfter(figureElm, image);
      figureElm.appendChild(image);
      figureElm.appendChild(DOM.create('figcaption', { contentEditable: 'true' }, 'Caption'));
      figureElm.contentEditable = 'false';
    };
    var removeFigure = function (image) {
      var figureElm = image.parentNode;
      DOM.insertAfter(image, figureElm);
      DOM.remove(figureElm);
    };
    var toggleCaption = function (image) {
      if (hasCaption(image)) {
        removeFigure(image);
      } else {
        wrapInFigure(image);
      }
    };
    var normalizeStyle = function (image, normalizeCss) {
      var attrValue = image.getAttribute('style');
      var value = normalizeCss(attrValue !== null ? attrValue : '');
      if (value.length > 0) {
        image.setAttribute('style', value);
        image.setAttribute('data-mce-style', value);
      } else {
        image.removeAttribute('style');
      }
    };
    var setSize = function (name, normalizeCss) {
      return function (image, name, value) {
        if (image.style[name]) {
          image.style[name] = addPixelSuffix(value);
          normalizeStyle(image, normalizeCss);
        } else {
          updateAttrib(image, name, value);
        }
      };
    };
    var getSize = function (image, name) {
      if (image.style[name]) {
        return removePixelSuffix(image.style[name]);
      } else {
        return getAttrib(image, name);
      }
    };
    var setHspace = function (image, value) {
      var pxValue = addPixelSuffix(value);
      image.style.marginLeft = pxValue;
      image.style.marginRight = pxValue;
    };
    var setVspace = function (image, value) {
      var pxValue = addPixelSuffix(value);
      image.style.marginTop = pxValue;
      image.style.marginBottom = pxValue;
    };
    var setBorder = function (image, value) {
      var pxValue = addPixelSuffix(value);
      image.style.borderWidth = pxValue;
    };
    var setBorderStyle = function (image, value) {
      image.style.borderStyle = value;
    };
    var getBorderStyle = function (image) {
      return getStyle(image, 'borderStyle');
    };
    var isFigure = function (elm) {
      return elm.nodeName === 'FIGURE';
    };
    var isImage = function (elm) {
      return elm.nodeName === 'IMG';
    };
    var getIsDecorative = function (image) {
      return DOM.getAttrib(image, 'alt').length === 0 && DOM.getAttrib(image, 'role') === 'presentation';
    };
    var getAlt = function (image) {
      if (getIsDecorative(image)) {
        return '';
      } else {
        return getAttrib(image, 'alt');
      }
    };
    var defaultData = function () {
      return {
        src: '',
        alt: '',
        title: '',
        width: '',
        height: '',
        class: '',
        style: '',
        caption: false,
        hspace: '',
        vspace: '',
        border: '',
        borderStyle: '',
        isDecorative: false
      };
    };
    var getStyleValue = function (normalizeCss, data) {
      var image = document.createElement('img');
      updateAttrib(image, 'style', data.style);
      if (getHspace(image) || data.hspace !== '') {
        setHspace(image, data.hspace);
      }
      if (getVspace(image) || data.vspace !== '') {
        setVspace(image, data.vspace);
      }
      if (getBorder(image) || data.border !== '') {
        setBorder(image, data.border);
      }
      if (getBorderStyle(image) || data.borderStyle !== '') {
        setBorderStyle(image, data.borderStyle);
      }
      return normalizeCss(image.getAttribute('style'));
    };
    var create = function (normalizeCss, data) {
      var image = document.createElement('img');
      write(normalizeCss, __assign(__assign({}, data), { caption: false }), image);
      setAlt(image, data.alt, data.isDecorative);
      if (data.caption) {
        var figure = DOM.create('figure', { class: 'image' });
        figure.appendChild(image);
        figure.appendChild(DOM.create('figcaption', { contentEditable: 'true' }, 'Caption'));
        figure.contentEditable = 'false';
        return figure;
      } else {
        return image;
      }
    };
    var read = function (normalizeCss, image) {
      return {
        src: getAttrib(image, 'src'),
        alt: getAlt(image),
        title: getAttrib(image, 'title'),
        width: getSize(image, 'width'),
        height: getSize(image, 'height'),
        class: getAttrib(image, 'class'),
        style: normalizeCss(getAttrib(image, 'style')),
        caption: hasCaption(image),
        hspace: getHspace(image),
        vspace: getVspace(image),
        border: getBorder(image),
        borderStyle: getStyle(image, 'borderStyle'),
        isDecorative: getIsDecorative(image)
      };
    };
    var updateProp = function (image, oldData, newData, name, set) {
      if (newData[name] !== oldData[name]) {
        set(image, name, newData[name]);
      }
    };
    var setAlt = function (image, alt, isDecorative) {
      if (isDecorative) {
        DOM.setAttrib(image, 'role', 'presentation');
        var sugarImage = SugarElement.fromDom(image);
        set(sugarImage, 'alt', '');
      } else {
        if (isNull(alt)) {
          var sugarImage = SugarElement.fromDom(image);
          remove(sugarImage, 'alt');
        } else {
          var sugarImage = SugarElement.fromDom(image);
          set(sugarImage, 'alt', alt);
        }
        if (DOM.getAttrib(image, 'role') === 'presentation') {
          DOM.setAttrib(image, 'role', '');
        }
      }
    };
    var updateAlt = function (image, oldData, newData) {
      if (newData.alt !== oldData.alt || newData.isDecorative !== oldData.isDecorative) {
        setAlt(image, newData.alt, newData.isDecorative);
      }
    };
    var normalized = function (set, normalizeCss) {
      return function (image, name, value) {
        set(image, value);
        normalizeStyle(image, normalizeCss);
      };
    };
    var write = function (normalizeCss, newData, image) {
      var oldData = read(normalizeCss, image);
      updateProp(image, oldData, newData, 'caption', function (image, _name, _value) {
        return toggleCaption(image);
      });
      updateProp(image, oldData, newData, 'src', updateAttrib);
      updateProp(image, oldData, newData, 'title', updateAttrib);
      updateProp(image, oldData, newData, 'width', setSize('width', normalizeCss));
      updateProp(image, oldData, newData, 'height', setSize('height', normalizeCss));
      updateProp(image, oldData, newData, 'class', updateAttrib);
      updateProp(image, oldData, newData, 'style', normalized(function (image, value) {
        return updateAttrib(image, 'style', value);
      }, normalizeCss));
      updateProp(image, oldData, newData, 'hspace', normalized(setHspace, normalizeCss));
      updateProp(image, oldData, newData, 'vspace', normalized(setVspace, normalizeCss));
      updateProp(image, oldData, newData, 'border', normalized(setBorder, normalizeCss));
      updateProp(image, oldData, newData, 'borderStyle', normalized(setBorderStyle, normalizeCss));
      updateAlt(image, oldData, newData);
    };

    var normalizeCss$1 = function (editor, cssText) {
      var css = editor.dom.styles.parse(cssText);
      var mergedCss = mergeMargins(css);
      var compressed = editor.dom.styles.parse(editor.dom.styles.serialize(mergedCss));
      return editor.dom.styles.serialize(compressed);
    };
    var getSelectedImage = function (editor) {
      var imgElm = editor.selection.getNode();
      var figureElm = editor.dom.getParent(imgElm, 'figure.image');
      if (figureElm) {
        return editor.dom.select('img', figureElm)[0];
      }
      if (imgElm && (imgElm.nodeName !== 'IMG' || isPlaceholderImage(imgElm))) {
        return null;
      }
      return imgElm;
    };
    var splitTextBlock = function (editor, figure) {
      var dom = editor.dom;
      var textBlockElements = filter(editor.schema.getTextBlockElements(), function (_, parentElm) {
        return !editor.schema.isValidChild(parentElm, 'figure');
      });
      var textBlock = dom.getParent(figure.parentNode, function (node) {
        return hasNonNullableKey(textBlockElements, node.nodeName);
      }, editor.getBody());
      if (textBlock) {
        return dom.split(textBlock, figure);
      } else {
        return figure;
      }
    };
    var readImageDataFromSelection = function (editor) {
      var image = getSelectedImage(editor);
      return image ? read(function (css) {
        return normalizeCss$1(editor, css);
      }, image) : defaultData();
    };
    var insertImageAtCaret = function (editor, data) {
      var elm = create(function (css) {
        return normalizeCss$1(editor, css);
      }, data);
      editor.dom.setAttrib(elm, 'data-mce-id', '__mcenew');
      editor.focus();
      editor.selection.setContent(elm.outerHTML);
      var insertedElm = editor.dom.select('*[data-mce-id="__mcenew"]')[0];
      editor.dom.setAttrib(insertedElm, 'data-mce-id', null);
      if (isFigure(insertedElm)) {
        var figure = splitTextBlock(editor, insertedElm);
        editor.selection.select(figure);
      } else {
        editor.selection.select(insertedElm);
      }
    };
    var syncSrcAttr = function (editor, image) {
      editor.dom.setAttrib(image, 'src', image.getAttribute('src'));
    };
    var deleteImage = function (editor, image) {
      if (image) {
        var elm = editor.dom.is(image.parentNode, 'figure.image') ? image.parentNode : image;
        editor.dom.remove(elm);
        editor.focus();
        editor.nodeChanged();
        if (editor.dom.isEmpty(editor.getBody())) {
          editor.setContent('');
          editor.selection.setCursorLocation();
        }
      }
    };
    var writeImageDataToSelection = function (editor, data) {
      var image = getSelectedImage(editor);
      write(function (css) {
        return normalizeCss$1(editor, css);
      }, data, image);
      syncSrcAttr(editor, image);
      if (isFigure(image.parentNode)) {
        var figure = image.parentNode;
        splitTextBlock(editor, figure);
        editor.selection.select(image.parentNode);
      } else {
        editor.selection.select(image);
        waitLoadImage(editor, data, image);
      }
    };
    var sanitizeImageData = function (editor, data) {
      var src = data.src;
      return __assign(__assign({}, data), { src: isSafeImageUrl(editor, src) ? src : '' });
    };
    var insertOrUpdateImage = function (editor, partialData) {
      var image = getSelectedImage(editor);
      if (image) {
        var selectedImageData = read(function (css) {
          return normalizeCss$1(editor, css);
        }, image);
        var data = __assign(__assign({}, selectedImageData), partialData);
        var sanitizedData = sanitizeImageData(editor, data);
        if (data.src) {
          writeImageDataToSelection(editor, sanitizedData);
        } else {
          deleteImage(editor, image);
        }
      } else if (partialData.src) {
        insertImageAtCaret(editor, __assign(__assign({}, defaultData()), partialData));
      }
    };

    var deep = function (old, nu) {
      var bothObjects = isObject(old) && isObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    var baseMerge = function (merger) {
      return function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        if (objects.length === 0) {
          throw new Error('Can\'t merge zero objects');
        }
        var ret = {};
        for (var j = 0; j < objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (has(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var deepMerge = baseMerge(deep);

    var isNotEmpty = function (s) {
      return s.length > 0;
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.ImageUploader');

    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getValue = function (item) {
      return isString(item.value) ? item.value : '';
    };
    var getText = function (item) {
      if (isString(item.text)) {
        return item.text;
      } else if (isString(item.title)) {
        return item.title;
      } else {
        return '';
      }
    };
    var sanitizeList = function (list, extractValue) {
      var out = [];
      global.each(list, function (item) {
        var text = getText(item);
        if (item.menu !== undefined) {
          var items = sanitizeList(item.menu, extractValue);
          out.push({
            text: text,
            items: items
          });
        } else {
          var value = extractValue(item);
          out.push({
            text: text,
            value: value
          });
        }
      });
      return out;
    };
    var sanitizer = function (extractor) {
      if (extractor === void 0) {
        extractor = getValue;
      }
      return function (list) {
        if (list) {
          return Optional.from(list).map(function (list) {
            return sanitizeList(list, extractor);
          });
        } else {
          return Optional.none();
        }
      };
    };
    var sanitize = function (list) {
      return sanitizer(getValue)(list);
    };
    var isGroup = function (item) {
      return has(item, 'items');
    };
    var findEntryDelegate = function (list, value) {
      return findMap(list, function (item) {
        if (isGroup(item)) {
          return findEntryDelegate(item.items, value);
        } else if (item.value === value) {
          return Optional.some(item);
        } else {
          return Optional.none();
        }
      });
    };
    var findEntry = function (optList, value) {
      return optList.bind(function (list) {
        return findEntryDelegate(list, value);
      });
    };
    var ListUtils = {
      sanitizer: sanitizer,
      sanitize: sanitize,
      findEntry: findEntry
    };

    var makeTab$2 = function (_info) {
      return {
        title: 'Advanced',
        name: 'advanced',
        items: [
          {
            type: 'input',
            label: 'Style',
            name: 'style'
          },
          {
            type: 'grid',
            columns: 2,
            items: [
              {
                type: 'input',
                label: 'Vertical space',
                name: 'vspace',
                inputMode: 'numeric'
              },
              {
                type: 'input',
                label: 'Horizontal space',
                name: 'hspace',
                inputMode: 'numeric'
              },
              {
                type: 'input',
                label: 'Border width',
                name: 'border',
                inputMode: 'numeric'
              },
              {
                type: 'listbox',
                name: 'borderstyle',
                label: 'Border style',
                items: [
                  {
                    text: 'Select...',
                    value: ''
                  },
                  {
                    text: 'Solid',
                    value: 'solid'
                  },
                  {
                    text: 'Dotted',
                    value: 'dotted'
                  },
                  {
                    text: 'Dashed',
                    value: 'dashed'
                  },
                  {
                    text: 'Double',
                    value: 'double'
                  },
                  {
                    text: 'Groove',
                    value: 'groove'
                  },
                  {
                    text: 'Ridge',
                    value: 'ridge'
                  },
                  {
                    text: 'Inset',
                    value: 'inset'
                  },
                  {
                    text: 'Outset',
                    value: 'outset'
                  },
                  {
                    text: 'None',
                    value: 'none'
                  },
                  {
                    text: 'Hidden',
                    value: 'hidden'
                  }
                ]
              }
            ]
          }
        ]
      };
    };
    var AdvTab = { makeTab: makeTab$2 };

    var collect = function (editor) {
      var urlListSanitizer = ListUtils.sanitizer(function (item) {
        return editor.convertURL(item.value || item.url, 'src');
      });
      var futureImageList = new global$4(function (completer) {
        createImageList(editor, function (imageList) {
          completer(urlListSanitizer(imageList).map(function (items) {
            return flatten([
              [{
                  text: 'None',
                  value: ''
                }],
              items
            ]);
          }));
        });
      });
      var classList = ListUtils.sanitize(getClassList(editor));
      var hasAdvTab$1 = hasAdvTab(editor);
      var hasUploadTab$1 = hasUploadTab(editor);
      var hasUploadUrl$1 = hasUploadUrl(editor);
      var hasUploadHandler$1 = hasUploadHandler(editor);
      var image = readImageDataFromSelection(editor);
      var hasDescription$1 = hasDescription(editor);
      var hasImageTitle$1 = hasImageTitle(editor);
      var hasDimensions$1 = hasDimensions(editor);
      var hasImageCaption$1 = hasImageCaption(editor);
      var hasAccessibilityOptions = showAccessibilityOptions(editor);
      var automaticUploads = isAutomaticUploadsEnabled(editor);
      var prependURL = Optional.some(getPrependUrl(editor)).filter(function (preUrl) {
        return isString(preUrl) && preUrl.length > 0;
      });
      return futureImageList.then(function (imageList) {
        return {
          image: image,
          imageList: imageList,
          classList: classList,
          hasAdvTab: hasAdvTab$1,
          hasUploadTab: hasUploadTab$1,
          hasUploadUrl: hasUploadUrl$1,
          hasUploadHandler: hasUploadHandler$1,
          hasDescription: hasDescription$1,
          hasImageTitle: hasImageTitle$1,
          hasDimensions: hasDimensions$1,
          hasImageCaption: hasImageCaption$1,
          prependURL: prependURL,
          hasAccessibilityOptions: hasAccessibilityOptions,
          automaticUploads: automaticUploads
        };
      });
    };

    var makeItems = function (info) {
      var imageUrl = {
        name: 'src',
        type: 'urlinput',
        filetype: 'image',
        label: 'Source'
      };
      var imageList = info.imageList.map(function (items) {
        return {
          name: 'images',
          type: 'listbox',
          label: 'Image list',
          items: items
        };
      });
      var imageDescription = {
        name: 'alt',
        type: 'input',
        label: 'Alternative description',
        disabled: info.hasAccessibilityOptions && info.image.isDecorative
      };
      var imageTitle = {
        name: 'title',
        type: 'input',
        label: 'Image title'
      };
      var imageDimensions = {
        name: 'dimensions',
        type: 'sizeinput'
      };
      var isDecorative = {
        type: 'label',
        label: 'Accessibility',
        items: [{
            name: 'isDecorative',
            type: 'checkbox',
            label: 'Image is decorative'
          }]
      };
      var classList = info.classList.map(function (items) {
        return {
          name: 'classes',
          type: 'listbox',
          label: 'Class',
          items: items
        };
      });
      var caption = {
        type: 'label',
        label: 'Caption',
        items: [{
            type: 'checkbox',
            name: 'caption',
            label: 'Show caption'
          }]
      };
      var getDialogContainerType = function (useColumns) {
        return useColumns ? {
          type: 'grid',
          columns: 2
        } : { type: 'panel' };
      };
      return flatten([
        [imageUrl],
        imageList.toArray(),
        info.hasAccessibilityOptions && info.hasDescription ? [isDecorative] : [],
        info.hasDescription ? [imageDescription] : [],
        info.hasImageTitle ? [imageTitle] : [],
        info.hasDimensions ? [imageDimensions] : [],
        [__assign(__assign({}, getDialogContainerType(info.classList.isSome() && info.hasImageCaption)), {
            items: flatten([
              classList.toArray(),
              info.hasImageCaption ? [caption] : []
            ])
          })]
      ]);
    };
    var makeTab$1 = function (info) {
      return {
        title: 'General',
        name: 'general',
        items: makeItems(info)
      };
    };
    var MainTab = {
      makeTab: makeTab$1,
      makeItems: makeItems
    };

    var makeTab = function (_info) {
      var items = [{
          type: 'dropzone',
          name: 'fileinput'
        }];
      return {
        title: 'Upload',
        name: 'upload',
        items: items
      };
    };
    var UploadTab = { makeTab: makeTab };

    var createState = function (info) {
      return {
        prevImage: ListUtils.findEntry(info.imageList, info.image.src),
        prevAlt: info.image.alt,
        open: true
      };
    };
    var fromImageData = function (image) {
      return {
        src: {
          value: image.src,
          meta: {}
        },
        images: image.src,
        alt: image.alt,
        title: image.title,
        dimensions: {
          width: image.width,
          height: image.height
        },
        classes: image.class,
        caption: image.caption,
        style: image.style,
        vspace: image.vspace,
        border: image.border,
        hspace: image.hspace,
        borderstyle: image.borderStyle,
        fileinput: [],
        isDecorative: image.isDecorative
      };
    };
    var toImageData = function (data, removeEmptyAlt) {
      return {
        src: data.src.value,
        alt: data.alt.length === 0 && removeEmptyAlt ? null : data.alt,
        title: data.title,
        width: data.dimensions.width,
        height: data.dimensions.height,
        class: data.classes,
        style: data.style,
        caption: data.caption,
        hspace: data.hspace,
        vspace: data.vspace,
        border: data.border,
        borderStyle: data.borderstyle,
        isDecorative: data.isDecorative
      };
    };
    var addPrependUrl2 = function (info, srcURL) {
      if (!/^(?:[a-zA-Z]+:)?\/\//.test(srcURL)) {
        return info.prependURL.bind(function (prependUrl) {
          if (srcURL.substring(0, prependUrl.length) !== prependUrl) {
            return Optional.some(prependUrl + srcURL);
          }
          return Optional.none();
        });
      }
      return Optional.none();
    };
    var addPrependUrl = function (info, api) {
      var data = api.getData();
      addPrependUrl2(info, data.src.value).each(function (srcURL) {
        api.setData({
          src: {
            value: srcURL,
            meta: data.src.meta
          }
        });
      });
    };
    var formFillFromMeta2 = function (info, data, meta) {
      if (info.hasDescription && isString(meta.alt)) {
        data.alt = meta.alt;
      }
      if (info.hasAccessibilityOptions) {
        data.isDecorative = meta.isDecorative || data.isDecorative || false;
      }
      if (info.hasImageTitle && isString(meta.title)) {
        data.title = meta.title;
      }
      if (info.hasDimensions) {
        if (isString(meta.width)) {
          data.dimensions.width = meta.width;
        }
        if (isString(meta.height)) {
          data.dimensions.height = meta.height;
        }
      }
      if (isString(meta.class)) {
        ListUtils.findEntry(info.classList, meta.class).each(function (entry) {
          data.classes = entry.value;
        });
      }
      if (info.hasImageCaption) {
        if (isBoolean(meta.caption)) {
          data.caption = meta.caption;
        }
      }
      if (info.hasAdvTab) {
        if (isString(meta.style)) {
          data.style = meta.style;
        }
        if (isString(meta.vspace)) {
          data.vspace = meta.vspace;
        }
        if (isString(meta.border)) {
          data.border = meta.border;
        }
        if (isString(meta.hspace)) {
          data.hspace = meta.hspace;
        }
        if (isString(meta.borderstyle)) {
          data.borderstyle = meta.borderstyle;
        }
      }
    };
    var formFillFromMeta = function (info, api) {
      var data = api.getData();
      var meta = data.src.meta;
      if (meta !== undefined) {
        var newData = deepMerge({}, data);
        formFillFromMeta2(info, newData, meta);
        api.setData(newData);
      }
    };
    var calculateImageSize = function (helpers, info, state, api) {
      var data = api.getData();
      var url = data.src.value;
      var meta = data.src.meta || {};
      if (!meta.width && !meta.height && info.hasDimensions) {
        if (isNotEmpty(url)) {
          helpers.imageSize(url).then(function (size) {
            if (state.open) {
              api.setData({ dimensions: size });
            }
          }).catch(function (e) {
            return console.error(e);
          });
        } else {
          api.setData({
            dimensions: {
              width: '',
              height: ''
            }
          });
        }
      }
    };
    var updateImagesDropdown = function (info, state, api) {
      var data = api.getData();
      var image = ListUtils.findEntry(info.imageList, data.src.value);
      state.prevImage = image;
      api.setData({
        images: image.map(function (entry) {
          return entry.value;
        }).getOr('')
      });
    };
    var changeSrc = function (helpers, info, state, api) {
      addPrependUrl(info, api);
      formFillFromMeta(info, api);
      calculateImageSize(helpers, info, state, api);
      updateImagesDropdown(info, state, api);
    };
    var changeImages = function (helpers, info, state, api) {
      var data = api.getData();
      var image = ListUtils.findEntry(info.imageList, data.images);
      image.each(function (img) {
        var updateAlt = data.alt === '' || state.prevImage.map(function (image) {
          return image.text === data.alt;
        }).getOr(false);
        if (updateAlt) {
          if (img.value === '') {
            api.setData({
              src: img,
              alt: state.prevAlt
            });
          } else {
            api.setData({
              src: img,
              alt: img.text
            });
          }
        } else {
          api.setData({ src: img });
        }
      });
      state.prevImage = image;
      changeSrc(helpers, info, state, api);
    };
    var calcVSpace = function (css) {
      var matchingTopBottom = css['margin-top'] && css['margin-bottom'] && css['margin-top'] === css['margin-bottom'];
      return matchingTopBottom ? removePixelSuffix(String(css['margin-top'])) : '';
    };
    var calcHSpace = function (css) {
      var matchingLeftRight = css['margin-right'] && css['margin-left'] && css['margin-right'] === css['margin-left'];
      return matchingLeftRight ? removePixelSuffix(String(css['margin-right'])) : '';
    };
    var calcBorderWidth = function (css) {
      return css['border-width'] ? removePixelSuffix(String(css['border-width'])) : '';
    };
    var calcBorderStyle = function (css) {
      return css['border-style'] ? String(css['border-style']) : '';
    };
    var calcStyle = function (parseStyle, serializeStyle, css) {
      return serializeStyle(parseStyle(serializeStyle(css)));
    };
    var changeStyle2 = function (parseStyle, serializeStyle, data) {
      var css = mergeMargins(parseStyle(data.style));
      var dataCopy = deepMerge({}, data);
      dataCopy.vspace = calcVSpace(css);
      dataCopy.hspace = calcHSpace(css);
      dataCopy.border = calcBorderWidth(css);
      dataCopy.borderstyle = calcBorderStyle(css);
      dataCopy.style = calcStyle(parseStyle, serializeStyle, css);
      return dataCopy;
    };
    var changeStyle = function (helpers, api) {
      var data = api.getData();
      var newData = changeStyle2(helpers.parseStyle, helpers.serializeStyle, data);
      api.setData(newData);
    };
    var changeAStyle = function (helpers, info, api) {
      var data = deepMerge(fromImageData(info.image), api.getData());
      var style = getStyleValue(helpers.normalizeCss, toImageData(data, false));
      api.setData({ style: style });
    };
    var changeFileInput = function (helpers, info, state, api) {
      var data = api.getData();
      api.block('Uploading image');
      head(data.fileinput).fold(function () {
        api.unblock();
      }, function (file) {
        var blobUri = URL.createObjectURL(file);
        var finalize = function () {
          api.unblock();
          URL.revokeObjectURL(blobUri);
        };
        var updateSrcAndSwitchTab = function (url) {
          api.setData({
            src: {
              value: url,
              meta: {}
            }
          });
          api.showTab('general');
          changeSrc(helpers, info, state, api);
        };
        blobToDataUri(file).then(function (dataUrl) {
          var blobInfo = helpers.createBlobCache(file, blobUri, dataUrl);
          if (info.automaticUploads) {
            helpers.uploadImage(blobInfo).then(function (result) {
              updateSrcAndSwitchTab(result.url);
              finalize();
            }).catch(function (err) {
              finalize();
              helpers.alertErr(err);
            });
          } else {
            helpers.addToBlobCache(blobInfo);
            updateSrcAndSwitchTab(blobInfo.blobUri());
            api.unblock();
          }
        });
      });
    };
    var changeHandler = function (helpers, info, state) {
      return function (api, evt) {
        if (evt.name === 'src') {
          changeSrc(helpers, info, state, api);
        } else if (evt.name === 'images') {
          changeImages(helpers, info, state, api);
        } else if (evt.name === 'alt') {
          state.prevAlt = api.getData().alt;
        } else if (evt.name === 'style') {
          changeStyle(helpers, api);
        } else if (evt.name === 'vspace' || evt.name === 'hspace' || evt.name === 'border' || evt.name === 'borderstyle') {
          changeAStyle(helpers, info, api);
        } else if (evt.name === 'fileinput') {
          changeFileInput(helpers, info, state, api);
        } else if (evt.name === 'isDecorative') {
          if (api.getData().isDecorative) {
            api.disable('alt');
          } else {
            api.enable('alt');
          }
        }
      };
    };
    var closeHandler = function (state) {
      return function () {
        state.open = false;
      };
    };
    var makeDialogBody = function (info) {
      if (info.hasAdvTab || info.hasUploadUrl || info.hasUploadHandler) {
        var tabPanel = {
          type: 'tabpanel',
          tabs: flatten([
            [MainTab.makeTab(info)],
            info.hasAdvTab ? [AdvTab.makeTab(info)] : [],
            info.hasUploadTab && (info.hasUploadUrl || info.hasUploadHandler) ? [UploadTab.makeTab(info)] : []
          ])
        };
        return tabPanel;
      } else {
        var panel = {
          type: 'panel',
          items: MainTab.makeItems(info)
        };
        return panel;
      }
    };
    var makeDialog = function (helpers) {
      return function (info) {
        var state = createState(info);
        return {
          title: 'Insert/Edit Image',
          size: 'normal',
          body: makeDialogBody(info),
          buttons: [
            {
              type: 'cancel',
              name: 'cancel',
              text: 'Cancel'
            },
            {
              type: 'submit',
              name: 'save',
              text: 'Save',
              primary: true
            }
          ],
          initialData: fromImageData(info.image),
          onSubmit: helpers.onSubmit(info),
          onChange: changeHandler(helpers, info, state),
          onClose: closeHandler(state)
        };
      };
    };
    var submitHandler = function (editor) {
      return function (info) {
        return function (api) {
          var data = deepMerge(fromImageData(info.image), api.getData());
          editor.execCommand('mceUpdateImage', false, toImageData(data, info.hasAccessibilityOptions));
          editor.editorUpload.uploadImagesAuto();
          api.close();
        };
      };
    };
    var imageSize = function (editor) {
      return function (url) {
        if (!isSafeImageUrl(editor, url)) {
          return global$4.resolve({
            width: '',
            height: ''
          });
        } else {
          return getImageSize(editor.documentBaseURI.toAbsolute(url)).then(function (dimensions) {
            return {
              width: String(dimensions.width),
              height: String(dimensions.height)
            };
          });
        }
      };
    };
    var createBlobCache = function (editor) {
      return function (file, blobUri, dataUrl) {
        return editor.editorUpload.blobCache.create({
          blob: file,
          blobUri: blobUri,
          name: file.name ? file.name.replace(/\.[^\.]+$/, '') : null,
          filename: file.name,
          base64: dataUrl.split(',')[1]
        });
      };
    };
    var addToBlobCache = function (editor) {
      return function (blobInfo) {
        editor.editorUpload.blobCache.add(blobInfo);
      };
    };
    var alertErr = function (editor) {
      return function (message) {
        editor.windowManager.alert(message);
      };
    };
    var normalizeCss = function (editor) {
      return function (cssText) {
        return normalizeCss$1(editor, cssText);
      };
    };
    var parseStyle = function (editor) {
      return function (cssText) {
        return editor.dom.parseStyle(cssText);
      };
    };
    var serializeStyle = function (editor) {
      return function (stylesArg, name) {
        return editor.dom.serializeStyle(stylesArg, name);
      };
    };
    var uploadImage = function (editor) {
      return function (blobInfo) {
        return global$1(editor).upload([blobInfo], false).then(function (results) {
          if (results.length === 0) {
            return global$4.reject('Failed to upload image');
          } else if (results[0].status === false) {
            return global$4.reject(results[0].error.message);
          } else {
            return results[0];
          }
        });
      };
    };
    var Dialog = function (editor) {
      var helpers = {
        onSubmit: submitHandler(editor),
        imageSize: imageSize(editor),
        addToBlobCache: addToBlobCache(editor),
        createBlobCache: createBlobCache(editor),
        alertErr: alertErr(editor),
        normalizeCss: normalizeCss(editor),
        parseStyle: parseStyle(editor),
        serializeStyle: serializeStyle(editor),
        uploadImage: uploadImage(editor)
      };
      var open = function () {
        collect(editor).then(makeDialog(helpers)).then(editor.windowManager.open);
      };
      return { open: open };
    };

    var register$1 = function (editor) {
      editor.addCommand('mceImage', Dialog(editor).open);
      editor.addCommand('mceUpdateImage', function (_ui, data) {
        editor.undoManager.transact(function () {
          return insertOrUpdateImage(editor, data);
        });
      });
    };

    var hasImageClass = function (node) {
      var className = node.attr('class');
      return className && /\bimage\b/.test(className);
    };
    var toggleContentEditableState = function (state) {
      return function (nodes) {
        var i = nodes.length;
        var toggleContentEditable = function (node) {
          node.attr('contenteditable', state ? 'true' : null);
        };
        while (i--) {
          var node = nodes[i];
          if (hasImageClass(node)) {
            node.attr('contenteditable', state ? 'false' : null);
            global.each(node.getAll('figcaption'), toggleContentEditable);
          }
        }
      };
    };
    var setup = function (editor) {
      editor.on('PreInit', function () {
        editor.parser.addNodeFilter('figure', toggleContentEditableState(true));
        editor.serializer.addNodeFilter('figure', toggleContentEditableState(false));
      });
    };

    var register = function (editor) {
      editor.ui.registry.addToggleButton('image', {
        icon: 'image',
        tooltip: 'Insert/edit image',
        onAction: Dialog(editor).open,
        onSetup: function (buttonApi) {
          buttonApi.setActive(isNonNullable(getSelectedImage(editor)));
          return editor.selection.selectorChangedWithUnbind('img:not([data-mce-object],[data-mce-placeholder]),figure.image', buttonApi.setActive).unbind;
        }
      });
      editor.ui.registry.addMenuItem('image', {
        icon: 'image',
        text: 'Image...',
        onAction: Dialog(editor).open
      });
      editor.ui.registry.addContextMenu('image', {
        update: function (element) {
          return isFigure(element) || isImage(element) && !isPlaceholderImage(element) ? ['image'] : [];
        }
      });
    };

    function Plugin () {
      global$6.add('image', function (editor) {
        setup(editor);
        register(editor);
        register$1(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "83d4":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var get$5 = function (fullscreenState) {
      return {
        isFullscreen: function () {
          return fullscreenState.get() !== null;
        }
      };
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isString = isType$1('string');
    var isArray = isType$1('array');
    var isBoolean = isSimpleType('boolean');
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var compose = function (fa, fb) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var compose1 = function (fbc, fab) {
      return function (a) {
        return fbc(fab(a));
      };
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var unbindable = function () {
      return singleton(function (s) {
        return s.unbind();
      });
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var nativePush = Array.prototype.push;
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var filter$1 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find$1 = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind$3 = function (xs, f) {
      return flatten(map(xs, f));
    };
    var get$4 = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get$4(xs, 0);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var keys = Object.keys;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };

    var contains = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };

    var isSupported$1 = function (dom) {
      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;

    var type = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isElement = isType(ELEMENT);
    var isText = isType(TEXT);
    var isDocument = isType(DOCUMENT);
    var isDocumentFragment = isType(DOCUMENT_FRAGMENT);

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() && !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      var isPhone = isiPhone || isMobile && !isTablet;
      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$2(group(1), group(2));
    };
    var detect$3 = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find(versionRegexes, cleanedAgent);
    };
    var unknown$2 = function () {
      return nu$2(0, 0);
    };
    var nu$2 = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$2,
      detect: detect$3,
      unknown: unknown$2
    };

    var detectBrowser$1 = function (browsers, userAgentData) {
      return findMap(userAgentData.brands, function (uaBrand) {
        var lcBrand = uaBrand.brand.toLowerCase();
        return find$1(browsers, function (browser) {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(function (info) {
          return {
            current: info.name,
            version: Version.nu(parseInt(uaBrand.version, 10), 0)
          };
        });
      });
    };

    var detect$2 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find$1(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$2(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$2(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains(uastring, target);
      };
    };
    var browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains(uastring, 'edge/') && contains(uastring, 'chrome') && contains(uastring, 'safari') && contains(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chrome',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains(uastring, 'chrome') && !contains(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains(uastring, 'msie') || contains(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains(uastring, 'safari') || contains(uastring, 'mobile/')) && contains(uastring, 'applewebkit');
        }
      }
    ];
    var oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: function (uastring) {
          return contains(uastring, 'iphone') || contains(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'OSX',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    var edge = 'Edge';
    var chrome = 'Chrome';
    var ie = 'IE';
    var opera = 'Opera';
    var firefox = 'Firefox';
    var safari = 'Safari';
    var unknown$1 = function () {
      return nu$1({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$1 = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$1,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    var windows = 'Windows';
    var ios = 'iOS';
    var android = 'Android';
    var linux = 'Linux';
    var osx = 'OSX';
    var solaris = 'Solaris';
    var freebsd = 'FreeBSD';
    var chromeos = 'ChromeOS';
    var unknown = function () {
      return nu({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown,
      nu: nu,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    var detect$1 = function (userAgent, userAgentDataOpt, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = userAgentDataOpt.bind(function (userAgentData) {
        return detectBrowser$1(browsers, userAgentData);
      }).orThunk(function () {
        return detectBrowser(browsers, userAgent);
      }).fold(Browser.unknown, Browser.nu);
      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$1 };

    var mediaMatch = function (query) {
      return window.matchMedia(query).matches;
    };
    var platform = cached(function () {
      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);
    });
    var detect = function () {
      return platform();
    };

    var is = function (element, selector) {
      var dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    };
    var all$1 = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);
    };

    var eq = function (e1, e2) {
      return e1.dom === e2.dom;
    };

    var owner = function (element) {
      return SugarElement.fromDom(element.dom.ownerDocument);
    };
    var documentOrOwner = function (dos) {
      return isDocument(dos) ? dos : owner(dos);
    };
    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var parents = function (element, isRoot) {
      var stop = isFunction(isRoot) ? isRoot : never;
      var dom = element.dom;
      var ret = [];
      while (dom.parentNode !== null && dom.parentNode !== undefined) {
        var rawParent = dom.parentNode;
        var p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
          break;
        } else {
          dom = rawParent;
        }
      }
      return ret;
    };
    var siblings$2 = function (element) {
      var filterSelf = function (elements) {
        return filter$1(elements, function (x) {
          return !eq(element, x);
        });
      };
      return parent(element).map(children).map(filterSelf).getOr([]);
    };
    var children = function (element) {
      return map(element.dom.childNodes, SugarElement.fromDom);
    };

    var isShadowRoot = function (dos) {
      return isDocumentFragment(dos) && isNonNullable(dos.dom.host);
    };
    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    var isSupported = constant(supported);
    var getRootNode = supported ? function (e) {
      return SugarElement.fromDom(e.dom.getRootNode());
    } : documentOrOwner;
    var getShadowRoot = function (e) {
      var r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    var getShadowHost = function (e) {
      return SugarElement.fromDom(e.dom.host);
    };
    var getOriginalEventTarget = function (event) {
      if (isSupported() && isNonNullable(event.target)) {
        var el = SugarElement.fromDom(event.target);
        if (isElement(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    var isOpenShadowHost = function (element) {
      return isNonNullable(element.dom.shadowRoot);
    };

    var inBody = function (element) {
      var dom = isText(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      var doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {
        return doc.body.contains(dom);
      }, compose1(inBody, getShadowHost));
    };
    var getBody = function (doc) {
      var b = doc.dom.body;
      if (b === null || b === undefined) {
        throw new Error('Body is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var get$3 = function (element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    var remove = function (element, key) {
      element.dom.removeAttribute(key);
    };

    var internalSet = function (dom, property, value) {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported$1(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var setAll = function (element, css) {
      var dom = element.dom;
      each(css, function (v, k) {
        internalSet(dom, k, v);
      });
    };
    var get$2 = function (element, property) {
      var dom = element.dom;
      var styles = window.getComputedStyle(dom);
      var r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    var getUnsafeProperty = function (dom, property) {
      return isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';
    };

    var mkEvent = function (target, x, y, stop, prevent, kill, raw) {
      return {
        target: target,
        x: x,
        y: y,
        stop: stop,
        prevent: prevent,
        kill: kill,
        raw: raw
      };
    };
    var fromRawEvent = function (rawEvent) {
      var target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      var stop = function () {
        return rawEvent.stopPropagation();
      };
      var prevent = function () {
        return rawEvent.preventDefault();
      };
      var kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    var handle = function (filter, handler) {
      return function (rawEvent) {
        if (filter(rawEvent)) {
          handler(fromRawEvent(rawEvent));
        }
      };
    };
    var binder = function (element, event, filter, handler, useCapture) {
      var wrapped = handle(filter, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    var bind$2 = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, false);
    };
    var unbind = function (element, event, handler, useCapture) {
      element.dom.removeEventListener(event, handler, useCapture);
    };

    var filter = always;
    var bind$1 = function (element, event, handler) {
      return bind$2(element, event, filter, handler);
    };

    var r = function (left, top) {
      var translate = function (x, y) {
        return r(left + x, top + y);
      };
      return {
        left: left,
        top: top,
        translate: translate
      };
    };
    var SugarPosition = r;

    var get$1 = function (_DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };

    var get = function (_win) {
      var win = _win === undefined ? window : _win;
      if (detect().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win['visualViewport']);
      }
    };
    var bounds = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var getBounds = function (_win) {
      var win = _win === undefined ? window : _win;
      var doc = win.document;
      var scroll = get$1(SugarElement.fromDom(doc));
      return get(win).fold(function () {
        var html = win.document.documentElement;
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      }, function (visualViewport) {
        return bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);
      });
    };
    var bind = function (name, callback, _win) {
      return get(_win).map(function (visualViewport) {
        var handler = function (e) {
          return callback(fromRawEvent(e));
        };
        visualViewport.addEventListener(name, handler);
        return {
          unbind: function () {
            return visualViewport.removeEventListener(name, handler);
          }
        };
      }).getOrThunk(function () {
        return { unbind: noop };
      });
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$1 = tinymce.util.Tools.resolve('tinymce.Env');

    var global = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var fireFullscreenStateChanged = function (editor, state) {
      editor.fire('FullscreenStateChanged', { state: state });
    };

    var getFullscreenNative = function (editor) {
      return editor.getParam('fullscreen_native', false, 'boolean');
    };

    var getFullscreenRoot = function (editor) {
      var elem = SugarElement.fromDom(editor.getElement());
      return getShadowRoot(elem).map(getShadowHost).getOrThunk(function () {
        return getBody(owner(elem));
      });
    };
    var getFullscreenElement = function (root) {
      if (root.fullscreenElement !== undefined) {
        return root.fullscreenElement;
      } else if (root.msFullscreenElement !== undefined) {
        return root.msFullscreenElement;
      } else if (root.webkitFullscreenElement !== undefined) {
        return root.webkitFullscreenElement;
      } else {
        return null;
      }
    };
    var getFullscreenchangeEventName = function () {
      if (document.fullscreenElement !== undefined) {
        return 'fullscreenchange';
      } else if (document.msFullscreenElement !== undefined) {
        return 'MSFullscreenChange';
      } else if (document.webkitFullscreenElement !== undefined) {
        return 'webkitfullscreenchange';
      } else {
        return 'fullscreenchange';
      }
    };
    var requestFullscreen = function (sugarElem) {
      var elem = sugarElem.dom;
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      } else if (elem.webkitRequestFullScreen) {
        elem.webkitRequestFullScreen();
      }
    };
    var exitFullscreen = function (sugarDoc) {
      var doc = sugarDoc.dom;
      if (doc.exitFullscreen) {
        doc.exitFullscreen();
      } else if (doc.msExitFullscreen) {
        doc.msExitFullscreen();
      } else if (doc.webkitCancelFullScreen) {
        doc.webkitCancelFullScreen();
      }
    };
    var isFullscreenElement = function (elem) {
      return elem.dom === getFullscreenElement(owner(elem).dom);
    };

    var ancestors$1 = function (scope, predicate, isRoot) {
      return filter$1(parents(scope, isRoot), predicate);
    };
    var siblings$1 = function (scope, predicate) {
      return filter$1(siblings$2(scope), predicate);
    };

    var all = function (selector) {
      return all$1(selector);
    };
    var ancestors = function (scope, selector, isRoot) {
      return ancestors$1(scope, function (e) {
        return is(e, selector);
      }, isRoot);
    };
    var siblings = function (scope, selector) {
      return siblings$1(scope, function (e) {
        return is(e, selector);
      });
    };

    var attr = 'data-ephox-mobile-fullscreen-style';
    var siblingStyles = 'display:none!important;';
    var ancestorPosition = 'position:absolute!important;';
    var ancestorStyles = 'top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;';
    var bgFallback = 'background-color:rgb(255,255,255)!important;';
    var isAndroid = global$1.os.isAndroid();
    var matchColor = function (editorBody) {
      var color = get$2(editorBody, 'background-color');
      return color !== undefined && color !== '' ? 'background-color:' + color + '!important' : bgFallback;
    };
    var clobberStyles = function (dom, container, editorBody) {
      var gatherSiblings = function (element) {
        return siblings(element, '*:not(.tox-silver-sink)');
      };
      var clobber = function (clobberStyle) {
        return function (element) {
          var styles = get$3(element, 'style');
          var backup = styles === undefined ? 'no-styles' : styles.trim();
          if (backup === clobberStyle) {
            return;
          } else {
            set(element, attr, backup);
            setAll(element, dom.parseStyle(clobberStyle));
          }
        };
      };
      var ancestors$1 = ancestors(container, '*');
      var siblings$1 = bind$3(ancestors$1, gatherSiblings);
      var bgColor = matchColor(editorBody);
      each$1(siblings$1, clobber(siblingStyles));
      each$1(ancestors$1, clobber(ancestorPosition + ancestorStyles + bgColor));
      var containerStyles = isAndroid === true ? '' : ancestorPosition;
      clobber(containerStyles + ancestorStyles + bgColor)(container);
    };
    var restoreStyles = function (dom) {
      var clobberedEls = all('[' + attr + ']');
      each$1(clobberedEls, function (element) {
        var restore = get$3(element, attr);
        if (restore !== 'no-styles') {
          setAll(element, dom.parseStyle(restore));
        } else {
          remove(element, 'style');
        }
        remove(element, attr);
      });
    };

    var DOM = global$2.DOM;
    var getScrollPos = function () {
      return getBounds(window);
    };
    var setScrollPos = function (pos) {
      return window.scrollTo(pos.x, pos.y);
    };
    var viewportUpdate = get().fold(function () {
      return {
        bind: noop,
        unbind: noop
      };
    }, function (visualViewport) {
      var editorContainer = value();
      var resizeBinder = unbindable();
      var scrollBinder = unbindable();
      var refreshScroll = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      };
      var refreshVisualViewport = function () {
        window.requestAnimationFrame(function () {
          editorContainer.on(function (container) {
            return setAll(container, {
              top: visualViewport.offsetTop + 'px',
              left: visualViewport.offsetLeft + 'px',
              height: visualViewport.height + 'px',
              width: visualViewport.width + 'px'
            });
          });
        });
      };
      var update = global.throttle(function () {
        refreshScroll();
        refreshVisualViewport();
      }, 50);
      var bind$1 = function (element) {
        editorContainer.set(element);
        update();
        resizeBinder.set(bind('resize', update));
        scrollBinder.set(bind('scroll', update));
      };
      var unbind = function () {
        editorContainer.on(function () {
          resizeBinder.clear();
          scrollBinder.clear();
        });
        editorContainer.clear();
      };
      return {
        bind: bind$1,
        unbind: unbind
      };
    });
    var toggleFullscreen = function (editor, fullscreenState) {
      var body = document.body;
      var documentElement = document.documentElement;
      var editorContainer = editor.getContainer();
      var editorContainerS = SugarElement.fromDom(editorContainer);
      var fullscreenRoot = getFullscreenRoot(editor);
      var fullscreenInfo = fullscreenState.get();
      var editorBody = SugarElement.fromDom(editor.getBody());
      var isTouch = global$1.deviceType.isTouch();
      var editorContainerStyle = editorContainer.style;
      var iframe = editor.iframeElement;
      var iframeStyle = iframe.style;
      var handleClasses = function (handler) {
        handler(body, 'tox-fullscreen');
        handler(documentElement, 'tox-fullscreen');
        handler(editorContainer, 'tox-fullscreen');
        getShadowRoot(editorContainerS).map(function (root) {
          return getShadowHost(root).dom;
        }).each(function (host) {
          handler(host, 'tox-fullscreen');
          handler(host, 'tox-shadowhost');
        });
      };
      var cleanup = function () {
        if (isTouch) {
          restoreStyles(editor.dom);
        }
        handleClasses(DOM.removeClass);
        viewportUpdate.unbind();
        Optional.from(fullscreenState.get()).each(function (info) {
          return info.fullscreenChangeHandler.unbind();
        });
      };
      if (!fullscreenInfo) {
        var fullscreenChangeHandler = bind$1(owner(fullscreenRoot), getFullscreenchangeEventName(), function (_evt) {
          if (getFullscreenNative(editor)) {
            if (!isFullscreenElement(fullscreenRoot) && fullscreenState.get() !== null) {
              toggleFullscreen(editor, fullscreenState);
            }
          }
        });
        var newFullScreenInfo = {
          scrollPos: getScrollPos(),
          containerWidth: editorContainerStyle.width,
          containerHeight: editorContainerStyle.height,
          containerTop: editorContainerStyle.top,
          containerLeft: editorContainerStyle.left,
          iframeWidth: iframeStyle.width,
          iframeHeight: iframeStyle.height,
          fullscreenChangeHandler: fullscreenChangeHandler
        };
        if (isTouch) {
          clobberStyles(editor.dom, editorContainerS, editorBody);
        }
        iframeStyle.width = iframeStyle.height = '100%';
        editorContainerStyle.width = editorContainerStyle.height = '';
        handleClasses(DOM.addClass);
        viewportUpdate.bind(editorContainerS);
        editor.on('remove', cleanup);
        fullscreenState.set(newFullScreenInfo);
        if (getFullscreenNative(editor)) {
          requestFullscreen(fullscreenRoot);
        }
        fireFullscreenStateChanged(editor, true);
      } else {
        fullscreenInfo.fullscreenChangeHandler.unbind();
        if (getFullscreenNative(editor) && isFullscreenElement(fullscreenRoot)) {
          exitFullscreen(owner(fullscreenRoot));
        }
        iframeStyle.width = fullscreenInfo.iframeWidth;
        iframeStyle.height = fullscreenInfo.iframeHeight;
        editorContainerStyle.width = fullscreenInfo.containerWidth;
        editorContainerStyle.height = fullscreenInfo.containerHeight;
        editorContainerStyle.top = fullscreenInfo.containerTop;
        editorContainerStyle.left = fullscreenInfo.containerLeft;
        setScrollPos(fullscreenInfo.scrollPos);
        fullscreenState.set(null);
        fireFullscreenStateChanged(editor, false);
        cleanup();
        editor.off('remove', cleanup);
      }
    };

    var register$1 = function (editor, fullscreenState) {
      editor.addCommand('mceFullScreen', function () {
        toggleFullscreen(editor, fullscreenState);
      });
    };

    var makeSetupHandler = function (editor, fullscreenState) {
      return function (api) {
        api.setActive(fullscreenState.get() !== null);
        var editorEventCallback = function (e) {
          return api.setActive(e.state);
        };
        editor.on('FullscreenStateChanged', editorEventCallback);
        return function () {
          return editor.off('FullscreenStateChanged', editorEventCallback);
        };
      };
    };
    var register = function (editor, fullscreenState) {
      var onAction = function () {
        return editor.execCommand('mceFullScreen');
      };
      editor.ui.registry.addToggleMenuItem('fullscreen', {
        text: 'Fullscreen',
        icon: 'fullscreen',
        shortcut: 'Meta+Shift+F',
        onAction: onAction,
        onSetup: makeSetupHandler(editor, fullscreenState)
      });
      editor.ui.registry.addToggleButton('fullscreen', {
        tooltip: 'Fullscreen',
        icon: 'fullscreen',
        onAction: onAction,
        onSetup: makeSetupHandler(editor, fullscreenState)
      });
    };

    function Plugin () {
      global$3.add('fullscreen', function (editor) {
        var fullscreenState = Cell(null);
        if (editor.inline) {
          return get$5(fullscreenState);
        }
        register$1(editor, fullscreenState);
        register(editor, fullscreenState);
        editor.addShortcut('Meta+Shift+F', '', 'mceFullScreen');
        return get$5(fullscreenState);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "8d66":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$2 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var fireInsertCustomChar = function (editor, chr) {
      return editor.fire('insertCustomChar', { chr: chr });
    };

    var insertChar = function (editor, chr) {
      var evtChr = fireInsertCustomChar(editor, chr).chr;
      editor.execCommand('mceInsertContent', false, evtChr);
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var eq = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isArray$1 = isType('array');
    var isNull = eq(null);

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var nativePush = Array.prototype.push;
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray$1(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getCharMap$1 = function (editor) {
      return editor.getParam('charmap');
    };
    var getCharMapAppend = function (editor) {
      return editor.getParam('charmap_append');
    };

    var isArray = global$1.isArray;
    var UserDefined = 'User Defined';
    var getDefaultCharMap = function () {
      return [
        {
          name: 'Currency',
          characters: [
            [
              36,
              'dollar sign'
            ],
            [
              162,
              'cent sign'
            ],
            [
              8364,
              'euro sign'
            ],
            [
              163,
              'pound sign'
            ],
            [
              165,
              'yen sign'
            ],
            [
              164,
              'currency sign'
            ],
            [
              8352,
              'euro-currency sign'
            ],
            [
              8353,
              'colon sign'
            ],
            [
              8354,
              'cruzeiro sign'
            ],
            [
              8355,
              'french franc sign'
            ],
            [
              8356,
              'lira sign'
            ],
            [
              8357,
              'mill sign'
            ],
            [
              8358,
              'naira sign'
            ],
            [
              8359,
              'peseta sign'
            ],
            [
              8360,
              'rupee sign'
            ],
            [
              8361,
              'won sign'
            ],
            [
              8362,
              'new sheqel sign'
            ],
            [
              8363,
              'dong sign'
            ],
            [
              8365,
              'kip sign'
            ],
            [
              8366,
              'tugrik sign'
            ],
            [
              8367,
              'drachma sign'
            ],
            [
              8368,
              'german penny symbol'
            ],
            [
              8369,
              'peso sign'
            ],
            [
              8370,
              'guarani sign'
            ],
            [
              8371,
              'austral sign'
            ],
            [
              8372,
              'hryvnia sign'
            ],
            [
              8373,
              'cedi sign'
            ],
            [
              8374,
              'livre tournois sign'
            ],
            [
              8375,
              'spesmilo sign'
            ],
            [
              8376,
              'tenge sign'
            ],
            [
              8377,
              'indian rupee sign'
            ],
            [
              8378,
              'turkish lira sign'
            ],
            [
              8379,
              'nordic mark sign'
            ],
            [
              8380,
              'manat sign'
            ],
            [
              8381,
              'ruble sign'
            ],
            [
              20870,
              'yen character'
            ],
            [
              20803,
              'yuan character'
            ],
            [
              22291,
              'yuan character, in hong kong and taiwan'
            ],
            [
              22278,
              'yen/yuan character variant one'
            ]
          ]
        },
        {
          name: 'Text',
          characters: [
            [
              169,
              'copyright sign'
            ],
            [
              174,
              'registered sign'
            ],
            [
              8482,
              'trade mark sign'
            ],
            [
              8240,
              'per mille sign'
            ],
            [
              181,
              'micro sign'
            ],
            [
              183,
              'middle dot'
            ],
            [
              8226,
              'bullet'
            ],
            [
              8230,
              'three dot leader'
            ],
            [
              8242,
              'minutes / feet'
            ],
            [
              8243,
              'seconds / inches'
            ],
            [
              167,
              'section sign'
            ],
            [
              182,
              'paragraph sign'
            ],
            [
              223,
              'sharp s / ess-zed'
            ]
          ]
        },
        {
          name: 'Quotations',
          characters: [
            [
              8249,
              'single left-pointing angle quotation mark'
            ],
            [
              8250,
              'single right-pointing angle quotation mark'
            ],
            [
              171,
              'left pointing guillemet'
            ],
            [
              187,
              'right pointing guillemet'
            ],
            [
              8216,
              'left single quotation mark'
            ],
            [
              8217,
              'right single quotation mark'
            ],
            [
              8220,
              'left double quotation mark'
            ],
            [
              8221,
              'right double quotation mark'
            ],
            [
              8218,
              'single low-9 quotation mark'
            ],
            [
              8222,
              'double low-9 quotation mark'
            ],
            [
              60,
              'less-than sign'
            ],
            [
              62,
              'greater-than sign'
            ],
            [
              8804,
              'less-than or equal to'
            ],
            [
              8805,
              'greater-than or equal to'
            ],
            [
              8211,
              'en dash'
            ],
            [
              8212,
              'em dash'
            ],
            [
              175,
              'macron'
            ],
            [
              8254,
              'overline'
            ],
            [
              164,
              'currency sign'
            ],
            [
              166,
              'broken bar'
            ],
            [
              168,
              'diaeresis'
            ],
            [
              161,
              'inverted exclamation mark'
            ],
            [
              191,
              'turned question mark'
            ],
            [
              710,
              'circumflex accent'
            ],
            [
              732,
              'small tilde'
            ],
            [
              176,
              'degree sign'
            ],
            [
              8722,
              'minus sign'
            ],
            [
              177,
              'plus-minus sign'
            ],
            [
              247,
              'division sign'
            ],
            [
              8260,
              'fraction slash'
            ],
            [
              215,
              'multiplication sign'
            ],
            [
              185,
              'superscript one'
            ],
            [
              178,
              'superscript two'
            ],
            [
              179,
              'superscript three'
            ],
            [
              188,
              'fraction one quarter'
            ],
            [
              189,
              'fraction one half'
            ],
            [
              190,
              'fraction three quarters'
            ]
          ]
        },
        {
          name: 'Mathematical',
          characters: [
            [
              402,
              'function / florin'
            ],
            [
              8747,
              'integral'
            ],
            [
              8721,
              'n-ary sumation'
            ],
            [
              8734,
              'infinity'
            ],
            [
              8730,
              'square root'
            ],
            [
              8764,
              'similar to'
            ],
            [
              8773,
              'approximately equal to'
            ],
            [
              8776,
              'almost equal to'
            ],
            [
              8800,
              'not equal to'
            ],
            [
              8801,
              'identical to'
            ],
            [
              8712,
              'element of'
            ],
            [
              8713,
              'not an element of'
            ],
            [
              8715,
              'contains as member'
            ],
            [
              8719,
              'n-ary product'
            ],
            [
              8743,
              'logical and'
            ],
            [
              8744,
              'logical or'
            ],
            [
              172,
              'not sign'
            ],
            [
              8745,
              'intersection'
            ],
            [
              8746,
              'union'
            ],
            [
              8706,
              'partial differential'
            ],
            [
              8704,
              'for all'
            ],
            [
              8707,
              'there exists'
            ],
            [
              8709,
              'diameter'
            ],
            [
              8711,
              'backward difference'
            ],
            [
              8727,
              'asterisk operator'
            ],
            [
              8733,
              'proportional to'
            ],
            [
              8736,
              'angle'
            ]
          ]
        },
        {
          name: 'Extended Latin',
          characters: [
            [
              192,
              'A - grave'
            ],
            [
              193,
              'A - acute'
            ],
            [
              194,
              'A - circumflex'
            ],
            [
              195,
              'A - tilde'
            ],
            [
              196,
              'A - diaeresis'
            ],
            [
              197,
              'A - ring above'
            ],
            [
              256,
              'A - macron'
            ],
            [
              198,
              'ligature AE'
            ],
            [
              199,
              'C - cedilla'
            ],
            [
              200,
              'E - grave'
            ],
            [
              201,
              'E - acute'
            ],
            [
              202,
              'E - circumflex'
            ],
            [
              203,
              'E - diaeresis'
            ],
            [
              274,
              'E - macron'
            ],
            [
              204,
              'I - grave'
            ],
            [
              205,
              'I - acute'
            ],
            [
              206,
              'I - circumflex'
            ],
            [
              207,
              'I - diaeresis'
            ],
            [
              298,
              'I - macron'
            ],
            [
              208,
              'ETH'
            ],
            [
              209,
              'N - tilde'
            ],
            [
              210,
              'O - grave'
            ],
            [
              211,
              'O - acute'
            ],
            [
              212,
              'O - circumflex'
            ],
            [
              213,
              'O - tilde'
            ],
            [
              214,
              'O - diaeresis'
            ],
            [
              216,
              'O - slash'
            ],
            [
              332,
              'O - macron'
            ],
            [
              338,
              'ligature OE'
            ],
            [
              352,
              'S - caron'
            ],
            [
              217,
              'U - grave'
            ],
            [
              218,
              'U - acute'
            ],
            [
              219,
              'U - circumflex'
            ],
            [
              220,
              'U - diaeresis'
            ],
            [
              362,
              'U - macron'
            ],
            [
              221,
              'Y - acute'
            ],
            [
              376,
              'Y - diaeresis'
            ],
            [
              562,
              'Y - macron'
            ],
            [
              222,
              'THORN'
            ],
            [
              224,
              'a - grave'
            ],
            [
              225,
              'a - acute'
            ],
            [
              226,
              'a - circumflex'
            ],
            [
              227,
              'a - tilde'
            ],
            [
              228,
              'a - diaeresis'
            ],
            [
              229,
              'a - ring above'
            ],
            [
              257,
              'a - macron'
            ],
            [
              230,
              'ligature ae'
            ],
            [
              231,
              'c - cedilla'
            ],
            [
              232,
              'e - grave'
            ],
            [
              233,
              'e - acute'
            ],
            [
              234,
              'e - circumflex'
            ],
            [
              235,
              'e - diaeresis'
            ],
            [
              275,
              'e - macron'
            ],
            [
              236,
              'i - grave'
            ],
            [
              237,
              'i - acute'
            ],
            [
              238,
              'i - circumflex'
            ],
            [
              239,
              'i - diaeresis'
            ],
            [
              299,
              'i - macron'
            ],
            [
              240,
              'eth'
            ],
            [
              241,
              'n - tilde'
            ],
            [
              242,
              'o - grave'
            ],
            [
              243,
              'o - acute'
            ],
            [
              244,
              'o - circumflex'
            ],
            [
              245,
              'o - tilde'
            ],
            [
              246,
              'o - diaeresis'
            ],
            [
              248,
              'o slash'
            ],
            [
              333,
              'o macron'
            ],
            [
              339,
              'ligature oe'
            ],
            [
              353,
              's - caron'
            ],
            [
              249,
              'u - grave'
            ],
            [
              250,
              'u - acute'
            ],
            [
              251,
              'u - circumflex'
            ],
            [
              252,
              'u - diaeresis'
            ],
            [
              363,
              'u - macron'
            ],
            [
              253,
              'y - acute'
            ],
            [
              254,
              'thorn'
            ],
            [
              255,
              'y - diaeresis'
            ],
            [
              563,
              'y - macron'
            ],
            [
              913,
              'Alpha'
            ],
            [
              914,
              'Beta'
            ],
            [
              915,
              'Gamma'
            ],
            [
              916,
              'Delta'
            ],
            [
              917,
              'Epsilon'
            ],
            [
              918,
              'Zeta'
            ],
            [
              919,
              'Eta'
            ],
            [
              920,
              'Theta'
            ],
            [
              921,
              'Iota'
            ],
            [
              922,
              'Kappa'
            ],
            [
              923,
              'Lambda'
            ],
            [
              924,
              'Mu'
            ],
            [
              925,
              'Nu'
            ],
            [
              926,
              'Xi'
            ],
            [
              927,
              'Omicron'
            ],
            [
              928,
              'Pi'
            ],
            [
              929,
              'Rho'
            ],
            [
              931,
              'Sigma'
            ],
            [
              932,
              'Tau'
            ],
            [
              933,
              'Upsilon'
            ],
            [
              934,
              'Phi'
            ],
            [
              935,
              'Chi'
            ],
            [
              936,
              'Psi'
            ],
            [
              937,
              'Omega'
            ],
            [
              945,
              'alpha'
            ],
            [
              946,
              'beta'
            ],
            [
              947,
              'gamma'
            ],
            [
              948,
              'delta'
            ],
            [
              949,
              'epsilon'
            ],
            [
              950,
              'zeta'
            ],
            [
              951,
              'eta'
            ],
            [
              952,
              'theta'
            ],
            [
              953,
              'iota'
            ],
            [
              954,
              'kappa'
            ],
            [
              955,
              'lambda'
            ],
            [
              956,
              'mu'
            ],
            [
              957,
              'nu'
            ],
            [
              958,
              'xi'
            ],
            [
              959,
              'omicron'
            ],
            [
              960,
              'pi'
            ],
            [
              961,
              'rho'
            ],
            [
              962,
              'final sigma'
            ],
            [
              963,
              'sigma'
            ],
            [
              964,
              'tau'
            ],
            [
              965,
              'upsilon'
            ],
            [
              966,
              'phi'
            ],
            [
              967,
              'chi'
            ],
            [
              968,
              'psi'
            ],
            [
              969,
              'omega'
            ]
          ]
        },
        {
          name: 'Symbols',
          characters: [
            [
              8501,
              'alef symbol'
            ],
            [
              982,
              'pi symbol'
            ],
            [
              8476,
              'real part symbol'
            ],
            [
              978,
              'upsilon - hook symbol'
            ],
            [
              8472,
              'Weierstrass p'
            ],
            [
              8465,
              'imaginary part'
            ]
          ]
        },
        {
          name: 'Arrows',
          characters: [
            [
              8592,
              'leftwards arrow'
            ],
            [
              8593,
              'upwards arrow'
            ],
            [
              8594,
              'rightwards arrow'
            ],
            [
              8595,
              'downwards arrow'
            ],
            [
              8596,
              'left right arrow'
            ],
            [
              8629,
              'carriage return'
            ],
            [
              8656,
              'leftwards double arrow'
            ],
            [
              8657,
              'upwards double arrow'
            ],
            [
              8658,
              'rightwards double arrow'
            ],
            [
              8659,
              'downwards double arrow'
            ],
            [
              8660,
              'left right double arrow'
            ],
            [
              8756,
              'therefore'
            ],
            [
              8834,
              'subset of'
            ],
            [
              8835,
              'superset of'
            ],
            [
              8836,
              'not a subset of'
            ],
            [
              8838,
              'subset of or equal to'
            ],
            [
              8839,
              'superset of or equal to'
            ],
            [
              8853,
              'circled plus'
            ],
            [
              8855,
              'circled times'
            ],
            [
              8869,
              'perpendicular'
            ],
            [
              8901,
              'dot operator'
            ],
            [
              8968,
              'left ceiling'
            ],
            [
              8969,
              'right ceiling'
            ],
            [
              8970,
              'left floor'
            ],
            [
              8971,
              'right floor'
            ],
            [
              9001,
              'left-pointing angle bracket'
            ],
            [
              9002,
              'right-pointing angle bracket'
            ],
            [
              9674,
              'lozenge'
            ],
            [
              9824,
              'black spade suit'
            ],
            [
              9827,
              'black club suit'
            ],
            [
              9829,
              'black heart suit'
            ],
            [
              9830,
              'black diamond suit'
            ],
            [
              8194,
              'en space'
            ],
            [
              8195,
              'em space'
            ],
            [
              8201,
              'thin space'
            ],
            [
              8204,
              'zero width non-joiner'
            ],
            [
              8205,
              'zero width joiner'
            ],
            [
              8206,
              'left-to-right mark'
            ],
            [
              8207,
              'right-to-left mark'
            ]
          ]
        }
      ];
    };
    var charmapFilter = function (charmap) {
      return global$1.grep(charmap, function (item) {
        return isArray(item) && item.length === 2;
      });
    };
    var getCharsFromSetting = function (settingValue) {
      if (isArray(settingValue)) {
        return charmapFilter(settingValue);
      }
      if (typeof settingValue === 'function') {
        return settingValue();
      }
      return [];
    };
    var extendCharMap = function (editor, charmap) {
      var userCharMap = getCharMap$1(editor);
      if (userCharMap) {
        charmap = [{
            name: UserDefined,
            characters: getCharsFromSetting(userCharMap)
          }];
      }
      var userCharMapAppend = getCharMapAppend(editor);
      if (userCharMapAppend) {
        var userDefinedGroup = global$1.grep(charmap, function (cg) {
          return cg.name === UserDefined;
        });
        if (userDefinedGroup.length) {
          userDefinedGroup[0].characters = [].concat(userDefinedGroup[0].characters).concat(getCharsFromSetting(userCharMapAppend));
          return charmap;
        }
        return charmap.concat({
          name: UserDefined,
          characters: getCharsFromSetting(userCharMapAppend)
        });
      }
      return charmap;
    };
    var getCharMap = function (editor) {
      var groups = extendCharMap(editor, getDefaultCharMap());
      return groups.length > 1 ? [{
          name: 'All',
          characters: bind(groups, function (g) {
            return g.characters;
          })
        }].concat(groups) : groups;
    };

    var get = function (editor) {
      var getCharMap$1 = function () {
        return getCharMap(editor);
      };
      var insertChar$1 = function (chr) {
        insertChar(editor, chr);
      };
      return {
        getCharMap: getCharMap$1,
        insertChar: insertChar$1
      };
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var last = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        cancel();
        timer = setTimeout(function () {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var nativeFromCodePoint = String.fromCodePoint;
    var contains = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var fromCodePoint = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (nativeFromCodePoint) {
        return nativeFromCodePoint.apply(void 0, codePoints);
      } else {
        var codeUnits = [];
        var codeLen = 0;
        var result = '';
        for (var index = 0, len = codePoints.length; index !== len; ++index) {
          var codePoint = +codePoints[index];
          if (!(codePoint < 1114111 && codePoint >>> 0 === codePoint)) {
            throw RangeError('Invalid code point: ' + codePoint);
          }
          if (codePoint <= 65535) {
            codeLen = codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeLen = codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (codeLen >= 16383) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result + String.fromCharCode.apply(null, codeUnits);
      }
    };

    var charMatches = function (charCode, name, lowerCasePattern) {
      if (contains(fromCodePoint(charCode).toLowerCase(), lowerCasePattern)) {
        return true;
      } else {
        return contains(name.toLowerCase(), lowerCasePattern) || contains(name.toLowerCase().replace(/\s+/g, ''), lowerCasePattern);
      }
    };
    var scan = function (group, pattern) {
      var matches = [];
      var lowerCasePattern = pattern.toLowerCase();
      each(group.characters, function (g) {
        if (charMatches(g[0], g[1], lowerCasePattern)) {
          matches.push(g);
        }
      });
      return map(matches, function (m) {
        return {
          text: m[1],
          value: fromCodePoint(m[0]),
          icon: fromCodePoint(m[0])
        };
      });
    };

    var patternName = 'pattern';
    var open = function (editor, charMap) {
      var makeGroupItems = function () {
        return [
          {
            label: 'Search',
            type: 'input',
            name: patternName
          },
          {
            type: 'collection',
            name: 'results'
          }
        ];
      };
      var makeTabs = function () {
        return map(charMap, function (charGroup) {
          return {
            title: charGroup.name,
            name: charGroup.name,
            items: makeGroupItems()
          };
        });
      };
      var makePanel = function () {
        return {
          type: 'panel',
          items: makeGroupItems()
        };
      };
      var makeTabPanel = function () {
        return {
          type: 'tabpanel',
          tabs: makeTabs()
        };
      };
      var currentTab = charMap.length === 1 ? Cell(UserDefined) : Cell('All');
      var scanAndSet = function (dialogApi, pattern) {
        find(charMap, function (group) {
          return group.name === currentTab.get();
        }).each(function (f) {
          var items = scan(f, pattern);
          dialogApi.setData({ results: items });
        });
      };
      var SEARCH_DELAY = 40;
      var updateFilter = last(function (dialogApi) {
        var pattern = dialogApi.getData().pattern;
        scanAndSet(dialogApi, pattern);
      }, SEARCH_DELAY);
      var body = charMap.length === 1 ? makePanel() : makeTabPanel();
      var initialData = {
        pattern: '',
        results: scan(charMap[0], '')
      };
      var bridgeSpec = {
        title: 'Special Character',
        size: 'normal',
        body: body,
        buttons: [{
            type: 'cancel',
            name: 'close',
            text: 'Close',
            primary: true
          }],
        initialData: initialData,
        onAction: function (api, details) {
          if (details.name === 'results') {
            insertChar(editor, details.value);
            api.close();
          }
        },
        onTabChange: function (dialogApi, details) {
          currentTab.set(details.newTabName);
          updateFilter.throttle(dialogApi);
        },
        onChange: function (dialogApi, changeData) {
          if (changeData.name === patternName) {
            updateFilter.throttle(dialogApi);
          }
        }
      };
      var dialogApi = editor.windowManager.open(bridgeSpec);
      dialogApi.focus(patternName);
    };

    var register$1 = function (editor, charMap) {
      editor.addCommand('mceShowCharmap', function () {
        open(editor, charMap);
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var init = function (editor, all) {
      editor.ui.registry.addAutocompleter('charmap', {
        ch: ':',
        columns: 'auto',
        minChars: 2,
        fetch: function (pattern, _maxResults) {
          return new global(function (resolve, _reject) {
            resolve(scan(all, pattern));
          });
        },
        onAction: function (autocompleteApi, rng, value) {
          editor.selection.setRng(rng);
          editor.insertContent(value);
          autocompleteApi.hide();
        }
      });
    };

    var register = function (editor) {
      editor.ui.registry.addButton('charmap', {
        icon: 'insert-character',
        tooltip: 'Special character',
        onAction: function () {
          return editor.execCommand('mceShowCharmap');
        }
      });
      editor.ui.registry.addMenuItem('charmap', {
        icon: 'insert-character',
        text: 'Special character...',
        onAction: function () {
          return editor.execCommand('mceShowCharmap');
        }
      });
    };

    function Plugin () {
      global$2.add('charmap', function (editor) {
        var charMap = getCharMap(editor);
        register$1(editor, charMap);
        register(editor);
        init(editor, charMap[0]);
        return get(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "8e0d":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "image" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/image')
//   ES2015:
//     import 'tinymce/plugins/image'
__webpack_require__("7fa5");

/***/ }),

/***/ "8e2c":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "searchreplace" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/searchreplace')
//   ES2015:
//     import 'tinymce/plugins/searchreplace'
__webpack_require__("2b99");

/***/ }),

/***/ "9005":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var register$1 = function (editor) {
      editor.addCommand('InsertHorizontalRule', function () {
        editor.execCommand('mceInsertContent', false, '<hr />');
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('InsertHorizontalRule');
      };
      editor.ui.registry.addButton('hr', {
        icon: 'horizontal-rule',
        tooltip: 'Horizontal line',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('hr', {
        icon: 'horizontal-rule',
        text: 'Horizontal line',
        onAction: onAction
      });
    };

    function Plugin () {
      global.add('hr', function (editor) {
        register$1(editor);
        register(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "9153":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "nonbreaking" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/nonbreaking')
//   ES2015:
//     import 'tinymce/plugins/nonbreaking'
__webpack_require__("3205");

/***/ }),

/***/ "9156":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "media" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/media')
//   ES2015:
//     import 'tinymce/plugins/media'
__webpack_require__("2c24");

/***/ }),

/***/ "9623":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isString = isType$1('string');
    var isObject = isType$1('object');
    var isArray = isType$1('array');
    var isBoolean = isSimpleType('boolean');
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var tripleEquals = function (a, b) {
      return a === b;
    };
    var not = function (f) {
      return function (t) {
        return !f(t);
      };
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var nativeSlice = Array.prototype.slice;
    var nativePush = Array.prototype.push;
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var filter$1 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var groupBy = function (xs, f) {
      if (xs.length === 0) {
        return [];
      } else {
        var wasType = f(xs[0]);
        var r = [];
        var group = [];
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          var type = f(x);
          if (type !== wasType) {
            r.push(group);
            group = [];
          }
          wasType = type;
          group.push(x);
        }
        if (group.length !== 0) {
          r.push(group);
        }
        return r;
      }
    };
    var foldl = function (xs, f, acc) {
      each$1(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find$1 = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };
    var reverse = function (xs) {
      var r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    var get$1 = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get$1(xs, 0);
    };
    var last = function (xs) {
      return get$1(xs, xs.length - 1);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() && !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      var isPhone = isiPhone || isMobile && !isTablet;
      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$2(group(1), group(2));
    };
    var detect$3 = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find(versionRegexes, cleanedAgent);
    };
    var unknown$2 = function () {
      return nu$2(0, 0);
    };
    var nu$2 = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$2,
      detect: detect$3,
      unknown: unknown$2
    };

    var detectBrowser$1 = function (browsers, userAgentData) {
      return findMap(userAgentData.brands, function (uaBrand) {
        var lcBrand = uaBrand.brand.toLowerCase();
        return find$1(browsers, function (browser) {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(function (info) {
          return {
            current: info.name,
            version: Version.nu(parseInt(uaBrand.version, 10), 0)
          };
        });
      });
    };

    var detect$2 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find$1(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$2(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$2(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    var contains$1 = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var blank = function (r) {
      return function (s) {
        return s.replace(r, '');
      };
    };
    var trim = blank(/^\s+|\s+$/g);
    var isNotEmpty = function (s) {
      return s.length > 0;
    };
    var isEmpty$1 = function (s) {
      return !isNotEmpty(s);
    };

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains$1(uastring, target);
      };
    };
    var browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chrome',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
        }
      }
    ];
    var oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: function (uastring) {
          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'OSX',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    var edge = 'Edge';
    var chrome = 'Chrome';
    var ie = 'IE';
    var opera = 'Opera';
    var firefox = 'Firefox';
    var safari = 'Safari';
    var unknown$1 = function () {
      return nu$1({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$1 = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$1,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    var windows = 'Windows';
    var ios = 'iOS';
    var android = 'Android';
    var linux = 'Linux';
    var osx = 'OSX';
    var solaris = 'Solaris';
    var freebsd = 'FreeBSD';
    var chromeos = 'ChromeOS';
    var unknown = function () {
      return nu({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown,
      nu: nu,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    var detect$1 = function (userAgent, userAgentDataOpt, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = userAgentDataOpt.bind(function (userAgentData) {
        return detectBrowser$1(browsers, userAgentData);
      }).orThunk(function () {
        return detectBrowser(browsers, userAgent);
      }).fold(Browser.unknown, Browser.nu);
      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$1 };

    var mediaMatch = function (query) {
      return window.matchMedia(query).matches;
    };
    var platform = cached(function () {
      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);
    });
    var detect = function () {
      return platform();
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) & match) !== 0;
    };
    var documentPositionContainedBy = function (a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
    };

    var ELEMENT = 1;

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    var is$2 = function (element, selector) {
      var dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };

    var eq = function (e1, e2) {
      return e1.dom === e2.dom;
    };
    var regularContains = function (e1, e2) {
      var d1 = e1.dom;
      var d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function (e1, e2) {
      return documentPositionContainedBy(e1.dom, e2.dom);
    };
    var contains = function (e1, e2) {
      return detect().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };
    var is$1 = is$2;

    var global$6 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');

    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');

    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');

    var keys = Object.keys;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var name = function (element) {
      var r = element.dom.nodeName;
      return r.toLowerCase();
    };
    var type = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isElement = isType(ELEMENT);
    var isTag = function (tag) {
      return function (e) {
        return isElement(e) && name(e) === tag;
      };
    };

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var setAll = function (element, attrs) {
      var dom = element.dom;
      each(attrs, function (v, k) {
        rawSet(dom, k, v);
      });
    };
    var clone$1 = function (element) {
      return foldl(element.dom.attributes, function (acc, attr) {
        acc[attr.name] = attr.value;
        return acc;
      }, {});
    };

    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var children = function (element) {
      return map(element.dom.childNodes, SugarElement.fromDom);
    };
    var child = function (element, index) {
      var cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    var firstChild = function (element) {
      return child(element, 0);
    };
    var lastChild = function (element) {
      return child(element, element.dom.childNodes.length - 1);
    };

    var before$1 = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var append$1 = function (parent, element) {
      parent.dom.appendChild(element.dom);
    };

    var before = function (marker, elements) {
      each$1(elements, function (x) {
        before$1(marker, x);
      });
    };
    var append = function (parent, elements) {
      each$1(elements, function (x) {
        append$1(parent, x);
      });
    };

    var remove = function (element) {
      var dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };

    var clone = function (original, isDeep) {
      return SugarElement.fromDom(original.dom.cloneNode(isDeep));
    };
    var deep = function (original) {
      return clone(original, true);
    };
    var shallowAs = function (original, tag) {
      var nu = SugarElement.fromTag(tag);
      var attributes = clone$1(original);
      setAll(nu, attributes);
      return nu;
    };
    var mutate = function (original, tag) {
      var nu = shallowAs(original, tag);
      before$1(original, nu);
      var children$1 = children(original);
      append(nu, children$1);
      remove(original);
      return nu;
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var matchNodeName = function (name) {
      return function (node) {
        return node && node.nodeName.toLowerCase() === name;
      };
    };
    var matchNodeNames = function (regex) {
      return function (node) {
        return node && regex.test(node.nodeName);
      };
    };
    var isTextNode = function (node) {
      return node && node.nodeType === 3;
    };
    var isListNode = matchNodeNames(/^(OL|UL|DL)$/);
    var isOlUlNode = matchNodeNames(/^(OL|UL)$/);
    var isOlNode = matchNodeName('ol');
    var isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);
    var isDlItemNode = matchNodeNames(/^(DT|DD)$/);
    var isTableCellNode = matchNodeNames(/^(TH|TD)$/);
    var isBr = matchNodeName('br');
    var isFirstChild = function (node) {
      return node.parentNode.firstChild === node;
    };
    var isTextBlock = function (editor, node) {
      return node && !!editor.schema.getTextBlockElements()[node.nodeName];
    };
    var isBlock = function (node, blockElements) {
      return node && node.nodeName in blockElements;
    };
    var isBogusBr = function (dom, node) {
      if (!isBr(node)) {
        return false;
      }
      return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);
    };
    var isEmpty = function (dom, elm, keepBookmarks) {
      var empty = dom.isEmpty(elm);
      if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {
        return false;
      }
      return empty;
    };
    var isChildOfBody = function (dom, elm) {
      return dom.isChildOf(elm, dom.getRoot());
    };

    var shouldIndentOnTab = function (editor) {
      return editor.getParam('lists_indent_on_tab', true);
    };
    var getForcedRootBlock = function (editor) {
      var block = editor.getParam('forced_root_block', 'p');
      if (block === false) {
        return '';
      } else if (block === true) {
        return 'p';
      } else {
        return block;
      }
    };
    var getForcedRootBlockAttrs = function (editor) {
      return editor.getParam('forced_root_block_attrs', {});
    };

    var createTextBlock = function (editor, contentNode) {
      var dom = editor.dom;
      var blockElements = editor.schema.getBlockElements();
      var fragment = dom.createFragment();
      var blockName = getForcedRootBlock(editor);
      var node, textBlock, hasContentNode;
      if (blockName) {
        textBlock = dom.create(blockName);
        if (textBlock.tagName === blockName.toUpperCase()) {
          dom.setAttribs(textBlock, getForcedRootBlockAttrs(editor));
        }
        if (!isBlock(contentNode.firstChild, blockElements)) {
          fragment.appendChild(textBlock);
        }
      }
      if (contentNode) {
        while (node = contentNode.firstChild) {
          var nodeName = node.nodeName;
          if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {
            hasContentNode = true;
          }
          if (isBlock(node, blockElements)) {
            fragment.appendChild(node);
            textBlock = null;
          } else {
            if (blockName) {
              if (!textBlock) {
                textBlock = dom.create(blockName);
                fragment.appendChild(textBlock);
              }
              textBlock.appendChild(node);
            } else {
              fragment.appendChild(node);
            }
          }
        }
      }
      if (!blockName) {
        fragment.appendChild(dom.create('br'));
      } else {
        if (!hasContentNode) {
          textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));
        }
      }
      return fragment;
    };

    var DOM$2 = global$3.DOM;
    var splitList = function (editor, list, li) {
      var removeAndKeepBookmarks = function (targetNode) {
        global$2.each(bookmarks, function (node) {
          targetNode.parentNode.insertBefore(node, li.parentNode);
        });
        DOM$2.remove(targetNode);
      };
      var bookmarks = DOM$2.select('span[data-mce-type="bookmark"]', list);
      var newBlock = createTextBlock(editor, li);
      var tmpRng = DOM$2.createRng();
      tmpRng.setStartAfter(li);
      tmpRng.setEndAfter(list);
      var fragment = tmpRng.extractContents();
      for (var node = fragment.firstChild; node; node = node.firstChild) {
        if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {
          DOM$2.remove(node);
          break;
        }
      }
      if (!editor.dom.isEmpty(fragment)) {
        DOM$2.insertAfter(fragment, list);
      }
      DOM$2.insertAfter(newBlock, list);
      if (isEmpty(editor.dom, li.parentNode)) {
        removeAndKeepBookmarks(li.parentNode);
      }
      DOM$2.remove(li);
      if (isEmpty(editor.dom, list)) {
        DOM$2.remove(list);
      }
    };

    var isDescriptionDetail = isTag('dd');
    var isDescriptionTerm = isTag('dt');
    var outdentDlItem = function (editor, item) {
      if (isDescriptionDetail(item)) {
        mutate(item, 'dt');
      } else if (isDescriptionTerm(item)) {
        parent(item).each(function (dl) {
          return splitList(editor, dl.dom, item.dom);
        });
      }
    };
    var indentDlItem = function (item) {
      if (isDescriptionTerm(item)) {
        mutate(item, 'dd');
      }
    };
    var dlIndentation = function (editor, indentation, dlItems) {
      if (indentation === 'Indent') {
        each$1(dlItems, indentDlItem);
      } else {
        each$1(dlItems, function (item) {
          return outdentDlItem(editor, item);
        });
      }
    };

    var getNormalizedPoint = function (container, offset) {
      if (isTextNode(container)) {
        return {
          container: container,
          offset: offset
        };
      }
      var node = global$6.getNode(container, offset);
      if (isTextNode(node)) {
        return {
          container: node,
          offset: offset >= container.childNodes.length ? node.data.length : 0
        };
      } else if (node.previousSibling && isTextNode(node.previousSibling)) {
        return {
          container: node.previousSibling,
          offset: node.previousSibling.data.length
        };
      } else if (node.nextSibling && isTextNode(node.nextSibling)) {
        return {
          container: node.nextSibling,
          offset: 0
        };
      }
      return {
        container: container,
        offset: offset
      };
    };
    var normalizeRange = function (rng) {
      var outRng = rng.cloneRange();
      var rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);
      outRng.setStart(rangeStart.container, rangeStart.offset);
      var rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);
      outRng.setEnd(rangeEnd.container, rangeEnd.offset);
      return outRng;
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.DomQuery');

    var getParentList = function (editor, node) {
      var selectionStart = node || editor.selection.getStart(true);
      return editor.dom.getParent(selectionStart, 'OL,UL,DL', getClosestListRootElm(editor, selectionStart));
    };
    var isParentListSelected = function (parentList, selectedBlocks) {
      return parentList && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;
    };
    var findSubLists = function (parentList) {
      return filter$1(parentList.querySelectorAll('ol,ul,dl'), isListNode);
    };
    var getSelectedSubLists = function (editor) {
      var parentList = getParentList(editor);
      var selectedBlocks = editor.selection.getSelectedBlocks();
      if (isParentListSelected(parentList, selectedBlocks)) {
        return findSubLists(parentList);
      } else {
        return filter$1(selectedBlocks, function (elm) {
          return isListNode(elm) && parentList !== elm;
        });
      }
    };
    var findParentListItemsNodes = function (editor, elms) {
      var listItemsElms = global$2.map(elms, function (elm) {
        var parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListRootElm(editor, elm));
        return parentLi ? parentLi : elm;
      });
      return global$1.unique(listItemsElms);
    };
    var getSelectedListItems = function (editor) {
      var selectedBlocks = editor.selection.getSelectedBlocks();
      return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);
    };
    var getSelectedDlItems = function (editor) {
      return filter$1(getSelectedListItems(editor), isDlItemNode);
    };
    var getClosestListRootElm = function (editor, elm) {
      var parentTableCell = editor.dom.getParents(elm, 'TD,TH');
      return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();
    };
    var findLastParentListNode = function (editor, elm) {
      var parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListRootElm(editor, elm));
      return last(parentLists);
    };
    var getSelectedLists = function (editor) {
      var firstList = findLastParentListNode(editor, editor.selection.getStart());
      var subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);
      return firstList.toArray().concat(subsequentLists);
    };
    var getSelectedListRoots = function (editor) {
      var selectedLists = getSelectedLists(editor);
      return getUniqueListRoots(editor, selectedLists);
    };
    var getUniqueListRoots = function (editor, lists) {
      var listRoots = map(lists, function (list) {
        return findLastParentListNode(editor, list).getOr(list);
      });
      return global$1.unique(listRoots);
    };

    var is = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lhs.exists(function (left) {
        return comparator(left, rhs);
      });
    };
    var lift2 = function (oa, ob, f) {
      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    };

    var fromElements = function (elements, scope) {
      var doc = scope || document;
      var fragment = doc.createDocumentFragment();
      each$1(elements, function (element) {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };

    var fireListEvent = function (editor, action, element) {
      return editor.fire('ListMutation', {
        action: action,
        element: element
      });
    };

    var isSupported = function (dom) {
      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
    };

    var internalSet = function (dom, property, value) {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var set = function (element, property, value) {
      var dom = element.dom;
      internalSet(dom, property, value);
    };

    var joinSegment = function (parent, child) {
      append$1(parent.item, child.list);
    };
    var joinSegments = function (segments) {
      for (var i = 1; i < segments.length; i++) {
        joinSegment(segments[i - 1], segments[i]);
      }
    };
    var appendSegments = function (head$1, tail) {
      lift2(last(head$1), head(tail), joinSegment);
    };
    var createSegment = function (scope, listType) {
      var segment = {
        list: SugarElement.fromTag(listType, scope),
        item: SugarElement.fromTag('li', scope)
      };
      append$1(segment.list, segment.item);
      return segment;
    };
    var createSegments = function (scope, entry, size) {
      var segments = [];
      for (var i = 0; i < size; i++) {
        segments.push(createSegment(scope, entry.listType));
      }
      return segments;
    };
    var populateSegments = function (segments, entry) {
      for (var i = 0; i < segments.length - 1; i++) {
        set(segments[i].item, 'list-style-type', 'none');
      }
      last(segments).each(function (segment) {
        setAll(segment.list, entry.listAttributes);
        setAll(segment.item, entry.itemAttributes);
        append(segment.item, entry.content);
      });
    };
    var normalizeSegment = function (segment, entry) {
      if (name(segment.list) !== entry.listType) {
        segment.list = mutate(segment.list, entry.listType);
      }
      setAll(segment.list, entry.listAttributes);
    };
    var createItem = function (scope, attr, content) {
      var item = SugarElement.fromTag('li', scope);
      setAll(item, attr);
      append(item, content);
      return item;
    };
    var appendItem = function (segment, item) {
      append$1(segment.list, item);
      segment.item = item;
    };
    var writeShallow = function (scope, cast, entry) {
      var newCast = cast.slice(0, entry.depth);
      last(newCast).each(function (segment) {
        var item = createItem(scope, entry.itemAttributes, entry.content);
        appendItem(segment, item);
        normalizeSegment(segment, entry);
      });
      return newCast;
    };
    var writeDeep = function (scope, cast, entry) {
      var segments = createSegments(scope, entry, entry.depth - cast.length);
      joinSegments(segments);
      populateSegments(segments, entry);
      appendSegments(cast, segments);
      return cast.concat(segments);
    };
    var composeList = function (scope, entries) {
      var cast = foldl(entries, function (cast, entry) {
        return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);
      }, []);
      return head(cast).map(function (segment) {
        return segment.list;
      });
    };

    var isList = function (el) {
      return is$1(el, 'OL,UL');
    };
    var hasFirstChildList = function (el) {
      return firstChild(el).exists(isList);
    };
    var hasLastChildList = function (el) {
      return lastChild(el).exists(isList);
    };

    var isIndented = function (entry) {
      return entry.depth > 0;
    };
    var isSelected = function (entry) {
      return entry.isSelected;
    };
    var cloneItemContent = function (li) {
      var children$1 = children(li);
      var content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;
      return map(content, deep);
    };
    var createEntry = function (li, depth, isSelected) {
      return parent(li).filter(isElement).map(function (list) {
        return {
          depth: depth,
          dirty: false,
          isSelected: isSelected,
          content: cloneItemContent(li),
          itemAttributes: clone$1(li),
          listAttributes: clone$1(list),
          listType: name(list)
        };
      });
    };

    var indentEntry = function (indentation, entry) {
      switch (indentation) {
      case 'Indent':
        entry.depth++;
        break;
      case 'Outdent':
        entry.depth--;
        break;
      case 'Flatten':
        entry.depth = 0;
      }
      entry.dirty = true;
    };

    var cloneListProperties = function (target, source) {
      target.listType = source.listType;
      target.listAttributes = __assign({}, source.listAttributes);
    };
    var cleanListProperties = function (entry) {
      entry.listAttributes = filter(entry.listAttributes, function (_value, key) {
        return key !== 'start';
      });
    };
    var closestSiblingEntry = function (entries, start) {
      var depth = entries[start].depth;
      var matches = function (entry) {
        return entry.depth === depth && !entry.dirty;
      };
      var until = function (entry) {
        return entry.depth < depth;
      };
      return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(function () {
        return findUntil(entries.slice(start + 1), matches, until);
      });
    };
    var normalizeEntries = function (entries) {
      each$1(entries, function (entry, i) {
        closestSiblingEntry(entries, i).fold(function () {
          if (entry.dirty) {
            cleanListProperties(entry);
          }
        }, function (matchingEntry) {
          return cloneListProperties(entry, matchingEntry);
        });
      });
      return entries;
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var parseItem = function (depth, itemSelection, selectionState, item) {
      return firstChild(item).filter(isList).fold(function () {
        itemSelection.each(function (selection) {
          if (eq(selection.start, item)) {
            selectionState.set(true);
          }
        });
        var currentItemEntry = createEntry(item, depth, selectionState.get());
        itemSelection.each(function (selection) {
          if (eq(selection.end, item)) {
            selectionState.set(false);
          }
        });
        var childListEntries = lastChild(item).filter(isList).map(function (list) {
          return parseList(depth, itemSelection, selectionState, list);
        }).getOr([]);
        return currentItemEntry.toArray().concat(childListEntries);
      }, function (list) {
        return parseList(depth, itemSelection, selectionState, list);
      });
    };
    var parseList = function (depth, itemSelection, selectionState, list) {
      return bind(children(list), function (element) {
        var parser = isList(element) ? parseList : parseItem;
        var newDepth = depth + 1;
        return parser(newDepth, itemSelection, selectionState, element);
      });
    };
    var parseLists = function (lists, itemSelection) {
      var selectionState = Cell(false);
      var initialDepth = 0;
      return map(lists, function (list) {
        return {
          sourceList: list,
          entries: parseList(initialDepth, itemSelection, selectionState, list)
        };
      });
    };

    var outdentedComposer = function (editor, entries) {
      var normalizedEntries = normalizeEntries(entries);
      return map(normalizedEntries, function (entry) {
        var content = fromElements(entry.content);
        return SugarElement.fromDom(createTextBlock(editor, content.dom));
      });
    };
    var indentedComposer = function (editor, entries) {
      var normalizedEntries = normalizeEntries(entries);
      return composeList(editor.contentDocument, normalizedEntries).toArray();
    };
    var composeEntries = function (editor, entries) {
      return bind(groupBy(entries, isIndented), function (entries) {
        var groupIsIndented = head(entries).exists(isIndented);
        return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);
      });
    };
    var indentSelectedEntries = function (entries, indentation) {
      each$1(filter$1(entries, isSelected), function (entry) {
        return indentEntry(indentation, entry);
      });
    };
    var getItemSelection = function (editor) {
      var selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);
      return lift2(find$1(selectedListItems, not(hasFirstChildList)), find$1(reverse(selectedListItems), not(hasFirstChildList)), function (start, end) {
        return {
          start: start,
          end: end
        };
      });
    };
    var listIndentation = function (editor, lists, indentation) {
      var entrySets = parseLists(lists, getItemSelection(editor));
      each$1(entrySets, function (entrySet) {
        indentSelectedEntries(entrySet.entries, indentation);
        var composedLists = composeEntries(editor, entrySet.entries);
        each$1(composedLists, function (composedList) {
          fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);
        });
        before(entrySet.sourceList, composedLists);
        remove(entrySet.sourceList);
      });
    };

    var selectionIndentation = function (editor, indentation) {
      var lists = map(getSelectedListRoots(editor), SugarElement.fromDom);
      var dlItems = map(getSelectedDlItems(editor), SugarElement.fromDom);
      var isHandled = false;
      if (lists.length || dlItems.length) {
        var bookmark = editor.selection.getBookmark();
        listIndentation(editor, lists, indentation);
        dlIndentation(editor, indentation, dlItems);
        editor.selection.moveToBookmark(bookmark);
        editor.selection.setRng(normalizeRange(editor.selection.getRng()));
        editor.nodeChanged();
        isHandled = true;
      }
      return isHandled;
    };
    var indentListSelection = function (editor) {
      return selectionIndentation(editor, 'Indent');
    };
    var outdentListSelection = function (editor) {
      return selectionIndentation(editor, 'Outdent');
    };
    var flattenListSelection = function (editor) {
      return selectionIndentation(editor, 'Flatten');
    };

    var global = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');

    var DOM$1 = global$3.DOM;
    var createBookmark = function (rng) {
      var bookmark = {};
      var setupEndPoint = function (start) {
        var container = rng[start ? 'startContainer' : 'endContainer'];
        var offset = rng[start ? 'startOffset' : 'endOffset'];
        if (container.nodeType === 1) {
          var offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });
          if (container.hasChildNodes()) {
            offset = Math.min(offset, container.childNodes.length - 1);
            if (start) {
              container.insertBefore(offsetNode, container.childNodes[offset]);
            } else {
              DOM$1.insertAfter(offsetNode, container.childNodes[offset]);
            }
          } else {
            container.appendChild(offsetNode);
          }
          container = offsetNode;
          offset = 0;
        }
        bookmark[start ? 'startContainer' : 'endContainer'] = container;
        bookmark[start ? 'startOffset' : 'endOffset'] = offset;
      };
      setupEndPoint(true);
      if (!rng.collapsed) {
        setupEndPoint();
      }
      return bookmark;
    };
    var resolveBookmark = function (bookmark) {
      var restoreEndPoint = function (start) {
        var node;
        var nodeIndex = function (container) {
          var node = container.parentNode.firstChild, idx = 0;
          while (node) {
            if (node === container) {
              return idx;
            }
            if (node.nodeType !== 1 || node.getAttribute('data-mce-type') !== 'bookmark') {
              idx++;
            }
            node = node.nextSibling;
          }
          return -1;
        };
        var container = node = bookmark[start ? 'startContainer' : 'endContainer'];
        var offset = bookmark[start ? 'startOffset' : 'endOffset'];
        if (!container) {
          return;
        }
        if (container.nodeType === 1) {
          offset = nodeIndex(container);
          container = container.parentNode;
          DOM$1.remove(node);
          if (!container.hasChildNodes() && DOM$1.isBlock(container)) {
            container.appendChild(DOM$1.create('br'));
          }
        }
        bookmark[start ? 'startContainer' : 'endContainer'] = container;
        bookmark[start ? 'startOffset' : 'endOffset'] = offset;
      };
      restoreEndPoint(true);
      restoreEndPoint();
      var rng = DOM$1.createRng();
      rng.setStart(bookmark.startContainer, bookmark.startOffset);
      if (bookmark.endContainer) {
        rng.setEnd(bookmark.endContainer, bookmark.endOffset);
      }
      return normalizeRange(rng);
    };

    var listToggleActionFromListName = function (listName) {
      switch (listName) {
      case 'UL':
        return 'ToggleUlList';
      case 'OL':
        return 'ToggleOlList';
      case 'DL':
        return 'ToggleDLList';
      }
    };

    var isCustomList = function (list) {
      return /\btox\-/.test(list.className);
    };
    var listState = function (editor, listName, activate) {
      var nodeChangeHandler = function (e) {
        var inList = findUntil(e.parents, isListNode, isTableCellNode).filter(function (list) {
          return list.nodeName === listName && !isCustomList(list);
        }).isSome();
        activate(inList);
      };
      var parents = editor.dom.getParents(editor.selection.getNode());
      nodeChangeHandler({ parents: parents });
      editor.on('NodeChange', nodeChangeHandler);
      return function () {
        return editor.off('NodeChange', nodeChangeHandler);
      };
    };

    var updateListStyle = function (dom, el, detail) {
      var type = detail['list-style-type'] ? detail['list-style-type'] : null;
      dom.setStyle(el, 'list-style-type', type);
    };
    var setAttribs = function (elm, attrs) {
      global$2.each(attrs, function (value, key) {
        elm.setAttribute(key, value);
      });
    };
    var updateListAttrs = function (dom, el, detail) {
      setAttribs(el, detail['list-attributes']);
      global$2.each(dom.select('li', el), function (li) {
        setAttribs(li, detail['list-item-attributes']);
      });
    };
    var updateListWithDetails = function (dom, el, detail) {
      updateListStyle(dom, el, detail);
      updateListAttrs(dom, el, detail);
    };
    var removeStyles = function (dom, element, styles) {
      global$2.each(styles, function (style) {
        var _a;
        return dom.setStyle(element, (_a = {}, _a[style] = '', _a));
      });
    };
    var getEndPointNode = function (editor, rng, start, root) {
      var container = rng[start ? 'startContainer' : 'endContainer'];
      var offset = rng[start ? 'startOffset' : 'endOffset'];
      if (container.nodeType === 1) {
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
      }
      if (!start && isBr(container.nextSibling)) {
        container = container.nextSibling;
      }
      while (container.parentNode !== root) {
        if (isTextBlock(editor, container)) {
          return container;
        }
        if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {
          return container;
        }
        container = container.parentNode;
      }
      return container;
    };
    var getSelectedTextBlocks = function (editor, rng, root) {
      var textBlocks = [];
      var dom = editor.dom;
      var startNode = getEndPointNode(editor, rng, true, root);
      var endNode = getEndPointNode(editor, rng, false, root);
      var block;
      var siblings = [];
      for (var node = startNode; node; node = node.nextSibling) {
        siblings.push(node);
        if (node === endNode) {
          break;
        }
      }
      global$2.each(siblings, function (node) {
        if (isTextBlock(editor, node)) {
          textBlocks.push(node);
          block = null;
          return;
        }
        if (dom.isBlock(node) || isBr(node)) {
          if (isBr(node)) {
            dom.remove(node);
          }
          block = null;
          return;
        }
        var nextSibling = node.nextSibling;
        if (global.isBookmarkNode(node)) {
          if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {
            block = null;
            return;
          }
        }
        if (!block) {
          block = dom.create('p');
          node.parentNode.insertBefore(block, node);
          textBlocks.push(block);
        }
        block.appendChild(node);
      });
      return textBlocks;
    };
    var hasCompatibleStyle = function (dom, sib, detail) {
      var sibStyle = dom.getStyle(sib, 'list-style-type');
      var detailStyle = detail ? detail['list-style-type'] : '';
      detailStyle = detailStyle === null ? '' : detailStyle;
      return sibStyle === detailStyle;
    };
    var applyList = function (editor, listName, detail) {
      var rng = editor.selection.getRng();
      var listItemName = 'LI';
      var root = getClosestListRootElm(editor, editor.selection.getStart(true));
      var dom = editor.dom;
      if (dom.getContentEditable(editor.selection.getNode()) === 'false') {
        return;
      }
      listName = listName.toUpperCase();
      if (listName === 'DL') {
        listItemName = 'DT';
      }
      var bookmark = createBookmark(rng);
      var selectedTextBlocks = getSelectedTextBlocks(editor, rng, root);
      global$2.each(selectedTextBlocks, function (block) {
        var listBlock;
        var sibling = block.previousSibling;
        var parent = block.parentNode;
        if (!isListItemNode(parent)) {
          if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {
            listBlock = sibling;
            block = dom.rename(block, listItemName);
            sibling.appendChild(block);
          } else {
            listBlock = dom.create(listName);
            block.parentNode.insertBefore(listBlock, block);
            listBlock.appendChild(block);
            block = dom.rename(block, listItemName);
          }
          removeStyles(dom, block, [
            'margin',
            'margin-right',
            'margin-bottom',
            'margin-left',
            'margin-top',
            'padding',
            'padding-right',
            'padding-bottom',
            'padding-left',
            'padding-top'
          ]);
          updateListWithDetails(dom, listBlock, detail);
          mergeWithAdjacentLists(editor.dom, listBlock);
        }
      });
      editor.selection.setRng(resolveBookmark(bookmark));
    };
    var isValidLists = function (list1, list2) {
      return list1 && list2 && isListNode(list1) && list1.nodeName === list2.nodeName;
    };
    var hasSameListStyle = function (dom, list1, list2) {
      var targetStyle = dom.getStyle(list1, 'list-style-type', true);
      var style = dom.getStyle(list2, 'list-style-type', true);
      return targetStyle === style;
    };
    var hasSameClasses = function (elm1, elm2) {
      return elm1.className === elm2.className;
    };
    var shouldMerge = function (dom, list1, list2) {
      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);
    };
    var mergeWithAdjacentLists = function (dom, listBlock) {
      var sibling, node;
      sibling = listBlock.nextSibling;
      if (shouldMerge(dom, listBlock, sibling)) {
        while (node = sibling.firstChild) {
          listBlock.appendChild(node);
        }
        dom.remove(sibling);
      }
      sibling = listBlock.previousSibling;
      if (shouldMerge(dom, listBlock, sibling)) {
        while (node = sibling.lastChild) {
          listBlock.insertBefore(node, listBlock.firstChild);
        }
        dom.remove(sibling);
      }
    };
    var updateList$1 = function (editor, list, listName, detail) {
      if (list.nodeName !== listName) {
        var newList = editor.dom.rename(list, listName);
        updateListWithDetails(editor.dom, newList, detail);
        fireListEvent(editor, listToggleActionFromListName(listName), newList);
      } else {
        updateListWithDetails(editor.dom, list, detail);
        fireListEvent(editor, listToggleActionFromListName(listName), list);
      }
    };
    var toggleMultipleLists = function (editor, parentList, lists, listName, detail) {
      var parentIsList = isListNode(parentList);
      if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail)) {
        flattenListSelection(editor);
      } else {
        applyList(editor, listName, detail);
        var bookmark = createBookmark(editor.selection.getRng());
        var allLists = parentIsList ? __spreadArray([parentList], lists, true) : lists;
        global$2.each(allLists, function (elm) {
          updateList$1(editor, elm, listName, detail);
        });
        editor.selection.setRng(resolveBookmark(bookmark));
      }
    };
    var hasListStyleDetail = function (detail) {
      return 'list-style-type' in detail;
    };
    var toggleSingleList = function (editor, parentList, listName, detail) {
      if (parentList === editor.getBody()) {
        return;
      }
      if (parentList) {
        if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {
          flattenListSelection(editor);
        } else {
          var bookmark = createBookmark(editor.selection.getRng());
          updateListWithDetails(editor.dom, parentList, detail);
          var newList = editor.dom.rename(parentList, listName);
          mergeWithAdjacentLists(editor.dom, newList);
          editor.selection.setRng(resolveBookmark(bookmark));
          applyList(editor, listName, detail);
          fireListEvent(editor, listToggleActionFromListName(listName), newList);
        }
      } else {
        applyList(editor, listName, detail);
        fireListEvent(editor, listToggleActionFromListName(listName), parentList);
      }
    };
    var toggleList = function (editor, listName, _detail) {
      var parentList = getParentList(editor);
      var selectedSubLists = getSelectedSubLists(editor);
      var detail = isObject(_detail) ? _detail : {};
      if (selectedSubLists.length > 0) {
        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);
      } else {
        toggleSingleList(editor, parentList, listName, detail);
      }
    };

    var DOM = global$3.DOM;
    var normalizeList = function (dom, list) {
      var parentNode = list.parentNode;
      if (parentNode.nodeName === 'LI' && parentNode.firstChild === list) {
        var sibling = parentNode.previousSibling;
        if (sibling && sibling.nodeName === 'LI') {
          sibling.appendChild(list);
          if (isEmpty(dom, parentNode)) {
            DOM.remove(parentNode);
          }
        } else {
          DOM.setStyle(parentNode, 'listStyleType', 'none');
        }
      }
      if (isListNode(parentNode)) {
        var sibling = parentNode.previousSibling;
        if (sibling && sibling.nodeName === 'LI') {
          sibling.appendChild(list);
        }
      }
    };
    var normalizeLists = function (dom, element) {
      var lists = global$2.grep(dom.select('ol,ul', element));
      global$2.each(lists, function (list) {
        normalizeList(dom, list);
      });
    };

    var findNextCaretContainer = function (editor, rng, isForward, root) {
      var node = rng.startContainer;
      var offset = rng.startOffset;
      if (isTextNode(node) && (isForward ? offset < node.data.length : offset > 0)) {
        return node;
      }
      var nonEmptyBlocks = editor.schema.getNonEmptyElements();
      if (node.nodeType === 1) {
        node = global$6.getNode(node, offset);
      }
      var walker = new global$5(node, root);
      if (isForward) {
        if (isBogusBr(editor.dom, node)) {
          walker.next();
        }
      }
      while (node = walker[isForward ? 'next' : 'prev2']()) {
        if (node.nodeName === 'LI' && !node.hasChildNodes()) {
          return node;
        }
        if (nonEmptyBlocks[node.nodeName]) {
          return node;
        }
        if (isTextNode(node) && node.data.length > 0) {
          return node;
        }
      }
    };
    var hasOnlyOneBlockChild = function (dom, elm) {
      var childNodes = elm.childNodes;
      return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);
    };
    var unwrapSingleBlockChild = function (dom, elm) {
      if (hasOnlyOneBlockChild(dom, elm)) {
        dom.remove(elm.firstChild, true);
      }
    };
    var moveChildren = function (dom, fromElm, toElm) {
      var node;
      var targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;
      unwrapSingleBlockChild(dom, fromElm);
      if (!isEmpty(dom, fromElm, true)) {
        while (node = fromElm.firstChild) {
          targetElm.appendChild(node);
        }
      }
    };
    var mergeLiElements = function (dom, fromElm, toElm) {
      var listNode;
      var ul = fromElm.parentNode;
      if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {
        return;
      }
      if (isListNode(toElm.lastChild)) {
        listNode = toElm.lastChild;
      }
      if (ul === toElm.lastChild) {
        if (isBr(ul.previousSibling)) {
          dom.remove(ul.previousSibling);
        }
      }
      var node = toElm.lastChild;
      if (node && isBr(node) && fromElm.hasChildNodes()) {
        dom.remove(node);
      }
      if (isEmpty(dom, toElm, true)) {
        dom.$(toElm).empty();
      }
      moveChildren(dom, fromElm, toElm);
      if (listNode) {
        toElm.appendChild(listNode);
      }
      var contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));
      var nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];
      dom.remove(fromElm);
      each$1(nestedLists, function (list) {
        if (isEmpty(dom, list) && list !== dom.getRoot()) {
          dom.remove(list);
        }
      });
    };
    var mergeIntoEmptyLi = function (editor, fromLi, toLi) {
      editor.dom.$(toLi).empty();
      mergeLiElements(editor.dom, fromLi, toLi);
      editor.selection.setCursorLocation(toLi, 0);
    };
    var mergeForward = function (editor, rng, fromLi, toLi) {
      var dom = editor.dom;
      if (dom.isEmpty(toLi)) {
        mergeIntoEmptyLi(editor, fromLi, toLi);
      } else {
        var bookmark = createBookmark(rng);
        mergeLiElements(dom, fromLi, toLi);
        editor.selection.setRng(resolveBookmark(bookmark));
      }
    };
    var mergeBackward = function (editor, rng, fromLi, toLi) {
      var bookmark = createBookmark(rng);
      mergeLiElements(editor.dom, fromLi, toLi);
      var resolvedBookmark = resolveBookmark(bookmark);
      editor.selection.setRng(resolvedBookmark);
    };
    var backspaceDeleteFromListToListCaret = function (editor, isForward) {
      var dom = editor.dom, selection = editor.selection;
      var selectionStartElm = selection.getStart();
      var root = getClosestListRootElm(editor, selectionStartElm);
      var li = dom.getParent(selection.getStart(), 'LI', root);
      if (li) {
        var ul = li.parentNode;
        if (ul === editor.getBody() && isEmpty(dom, ul)) {
          return true;
        }
        var rng_1 = normalizeRange(selection.getRng());
        var otherLi_1 = dom.getParent(findNextCaretContainer(editor, rng_1, isForward, root), 'LI', root);
        if (otherLi_1 && otherLi_1 !== li) {
          editor.undoManager.transact(function () {
            if (isForward) {
              mergeForward(editor, rng_1, otherLi_1, li);
            } else {
              if (isFirstChild(li)) {
                outdentListSelection(editor);
              } else {
                mergeBackward(editor, rng_1, li, otherLi_1);
              }
            }
          });
          return true;
        } else if (!otherLi_1) {
          if (!isForward && rng_1.startOffset === 0 && rng_1.endOffset === 0) {
            editor.undoManager.transact(function () {
              flattenListSelection(editor);
            });
            return true;
          }
        }
      }
      return false;
    };
    var removeBlock = function (dom, block, root) {
      var parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);
      dom.remove(block);
      if (parentBlock && dom.isEmpty(parentBlock)) {
        dom.remove(parentBlock);
      }
    };
    var backspaceDeleteIntoListCaret = function (editor, isForward) {
      var dom = editor.dom;
      var selectionStartElm = editor.selection.getStart();
      var root = getClosestListRootElm(editor, selectionStartElm);
      var block = dom.getParent(selectionStartElm, dom.isBlock, root);
      if (block && dom.isEmpty(block)) {
        var rng = normalizeRange(editor.selection.getRng());
        var otherLi_2 = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);
        if (otherLi_2) {
          editor.undoManager.transact(function () {
            removeBlock(dom, block, root);
            mergeWithAdjacentLists(dom, otherLi_2.parentNode);
            editor.selection.select(otherLi_2, true);
            editor.selection.collapse(isForward);
          });
          return true;
        }
      }
      return false;
    };
    var backspaceDeleteCaret = function (editor, isForward) {
      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);
    };
    var backspaceDeleteRange = function (editor) {
      var selectionStartElm = editor.selection.getStart();
      var root = getClosestListRootElm(editor, selectionStartElm);
      var startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);
      if (startListParent || getSelectedListItems(editor).length > 0) {
        editor.undoManager.transact(function () {
          editor.execCommand('Delete');
          normalizeLists(editor.dom, editor.getBody());
        });
        return true;
      }
      return false;
    };
    var backspaceDelete = function (editor, isForward) {
      return editor.selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor);
    };
    var setup$1 = function (editor) {
      editor.on('keydown', function (e) {
        if (e.keyCode === global$4.BACKSPACE) {
          if (backspaceDelete(editor, false)) {
            e.preventDefault();
          }
        } else if (e.keyCode === global$4.DELETE) {
          if (backspaceDelete(editor, true)) {
            e.preventDefault();
          }
        }
      });
    };

    var get = function (editor) {
      return {
        backspaceDelete: function (isForward) {
          backspaceDelete(editor, isForward);
        }
      };
    };

    var updateList = function (editor, update) {
      var parentList = getParentList(editor);
      editor.undoManager.transact(function () {
        if (isObject(update.styles)) {
          editor.dom.setStyles(parentList, update.styles);
        }
        if (isObject(update.attrs)) {
          each(update.attrs, function (v, k) {
            return editor.dom.setAttrib(parentList, k, v);
          });
        }
      });
    };

    var parseAlphabeticBase26 = function (str) {
      var chars = reverse(trim(str).split(''));
      var values = map(chars, function (char, i) {
        var charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;
        return Math.pow(26, i) * charValue;
      });
      return foldl(values, function (sum, v) {
        return sum + v;
      }, 0);
    };
    var composeAlphabeticBase26 = function (value) {
      value--;
      if (value < 0) {
        return '';
      } else {
        var remainder = value % 26;
        var quotient = Math.floor(value / 26);
        var rest = composeAlphabeticBase26(quotient);
        var char = String.fromCharCode('A'.charCodeAt(0) + remainder);
        return rest + char;
      }
    };
    var isUppercase = function (str) {
      return /^[A-Z]+$/.test(str);
    };
    var isLowercase = function (str) {
      return /^[a-z]+$/.test(str);
    };
    var isNumeric = function (str) {
      return /^[0-9]+$/.test(str);
    };
    var deduceListType = function (start) {
      if (isNumeric(start)) {
        return 2;
      } else if (isUppercase(start)) {
        return 0;
      } else if (isLowercase(start)) {
        return 1;
      } else if (isEmpty$1(start)) {
        return 3;
      } else {
        return 4;
      }
    };
    var parseStartValue = function (start) {
      switch (deduceListType(start)) {
      case 2:
        return Optional.some({
          listStyleType: Optional.none(),
          start: start
        });
      case 0:
        return Optional.some({
          listStyleType: Optional.some('upper-alpha'),
          start: parseAlphabeticBase26(start).toString()
        });
      case 1:
        return Optional.some({
          listStyleType: Optional.some('lower-alpha'),
          start: parseAlphabeticBase26(start).toString()
        });
      case 3:
        return Optional.some({
          listStyleType: Optional.none(),
          start: ''
        });
      case 4:
        return Optional.none();
      }
    };
    var parseDetail = function (detail) {
      var start = parseInt(detail.start, 10);
      if (is(detail.listStyleType, 'upper-alpha')) {
        return composeAlphabeticBase26(start);
      } else if (is(detail.listStyleType, 'lower-alpha')) {
        return composeAlphabeticBase26(start).toLowerCase();
      } else {
        return detail.start;
      }
    };

    var open = function (editor) {
      var currentList = getParentList(editor);
      if (!isOlNode(currentList)) {
        return;
      }
      editor.windowManager.open({
        title: 'List Properties',
        body: {
          type: 'panel',
          items: [{
              type: 'input',
              name: 'start',
              label: 'Start list at number',
              inputMode: 'numeric'
            }]
        },
        initialData: {
          start: parseDetail({
            start: editor.dom.getAttrib(currentList, 'start', '1'),
            listStyleType: Optional.some(editor.dom.getStyle(currentList, 'list-style-type'))
          })
        },
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        onSubmit: function (api) {
          var data = api.getData();
          parseStartValue(data.start).each(function (detail) {
            editor.execCommand('mceListUpdate', false, {
              attrs: { start: detail.start === '1' ? '' : detail.start },
              styles: { 'list-style-type': detail.listStyleType.getOr('') }
            });
          });
          api.close();
        }
      });
    };

    var queryListCommandState = function (editor, listName) {
      return function () {
        var parentList = getParentList(editor);
        return parentList && parentList.nodeName === listName;
      };
    };
    var registerDialog = function (editor) {
      editor.addCommand('mceListProps', function () {
        open(editor);
      });
    };
    var register$2 = function (editor) {
      editor.on('BeforeExecCommand', function (e) {
        var cmd = e.command.toLowerCase();
        if (cmd === 'indent') {
          indentListSelection(editor);
        } else if (cmd === 'outdent') {
          outdentListSelection(editor);
        }
      });
      editor.addCommand('InsertUnorderedList', function (ui, detail) {
        toggleList(editor, 'UL', detail);
      });
      editor.addCommand('InsertOrderedList', function (ui, detail) {
        toggleList(editor, 'OL', detail);
      });
      editor.addCommand('InsertDefinitionList', function (ui, detail) {
        toggleList(editor, 'DL', detail);
      });
      editor.addCommand('RemoveList', function () {
        flattenListSelection(editor);
      });
      registerDialog(editor);
      editor.addCommand('mceListUpdate', function (ui, detail) {
        if (isObject(detail)) {
          updateList(editor, detail);
        }
      });
      editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));
      editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));
      editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));
    };

    var setupTabKey = function (editor) {
      editor.on('keydown', function (e) {
        if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) {
          return;
        }
        editor.undoManager.transact(function () {
          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {
            e.preventDefault();
          }
        });
      });
    };
    var setup = function (editor) {
      if (shouldIndentOnTab(editor)) {
        setupTabKey(editor);
      }
      setup$1(editor);
    };

    var register$1 = function (editor) {
      var exec = function (command) {
        return function () {
          return editor.execCommand(command);
        };
      };
      if (!editor.hasPlugin('advlist')) {
        editor.ui.registry.addToggleButton('numlist', {
          icon: 'ordered-list',
          active: false,
          tooltip: 'Numbered list',
          onAction: exec('InsertOrderedList'),
          onSetup: function (api) {
            return listState(editor, 'OL', api.setActive);
          }
        });
        editor.ui.registry.addToggleButton('bullist', {
          icon: 'unordered-list',
          active: false,
          tooltip: 'Bullet list',
          onAction: exec('InsertUnorderedList'),
          onSetup: function (api) {
            return listState(editor, 'UL', api.setActive);
          }
        });
      }
    };

    var register = function (editor) {
      var listProperties = {
        text: 'List properties...',
        icon: 'ordered-list',
        onAction: function () {
          return editor.execCommand('mceListProps');
        },
        onSetup: function (api) {
          return listState(editor, 'OL', function (active) {
            return api.setDisabled(!active);
          });
        }
      };
      editor.ui.registry.addMenuItem('listprops', listProperties);
      editor.ui.registry.addContextMenu('lists', {
        update: function (node) {
          var parentList = getParentList(editor, node);
          return isOlNode(parentList) ? ['listprops'] : [];
        }
      });
    };

    function Plugin () {
      global$7.add('lists', function (editor) {
        if (editor.hasPlugin('rtc', true) === false) {
          setup(editor);
          register$2(editor);
        } else {
          registerDialog(editor);
        }
        register$1(editor);
        register(editor);
        return get(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "9acd":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$2 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var identity = function (x) {
      return x;
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var zeroWidth = '\uFEFF';
    var removeZwsp$1 = function (s) {
      return s.replace(/\uFEFF/g, '');
    };

    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };

    var punctuationStr = '[!-#%-*,-\\/:;?@\\[-\\]_{}\xA1\xAB\xB7\xBB\xBF;\xB7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uff3f\uFF5B\uFF5D\uFF5F-\uFF65]';
    var regExps = {
      aletter: '[A-Za-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05F3\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bc0-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u24B6-\u24E9\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005\u303b\u303c\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790\ua791\ua7a0-\ua7a9\ua7fa-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uffa0-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]',
      midnumlet: '[-\'\\.\u2018\u2019\u2024\uFE52\uFF07\uFF0E]',
      midletter: '[:\xB7\xB7\u05F4\u2027\uFE13\uFE55\uFF1A]',
      midnum: '[\xB1+*/,;;\u0589\u060C\u060D\u066C\u07F8\u2044\uFE10\uFE14\uFE50\uFE54\uFF0C\uFF1B]',
      numeric: '[0-9\u0660-\u0669\u066B\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\uaa50-\uaa59\uabf0-\uabf9]',
      cr: '\\r',
      lf: '\\n',
      newline: '[\x0B\f\x85\u2028\u2029]',
      extend: '[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f\u109a-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b6-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u192b\u1930-\u193b\u19b0-\u19c0\u19c8\u19c9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f\u1b00-\u1b04\u1b34-\u1b44\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1baa\u1be6-\u1bf3\u1c24-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\uA672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe3-\uabea\uabec\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]',
      format: '[\xAD\u0600-\u0603\u06DD\u070F\u17b4\u17b5\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB]',
      katakana: '[\u3031-\u3035\u309B\u309C\u30A0-\u30fa\u30fc-\u30ff\u31f0-\u31ff\u32D0-\u32FE\u3300-\u3357\uff66-\uff9d]',
      extendnumlet: '[=_\u203f\u2040\u2054\ufe33\ufe34\ufe4d-\ufe4f\uff3f\u2200-\u22FF<>]',
      punctuation: punctuationStr
    };
    var characterIndices = {
      ALETTER: 0,
      MIDNUMLET: 1,
      MIDLETTER: 2,
      MIDNUM: 3,
      NUMERIC: 4,
      CR: 5,
      LF: 6,
      NEWLINE: 7,
      EXTEND: 8,
      FORMAT: 9,
      KATAKANA: 10,
      EXTENDNUMLET: 11,
      AT: 12,
      OTHER: 13
    };
    var SETS$1 = [
      new RegExp(regExps.aletter),
      new RegExp(regExps.midnumlet),
      new RegExp(regExps.midletter),
      new RegExp(regExps.midnum),
      new RegExp(regExps.numeric),
      new RegExp(regExps.cr),
      new RegExp(regExps.lf),
      new RegExp(regExps.newline),
      new RegExp(regExps.extend),
      new RegExp(regExps.format),
      new RegExp(regExps.katakana),
      new RegExp(regExps.extendnumlet),
      new RegExp('@')
    ];
    var EMPTY_STRING$1 = '';
    var PUNCTUATION$1 = new RegExp('^' + regExps.punctuation + '$');
    var WHITESPACE$1 = /^\s+$/;

    var SETS = SETS$1;
    var OTHER = characterIndices.OTHER;
    var getType = function (char) {
      var type = OTHER;
      var setsLength = SETS.length;
      for (var j = 0; j < setsLength; ++j) {
        var set = SETS[j];
        if (set && set.test(char)) {
          type = j;
          break;
        }
      }
      return type;
    };
    var memoize = function (func) {
      var cache = {};
      return function (char) {
        if (cache[char]) {
          return cache[char];
        } else {
          var result = func(char);
          cache[char] = result;
          return result;
        }
      };
    };
    var classify = function (characters) {
      var memoized = memoize(getType);
      return map(characters, memoized);
    };

    var isWordBoundary = function (map, index) {
      var type = map[index];
      var nextType = map[index + 1];
      if (index < 0 || index > map.length - 1 && index !== 0) {
        return false;
      }
      if (type === characterIndices.ALETTER && nextType === characterIndices.ALETTER) {
        return false;
      }
      var nextNextType = map[index + 2];
      if (type === characterIndices.ALETTER && (nextType === characterIndices.MIDLETTER || nextType === characterIndices.MIDNUMLET || nextType === characterIndices.AT) && nextNextType === characterIndices.ALETTER) {
        return false;
      }
      var prevType = map[index - 1];
      if ((type === characterIndices.MIDLETTER || type === characterIndices.MIDNUMLET || nextType === characterIndices.AT) && nextType === characterIndices.ALETTER && prevType === characterIndices.ALETTER) {
        return false;
      }
      if ((type === characterIndices.NUMERIC || type === characterIndices.ALETTER) && (nextType === characterIndices.NUMERIC || nextType === characterIndices.ALETTER)) {
        return false;
      }
      if ((type === characterIndices.MIDNUM || type === characterIndices.MIDNUMLET) && nextType === characterIndices.NUMERIC && prevType === characterIndices.NUMERIC) {
        return false;
      }
      if (type === characterIndices.NUMERIC && (nextType === characterIndices.MIDNUM || nextType === characterIndices.MIDNUMLET) && nextNextType === characterIndices.NUMERIC) {
        return false;
      }
      if (type === characterIndices.EXTEND || type === characterIndices.FORMAT || prevType === characterIndices.EXTEND || prevType === characterIndices.FORMAT || nextType === characterIndices.EXTEND || nextType === characterIndices.FORMAT) {
        return false;
      }
      if (type === characterIndices.CR && nextType === characterIndices.LF) {
        return false;
      }
      if (type === characterIndices.NEWLINE || type === characterIndices.CR || type === characterIndices.LF) {
        return true;
      }
      if (nextType === characterIndices.NEWLINE || nextType === characterIndices.CR || nextType === characterIndices.LF) {
        return true;
      }
      if (type === characterIndices.KATAKANA && nextType === characterIndices.KATAKANA) {
        return false;
      }
      if (nextType === characterIndices.EXTENDNUMLET && (type === characterIndices.ALETTER || type === characterIndices.NUMERIC || type === characterIndices.KATAKANA || type === characterIndices.EXTENDNUMLET)) {
        return false;
      }
      if (type === characterIndices.EXTENDNUMLET && (nextType === characterIndices.ALETTER || nextType === characterIndices.NUMERIC || nextType === characterIndices.KATAKANA)) {
        return false;
      }
      if (type === characterIndices.AT) {
        return false;
      }
      return true;
    };

    var EMPTY_STRING = EMPTY_STRING$1;
    var WHITESPACE = WHITESPACE$1;
    var PUNCTUATION = PUNCTUATION$1;
    var isProtocol = function (str) {
      return str === 'http' || str === 'https';
    };
    var findWordEnd = function (characters, startIndex) {
      var i;
      for (i = startIndex; i < characters.length; i++) {
        if (WHITESPACE.test(characters[i])) {
          break;
        }
      }
      return i;
    };
    var findUrlEnd = function (characters, startIndex) {
      var endIndex = findWordEnd(characters, startIndex + 1);
      var peakedWord = characters.slice(startIndex + 1, endIndex).join(EMPTY_STRING);
      return peakedWord.substr(0, 3) === '://' ? endIndex : startIndex;
    };
    var findWords = function (chars, sChars, characterMap, options) {
      var words = [];
      var word = [];
      for (var i = 0; i < characterMap.length; ++i) {
        word.push(chars[i]);
        if (isWordBoundary(characterMap, i)) {
          var ch = sChars[i];
          if ((options.includeWhitespace || !WHITESPACE.test(ch)) && (options.includePunctuation || !PUNCTUATION.test(ch))) {
            var startOfWord = i - word.length + 1;
            var endOfWord = i + 1;
            var str = sChars.slice(startOfWord, endOfWord).join(EMPTY_STRING);
            if (isProtocol(str)) {
              var endOfUrl = findUrlEnd(sChars, i);
              var url = chars.slice(endOfWord, endOfUrl);
              Array.prototype.push.apply(word, url);
              i = endOfUrl;
            }
            words.push(word);
          }
          word = [];
        }
      }
      return words;
    };
    var getDefaultOptions = function () {
      return {
        includeWhitespace: false,
        includePunctuation: false
      };
    };
    var getWords$1 = function (chars, extract, options) {
      options = __assign(__assign({}, getDefaultOptions()), options);
      var filteredChars = [];
      var extractedChars = [];
      for (var i = 0; i < chars.length; i++) {
        var ch = extract(chars[i]);
        if (ch !== zeroWidth) {
          filteredChars.push(chars[i]);
          extractedChars.push(ch);
        }
      }
      var characterMap = classify(extractedChars);
      return findWords(filteredChars, extractedChars, characterMap, options);
    };

    var getWords = getWords$1;

    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');

    var getText = function (node, schema) {
      var blockElements = schema.getBlockElements();
      var shortEndedElements = schema.getShortEndedElements();
      var isNewline = function (node) {
        return blockElements[node.nodeName] || shortEndedElements[node.nodeName];
      };
      var textBlocks = [];
      var txt = '';
      var treeWalker = new global$1(node, node);
      while (node = treeWalker.next()) {
        if (node.nodeType === 3) {
          txt += removeZwsp$1(node.data);
        } else if (isNewline(node) && txt.length) {
          textBlocks.push(txt);
          txt = '';
        }
      }
      if (txt.length) {
        textBlocks.push(txt);
      }
      return textBlocks;
    };

    var removeZwsp = function (text) {
      return text.replace(/\u200B/g, '');
    };
    var strLen = function (str) {
      return str.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '_').length;
    };
    var countWords = function (node, schema) {
      var text = removeZwsp(getText(node, schema).join('\n'));
      return getWords(text.split(''), identity).length;
    };
    var countCharacters = function (node, schema) {
      var text = getText(node, schema).join('');
      return strLen(text);
    };
    var countCharactersWithoutSpaces = function (node, schema) {
      var text = getText(node, schema).join('').replace(/\s/g, '');
      return strLen(text);
    };

    var createBodyCounter = function (editor, count) {
      return function () {
        return count(editor.getBody(), editor.schema);
      };
    };
    var createSelectionCounter = function (editor, count) {
      return function () {
        return count(editor.selection.getRng().cloneContents(), editor.schema);
      };
    };
    var createBodyWordCounter = function (editor) {
      return createBodyCounter(editor, countWords);
    };
    var get = function (editor) {
      return {
        body: {
          getWordCount: createBodyWordCounter(editor),
          getCharacterCount: createBodyCounter(editor, countCharacters),
          getCharacterCountWithoutSpaces: createBodyCounter(editor, countCharactersWithoutSpaces)
        },
        selection: {
          getWordCount: createSelectionCounter(editor, countWords),
          getCharacterCount: createSelectionCounter(editor, countCharacters),
          getCharacterCountWithoutSpaces: createSelectionCounter(editor, countCharactersWithoutSpaces)
        },
        getCount: createBodyWordCounter(editor)
      };
    };

    var open = function (editor, api) {
      editor.windowManager.open({
        title: 'Word Count',
        body: {
          type: 'panel',
          items: [{
              type: 'table',
              header: [
                'Count',
                'Document',
                'Selection'
              ],
              cells: [
                [
                  'Words',
                  String(api.body.getWordCount()),
                  String(api.selection.getWordCount())
                ],
                [
                  'Characters (no spaces)',
                  String(api.body.getCharacterCountWithoutSpaces()),
                  String(api.selection.getCharacterCountWithoutSpaces())
                ],
                [
                  'Characters',
                  String(api.body.getCharacterCount()),
                  String(api.selection.getCharacterCount())
                ]
              ]
            }]
        },
        buttons: [{
            type: 'cancel',
            name: 'close',
            text: 'Close',
            primary: true
          }]
      });
    };

    var register$1 = function (editor, api) {
      editor.addCommand('mceWordCount', function () {
        return open(editor, api);
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var fireWordCountUpdate = function (editor, api) {
      editor.fire('wordCountUpdate', {
        wordCount: {
          words: api.body.getWordCount(),
          characters: api.body.getCharacterCount(),
          charactersWithoutSpaces: api.body.getCharacterCountWithoutSpaces()
        }
      });
    };

    var updateCount = function (editor, api) {
      fireWordCountUpdate(editor, api);
    };
    var setup = function (editor, api, delay) {
      var debouncedUpdate = global.debounce(function () {
        return updateCount(editor, api);
      }, delay);
      editor.on('init', function () {
        updateCount(editor, api);
        global.setEditorTimeout(editor, function () {
          editor.on('SetContent BeforeAddUndo Undo Redo ViewUpdate keyup', debouncedUpdate);
        }, 0);
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceWordCount');
      };
      editor.ui.registry.addButton('wordcount', {
        tooltip: 'Word count',
        icon: 'character-count',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('wordcount', {
        text: 'Word count',
        icon: 'character-count',
        onAction: onAction
      });
    };

    function Plugin (delay) {
      if (delay === void 0) {
        delay = 300;
      }
      global$2.add('wordcount', function (editor) {
        var api = get(editor);
        register$1(editor, api);
        register(editor);
        setup(editor, api, delay);
        return api;
      });
    }

    Plugin();

}());


/***/ }),

/***/ "9c16":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "paste" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/paste')
//   ES2015:
//     import 'tinymce/plugins/paste'
__webpack_require__("18f5");

/***/ }),

/***/ "a7fd":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var eq = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isNull = eq(null);

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var map$1 = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$1 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var last = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        cancel();
        timer = setTimeout(function () {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var insertEmoticon = function (editor, ch) {
      editor.insertContent(ch);
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map = function (obj, f) {
      return tupleMap(obj, function (x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function (obj, f) {
      var r = {};
      each(obj, function (x, i) {
        var tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    var shallow = function (old, nu) {
      return nu;
    };
    var baseMerge = function (merger) {
      return function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        if (objects.length === 0) {
          throw new Error('Can\'t merge zero objects');
        }
        var ret = {};
        for (var j = 0; j < objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (has(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var merge = baseMerge(shallow);

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var contains = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.Resource');

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Delay');

    var global = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var DEFAULT_ID = 'tinymce.plugins.emoticons';
    var getEmoticonDatabase = function (editor) {
      return editor.getParam('emoticons_database', 'emojis', 'string');
    };
    var getEmoticonDatabaseUrl = function (editor, pluginUrl) {
      var database = getEmoticonDatabase(editor);
      return editor.getParam('emoticons_database_url', pluginUrl + '/js/' + database + editor.suffix + '.js', 'string');
    };
    var getEmoticonDatabaseId = function (editor) {
      return editor.getParam('emoticons_database_id', DEFAULT_ID, 'string');
    };
    var getAppendedEmoticons = function (editor) {
      return editor.getParam('emoticons_append', {}, 'object');
    };
    var getEmotionsImageUrl = function (editor) {
      return editor.getParam('emoticons_images_url', 'https://twemoji.maxcdn.com/v/13.0.1/72x72/', 'string');
    };

    var ALL_CATEGORY = 'All';
    var categoryNameMap = {
      symbols: 'Symbols',
      people: 'People',
      animals_and_nature: 'Animals and Nature',
      food_and_drink: 'Food and Drink',
      activity: 'Activity',
      travel_and_places: 'Travel and Places',
      objects: 'Objects',
      flags: 'Flags',
      user: 'User Defined'
    };
    var translateCategory = function (categories, name) {
      return has(categories, name) ? categories[name] : name;
    };
    var getUserDefinedEmoticons = function (editor) {
      var userDefinedEmoticons = getAppendedEmoticons(editor);
      return map(userDefinedEmoticons, function (value) {
        return __assign({
          keywords: [],
          category: 'user'
        }, value);
      });
    };
    var initDatabase = function (editor, databaseUrl, databaseId) {
      var categories = value();
      var all = value();
      var emojiImagesUrl = getEmotionsImageUrl(editor);
      var getEmoji = function (lib) {
        if (startsWith(lib.char, '<img')) {
          return lib.char.replace(/src="([^"]+)"/, function (match, url) {
            return 'src="' + emojiImagesUrl + url + '"';
          });
        } else {
          return lib.char;
        }
      };
      var processEmojis = function (emojis) {
        var cats = {};
        var everything = [];
        each(emojis, function (lib, title) {
          var entry = {
            title: title,
            keywords: lib.keywords,
            char: getEmoji(lib),
            category: translateCategory(categoryNameMap, lib.category)
          };
          var current = cats[entry.category] !== undefined ? cats[entry.category] : [];
          cats[entry.category] = current.concat([entry]);
          everything.push(entry);
        });
        categories.set(cats);
        all.set(everything);
      };
      editor.on('init', function () {
        global$2.load(databaseId, databaseUrl).then(function (emojis) {
          var userEmojis = getUserDefinedEmoticons(editor);
          processEmojis(merge(emojis, userEmojis));
        }, function (err) {
          console.log('Failed to load emoticons: ' + err);
          categories.set({});
          all.set([]);
        });
      });
      var listCategory = function (category) {
        if (category === ALL_CATEGORY) {
          return listAll();
        }
        return categories.get().bind(function (cats) {
          return Optional.from(cats[category]);
        }).getOr([]);
      };
      var listAll = function () {
        return all.get().getOr([]);
      };
      var listCategories = function () {
        return [ALL_CATEGORY].concat(keys(categories.get().getOr({})));
      };
      var waitForLoad = function () {
        if (hasLoaded()) {
          return global.resolve(true);
        } else {
          return new global(function (resolve, reject) {
            var numRetries = 15;
            var interval = global$1.setInterval(function () {
              if (hasLoaded()) {
                global$1.clearInterval(interval);
                resolve(true);
              } else {
                numRetries--;
                if (numRetries < 0) {
                  console.log('Could not load emojis from url: ' + databaseUrl);
                  global$1.clearInterval(interval);
                  reject(false);
                }
              }
            }, 100);
          });
        }
      };
      var hasLoaded = function () {
        return categories.isSet() && all.isSet();
      };
      return {
        listCategories: listCategories,
        hasLoaded: hasLoaded,
        waitForLoad: waitForLoad,
        listAll: listAll,
        listCategory: listCategory
      };
    };

    var emojiMatches = function (emoji, lowerCasePattern) {
      return contains(emoji.title.toLowerCase(), lowerCasePattern) || exists(emoji.keywords, function (k) {
        return contains(k.toLowerCase(), lowerCasePattern);
      });
    };
    var emojisFrom = function (list, pattern, maxResults) {
      var matches = [];
      var lowerCasePattern = pattern.toLowerCase();
      var reachedLimit = maxResults.fold(function () {
        return never;
      }, function (max) {
        return function (size) {
          return size >= max;
        };
      });
      for (var i = 0; i < list.length; i++) {
        if (pattern.length === 0 || emojiMatches(list[i], lowerCasePattern)) {
          matches.push({
            value: list[i].char,
            text: list[i].title,
            icon: list[i].char
          });
          if (reachedLimit(matches.length)) {
            break;
          }
        }
      }
      return matches;
    };

    var patternName = 'pattern';
    var open = function (editor, database) {
      var initialState = {
        pattern: '',
        results: emojisFrom(database.listAll(), '', Optional.some(300))
      };
      var currentTab = Cell(ALL_CATEGORY);
      var scan = function (dialogApi) {
        var dialogData = dialogApi.getData();
        var category = currentTab.get();
        var candidates = database.listCategory(category);
        var results = emojisFrom(candidates, dialogData[patternName], category === ALL_CATEGORY ? Optional.some(300) : Optional.none());
        dialogApi.setData({ results: results });
      };
      var updateFilter = last(function (dialogApi) {
        scan(dialogApi);
      }, 200);
      var searchField = {
        label: 'Search',
        type: 'input',
        name: patternName
      };
      var resultsField = {
        type: 'collection',
        name: 'results'
      };
      var getInitialState = function () {
        var body = {
          type: 'tabpanel',
          tabs: map$1(database.listCategories(), function (cat) {
            return {
              title: cat,
              name: cat,
              items: [
                searchField,
                resultsField
              ]
            };
          })
        };
        return {
          title: 'Emoticons',
          size: 'normal',
          body: body,
          initialData: initialState,
          onTabChange: function (dialogApi, details) {
            currentTab.set(details.newTabName);
            updateFilter.throttle(dialogApi);
          },
          onChange: updateFilter.throttle,
          onAction: function (dialogApi, actionData) {
            if (actionData.name === 'results') {
              insertEmoticon(editor, actionData.value);
              dialogApi.close();
            }
          },
          buttons: [{
              type: 'cancel',
              text: 'Close',
              primary: true
            }]
        };
      };
      var dialogApi = editor.windowManager.open(getInitialState());
      dialogApi.focus(patternName);
      if (!database.hasLoaded()) {
        dialogApi.block('Loading emoticons...');
        database.waitForLoad().then(function () {
          dialogApi.redial(getInitialState());
          updateFilter.throttle(dialogApi);
          dialogApi.focus(patternName);
          dialogApi.unblock();
        }).catch(function (_err) {
          dialogApi.redial({
            title: 'Emoticons',
            body: {
              type: 'panel',
              items: [{
                  type: 'alertbanner',
                  level: 'error',
                  icon: 'warning',
                  text: '<p>Could not load emoticons</p>'
                }]
            },
            buttons: [{
                type: 'cancel',
                text: 'Close',
                primary: true
              }],
            initialData: {
              pattern: '',
              results: []
            }
          });
          dialogApi.focus(patternName);
          dialogApi.unblock();
        });
      }
    };

    var register$1 = function (editor, database) {
      editor.addCommand('mceEmoticons', function () {
        return open(editor, database);
      });
    };

    var setup = function (editor) {
      editor.on('PreInit', function () {
        editor.parser.addAttributeFilter('data-emoticon', function (nodes) {
          each$1(nodes, function (node) {
            node.attr('data-mce-resize', 'false');
            node.attr('data-mce-placeholder', '1');
          });
        });
      });
    };

    var init = function (editor, database) {
      editor.ui.registry.addAutocompleter('emoticons', {
        ch: ':',
        columns: 'auto',
        minChars: 2,
        fetch: function (pattern, maxResults) {
          return database.waitForLoad().then(function () {
            var candidates = database.listAll();
            return emojisFrom(candidates, pattern, Optional.some(maxResults));
          });
        },
        onAction: function (autocompleteApi, rng, value) {
          editor.selection.setRng(rng);
          editor.insertContent(value);
          autocompleteApi.hide();
        }
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceEmoticons');
      };
      editor.ui.registry.addButton('emoticons', {
        tooltip: 'Emoticons',
        icon: 'emoji',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('emoticons', {
        text: 'Emoticons...',
        icon: 'emoji',
        onAction: onAction
      });
    };

    function Plugin () {
      global$3.add('emoticons', function (editor, pluginUrl) {
        var databaseUrl = getEmoticonDatabaseUrl(editor, pluginUrl);
        var databaseId = getEmoticonDatabaseId(editor);
        var database = initDatabase(editor, databaseUrl, databaseId);
        register$1(editor, database);
        register(editor);
        init(editor, database);
        setup(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "b094":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var get$1 = function (customTabs) {
      var addTab = function (spec) {
        var currentCustomTabs = customTabs.get();
        currentCustomTabs[spec.name] = spec;
        customTabs.set(currentCustomTabs);
      };
      return { addTab: addTab };
    };

    var register$1 = function (editor, dialogOpener) {
      editor.addCommand('mceHelp', dialogOpener);
    };

    var register = function (editor, dialogOpener) {
      editor.ui.registry.addButton('help', {
        icon: 'help',
        tooltip: 'Help',
        onAction: dialogOpener
      });
      editor.ui.registry.addMenuItem('help', {
        text: 'Help',
        icon: 'help',
        shortcut: 'Alt+0',
        onAction: dialogOpener
      });
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var nativeIndexOf = Array.prototype.indexOf;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var contains = function (xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var filter = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find = function (xs, pred) {
      return findUntil(xs, pred, never);
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var get = function (obj, key) {
      return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };

    var getHelpTabs = function (editor) {
      return Optional.from(editor.getParam('help_tabs'));
    };
    var getForcedPlugins = function (editor) {
      return editor.getParam('forced_plugins');
    };

    var description = '<h1>Editor UI keyboard navigation</h1>\n\n<h2>Activating keyboard navigation</h2>\n\n<p>The sections of the outer UI of the editor - the menubar, toolbar, sidebar and footer - are all keyboard navigable. As such, there are multiple ways to activate keyboard navigation:</p>\n<ul>\n  <li>Focus the menubar: Alt + F9 (Windows) or &#x2325;F9 (MacOS)</li>\n  <li>Focus the toolbar: Alt + F10 (Windows) or &#x2325;F10 (MacOS)</li>\n  <li>Focus the footer: Alt + F11 (Windows) or &#x2325;F11 (MacOS)</li>\n</ul>\n\n<p>Focusing the menubar or toolbar will start keyboard navigation at the first item in the menubar or toolbar, which will be highlighted with a gray background. Focusing the footer will start keyboard navigation at the first item in the element path, which will be highlighted with an underline. </p>\n\n<h2>Moving between UI sections</h2>\n\n<p>When keyboard navigation is active, pressing tab will move the focus to the next major section of the UI, where applicable. These sections are:</p>\n<ul>\n  <li>the menubar</li>\n  <li>each group of the toolbar </li>\n  <li>the sidebar</li>\n  <li>the element path in the footer </li>\n  <li>the wordcount toggle button in the footer </li>\n  <li>the branding link in the footer </li>\n  <li>the editor resize handle in the footer</li>\n</ul>\n\n<p>Pressing shift + tab will move backwards through the same sections, except when moving from the footer to the toolbar. Focusing the element path then pressing shift + tab will move focus to the first toolbar group, not the last.</p>\n\n<h2>Moving within UI sections</h2>\n\n<p>Keyboard navigation within UI sections can usually be achieved using the left and right arrow keys. This includes:</p>\n<ul>\n  <li>moving between menus in the menubar</li>\n  <li>moving between buttons in a toolbar group</li>\n  <li>moving between items in the element path</li>\n</ul>\n\n<p>In all these UI sections, keyboard navigation will cycle within the section. For example, focusing the last button in a toolbar group then pressing right arrow will move focus to the first item in the same toolbar group. </p>\n\n<h1>Executing buttons</h1>\n\n<p>To execute a button, navigate the selection to the desired button and hit space or enter.</p>\n\n<h1>Opening, navigating and closing menus</h1>\n\n<p>When focusing a menubar button or a toolbar button with a menu, pressing space, enter or down arrow will open the menu. When the menu opens the first item will be selected. To move up or down the menu, press the up or down arrow key respectively. This is the same for submenus, which can also be opened and closed using the left and right arrow keys.</p>\n\n<p>To close any active menu, hit the escape key. When a menu is closed the selection will be restored to its previous selection. This also works for closing submenus.</p>\n\n<h1>Context toolbars and menus</h1>\n\n<p>To focus an open context toolbar such as the table context toolbar, press Ctrl + F9 (Windows) or &#x2303;F9 (MacOS).</p>\n\n<p>Context toolbar navigation is the same as toolbar navigation, and context menu navigation is the same as standard menu navigation.</p>\n\n<h1>Dialog navigation</h1>\n\n<p>There are two types of dialog UIs in TinyMCE: tabbed dialogs and non-tabbed dialogs.</p>\n\n<p>When a non-tabbed dialog is opened, the first interactive component in the dialog will be focused. Users can navigate between interactive components by pressing tab. This includes any footer buttons. Navigation will cycle back to the first dialog component if tab is pressed while focusing the last component in the dialog. Pressing shift + tab will navigate backwards.</p>\n\n<p>When a tabbed dialog is opened, the first button in the tab menu is focused. Pressing tab will navigate to the first interactive component in that tab, and will cycle through the tab\u2019s components, the footer buttons, then back to the tab button. To switch to another tab, focus the tab button for the current tab, then use the arrow keys to cycle through the tab buttons.</p>';
    var tab$3 = function () {
      var body = {
        type: 'htmlpanel',
        presets: 'document',
        html: description
      };
      return {
        name: 'keyboardnav',
        title: 'Keyboard Navigation',
        items: [body]
      };
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.Env');

    var convertText = function (source) {
      var mac = {
        alt: '&#x2325;',
        ctrl: '&#x2303;',
        shift: '&#x21E7;',
        meta: '&#x2318;',
        access: '&#x2303;&#x2325;'
      };
      var other = {
        meta: 'Ctrl ',
        access: 'Shift + Alt '
      };
      var replace = global$2.mac ? mac : other;
      var shortcut = source.split('+');
      var updated = map(shortcut, function (segment) {
        var search = segment.toLowerCase().trim();
        return has(replace, search) ? replace[search] : segment;
      });
      return global$2.mac ? updated.join('').replace(/\s/, '') : updated.join('+');
    };

    var shortcuts = [
      {
        shortcuts: ['Meta + B'],
        action: 'Bold'
      },
      {
        shortcuts: ['Meta + I'],
        action: 'Italic'
      },
      {
        shortcuts: ['Meta + U'],
        action: 'Underline'
      },
      {
        shortcuts: ['Meta + A'],
        action: 'Select all'
      },
      {
        shortcuts: [
          'Meta + Y',
          'Meta + Shift + Z'
        ],
        action: 'Redo'
      },
      {
        shortcuts: ['Meta + Z'],
        action: 'Undo'
      },
      {
        shortcuts: ['Access + 1'],
        action: 'Heading 1'
      },
      {
        shortcuts: ['Access + 2'],
        action: 'Heading 2'
      },
      {
        shortcuts: ['Access + 3'],
        action: 'Heading 3'
      },
      {
        shortcuts: ['Access + 4'],
        action: 'Heading 4'
      },
      {
        shortcuts: ['Access + 5'],
        action: 'Heading 5'
      },
      {
        shortcuts: ['Access + 6'],
        action: 'Heading 6'
      },
      {
        shortcuts: ['Access + 7'],
        action: 'Paragraph'
      },
      {
        shortcuts: ['Access + 8'],
        action: 'Div'
      },
      {
        shortcuts: ['Access + 9'],
        action: 'Address'
      },
      {
        shortcuts: ['Alt + 0'],
        action: 'Open help dialog'
      },
      {
        shortcuts: ['Alt + F9'],
        action: 'Focus to menubar'
      },
      {
        shortcuts: ['Alt + F10'],
        action: 'Focus to toolbar'
      },
      {
        shortcuts: ['Alt + F11'],
        action: 'Focus to element path'
      },
      {
        shortcuts: ['Ctrl + F9'],
        action: 'Focus to contextual toolbar'
      },
      {
        shortcuts: ['Shift + Enter'],
        action: 'Open popup menu for split buttons'
      },
      {
        shortcuts: ['Meta + K'],
        action: 'Insert link (if link plugin activated)'
      },
      {
        shortcuts: ['Meta + S'],
        action: 'Save (if save plugin activated)'
      },
      {
        shortcuts: ['Meta + F'],
        action: 'Find (if searchreplace plugin activated)'
      },
      {
        shortcuts: ['Meta + Shift + F'],
        action: 'Switch to or from fullscreen mode'
      }
    ];

    var tab$2 = function () {
      var shortcutList = map(shortcuts, function (shortcut) {
        var shortcutText = map(shortcut.shortcuts, convertText).join(' or ');
        return [
          shortcut.action,
          shortcutText
        ];
      });
      var tablePanel = {
        type: 'table',
        header: [
          'Action',
          'Shortcut'
        ],
        cells: shortcutList
      };
      return {
        name: 'shortcuts',
        title: 'Handy Shortcuts',
        items: [tablePanel]
      };
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.I18n');

    var urls = map([
      {
        key: 'advlist',
        name: 'Advanced List'
      },
      {
        key: 'anchor',
        name: 'Anchor'
      },
      {
        key: 'autolink',
        name: 'Autolink'
      },
      {
        key: 'autoresize',
        name: 'Autoresize'
      },
      {
        key: 'autosave',
        name: 'Autosave'
      },
      {
        key: 'bbcode',
        name: 'BBCode'
      },
      {
        key: 'charmap',
        name: 'Character Map'
      },
      {
        key: 'code',
        name: 'Code'
      },
      {
        key: 'codesample',
        name: 'Code Sample'
      },
      {
        key: 'colorpicker',
        name: 'Color Picker'
      },
      {
        key: 'directionality',
        name: 'Directionality'
      },
      {
        key: 'emoticons',
        name: 'Emoticons'
      },
      {
        key: 'fullpage',
        name: 'Full Page'
      },
      {
        key: 'fullscreen',
        name: 'Full Screen'
      },
      {
        key: 'help',
        name: 'Help'
      },
      {
        key: 'hr',
        name: 'Horizontal Rule'
      },
      {
        key: 'image',
        name: 'Image'
      },
      {
        key: 'imagetools',
        name: 'Image Tools'
      },
      {
        key: 'importcss',
        name: 'Import CSS'
      },
      {
        key: 'insertdatetime',
        name: 'Insert Date/Time'
      },
      {
        key: 'legacyoutput',
        name: 'Legacy Output'
      },
      {
        key: 'link',
        name: 'Link'
      },
      {
        key: 'lists',
        name: 'Lists'
      },
      {
        key: 'media',
        name: 'Media'
      },
      {
        key: 'nonbreaking',
        name: 'Nonbreaking'
      },
      {
        key: 'noneditable',
        name: 'Noneditable'
      },
      {
        key: 'pagebreak',
        name: 'Page Break'
      },
      {
        key: 'paste',
        name: 'Paste'
      },
      {
        key: 'preview',
        name: 'Preview'
      },
      {
        key: 'print',
        name: 'Print'
      },
      {
        key: 'quickbars',
        name: 'Quick Toolbars'
      },
      {
        key: 'save',
        name: 'Save'
      },
      {
        key: 'searchreplace',
        name: 'Search and Replace'
      },
      {
        key: 'spellchecker',
        name: 'Spell Checker'
      },
      {
        key: 'tabfocus',
        name: 'Tab Focus'
      },
      {
        key: 'table',
        name: 'Table'
      },
      {
        key: 'template',
        name: 'Template'
      },
      {
        key: 'textcolor',
        name: 'Text Color'
      },
      {
        key: 'textpattern',
        name: 'Text Pattern'
      },
      {
        key: 'toc',
        name: 'Table of Contents'
      },
      {
        key: 'visualblocks',
        name: 'Visual Blocks'
      },
      {
        key: 'visualchars',
        name: 'Visual Characters'
      },
      {
        key: 'wordcount',
        name: 'Word Count'
      },
      {
        key: 'a11ychecker',
        name: 'Accessibility Checker',
        type: 'premium'
      },
      {
        key: 'advcode',
        name: 'Advanced Code Editor',
        type: 'premium'
      },
      {
        key: 'advtable',
        name: 'Advanced Tables',
        type: 'premium'
      },
      {
        key: 'autocorrect',
        name: 'Autocorrect',
        type: 'premium'
      },
      {
        key: 'casechange',
        name: 'Case Change',
        type: 'premium'
      },
      {
        key: 'checklist',
        name: 'Checklist',
        type: 'premium'
      },
      {
        key: 'export',
        name: 'Export',
        type: 'premium'
      },
      {
        key: 'mediaembed',
        name: 'Enhanced Media Embed',
        type: 'premium'
      },
      {
        key: 'formatpainter',
        name: 'Format Painter',
        type: 'premium'
      },
      {
        key: 'linkchecker',
        name: 'Link Checker',
        type: 'premium'
      },
      {
        key: 'mentions',
        name: 'Mentions',
        type: 'premium'
      },
      {
        key: 'pageembed',
        name: 'Page Embed',
        type: 'premium'
      },
      {
        key: 'permanentpen',
        name: 'Permanent Pen',
        type: 'premium'
      },
      {
        key: 'powerpaste',
        name: 'PowerPaste',
        type: 'premium'
      },
      {
        key: 'rtc',
        name: 'Real-Time Collaboration',
        type: 'premium'
      },
      {
        key: 'tinymcespellchecker',
        name: 'Spell Checker Pro',
        type: 'premium'
      },
      {
        key: 'tinycomments',
        name: 'Tiny Comments',
        type: 'premium',
        slug: 'comments'
      },
      {
        key: 'tinydrive',
        name: 'Tiny Drive',
        type: 'premium'
      }
    ], function (item) {
      return __assign(__assign({}, item), {
        type: item.type || 'opensource',
        slug: item.slug || item.key
      });
    });

    var tab$1 = function (editor) {
      var availablePlugins = function () {
        var premiumPlugins = filter(urls, function (_a) {
          var key = _a.key, type = _a.type;
          return key !== 'autocorrect' && type === 'premium';
        });
        var premiumPluginList = map(premiumPlugins, function (plugin) {
          return '<li>' + global$1.translate(plugin.name) + '</li>';
        }).join('');
        return '<div data-mce-tabstop="1" tabindex="-1">' + '<p><b>' + global$1.translate('Premium plugins:') + '</b></p>' + '<ul>' + premiumPluginList + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" target="_blank">' + global$1.translate('Learn more...') + '</a></li>' + '</ul>' + '</div>';
      };
      var makeLink = function (p) {
        return '<a href="' + p.url + '" target="_blank" rel="noopener">' + p.name + '</a>';
      };
      var maybeUrlize = function (editor, key) {
        return find(urls, function (x) {
          return x.key === key;
        }).fold(function () {
          var getMetadata = editor.plugins[key].getMetadata;
          return typeof getMetadata === 'function' ? makeLink(getMetadata()) : key;
        }, function (x) {
          var name = x.type === 'premium' ? x.name + '*' : x.name;
          return makeLink({
            name: name,
            url: 'https://www.tiny.cloud/docs/plugins/' + x.type + '/' + x.slug
          });
        });
      };
      var getPluginKeys = function (editor) {
        var keys$1 = keys(editor.plugins);
        var forced_plugins = getForcedPlugins(editor);
        return forced_plugins === undefined ? keys$1 : filter(keys$1, function (k) {
          return !contains(forced_plugins, k);
        });
      };
      var pluginLister = function (editor) {
        var pluginKeys = getPluginKeys(editor);
        var pluginLis = map(pluginKeys, function (key) {
          return '<li>' + maybeUrlize(editor, key) + '</li>';
        });
        var count = pluginLis.length;
        var pluginsString = pluginLis.join('');
        var html = '<p><b>' + global$1.translate([
          'Plugins installed ({0}):',
          count
        ]) + '</b></p>' + '<ul>' + pluginsString + '</ul>';
        return html;
      };
      var installedPlugins = function (editor) {
        if (editor == null) {
          return '';
        }
        return '<div data-mce-tabstop="1" tabindex="-1">' + pluginLister(editor) + '</div>';
      };
      var htmlPanel = {
        type: 'htmlpanel',
        presets: 'document',
        html: [
          installedPlugins(editor),
          availablePlugins()
        ].join('')
      };
      return {
        name: 'plugins',
        title: 'Plugins',
        items: [htmlPanel]
      };
    };

    var global = tinymce.util.Tools.resolve('tinymce.EditorManager');

    var tab = function () {
      var getVersion = function (major, minor) {
        return major.indexOf('@') === 0 ? 'X.X.X' : major + '.' + minor;
      };
      var version = getVersion(global.majorVersion, global.minorVersion);
      var changeLogLink = '<a href="https://www.tiny.cloud/docs/changelog/?utm_campaign=editor_referral&utm_medium=help_dialog&utm_source=tinymce" target="_blank">TinyMCE ' + version + '</a>';
      var htmlPanel = {
        type: 'htmlpanel',
        html: '<p>' + global$1.translate([
          'You are using {0}',
          changeLogLink
        ]) + '</p>',
        presets: 'document'
      };
      return {
        name: 'versions',
        title: 'Version',
        items: [htmlPanel]
      };
    };

    var parseHelpTabsSetting = function (tabsFromSettings, tabs) {
      var newTabs = {};
      var names = map(tabsFromSettings, function (t) {
        if (typeof t === 'string') {
          if (has(tabs, t)) {
            newTabs[t] = tabs[t];
          }
          return t;
        } else {
          newTabs[t.name] = t;
          return t.name;
        }
      });
      return {
        tabs: newTabs,
        names: names
      };
    };
    var getNamesFromTabs = function (tabs) {
      var names = keys(tabs);
      var idx = names.indexOf('versions');
      if (idx !== -1) {
        names.splice(idx, 1);
        names.push('versions');
      }
      return {
        tabs: tabs,
        names: names
      };
    };
    var parseCustomTabs = function (editor, customTabs) {
      var _a;
      var shortcuts = tab$2();
      var nav = tab$3();
      var plugins = tab$1(editor);
      var versions = tab();
      var tabs = __assign((_a = {}, _a[shortcuts.name] = shortcuts, _a[nav.name] = nav, _a[plugins.name] = plugins, _a[versions.name] = versions, _a), customTabs.get());
      return getHelpTabs(editor).fold(function () {
        return getNamesFromTabs(tabs);
      }, function (tabsFromSettings) {
        return parseHelpTabsSetting(tabsFromSettings, tabs);
      });
    };
    var init = function (editor, customTabs) {
      return function () {
        var _a = parseCustomTabs(editor, customTabs), tabs = _a.tabs, names = _a.names;
        var foundTabs = map(names, function (name) {
          return get(tabs, name);
        });
        var dialogTabs = cat(foundTabs);
        var body = {
          type: 'tabpanel',
          tabs: dialogTabs
        };
        editor.windowManager.open({
          title: 'Help',
          size: 'medium',
          body: body,
          buttons: [{
              type: 'cancel',
              name: 'close',
              text: 'Close',
              primary: true
            }],
          initialData: {}
        });
      };
    };

    function Plugin () {
      global$3.add('help', function (editor) {
        var customTabs = Cell({});
        var api = get$1(customTabs);
        var dialogOpener = init(editor, customTabs);
        register(editor, dialogOpener);
        register$1(editor, dialogOpener);
        editor.shortcuts.add('Alt+0', 'Open help dialog', 'mceHelp');
        return api;
      });
    }

    Plugin();

}());


/***/ }),

/***/ "b9b0":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var contains = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };

    var global = tinymce.util.Tools.resolve('tinymce.Env');

    var link = function () {
      return /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-+~=.,%()\/\w]*[-+~=%()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g;
    };

    var defaultLinkPattern = new RegExp('^' + link().source + '$', 'i');
    var getAutoLinkPattern = function (editor) {
      return editor.getParam('autolink_pattern', defaultLinkPattern);
    };
    var getDefaultLinkTarget = function (editor) {
      return editor.getParam('default_link_target', false);
    };
    var getDefaultLinkProtocol = function (editor) {
      return editor.getParam('link_default_protocol', 'http', 'string');
    };

    var rangeEqualsBracketOrSpace = function (rangeString) {
      return /^[(\[{ \u00a0]$/.test(rangeString);
    };
    var isTextNode = function (node) {
      return node.nodeType === 3;
    };
    var isElement = function (node) {
      return node.nodeType === 1;
    };
    var handleBracket = function (editor) {
      return parseCurrentLine(editor, -1);
    };
    var handleSpacebar = function (editor) {
      return parseCurrentLine(editor, 0);
    };
    var handleEnter = function (editor) {
      return parseCurrentLine(editor, -1);
    };
    var scopeIndex = function (container, index) {
      if (index < 0) {
        index = 0;
      }
      if (isTextNode(container)) {
        var len = container.data.length;
        if (index > len) {
          index = len;
        }
      }
      return index;
    };
    var setStart = function (rng, container, offset) {
      if (!isElement(container) || container.hasChildNodes()) {
        rng.setStart(container, scopeIndex(container, offset));
      } else {
        rng.setStartBefore(container);
      }
    };
    var setEnd = function (rng, container, offset) {
      if (!isElement(container) || container.hasChildNodes()) {
        rng.setEnd(container, scopeIndex(container, offset));
      } else {
        rng.setEndAfter(container);
      }
    };
    var hasProtocol = function (url) {
      return /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(url);
    };
    var isPunctuation = function (char) {
      return /[?!,.;:]/.test(char);
    };
    var parseCurrentLine = function (editor, endOffset) {
      var end, endContainer, bookmark, text, prev, len, rngText;
      var autoLinkPattern = getAutoLinkPattern(editor);
      var defaultLinkTarget = getDefaultLinkTarget(editor);
      if (editor.dom.getParent(editor.selection.getNode(), 'a[href]') !== null) {
        return;
      }
      var rng = editor.selection.getRng().cloneRange();
      if (rng.startOffset < 5) {
        prev = rng.endContainer.previousSibling;
        if (!prev) {
          if (!rng.endContainer.firstChild || !rng.endContainer.firstChild.nextSibling) {
            return;
          }
          prev = rng.endContainer.firstChild.nextSibling;
        }
        len = prev.length;
        setStart(rng, prev, len);
        setEnd(rng, prev, len);
        if (rng.endOffset < 5) {
          return;
        }
        end = rng.endOffset;
        endContainer = prev;
      } else {
        endContainer = rng.endContainer;
        if (!isTextNode(endContainer) && endContainer.firstChild) {
          while (!isTextNode(endContainer) && endContainer.firstChild) {
            endContainer = endContainer.firstChild;
          }
          if (isTextNode(endContainer)) {
            setStart(rng, endContainer, 0);
            setEnd(rng, endContainer, endContainer.nodeValue.length);
          }
        }
        if (rng.endOffset === 1) {
          end = 2;
        } else {
          end = rng.endOffset - 1 - endOffset;
        }
      }
      var start = end;
      do {
        setStart(rng, endContainer, end >= 2 ? end - 2 : 0);
        setEnd(rng, endContainer, end >= 1 ? end - 1 : 0);
        end -= 1;
        rngText = rng.toString();
      } while (!rangeEqualsBracketOrSpace(rngText) && end - 2 >= 0);
      if (rangeEqualsBracketOrSpace(rng.toString())) {
        setStart(rng, endContainer, end);
        setEnd(rng, endContainer, start);
        end += 1;
      } else if (rng.startOffset === 0) {
        setStart(rng, endContainer, 0);
        setEnd(rng, endContainer, start);
      } else {
        setStart(rng, endContainer, end);
        setEnd(rng, endContainer, start);
      }
      text = rng.toString();
      if (isPunctuation(text.charAt(text.length - 1))) {
        setEnd(rng, endContainer, start - 1);
      }
      text = rng.toString().trim();
      var matches = text.match(autoLinkPattern);
      var protocol = getDefaultLinkProtocol(editor);
      if (matches) {
        var url = matches[0];
        if (startsWith(url, 'www.')) {
          url = protocol + '://' + url;
        } else if (contains(url, '@') && !hasProtocol(url)) {
          url = 'mailto:' + url;
        }
        bookmark = editor.selection.getBookmark();
        editor.selection.setRng(rng);
        editor.execCommand('createlink', false, url);
        if (defaultLinkTarget !== false) {
          editor.dom.setAttrib(editor.selection.getNode(), 'target', defaultLinkTarget);
        }
        editor.selection.moveToBookmark(bookmark);
        editor.nodeChanged();
      }
    };
    var setup = function (editor) {
      var autoUrlDetectState;
      editor.on('keydown', function (e) {
        if (e.keyCode === 13) {
          return handleEnter(editor);
        }
      });
      if (global.browser.isIE()) {
        editor.on('focus', function () {
          if (!autoUrlDetectState) {
            autoUrlDetectState = true;
            try {
              editor.execCommand('AutoUrlDetect', false, true);
            } catch (ex) {
            }
          }
        });
        return;
      }
      editor.on('keypress', function (e) {
        if (e.keyCode === 41 || e.keyCode === 93 || e.keyCode === 125) {
          return handleBracket(editor);
        }
      });
      editor.on('keyup', function (e) {
        if (e.keyCode === 32) {
          return handleSpacebar(editor);
        }
      });
    };

    function Plugin () {
      global$1.add('autolink', function (editor) {
        setup(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "baf7":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var applyListFormat = function (editor, listName, styleValue) {
      var cmd = listName === 'UL' ? 'InsertUnorderedList' : 'InsertOrderedList';
      editor.execCommand(cmd, false, styleValue === false ? null : { 'list-style-type': styleValue });
    };

    var register$1 = function (editor) {
      editor.addCommand('ApplyUnorderedListStyle', function (ui, value) {
        applyListFormat(editor, 'UL', value['list-style-type']);
      });
      editor.addCommand('ApplyOrderedListStyle', function (ui, value) {
        applyListFormat(editor, 'OL', value['list-style-type']);
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getNumberStyles = function (editor) {
      var styles = editor.getParam('advlist_number_styles', 'default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman');
      return styles ? styles.split(/[ ,]/) : [];
    };
    var getBulletStyles = function (editor) {
      var styles = editor.getParam('advlist_bullet_styles', 'default,circle,square');
      return styles ? styles.split(/[ ,]/) : [];
    };

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var isChildOfBody = function (editor, elm) {
      return editor.$.contains(editor.getBody(), elm);
    };
    var isTableCellNode = function (node) {
      return node && /^(TH|TD)$/.test(node.nodeName);
    };
    var isListNode = function (editor) {
      return function (node) {
        return node && /^(OL|UL|DL)$/.test(node.nodeName) && isChildOfBody(editor, node);
      };
    };
    var getSelectedStyleType = function (editor) {
      var listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');
      var style = editor.dom.getStyle(listElm, 'listStyleType');
      return Optional.from(style);
    };

    var findIndex = function (list, predicate) {
      for (var index = 0; index < list.length; index++) {
        var element = list[index];
        if (predicate(element)) {
          return index;
        }
      }
      return -1;
    };
    var styleValueToText = function (styleValue) {
      return styleValue.replace(/\-/g, ' ').replace(/\b\w/g, function (chr) {
        return chr.toUpperCase();
      });
    };
    var isWithinList = function (editor, e, nodeName) {
      var tableCellIndex = findIndex(e.parents, isTableCellNode);
      var parents = tableCellIndex !== -1 ? e.parents.slice(0, tableCellIndex) : e.parents;
      var lists = global.grep(parents, isListNode(editor));
      return lists.length > 0 && lists[0].nodeName === nodeName;
    };
    var makeSetupHandler = function (editor, nodeName) {
      return function (api) {
        var nodeChangeHandler = function (e) {
          api.setActive(isWithinList(editor, e, nodeName));
        };
        editor.on('NodeChange', nodeChangeHandler);
        return function () {
          return editor.off('NodeChange', nodeChangeHandler);
        };
      };
    };
    var addSplitButton = function (editor, id, tooltip, cmd, nodeName, styles) {
      editor.ui.registry.addSplitButton(id, {
        tooltip: tooltip,
        icon: nodeName === 'OL' ? 'ordered-list' : 'unordered-list',
        presets: 'listpreview',
        columns: 3,
        fetch: function (callback) {
          var items = global.map(styles, function (styleValue) {
            var iconStyle = nodeName === 'OL' ? 'num' : 'bull';
            var iconName = styleValue === 'disc' || styleValue === 'decimal' ? 'default' : styleValue;
            var itemValue = styleValue === 'default' ? '' : styleValue;
            var displayText = styleValueToText(styleValue);
            return {
              type: 'choiceitem',
              value: itemValue,
              icon: 'list-' + iconStyle + '-' + iconName,
              text: displayText
            };
          });
          callback(items);
        },
        onAction: function () {
          return editor.execCommand(cmd);
        },
        onItemAction: function (_splitButtonApi, value) {
          applyListFormat(editor, nodeName, value);
        },
        select: function (value) {
          var listStyleType = getSelectedStyleType(editor);
          return listStyleType.map(function (listStyle) {
            return value === listStyle;
          }).getOr(false);
        },
        onSetup: makeSetupHandler(editor, nodeName)
      });
    };
    var addButton = function (editor, id, tooltip, cmd, nodeName, _styles) {
      editor.ui.registry.addToggleButton(id, {
        active: false,
        tooltip: tooltip,
        icon: nodeName === 'OL' ? 'ordered-list' : 'unordered-list',
        onSetup: makeSetupHandler(editor, nodeName),
        onAction: function () {
          return editor.execCommand(cmd);
        }
      });
    };
    var addControl = function (editor, id, tooltip, cmd, nodeName, styles) {
      if (styles.length > 1) {
        addSplitButton(editor, id, tooltip, cmd, nodeName, styles);
      } else {
        addButton(editor, id, tooltip, cmd, nodeName);
      }
    };
    var register = function (editor) {
      addControl(editor, 'numlist', 'Numbered list', 'InsertOrderedList', 'OL', getNumberStyles(editor));
      addControl(editor, 'bullist', 'Bullet list', 'InsertUnorderedList', 'UL', getBulletStyles(editor));
    };

    function Plugin () {
      global$1.add('advlist', function (editor) {
        if (editor.hasPlugin('lists')) {
          register(editor);
          register$1(editor);
        } else {
          console.error('Please use the Lists plugin together with the Advanced List plugin.');
        }
      });
    }

    Plugin();

}());


/***/ }),

/***/ "bc75":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var typeOf$1 = function (x) {
      if (x === null) {
        return 'null';
      }
      if (x === undefined) {
        return 'undefined';
      }
      var t = typeof x;
      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      }
      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      }
      return t;
    };
    var isEquatableType = function (x) {
      return [
        'undefined',
        'boolean',
        'number',
        'string',
        'function',
        'xml',
        'null'
      ].indexOf(x) !== -1;
    };

    var sort$1 = function (xs, compareFn) {
      var clone = Array.prototype.slice.call(xs);
      return clone.sort(compareFn);
    };

    var contramap = function (eqa, f) {
      return eq$2(function (x, y) {
        return eqa.eq(f(x), f(y));
      });
    };
    var eq$2 = function (f) {
      return { eq: f };
    };
    var tripleEq = eq$2(function (x, y) {
      return x === y;
    });
    var eqString = tripleEq;
    var eqArray = function (eqa) {
      return eq$2(function (x, y) {
        if (x.length !== y.length) {
          return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
          if (!eqa.eq(x[i], y[i])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqSortedArray = function (eqa, compareFn) {
      return contramap(eqArray(eqa), function (xs) {
        return sort$1(xs, compareFn);
      });
    };
    var eqRecord = function (eqa) {
      return eq$2(function (x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
          return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
          var q = kx[i];
          if (!eqa.eq(x[q], y[q])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqAny = eq$2(function (x, y) {
      if (x === y) {
        return true;
      }
      var tx = typeOf$1(x);
      var ty = typeOf$1(y);
      if (tx !== ty) {
        return false;
      }
      if (isEquatableType(tx)) {
        return x === y;
      } else if (tx === 'array') {
        return eqArray(eqAny).eq(x, y);
      } else if (tx === 'object') {
        return eqRecord(eqAny).eq(x, y);
      }
      return false;
    });

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq$1 = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString$1 = isType$1('string');
    var isObject = isType$1('object');
    var isArray$1 = isType$1('array');
    var isNull = eq$1(null);
    var isBoolean = isSimpleType('boolean');
    var isUndefined = eq$1(undefined);
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var compose = function (fa, fb) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var compose1 = function (fbc, fab) {
      return function (a) {
        return fbc(fab(a));
      };
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var tripleEquals = function (a, b) {
      return a === b;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var not = function (f) {
      return function (t) {
        return !f(t);
      };
    };
    var die = function (msg) {
      return function () {
        throw new Error(msg);
      };
    };
    var apply = function (f) {
      return f();
    };
    var call = function (f) {
      f();
    };
    var never = constant(false);
    var always = constant(true);

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from$1 = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from$1
    };

    var nativeSlice = Array.prototype.slice;
    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var indexOf$2 = function (xs, x) {
      var r = rawIndexOf(xs, x);
      return r === -1 ? Optional.none() : Optional.some(r);
    };
    var contains$3 = function (xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var map$3 = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$k = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function (xs, f) {
      for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var partition = function (xs, pred) {
      var pass = [];
      var fail = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        var arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass: pass,
        fail: fail
      };
    };
    var filter$4 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var foldr = function (xs, f, acc) {
      eachr(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var foldl = function (xs, f, acc) {
      each$k(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var findUntil$1 = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find$3 = function (xs, pred) {
      return findUntil$1(xs, pred, never);
    };
    var findIndex$2 = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray$1(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map$3(xs, f));
    };
    var forall = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    var reverse = function (xs) {
      var r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    var difference = function (a1, a2) {
      return filter$4(a1, function (x) {
        return !contains$3(a2, x);
      });
    };
    var mapToObject = function (xs, f) {
      var r = {};
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    var sort = function (xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    var get$a = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get$a(xs, 0);
    };
    var last$2 = function (xs) {
      return get$a(xs, xs.length - 1);
    };
    var from = isFunction(Array.from) ? Array.from : function (x) {
      return nativeSlice.call(x);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var keys = Object.keys;
    var hasOwnProperty$1 = Object.hasOwnProperty;
    var each$j = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map$2 = function (obj, f) {
      return tupleMap(obj, function (x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function (obj, f) {
      var r = {};
      each$j(obj, function (x, i) {
        var tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each$j(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var bifilter = function (obj, pred) {
      var t = {};
      var f = {};
      internalFilter(obj, pred, objAcc(t), objAcc(f));
      return {
        t: t,
        f: f
      };
    };
    var filter$3 = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var mapToArray = function (obj, f) {
      var r = [];
      each$j(obj, function (value, name) {
        r.push(f(value, name));
      });
      return r;
    };
    var values = function (obj) {
      return mapToArray(obj, identity);
    };
    var get$9 = function (obj, key) {
      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has$2 = function (obj, key) {
      return hasOwnProperty$1.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };
    var equal$1 = function (a1, a2, eq) {
      if (eq === void 0) {
        eq = eqAny;
      }
      return eqRecord(eq).eq(a1, a2);
    };

    var isArray = Array.isArray;
    var toArray$1 = function (obj) {
      if (!isArray(obj)) {
        var array = [];
        for (var i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
        return array;
      } else {
        return obj;
      }
    };
    var each$i = function (o, cb, s) {
      var n, l;
      if (!o) {
        return false;
      }
      s = s || o;
      if (o.length !== undefined) {
        for (n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      } else {
        for (n in o) {
          if (has$2(o, n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return false;
            }
          }
        }
      }
      return true;
    };
    var map$1 = function (array, callback) {
      var out = [];
      each$i(array, function (item, index) {
        out.push(callback(item, index, array));
      });
      return out;
    };
    var filter$2 = function (a, f) {
      var o = [];
      each$i(a, function (v, index) {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });
      return o;
    };
    var indexOf$1 = function (a, v) {
      if (a) {
        for (var i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }
      return -1;
    };
    var reduce = function (collection, iteratee, accumulator, thisArg) {
      var acc = isUndefined(accumulator) ? collection[0] : accumulator;
      for (var i = 0; i < collection.length; i++) {
        acc = iteratee.call(thisArg, acc, collection[i], i);
      }
      return acc;
    };
    var findIndex$1 = function (array, predicate, thisArg) {
      var i, l;
      for (i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    var last$1 = function (collection) {
      return collection[collection.length - 1];
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() && !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      var isPhone = isiPhone || isMobile && !isTablet;
      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find$2 = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$4(group(1), group(2));
    };
    var detect$3 = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find$2(versionRegexes, cleanedAgent);
    };
    var unknown$2 = function () {
      return nu$4(0, 0);
    };
    var nu$4 = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$4,
      detect: detect$3,
      unknown: unknown$2
    };

    var detectBrowser$1 = function (browsers, userAgentData) {
      return findMap(userAgentData.brands, function (uaBrand) {
        var lcBrand = uaBrand.brand.toLowerCase();
        return find$3(browsers, function (browser) {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(function (info) {
          return {
            current: info.name,
            version: Version.nu(parseInt(uaBrand.version, 10), 0)
          };
        });
      });
    };

    var detect$2 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find$3(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$2(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$2(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    var removeFromStart = function (str, numChars) {
      return str.substring(numChars);
    };

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var removeLeading = function (str, prefix) {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    var contains$2 = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };
    var blank = function (r) {
      return function (s) {
        return s.replace(r, '');
      };
    };
    var trim$4 = blank(/^\s+|\s+$/g);
    var lTrim = blank(/^\s+/g);
    var rTrim = blank(/\s+$/g);
    var isNotEmpty = function (s) {
      return s.length > 0;
    };
    var isEmpty$3 = function (s) {
      return !isNotEmpty(s);
    };

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains$2(uastring, target);
      };
    };
    var browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains$2(uastring, 'edge/') && contains$2(uastring, 'chrome') && contains$2(uastring, 'safari') && contains$2(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chrome',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains$2(uastring, 'chrome') && !contains$2(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains$2(uastring, 'msie') || contains$2(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains$2(uastring, 'safari') || contains$2(uastring, 'mobile/')) && contains$2(uastring, 'applewebkit');
        }
      }
    ];
    var oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: function (uastring) {
          return contains$2(uastring, 'iphone') || contains$2(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'OSX',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    var edge = 'Edge';
    var chrome = 'Chrome';
    var ie$1 = 'IE';
    var opera = 'Opera';
    var firefox = 'Firefox';
    var safari = 'Safari';
    var unknown$1 = function () {
      return nu$3({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$3 = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie$1),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$3,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie$1),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    var windows = 'Windows';
    var ios = 'iOS';
    var android = 'Android';
    var linux = 'Linux';
    var osx = 'OSX';
    var solaris = 'Solaris';
    var freebsd = 'FreeBSD';
    var chromeos = 'ChromeOS';
    var unknown = function () {
      return nu$2({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$2 = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown,
      nu: nu$2,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    var detect$1 = function (userAgent, userAgentDataOpt, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = userAgentDataOpt.bind(function (userAgentData) {
        return detectBrowser$1(browsers, userAgentData);
      }).orThunk(function () {
        return detectBrowser(browsers, userAgent);
      }).fold(Browser.unknown, Browser.nu);
      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$1 };

    var mediaMatch = function (query) {
      return window.matchMedia(query).matches;
    };
    var platform$2 = cached(function () {
      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);
    });
    var detect = function () {
      return platform$2();
    };

    var userAgent = navigator.userAgent;
    var platform$1 = detect();
    var browser$4 = platform$1.browser;
    var os = platform$1.os;
    var deviceType = platform$1.deviceType;
    var webkit = /WebKit/.test(userAgent) && !browser$4.isEdge();
    var fileApi = 'FormData' in window && 'FileReader' in window && 'URL' in window && !!URL.createObjectURL;
    var windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
    var Env = {
      opera: browser$4.isOpera(),
      webkit: webkit,
      ie: browser$4.isIE() || browser$4.isEdge() ? browser$4.version.major : false,
      gecko: browser$4.isFirefox(),
      mac: os.isOSX() || os.isiOS(),
      iOS: deviceType.isiPad() || deviceType.isiPhone(),
      android: os.isAndroid(),
      contentEditable: true,
      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      caretAfter: true,
      range: window.getSelection && 'Range' in window,
      documentMode: browser$4.isIE() ? document.documentMode || 7 : 10,
      fileApi: fileApi,
      ceFalse: true,
      cacheSuffix: null,
      container: null,
      experimentalShadowDom: false,
      canHaveCSP: !browser$4.isIE(),
      desktop: deviceType.isDesktop(),
      windowsPhone: windowsPhone,
      browser: {
        current: browser$4.current,
        version: browser$4.version,
        isChrome: browser$4.isChrome,
        isEdge: browser$4.isEdge,
        isFirefox: browser$4.isFirefox,
        isIE: browser$4.isIE,
        isOpera: browser$4.isOpera,
        isSafari: browser$4.isSafari
      },
      os: {
        current: os.current,
        version: os.version,
        isAndroid: os.isAndroid,
        isChromeOS: os.isChromeOS,
        isFreeBSD: os.isFreeBSD,
        isiOS: os.isiOS,
        isLinux: os.isLinux,
        isOSX: os.isOSX,
        isSolaris: os.isSolaris,
        isWindows: os.isWindows
      },
      deviceType: {
        isDesktop: deviceType.isDesktop,
        isiPad: deviceType.isiPad,
        isiPhone: deviceType.isiPhone,
        isPhone: deviceType.isPhone,
        isTablet: deviceType.isTablet,
        isTouch: deviceType.isTouch,
        isWebView: deviceType.isWebView
      }
    };

    var whiteSpaceRegExp$2 = /^\s*|\s*$/g;
    var trim$3 = function (str) {
      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$2, '');
    };
    var is$3 = function (obj, type) {
      if (!type) {
        return obj !== undefined;
      }
      if (type === 'array' && isArray(obj)) {
        return true;
      }
      return typeof obj === type;
    };
    var makeMap$4 = function (items, delim, map) {
      var i;
      items = items || [];
      delim = delim || ',';
      if (typeof items === 'string') {
        items = items.split(delim);
      }
      map = map || {};
      i = items.length;
      while (i--) {
        map[items[i]] = {};
      }
      return map;
    };
    var hasOwnProperty = has$2;
    var create$9 = function (s, p, root) {
      var self = this;
      var sp, scn, c, de = 0;
      s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
      var cn = s[3].match(/(^|\.)(\w+)$/i)[2];
      var ns = self.createNS(s[3].replace(/\.\w+$/, ''), root);
      if (ns[cn]) {
        return;
      }
      if (s[2] === 'static') {
        ns[cn] = p;
        if (this.onCreate) {
          this.onCreate(s[2], s[3], ns[cn]);
        }
        return;
      }
      if (!p[cn]) {
        p[cn] = function () {
        };
        de = 1;
      }
      ns[cn] = p[cn];
      self.extend(ns[cn].prototype, p);
      if (s[5]) {
        sp = self.resolve(s[5]).prototype;
        scn = s[5].match(/\.(\w+)$/i)[1];
        c = ns[cn];
        if (de) {
          ns[cn] = function () {
            return sp[scn].apply(this, arguments);
          };
        } else {
          ns[cn] = function () {
            this.parent = sp[scn];
            return c.apply(this, arguments);
          };
        }
        ns[cn].prototype[cn] = ns[cn];
        self.each(sp, function (f, n) {
          ns[cn].prototype[n] = sp[n];
        });
        self.each(p, function (f, n) {
          if (sp[n]) {
            ns[cn].prototype[n] = function () {
              this.parent = sp[n];
              return f.apply(this, arguments);
            };
          } else {
            if (n !== cn) {
              ns[cn].prototype[n] = f;
            }
          }
        });
      }
      self.each(p.static, function (f, n) {
        ns[cn][n] = f;
      });
    };
    var extend$6 = function (obj) {
      var exts = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        exts[_i - 1] = arguments[_i];
      }
      for (var i = 0; i < exts.length; i++) {
        var ext = exts[i];
        for (var name_1 in ext) {
          if (has$2(ext, name_1)) {
            var value = ext[name_1];
            if (value !== undefined) {
              obj[name_1] = value;
            }
          }
        }
      }
      return obj;
    };
    var walk$3 = function (o, f, n, s) {
      s = s || this;
      if (o) {
        if (n) {
          o = o[n];
        }
        each$i(o, function (o, i) {
          if (f.call(s, o, i, n) === false) {
            return false;
          }
          walk$3(o, f, n, s);
        });
      }
    };
    var createNS = function (n, o) {
      var i, v;
      o = o || window;
      n = n.split('.');
      for (i = 0; i < n.length; i++) {
        v = n[i];
        if (!o[v]) {
          o[v] = {};
        }
        o = o[v];
      }
      return o;
    };
    var resolve$3 = function (n, o) {
      var i, l;
      o = o || window;
      n = n.split('.');
      for (i = 0, l = n.length; i < l; i++) {
        o = o[n[i]];
        if (!o) {
          break;
        }
      }
      return o;
    };
    var explode$4 = function (s, d) {
      if (!s || is$3(s, 'array')) {
        return s;
      }
      return map$1(s.split(d || ','), trim$3);
    };
    var _addCacheSuffix = function (url) {
      var cacheSuffix = Env.cacheSuffix;
      if (cacheSuffix) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
      }
      return url;
    };
    var Tools = {
      trim: trim$3,
      isArray: isArray,
      is: is$3,
      toArray: toArray$1,
      makeMap: makeMap$4,
      each: each$i,
      map: map$1,
      grep: filter$2,
      inArray: indexOf$1,
      hasOwn: hasOwnProperty,
      extend: extend$6,
      create: create$9,
      walk: walk$3,
      createNS: createNS,
      resolve: resolve$3,
      explode: explode$4,
      _addCacheSuffix: _addCacheSuffix
    };

    var fromHtml$1 = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom$2(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom$2(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom$2(node);
    };
    var fromDom$2 = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint$1 = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    };
    var SugarElement = {
      fromHtml: fromHtml$1,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom$2,
      fromPoint: fromPoint$1
    };

    var toArray = function (target, f) {
      var r = [];
      var recurse = function (e) {
        r.push(e);
        return f(e);
      };
      var cur = f(target);
      do {
        cur = cur.bind(recurse);
      } while (cur.isSome());
      return r;
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) & match) !== 0;
    };
    var documentPositionContainedBy = function (a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
    };

    var COMMENT = 8;
    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;

    var is$2 = function (element, selector) {
      var dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    };
    var all = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    var one = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    var eq = function (e1, e2) {
      return e1.dom === e2.dom;
    };
    var regularContains = function (e1, e2) {
      var d1 = e1.dom;
      var d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function (e1, e2) {
      return documentPositionContainedBy(e1.dom, e2.dom);
    };
    var contains$1 = function (e1, e2) {
      return detect().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var name = function (element) {
      var r = element.dom.nodeName;
      return r.toLowerCase();
    };
    var type = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isComment$1 = function (element) {
      return type(element) === COMMENT || name(element) === '#comment';
    };
    var isElement$6 = isType(ELEMENT);
    var isText$8 = isType(TEXT);
    var isDocument$2 = isType(DOCUMENT);
    var isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    var isTag = function (tag) {
      return function (e) {
        return isElement$6(e) && name(e) === tag;
      };
    };

    var owner$1 = function (element) {
      return SugarElement.fromDom(element.dom.ownerDocument);
    };
    var documentOrOwner = function (dos) {
      return isDocument$2(dos) ? dos : owner$1(dos);
    };
    var documentElement = function (element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    };
    var defaultView = function (element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    };
    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var parents$1 = function (element, isRoot) {
      var stop = isFunction(isRoot) ? isRoot : never;
      var dom = element.dom;
      var ret = [];
      while (dom.parentNode !== null && dom.parentNode !== undefined) {
        var rawParent = dom.parentNode;
        var p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
          break;
        } else {
          dom = rawParent;
        }
      }
      return ret;
    };
    var siblings = function (element) {
      var filterSelf = function (elements) {
        return filter$4(elements, function (x) {
          return !eq(element, x);
        });
      };
      return parent(element).map(children).map(filterSelf).getOr([]);
    };
    var prevSibling = function (element) {
      return Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    };
    var nextSibling = function (element) {
      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    };
    var prevSiblings = function (element) {
      return reverse(toArray(element, prevSibling));
    };
    var nextSiblings = function (element) {
      return toArray(element, nextSibling);
    };
    var children = function (element) {
      return map$3(element.dom.childNodes, SugarElement.fromDom);
    };
    var child$1 = function (element, index) {
      var cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    var firstChild = function (element) {
      return child$1(element, 0);
    };
    var lastChild = function (element) {
      return child$1(element, element.dom.childNodes.length - 1);
    };
    var childNodesCount = function (element) {
      return element.dom.childNodes.length;
    };

    var getHead = function (doc) {
      var b = doc.dom.head;
      if (b === null || b === undefined) {
        throw new Error('Head is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    var isShadowRoot = function (dos) {
      return isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    };
    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    var isSupported$1 = constant(supported);
    var getRootNode = supported ? function (e) {
      return SugarElement.fromDom(e.dom.getRootNode());
    } : documentOrOwner;
    var getStyleContainer = function (dos) {
      return isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    };
    var getShadowRoot = function (e) {
      var r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    var getShadowHost = function (e) {
      return SugarElement.fromDom(e.dom.host);
    };
    var getOriginalEventTarget = function (event) {
      if (isSupported$1() && isNonNullable(event.target)) {
        var el = SugarElement.fromDom(event.target);
        if (isElement$6(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    var isOpenShadowHost = function (element) {
      return isNonNullable(element.dom.shadowRoot);
    };

    var before$4 = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var after$3 = function (marker, element) {
      var sibling = nextSibling(marker);
      sibling.fold(function () {
        var parent$1 = parent(marker);
        parent$1.each(function (v) {
          append$1(v, element);
        });
      }, function (v) {
        before$4(v, element);
      });
    };
    var prepend = function (parent, element) {
      var firstChild$1 = firstChild(parent);
      firstChild$1.fold(function () {
        append$1(parent, element);
      }, function (v) {
        parent.dom.insertBefore(element.dom, v.dom);
      });
    };
    var append$1 = function (parent, element) {
      parent.dom.appendChild(element.dom);
    };
    var wrap$3 = function (element, wrapper) {
      before$4(element, wrapper);
      append$1(wrapper, element);
    };

    var before$3 = function (marker, elements) {
      each$k(elements, function (x) {
        before$4(marker, x);
      });
    };
    var append = function (parent, elements) {
      each$k(elements, function (x) {
        append$1(parent, x);
      });
    };

    var empty = function (element) {
      element.dom.textContent = '';
      each$k(children(element), function (rogue) {
        remove$7(rogue);
      });
    };
    var remove$7 = function (element) {
      var dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    var unwrap = function (wrapper) {
      var children$1 = children(wrapper);
      if (children$1.length > 0) {
        before$3(wrapper, children$1);
      }
      remove$7(wrapper);
    };

    var inBody = function (element) {
      var dom = isText$8(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      var doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {
        return doc.body.contains(dom);
      }, compose1(inBody, getShadowHost));
    };

    var r = function (left, top) {
      var translate = function (x, y) {
        return r(left + x, top + y);
      };
      return {
        left: left,
        top: top,
        translate: translate
      };
    };
    var SugarPosition = r;

    var boxPosition = function (dom) {
      var box = dom.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    var firstDefinedOrZero = function (a, b) {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    var absolute = function (element) {
      var doc = element.dom.ownerDocument;
      var body = doc.body;
      var win = doc.defaultView;
      var html = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    var viewport = function (element) {
      var dom = element.dom;
      var doc = dom.ownerDocument;
      var body = doc.body;
      if (body === dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom);
    };

    var get$8 = function (_DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    var to = function (x, y, _DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var win = doc.defaultView;
      if (win) {
        win.scrollTo(x, y);
      }
    };
    var intoView = function (element, alignToTop) {
      var isSafari = detect().browser.isSafari();
      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
        element.dom.scrollIntoViewIfNeeded(false);
      } else {
        element.dom.scrollIntoView(alignToTop);
      }
    };

    var get$7 = function (_win) {
      var win = _win === undefined ? window : _win;
      if (detect().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win['visualViewport']);
      }
    };
    var bounds = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var getBounds = function (_win) {
      var win = _win === undefined ? window : _win;
      var doc = win.document;
      var scroll = get$8(SugarElement.fromDom(doc));
      return get$7(win).fold(function () {
        var html = win.document.documentElement;
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      }, function (visualViewport) {
        return bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);
      });
    };

    var isNodeType = function (type) {
      return function (node) {
        return !!node && node.nodeType === type;
      };
    };
    var isRestrictedNode = function (node) {
      return !!node && !Object.getPrototypeOf(node);
    };
    var isElement$5 = isNodeType(1);
    var matchNodeNames = function (names) {
      var lowercasedNames = names.map(function (s) {
        return s.toLowerCase();
      });
      return function (node) {
        if (node && node.nodeName) {
          var nodeName = node.nodeName.toLowerCase();
          return contains$3(lowercasedNames, nodeName);
        }
        return false;
      };
    };
    var matchStyleValues = function (name, values) {
      var items = values.toLowerCase().split(' ');
      return function (node) {
        if (isElement$5(node)) {
          for (var i = 0; i < items.length; i++) {
            var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);
            var cssValue = computed ? computed.getPropertyValue(name) : null;
            if (cssValue === items[i]) {
              return true;
            }
          }
        }
        return false;
      };
    };
    var hasAttribute = function (attrName) {
      return function (node) {
        return isElement$5(node) && node.hasAttribute(attrName);
      };
    };
    var hasAttributeValue = function (attrName, attrValue) {
      return function (node) {
        return isElement$5(node) && node.getAttribute(attrName) === attrValue;
      };
    };
    var isBogus$2 = function (node) {
      return isElement$5(node) && node.hasAttribute('data-mce-bogus');
    };
    var isBogusAll$1 = function (node) {
      return isElement$5(node) && node.getAttribute('data-mce-bogus') === 'all';
    };
    var isTable$3 = function (node) {
      return isElement$5(node) && node.tagName === 'TABLE';
    };
    var hasContentEditableState = function (value) {
      return function (node) {
        if (isElement$5(node)) {
          if (node.contentEditable === value) {
            return true;
          }
          if (node.getAttribute('data-mce-contenteditable') === value) {
            return true;
          }
        }
        return false;
      };
    };
    var isTextareaOrInput = matchNodeNames([
      'textarea',
      'input'
    ]);
    var isText$7 = isNodeType(3);
    var isComment = isNodeType(8);
    var isDocument$1 = isNodeType(9);
    var isDocumentFragment = isNodeType(11);
    var isBr$5 = matchNodeNames(['br']);
    var isImg = matchNodeNames(['img']);
    var isContentEditableTrue$4 = hasContentEditableState('true');
    var isContentEditableFalse$b = hasContentEditableState('false');
    var isTableCell$5 = matchNodeNames([
      'td',
      'th'
    ]);
    var isMedia$2 = matchNodeNames([
      'video',
      'audio',
      'object',
      'embed'
    ]);

    var is$1 = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lhs.exists(function (left) {
        return comparator(left, rhs);
      });
    };
    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    var lift2 = function (oa, ob, f) {
      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    };
    var lift3 = function (oa, ob, oc, f) {
      return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    };
    var someIf = function (b, a) {
      return b ? Optional.some(a) : Optional.none();
    };

    var isSupported = function (dom) {
      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
    };

    var rawSet = function (dom, key, value) {
      if (isString$1(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set$1 = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var setAll$1 = function (element, attrs) {
      var dom = element.dom;
      each$j(attrs, function (v, k) {
        rawSet(dom, k, v);
      });
    };
    var get$6 = function (element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    var getOpt = function (element, key) {
      return Optional.from(get$6(element, key));
    };
    var has$1 = function (element, key) {
      var dom = element.dom;
      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    var remove$6 = function (element, key) {
      element.dom.removeAttribute(key);
    };
    var clone$3 = function (element) {
      return foldl(element.dom.attributes, function (acc, attr) {
        acc[attr.name] = attr.value;
        return acc;
      }, {});
    };

    var internalSet = function (dom, property, value) {
      if (!isString$1(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var setAll = function (element, css) {
      var dom = element.dom;
      each$j(css, function (v, k) {
        internalSet(dom, k, v);
      });
    };
    var get$5 = function (element, property) {
      var dom = element.dom;
      var styles = window.getComputedStyle(dom);
      var r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    var getUnsafeProperty = function (dom, property) {
      return isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    };
    var getRaw = function (element, property) {
      var dom = element.dom;
      var raw = getUnsafeProperty(dom, property);
      return Optional.from(raw).filter(function (r) {
        return r.length > 0;
      });
    };
    var getAllRaw = function (element) {
      var css = {};
      var dom = element.dom;
      if (isSupported(dom)) {
        for (var i = 0; i < dom.style.length; i++) {
          var ruleName = dom.style.item(i);
          css[ruleName] = dom.style[ruleName];
        }
      }
      return css;
    };
    var reflow = function (e) {
      return e.dom.offsetWidth;
    };

    var browser$3 = detect().browser;
    var firstElement = function (nodes) {
      return find$3(nodes, isElement$6);
    };
    var getTableCaptionDeltaY = function (elm) {
      if (browser$3.isFirefox() && name(elm) === 'table') {
        return firstElement(children(elm)).filter(function (elm) {
          return name(elm) === 'caption';
        }).bind(function (caption) {
          return firstElement(nextSiblings(caption)).map(function (body) {
            var bodyTop = body.dom.offsetTop;
            var captionTop = caption.dom.offsetTop;
            var captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        }).getOr(0);
      } else {
        return 0;
      }
    };
    var hasChild = function (elm, child) {
      return elm.children && contains$3(elm.children, child);
    };
    var getPos = function (body, elm, rootElm) {
      var x = 0, y = 0;
      var doc = body.ownerDocument;
      rootElm = rootElm ? rootElm : body;
      if (elm) {
        if (rootElm === body && elm.getBoundingClientRect && get$5(SugarElement.fromDom(body), 'position') === 'static') {
          var pos = elm.getBoundingClientRect();
          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
          return {
            x: x,
            y: y
          };
        }
        var offsetParent = elm;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          var castOffsetParent = offsetParent;
          x += castOffsetParent.offsetLeft || 0;
          y += castOffsetParent.offsetTop || 0;
          offsetParent = castOffsetParent.offsetParent;
        }
        offsetParent = elm.parentNode;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x -= offsetParent.scrollLeft || 0;
          y -= offsetParent.scrollTop || 0;
          offsetParent = offsetParent.parentNode;
        }
        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
      }
      return {
        x: x,
        y: y
      };
    };

    var exports$1 = {}, module$1 = { exports: exports$1 };
    (function (define, exports, module, require) {
      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EphoxContactWrapper = factory());
      }(this, function () {
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        var promise = { exports: {} };
        (function (module) {
          (function (root) {
            var setTimeoutFunc = setTimeout;
            function noop() {
            }
            function bind(fn, thisArg) {
              return function () {
                fn.apply(thisArg, arguments);
              };
            }
            function Promise(fn) {
              if (typeof this !== 'object')
                throw new TypeError('Promises must be constructed via new');
              if (typeof fn !== 'function')
                throw new TypeError('not a function');
              this._state = 0;
              this._handled = false;
              this._value = undefined;
              this._deferreds = [];
              doResolve(fn, this);
            }
            function handle(self, deferred) {
              while (self._state === 3) {
                self = self._value;
              }
              if (self._state === 0) {
                self._deferreds.push(deferred);
                return;
              }
              self._handled = true;
              Promise._immediateFn(function () {
                var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                if (cb === null) {
                  (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                  return;
                }
                var ret;
                try {
                  ret = cb(self._value);
                } catch (e) {
                  reject(deferred.promise, e);
                  return;
                }
                resolve(deferred.promise, ret);
              });
            }
            function resolve(self, newValue) {
              try {
                if (newValue === self)
                  throw new TypeError('A promise cannot be resolved with itself.');
                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                  var then = newValue.then;
                  if (newValue instanceof Promise) {
                    self._state = 3;
                    self._value = newValue;
                    finale(self);
                    return;
                  } else if (typeof then === 'function') {
                    doResolve(bind(then, newValue), self);
                    return;
                  }
                }
                self._state = 1;
                self._value = newValue;
                finale(self);
              } catch (e) {
                reject(self, e);
              }
            }
            function reject(self, newValue) {
              self._state = 2;
              self._value = newValue;
              finale(self);
            }
            function finale(self) {
              if (self._state === 2 && self._deferreds.length === 0) {
                Promise._immediateFn(function () {
                  if (!self._handled) {
                    Promise._unhandledRejectionFn(self._value);
                  }
                });
              }
              for (var i = 0, len = self._deferreds.length; i < len; i++) {
                handle(self, self._deferreds[i]);
              }
              self._deferreds = null;
            }
            function Handler(onFulfilled, onRejected, promise) {
              this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
              this.onRejected = typeof onRejected === 'function' ? onRejected : null;
              this.promise = promise;
            }
            function doResolve(fn, self) {
              var done = false;
              try {
                fn(function (value) {
                  if (done)
                    return;
                  done = true;
                  resolve(self, value);
                }, function (reason) {
                  if (done)
                    return;
                  done = true;
                  reject(self, reason);
                });
              } catch (ex) {
                if (done)
                  return;
                done = true;
                reject(self, ex);
              }
            }
            Promise.prototype['catch'] = function (onRejected) {
              return this.then(null, onRejected);
            };
            Promise.prototype.then = function (onFulfilled, onRejected) {
              var prom = new this.constructor(noop);
              handle(this, new Handler(onFulfilled, onRejected, prom));
              return prom;
            };
            Promise.all = function (arr) {
              var args = Array.prototype.slice.call(arr);
              return new Promise(function (resolve, reject) {
                if (args.length === 0)
                  return resolve([]);
                var remaining = args.length;
                function res(i, val) {
                  try {
                    if (val && (typeof val === 'object' || typeof val === 'function')) {
                      var then = val.then;
                      if (typeof then === 'function') {
                        then.call(val, function (val) {
                          res(i, val);
                        }, reject);
                        return;
                      }
                    }
                    args[i] = val;
                    if (--remaining === 0) {
                      resolve(args);
                    }
                  } catch (ex) {
                    reject(ex);
                  }
                }
                for (var i = 0; i < args.length; i++) {
                  res(i, args[i]);
                }
              });
            };
            Promise.resolve = function (value) {
              if (value && typeof value === 'object' && value.constructor === Promise) {
                return value;
              }
              return new Promise(function (resolve) {
                resolve(value);
              });
            };
            Promise.reject = function (value) {
              return new Promise(function (resolve, reject) {
                reject(value);
              });
            };
            Promise.race = function (values) {
              return new Promise(function (resolve, reject) {
                for (var i = 0, len = values.length; i < len; i++) {
                  values[i].then(resolve, reject);
                }
              });
            };
            Promise._immediateFn = typeof setImmediate === 'function' ? function (fn) {
              setImmediate(fn);
            } : function (fn) {
              setTimeoutFunc(fn, 0);
            };
            Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
              if (typeof console !== 'undefined' && console) {
                console.warn('Possible Unhandled Promise Rejection:', err);
              }
            };
            Promise._setImmediateFn = function _setImmediateFn(fn) {
              Promise._immediateFn = fn;
            };
            Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
              Promise._unhandledRejectionFn = fn;
            };
            if (module.exports) {
              module.exports = Promise;
            } else if (!root.Promise) {
              root.Promise = Promise;
            }
          }(commonjsGlobal));
        }(promise));
        var promisePolyfill = promise.exports;
        var Global = function () {
          if (typeof window !== 'undefined') {
            return window;
          } else {
            return Function('return this;')();
          }
        }();
        var promisePolyfill_1 = { boltExport: Global.Promise || promisePolyfill };
        return promisePolyfill_1;
      }));
    }(undefined, exports$1, module$1));
    var Promise$1 = module$1.exports.boltExport;

    var nu$1 = function (baseFn) {
      var data = Optional.none();
      var callbacks = [];
      var map = function (f) {
        return nu$1(function (nCallback) {
          get(function (data) {
            nCallback(f(data));
          });
        });
      };
      var get = function (nCallback) {
        if (isReady()) {
          call(nCallback);
        } else {
          callbacks.push(nCallback);
        }
      };
      var set = function (x) {
        if (!isReady()) {
          data = Optional.some(x);
          run(callbacks);
          callbacks = [];
        }
      };
      var isReady = function () {
        return data.isSome();
      };
      var run = function (cbs) {
        each$k(cbs, call);
      };
      var call = function (cb) {
        data.each(function (x) {
          setTimeout(function () {
            cb(x);
          }, 0);
        });
      };
      baseFn(set);
      return {
        get: get,
        map: map,
        isReady: isReady
      };
    };
    var pure$1 = function (a) {
      return nu$1(function (callback) {
        callback(a);
      });
    };
    var LazyValue = {
      nu: nu$1,
      pure: pure$1
    };

    var errorReporter = function (err) {
      setTimeout(function () {
        throw err;
      }, 0);
    };
    var make = function (run) {
      var get = function (callback) {
        run().then(callback, errorReporter);
      };
      var map = function (fab) {
        return make(function () {
          return run().then(fab);
        });
      };
      var bind = function (aFutureB) {
        return make(function () {
          return run().then(function (v) {
            return aFutureB(v).toPromise();
          });
        });
      };
      var anonBind = function (futureB) {
        return make(function () {
          return run().then(function () {
            return futureB.toPromise();
          });
        });
      };
      var toLazy = function () {
        return LazyValue.nu(get);
      };
      var toCached = function () {
        var cache = null;
        return make(function () {
          if (cache === null) {
            cache = run();
          }
          return cache;
        });
      };
      var toPromise = run;
      return {
        map: map,
        bind: bind,
        anonBind: anonBind,
        toLazy: toLazy,
        toCached: toCached,
        toPromise: toPromise,
        get: get
      };
    };
    var nu = function (baseFn) {
      return make(function () {
        return new Promise$1(baseFn);
      });
    };
    var pure = function (a) {
      return make(function () {
        return Promise$1.resolve(a);
      });
    };
    var Future = {
      nu: nu,
      pure: pure
    };

    var par$1 = function (asyncValues, nu) {
      return nu(function (callback) {
        var r = [];
        var count = 0;
        var cb = function (i) {
          return function (value) {
            r[i] = value;
            count++;
            if (count >= asyncValues.length) {
              callback(r);
            }
          };
        };
        if (asyncValues.length === 0) {
          callback([]);
        } else {
          each$k(asyncValues, function (asyncValue, i) {
            asyncValue.get(cb(i));
          });
        }
      });
    };

    var par = function (futures) {
      return par$1(futures, Future.nu);
    };

    var value$1 = function (o) {
      var or = function (_opt) {
        return value$1(o);
      };
      var orThunk = function (_f) {
        return value$1(o);
      };
      var map = function (f) {
        return value$1(f(o));
      };
      var mapError = function (_f) {
        return value$1(o);
      };
      var each = function (f) {
        f(o);
      };
      var bind = function (f) {
        return f(o);
      };
      var fold = function (_, onValue) {
        return onValue(o);
      };
      var exists = function (f) {
        return f(o);
      };
      var forall = function (f) {
        return f(o);
      };
      var toOptional = function () {
        return Optional.some(o);
      };
      return {
        isValue: always,
        isError: never,
        getOr: constant(o),
        getOrThunk: constant(o),
        getOrDie: constant(o),
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: each,
        bind: bind,
        exists: exists,
        forall: forall,
        toOptional: toOptional
      };
    };
    var error = function (message) {
      var getOrThunk = function (f) {
        return f();
      };
      var getOrDie = function () {
        return die(String(message))();
      };
      var or = identity;
      var orThunk = function (f) {
        return f();
      };
      var map = function (_f) {
        return error(message);
      };
      var mapError = function (f) {
        return error(f(message));
      };
      var bind = function (_f) {
        return error(message);
      };
      var fold = function (onError, _) {
        return onError(message);
      };
      return {
        isValue: never,
        isError: always,
        getOr: identity,
        getOrThunk: getOrThunk,
        getOrDie: getOrDie,
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: noop,
        bind: bind,
        exists: never,
        forall: always,
        toOptional: Optional.none
      };
    };
    var fromOption = function (opt, err) {
      return opt.fold(function () {
        return error(err);
      }, value$1);
    };
    var Result = {
      value: value$1,
      error: error,
      fromOption: fromOption
    };

    var generate$1 = function (cases) {
      if (!isArray$1(cases)) {
        throw new Error('cases must be an array');
      }
      if (cases.length === 0) {
        throw new Error('there must be at least one case');
      }
      var constructors = [];
      var adt = {};
      each$k(cases, function (acase, count) {
        var keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error('one and only one name per case');
        }
        var key = keys$1[0];
        var value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error('duplicate key detected:' + key);
        } else if (key === 'cata') {
          throw new Error('cannot have a case named cata (sorry)');
        } else if (!isArray$1(value)) {
          throw new Error('case arguments must be an array');
        }
        constructors.push(key);
        adt[key] = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var argLength = args.length;
          if (argLength !== value.length) {
            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
          }
          var match = function (branches) {
            var branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
            }
            var allReqd = forall(constructors, function (reqKey) {
              return contains$3(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: function () {
              var foldArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                foldArgs[_i] = arguments[_i];
              }
              if (foldArgs.length !== cases.length) {
                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
              }
              var target = foldArgs[count];
              return target.apply(null, args);
            },
            match: match,
            log: function (label) {
              console.log(label, {
                constructors: constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    var Adt = { generate: generate$1 };

    Adt.generate([
      {
        bothErrors: [
          'error1',
          'error2'
        ]
      },
      {
        firstError: [
          'error1',
          'value2'
        ]
      },
      {
        secondError: [
          'value1',
          'error2'
        ]
      },
      {
        bothValues: [
          'value1',
          'value2'
        ]
      }
    ]);
    var unite = function (result) {
      return result.fold(identity, identity);
    };

    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
      if (is(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor(scope, a, isRoot);
      }
    }

    var ancestor$3 = function (scope, predicate, isRoot) {
      var element = scope.dom;
      var stop = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$3 = function (scope, predicate, isRoot) {
      var is = function (s, test) {
        return test(s);
      };
      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);
    };
    var sibling$2 = function (scope, predicate) {
      var element = scope.dom;
      if (!element.parentNode) {
        return Optional.none();
      }
      return child(SugarElement.fromDom(element.parentNode), function (x) {
        return !eq(scope, x) && predicate(x);
      });
    };
    var child = function (scope, predicate) {
      var pred = function (node) {
        return predicate(SugarElement.fromDom(node));
      };
      var result = find$3(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };

    var ancestor$2 = function (scope, selector, isRoot) {
      return ancestor$3(scope, function (e) {
        return is$2(e, selector);
      }, isRoot);
    };
    var descendant = function (scope, selector) {
      return one(selector, scope);
    };
    var closest$2 = function (scope, selector, isRoot) {
      var is = function (element, selector) {
        return is$2(element, selector);
      };
      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);
    };

    var promiseObj = window.Promise ? window.Promise : Promise$1;

    var requestAnimationFramePromise;
    var requestAnimationFrame = function (callback, element) {
      var requestAnimationFrameFunc = window.requestAnimationFrame;
      var vendors = [
        'ms',
        'moz',
        'webkit'
      ];
      var featurefill = function (cb) {
        window.setTimeout(cb, 0);
      };
      for (var i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
        requestAnimationFrameFunc = window[vendors[i] + 'RequestAnimationFrame'];
      }
      if (!requestAnimationFrameFunc) {
        requestAnimationFrameFunc = featurefill;
      }
      requestAnimationFrameFunc(callback, element);
    };
    var wrappedSetTimeout = function (callback, time) {
      if (typeof time !== 'number') {
        time = 0;
      }
      return setTimeout(callback, time);
    };
    var wrappedSetInterval = function (callback, time) {
      if (typeof time !== 'number') {
        time = 1;
      }
      return setInterval(callback, time);
    };
    var wrappedClearTimeout = function (id) {
      return clearTimeout(id);
    };
    var wrappedClearInterval = function (id) {
      return clearInterval(id);
    };
    var debounce = function (callback, time) {
      var timer;
      var func = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        clearTimeout(timer);
        timer = wrappedSetTimeout(function () {
          callback.apply(this, args);
        }, time);
      };
      func.stop = function () {
        clearTimeout(timer);
      };
      return func;
    };
    var Delay = {
      requestAnimationFrame: function (callback, element) {
        if (requestAnimationFramePromise) {
          requestAnimationFramePromise.then(callback);
          return;
        }
        requestAnimationFramePromise = new promiseObj(function (resolve) {
          if (!element) {
            element = document.body;
          }
          requestAnimationFrame(resolve, element);
        }).then(callback);
      },
      setTimeout: wrappedSetTimeout,
      setInterval: wrappedSetInterval,
      setEditorTimeout: function (editor, callback, time) {
        return wrappedSetTimeout(function () {
          if (!editor.removed) {
            callback();
          }
        }, time);
      },
      setEditorInterval: function (editor, callback, time) {
        var timer = wrappedSetInterval(function () {
          if (!editor.removed) {
            callback();
          } else {
            clearInterval(timer);
          }
        }, time);
        return timer;
      },
      debounce: debounce,
      throttle: debounce,
      clearInterval: wrappedClearInterval,
      clearTimeout: wrappedClearTimeout
    };

    var StyleSheetLoader = function (documentOrShadowRoot, settings) {
      if (settings === void 0) {
        settings = {};
      }
      var idCount = 0;
      var loadedStates = {};
      var edos = SugarElement.fromDom(documentOrShadowRoot);
      var doc = documentOrOwner(edos);
      var maxLoadTime = settings.maxLoadTime || 5000;
      var _setReferrerPolicy = function (referrerPolicy) {
        settings.referrerPolicy = referrerPolicy;
      };
      var addStyle = function (element) {
        append$1(getStyleContainer(edos), element);
      };
      var removeStyle = function (id) {
        var styleContainer = getStyleContainer(edos);
        descendant(styleContainer, '#' + id).each(remove$7);
      };
      var getOrCreateState = function (url) {
        return get$9(loadedStates, url).getOrThunk(function () {
          return {
            id: 'mce-u' + idCount++,
            passed: [],
            failed: [],
            count: 0
          };
        });
      };
      var load = function (url, success, failure) {
        var link;
        var urlWithSuffix = Tools._addCacheSuffix(url);
        var state = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state;
        state.count++;
        var resolve = function (callbacks, status) {
          var i = callbacks.length;
          while (i--) {
            callbacks[i]();
          }
          state.status = status;
          state.passed = [];
          state.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        var passed = function () {
          return resolve(state.passed, 2);
        };
        var failed = function () {
          return resolve(state.failed, 3);
        };
        var wait = function (testCallback, waitCallback) {
          if (!testCallback()) {
            if (Date.now() - startTime < maxLoadTime) {
              Delay.setTimeout(waitCallback);
            } else {
              failed();
            }
          }
        };
        var waitForWebKitLinkLoaded = function () {
          wait(function () {
            var styleSheets = documentOrShadowRoot.styleSheets;
            var i = styleSheets.length;
            while (i--) {
              var styleSheet = styleSheets[i];
              var owner = styleSheet.ownerNode;
              if (owner && owner.id === link.id) {
                passed();
                return true;
              }
            }
            return false;
          }, waitForWebKitLinkLoaded);
        };
        if (success) {
          state.passed.push(success);
        }
        if (failure) {
          state.failed.push(failure);
        }
        if (state.status === 1) {
          return;
        }
        if (state.status === 2) {
          passed();
          return;
        }
        if (state.status === 3) {
          failed();
          return;
        }
        state.status = 1;
        var linkElem = SugarElement.fromTag('link', doc.dom);
        setAll$1(linkElem, {
          rel: 'stylesheet',
          type: 'text/css',
          id: state.id
        });
        var startTime = Date.now();
        if (settings.contentCssCors) {
          set$1(linkElem, 'crossOrigin', 'anonymous');
        }
        if (settings.referrerPolicy) {
          set$1(linkElem, 'referrerpolicy', settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = waitForWebKitLinkLoaded;
        link.onerror = failed;
        addStyle(linkElem);
        set$1(linkElem, 'href', urlWithSuffix);
      };
      var loadF = function (url) {
        return Future.nu(function (resolve) {
          load(url, compose(resolve, constant(Result.value(url))), compose(resolve, constant(Result.error(url))));
        });
      };
      var loadAll = function (urls, success, failure) {
        par(map$3(urls, loadF)).get(function (result) {
          var parts = partition(result, function (r) {
            return r.isValue();
          });
          if (parts.fail.length > 0) {
            failure(parts.fail.map(unite));
          } else {
            success(parts.pass.map(unite));
          }
        });
      };
      var unload = function (url) {
        var urlWithSuffix = Tools._addCacheSuffix(url);
        get$9(loadedStates, urlWithSuffix).each(function (state) {
          var count = --state.count;
          if (count === 0) {
            delete loadedStates[urlWithSuffix];
            removeStyle(state.id);
          }
        });
      };
      var unloadAll = function (urls) {
        each$k(urls, function (url) {
          unload(url);
        });
      };
      return {
        load: load,
        loadAll: loadAll,
        unload: unload,
        unloadAll: unloadAll,
        _setReferrerPolicy: _setReferrerPolicy
      };
    };

    var create$8 = function () {
      var map = new WeakMap();
      var forElement = function (referenceElement, settings) {
        var root = getRootNode(referenceElement);
        var rootDom = root.dom;
        return Optional.from(map.get(rootDom)).getOrThunk(function () {
          var sl = StyleSheetLoader(rootDom, settings);
          map.set(rootDom, sl);
          return sl;
        });
      };
      return { forElement: forElement };
    };
    var instance = create$8();

    var DomTreeWalker = function () {
      function DomTreeWalker(startNode, rootNode) {
        this.node = startNode;
        this.rootNode = rootNode;
        this.current = this.current.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.prev2 = this.prev2.bind(this);
      }
      DomTreeWalker.prototype.current = function () {
        return this.node;
      };
      DomTreeWalker.prototype.next = function (shallow) {
        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
        return this.node;
      };
      DomTreeWalker.prototype.prev = function (shallow) {
        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
        return this.node;
      };
      DomTreeWalker.prototype.prev2 = function (shallow) {
        this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);
        return this.node;
      };
      DomTreeWalker.prototype.findSibling = function (node, startName, siblingName, shallow) {
        var sibling, parent;
        if (node) {
          if (!shallow && node[startName]) {
            return node[startName];
          }
          if (node !== this.rootNode) {
            sibling = node[siblingName];
            if (sibling) {
              return sibling;
            }
            for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
              sibling = parent[siblingName];
              if (sibling) {
                return sibling;
              }
            }
          }
        }
      };
      DomTreeWalker.prototype.findPreviousNode = function (node, startName, siblingName, shallow) {
        var sibling, parent, child;
        if (node) {
          sibling = node[siblingName];
          if (this.rootNode && sibling === this.rootNode) {
            return;
          }
          if (sibling) {
            if (!shallow) {
              for (child = sibling[startName]; child; child = child[startName]) {
                if (!child[startName]) {
                  return child;
                }
              }
            }
            return sibling;
          }
          parent = node.parentNode;
          if (parent && parent !== this.rootNode) {
            return parent;
          }
        }
      };
      return DomTreeWalker;
    }();

    var blocks = [
      'article',
      'aside',
      'details',
      'div',
      'dt',
      'figcaption',
      'footer',
      'form',
      'fieldset',
      'header',
      'hgroup',
      'html',
      'main',
      'nav',
      'section',
      'summary',
      'body',
      'p',
      'dl',
      'multicol',
      'dd',
      'figure',
      'address',
      'center',
      'blockquote',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'listing',
      'xmp',
      'pre',
      'plaintext',
      'menu',
      'dir',
      'ul',
      'ol',
      'li',
      'hr',
      'table',
      'tbody',
      'thead',
      'tfoot',
      'th',
      'tr',
      'td',
      'caption'
    ];
    var tableCells = [
      'td',
      'th'
    ];
    var tableSections = [
      'thead',
      'tbody',
      'tfoot'
    ];
    var textBlocks = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'p',
      'div',
      'address',
      'pre',
      'form',
      'blockquote',
      'center',
      'dir',
      'fieldset',
      'header',
      'footer',
      'article',
      'section',
      'hgroup',
      'aside',
      'nav',
      'figure'
    ];
    var headings = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6'
    ];
    var listItems$1 = [
      'li',
      'dd',
      'dt'
    ];
    var lists = [
      'ul',
      'ol',
      'dl'
    ];
    var wsElements = [
      'pre',
      'script',
      'textarea',
      'style'
    ];
    var lazyLookup = function (items) {
      var lookup;
      return function (node) {
        lookup = lookup ? lookup : mapToObject(items, always);
        return has$2(lookup, name(node));
      };
    };
    var isHeading = lazyLookup(headings);
    var isBlock$2 = lazyLookup(blocks);
    var isTable$2 = function (node) {
      return name(node) === 'table';
    };
    var isInline$1 = function (node) {
      return isElement$6(node) && !isBlock$2(node);
    };
    var isBr$4 = function (node) {
      return isElement$6(node) && name(node) === 'br';
    };
    var isTextBlock$2 = lazyLookup(textBlocks);
    var isList = lazyLookup(lists);
    var isListItem = lazyLookup(listItems$1);
    var isTableSection = lazyLookup(tableSections);
    var isTableCell$4 = lazyLookup(tableCells);
    var isWsPreserveElement = lazyLookup(wsElements);

    var ancestor$1 = function (scope, selector, isRoot) {
      return ancestor$2(scope, selector, isRoot).isSome();
    };

    var zeroWidth = '\uFEFF';
    var nbsp = '\xA0';
    var isZwsp$1 = function (char) {
      return char === zeroWidth;
    };
    var removeZwsp = function (s) {
      return s.replace(/\uFEFF/g, '');
    };

    var ZWSP$1 = zeroWidth;
    var isZwsp = isZwsp$1;
    var trim$2 = removeZwsp;

    var isElement$4 = isElement$5;
    var isText$6 = isText$7;
    var isCaretContainerBlock$1 = function (node) {
      if (isText$6(node)) {
        node = node.parentNode;
      }
      return isElement$4(node) && node.hasAttribute('data-mce-caret');
    };
    var isCaretContainerInline = function (node) {
      return isText$6(node) && isZwsp(node.data);
    };
    var isCaretContainer$2 = function (node) {
      return isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    };
    var hasContent = function (node) {
      return node.firstChild !== node.lastChild || !isBr$5(node.firstChild);
    };
    var insertInline$1 = function (node, before) {
      var doc = node.ownerDocument;
      var textNode = doc.createTextNode(ZWSP$1);
      var parentNode = node.parentNode;
      if (!before) {
        var sibling = node.nextSibling;
        if (isText$6(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (startsWithCaretContainer$1(sibling)) {
            sibling.splitText(1);
            return sibling;
          }
        }
        if (node.nextSibling) {
          parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode.appendChild(textNode);
        }
      } else {
        var sibling = node.previousSibling;
        if (isText$6(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (endsWithCaretContainer$1(sibling)) {
            return sibling.splitText(sibling.data.length - 1);
          }
        }
        parentNode.insertBefore(textNode, node);
      }
      return textNode;
    };
    var isBeforeInline = function (pos) {
      var container = pos.container();
      if (!isText$7(container)) {
        return false;
      }
      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    var isAfterInline = function (pos) {
      var container = pos.container();
      if (!isText$7(container)) {
        return false;
      }
      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    var createBogusBr = function () {
      var br = document.createElement('br');
      br.setAttribute('data-mce-bogus', '1');
      return br;
    };
    var insertBlock$1 = function (blockName, node, before) {
      var doc = node.ownerDocument;
      var blockNode = doc.createElement(blockName);
      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
      blockNode.setAttribute('data-mce-bogus', 'all');
      blockNode.appendChild(createBogusBr());
      var parentNode = node.parentNode;
      if (!before) {
        if (node.nextSibling) {
          parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode.appendChild(blockNode);
        }
      } else {
        parentNode.insertBefore(blockNode, node);
      }
      return blockNode;
    };
    var startsWithCaretContainer$1 = function (node) {
      return isText$6(node) && node.data[0] === ZWSP$1;
    };
    var endsWithCaretContainer$1 = function (node) {
      return isText$6(node) && node.data[node.data.length - 1] === ZWSP$1;
    };
    var trimBogusBr = function (elm) {
      var brs = elm.getElementsByTagName('br');
      var lastBr = brs[brs.length - 1];
      if (isBogus$2(lastBr)) {
        lastBr.parentNode.removeChild(lastBr);
      }
    };
    var showCaretContainerBlock = function (caretContainer) {
      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute('data-mce-caret');
        caretContainer.removeAttribute('data-mce-bogus');
        caretContainer.removeAttribute('style');
        caretContainer.removeAttribute('_moz_abspos');
        return caretContainer;
      }
      return null;
    };
    var isRangeInCaretContainerBlock = function (range) {
      return isCaretContainerBlock$1(range.startContainer);
    };

    var isContentEditableTrue$3 = isContentEditableTrue$4;
    var isContentEditableFalse$a = isContentEditableFalse$b;
    var isBr$3 = isBr$5;
    var isText$5 = isText$7;
    var isInvalidTextElement = matchNodeNames([
      'script',
      'style',
      'textarea'
    ]);
    var isAtomicInline = matchNodeNames([
      'img',
      'input',
      'textarea',
      'hr',
      'iframe',
      'video',
      'audio',
      'object',
      'embed'
    ]);
    var isTable$1 = matchNodeNames(['table']);
    var isCaretContainer$1 = isCaretContainer$2;
    var isCaretCandidate$3 = function (node) {
      if (isCaretContainer$1(node)) {
        return false;
      }
      if (isText$5(node)) {
        return !isInvalidTextElement(node.parentNode);
      }
      return isAtomicInline(node) || isBr$3(node) || isTable$1(node) || isNonUiContentEditableFalse(node);
    };
    var isUnselectable = function (node) {
      return isElement$5(node) && node.getAttribute('unselectable') === 'true';
    };
    var isNonUiContentEditableFalse = function (node) {
      return isUnselectable(node) === false && isContentEditableFalse$a(node);
    };
    var isInEditable = function (node, root) {
      for (node = node.parentNode; node && node !== root; node = node.parentNode) {
        if (isNonUiContentEditableFalse(node)) {
          return false;
        }
        if (isContentEditableTrue$3(node)) {
          return true;
        }
      }
      return true;
    };
    var isAtomicContentEditableFalse = function (node) {
      if (!isNonUiContentEditableFalse(node)) {
        return false;
      }
      return foldl(from(node.getElementsByTagName('*')), function (result, elm) {
        return result || isContentEditableTrue$3(elm);
      }, false) !== true;
    };
    var isAtomic$1 = function (node) {
      return isAtomicInline(node) || isAtomicContentEditableFalse(node);
    };
    var isEditableCaretCandidate$1 = function (node, root) {
      return isCaretCandidate$3(node) && isInEditable(node, root);
    };

    var whiteSpaceRegExp$1 = /^[ \t\r\n]*$/;
    var isWhitespaceText = function (text) {
      return whiteSpaceRegExp$1.test(text);
    };

    var hasWhitespacePreserveParent = function (node, rootNode) {
      var rootElement = SugarElement.fromDom(rootNode);
      var startNode = SugarElement.fromDom(node);
      return ancestor$1(startNode, 'pre,code', curry(eq, rootElement));
    };
    var isWhitespace = function (node, rootNode) {
      return isText$7(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;
    };
    var isNamedAnchor = function (node) {
      return isElement$5(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));
    };
    var isContent$1 = function (node, rootNode) {
      return isCaretCandidate$3(node) && isWhitespace(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);
    };
    var isBookmark = hasAttribute('data-mce-bookmark');
    var isBogus$1 = hasAttribute('data-mce-bogus');
    var isBogusAll = hasAttributeValue('data-mce-bogus', 'all');
    var isEmptyNode = function (targetNode, skipBogus) {
      var brCount = 0;
      if (isContent$1(targetNode, targetNode)) {
        return false;
      } else {
        var node = targetNode.firstChild;
        if (!node) {
          return true;
        }
        var walker = new DomTreeWalker(node, targetNode);
        do {
          if (skipBogus) {
            if (isBogusAll(node)) {
              node = walker.next(true);
              continue;
            }
            if (isBogus$1(node)) {
              node = walker.next();
              continue;
            }
          }
          if (isBr$5(node)) {
            brCount++;
            node = walker.next();
            continue;
          }
          if (isContent$1(node, targetNode)) {
            return false;
          }
          node = walker.next();
        } while (node);
        return brCount <= 1;
      }
    };
    var isEmpty$2 = function (elm, skipBogus) {
      if (skipBogus === void 0) {
        skipBogus = true;
      }
      return isEmptyNode(elm.dom, skipBogus);
    };

    var isSpan = function (node) {
      return node.nodeName.toLowerCase() === 'span';
    };
    var isInlineContent = function (node, root) {
      return isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));
    };
    var surroundedByInlineContent = function (node, root) {
      var prev = new DomTreeWalker(node, root).prev(false);
      var next = new DomTreeWalker(node, root).next(false);
      var prevIsInline = isUndefined(prev) || isInlineContent(prev, root);
      var nextIsInline = isUndefined(next) || isInlineContent(next, root);
      return prevIsInline && nextIsInline;
    };
    var isBookmarkNode$2 = function (node) {
      return isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';
    };
    var isKeepTextNode = function (node, root) {
      return isText$7(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
    };
    var isKeepElement = function (node) {
      return isElement$5(node) ? node.childNodes.length > 0 : false;
    };
    var isDocument = function (node) {
      return isDocumentFragment(node) || isDocument$1(node);
    };
    var trimNode = function (dom, node, root) {
      var rootNode = root || node;
      if (isElement$5(node) && isBookmarkNode$2(node)) {
        return node;
      }
      var children = node.childNodes;
      for (var i = children.length - 1; i >= 0; i--) {
        trimNode(dom, children[i], rootNode);
      }
      if (isElement$5(node)) {
        var currentChildren = node.childNodes;
        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
          node.parentNode.insertBefore(currentChildren[0], node);
        }
      }
      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
        dom.remove(node);
      }
      return node;
    };

    var makeMap$3 = Tools.makeMap;
    var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var rawCharsRegExp = /[<>&\"\']/g;
    var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    var asciiMap = {
      128: '\u20AC',
      130: '\u201A',
      131: '\u0192',
      132: '\u201E',
      133: '\u2026',
      134: '\u2020',
      135: '\u2021',
      136: '\u02c6',
      137: '\u2030',
      138: '\u0160',
      139: '\u2039',
      140: '\u0152',
      142: '\u017d',
      145: '\u2018',
      146: '\u2019',
      147: '\u201C',
      148: '\u201D',
      149: '\u2022',
      150: '\u2013',
      151: '\u2014',
      152: '\u02DC',
      153: '\u2122',
      154: '\u0161',
      155: '\u203A',
      156: '\u0153',
      158: '\u017e',
      159: '\u0178'
    };
    var baseEntities = {
      '"': '&quot;',
      '\'': '&#39;',
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '`': '&#96;'
    };
    var reverseEntities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': '\''
    };
    var nativeDecode = function (text) {
      var elm = SugarElement.fromTag('div').dom;
      elm.innerHTML = text;
      return elm.textContent || elm.innerText || text;
    };
    var buildEntitiesLookup = function (items, radix) {
      var i, chr, entity;
      var lookup = {};
      if (items) {
        items = items.split(',');
        radix = radix || 10;
        for (i = 0; i < items.length; i += 2) {
          chr = String.fromCharCode(parseInt(items[i], radix));
          if (!baseEntities[chr]) {
            entity = '&' + items[i + 1] + ';';
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }
        return lookup;
      }
    };
    var namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    var encodeRaw = function (text, attr) {
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
        return baseEntities[chr] || chr;
      });
    };
    var encodeAllRaw = function (text) {
      return ('' + text).replace(rawCharsRegExp, function (chr) {
        return baseEntities[chr] || chr;
      });
    };
    var encodeNumeric = function (text, attr) {
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
        if (chr.length > 1) {
          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
        }
        return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
      });
    };
    var encodeNamed = function (text, attr, entities) {
      entities = entities || namedEntities;
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
        return baseEntities[chr] || entities[chr] || chr;
      });
    };
    var getEncodeFunc = function (name, entities) {
      var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
      var encodeNamedAndNumeric = function (text, attr) {
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
          if (baseEntities[chr] !== undefined) {
            return baseEntities[chr];
          }
          if (entitiesMap[chr] !== undefined) {
            return entitiesMap[chr];
          }
          if (chr.length > 1) {
            return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
          }
          return '&#' + chr.charCodeAt(0) + ';';
        });
      };
      var encodeCustomNamed = function (text, attr) {
        return encodeNamed(text, attr, entitiesMap);
      };
      var nameMap = makeMap$3(name.replace(/\+/g, ','));
      if (nameMap.named && nameMap.numeric) {
        return encodeNamedAndNumeric;
      }
      if (nameMap.named) {
        if (entities) {
          return encodeCustomNamed;
        }
        return encodeNamed;
      }
      if (nameMap.numeric) {
        return encodeNumeric;
      }
      return encodeRaw;
    };
    var decode = function (text) {
      return text.replace(entityRegExp, function (all, numeric) {
        if (numeric) {
          if (numeric.charAt(0).toLowerCase() === 'x') {
            numeric = parseInt(numeric.substr(1), 16);
          } else {
            numeric = parseInt(numeric, 10);
          }
          if (numeric > 65535) {
            numeric -= 65536;
            return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
          }
          return asciiMap[numeric] || String.fromCharCode(numeric);
        }
        return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
      });
    };
    var Entities = {
      encodeRaw: encodeRaw,
      encodeAllRaw: encodeAllRaw,
      encodeNumeric: encodeNumeric,
      encodeNamed: encodeNamed,
      getEncodeFunc: getEncodeFunc,
      decode: decode
    };

    var mapCache = {}, dummyObj = {};
    var makeMap$2 = Tools.makeMap, each$h = Tools.each, extend$5 = Tools.extend, explode$3 = Tools.explode, inArray$2 = Tools.inArray;
    var split$1 = function (items, delim) {
      items = Tools.trim(items);
      return items ? items.split(delim || ' ') : [];
    };
    var compileSchema = function (type) {
      var schema = {};
      var globalAttributes, blockContent;
      var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
      var add = function (name, attributes, children) {
        var ni, attributesOrder, element;
        var arrayToMap = function (array, obj) {
          var map = {};
          var i, l;
          for (i = 0, l = array.length; i < l; i++) {
            map[array[i]] = obj || {};
          }
          return map;
        };
        children = children || [];
        attributes = attributes || '';
        if (typeof children === 'string') {
          children = split$1(children);
        }
        var names = split$1(name);
        ni = names.length;
        while (ni--) {
          attributesOrder = split$1([
            globalAttributes,
            attributes
          ].join(' '));
          element = {
            attributes: arrayToMap(attributesOrder),
            attributesOrder: attributesOrder,
            children: arrayToMap(children, dummyObj)
          };
          schema[names[ni]] = element;
        }
      };
      var addAttrs = function (name, attributes) {
        var ni, schemaItem, i, l;
        var names = split$1(name);
        ni = names.length;
        var attrs = split$1(attributes);
        while (ni--) {
          schemaItem = schema[names[ni]];
          for (i = 0, l = attrs.length; i < l; i++) {
            schemaItem.attributes[attrs[i]] = {};
            schemaItem.attributesOrder.push(attrs[i]);
          }
        }
      };
      if (mapCache[type]) {
        return mapCache[type];
      }
      globalAttributes = 'id accesskey class dir lang style tabindex title role';
      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';
      if (type !== 'html4') {
        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';
        blockContent += ' article aside details dialog figure main header footer hgroup section nav';
        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';
      }
      if (type !== 'html5-strict') {
        globalAttributes += ' xml:lang';
        html4PhrasingContent = 'acronym applet basefont big font strike tt';
        phrasingContent = [
          phrasingContent,
          html4PhrasingContent
        ].join(' ');
        each$h(split$1(html4PhrasingContent), function (name) {
          add(name, '', phrasingContent);
        });
        html4BlockContent = 'center dir isindex noframes';
        blockContent = [
          blockContent,
          html4BlockContent
        ].join(' ');
        flowContent = [
          blockContent,
          phrasingContent
        ].join(' ');
        each$h(split$1(html4BlockContent), function (name) {
          add(name, '', flowContent);
        });
      }
      flowContent = flowContent || [
        blockContent,
        phrasingContent
      ].join(' ');
      add('html', 'manifest', 'head body');
      add('head', '', 'base command link meta noscript script style title');
      add('title hr noscript br');
      add('base', 'href target');
      add('link', 'href rel media hreflang type sizes hreflang');
      add('meta', 'name http-equiv content charset');
      add('style', 'media type scoped');
      add('script', 'src async defer type charset');
      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);
      add('address dt dd div caption', '', flowContent);
      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
      add('blockquote', 'cite', flowContent);
      add('ol', 'reversed start type', 'li');
      add('ul', '', 'li');
      add('li', 'value', flowContent);
      add('dl', '', 'dt dd');
      add('a', 'href target rel media hreflang type', phrasingContent);
      add('q', 'cite', phrasingContent);
      add('ins del', 'cite datetime', flowContent);
      add('img', 'src sizes srcset alt usemap ismap width height');
      add('iframe', 'src name width height', flowContent);
      add('embed', 'src type width height');
      add('object', 'data type typemustmatch name usemap form width height', [
        flowContent,
        'param'
      ].join(' '));
      add('param', 'name value');
      add('map', 'name', [
        flowContent,
        'area'
      ].join(' '));
      add('area', 'alt coords shape href target rel media hreflang type');
      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
      add('colgroup', 'span', 'col');
      add('col', 'span');
      add('tbody thead tfoot', '', 'tr');
      add('tr', '', 'td th');
      add('td', 'colspan rowspan headers', flowContent);
      add('th', 'colspan rowspan headers scope abbr', flowContent);
      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
      add('fieldset', 'disabled form name', [
        flowContent,
        'legend'
      ].join(' '));
      add('label', 'form for', phrasingContent);
      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
      add('select', 'disabled form multiple name required size', 'option optgroup');
      add('optgroup', 'disabled label', 'option');
      add('option', 'disabled label selected value');
      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
      add('menu', 'type label', [
        flowContent,
        'li'
      ].join(' '));
      add('noscript', '', flowContent);
      if (type !== 'html4') {
        add('wbr');
        add('ruby', '', [
          phrasingContent,
          'rt rp'
        ].join(' '));
        add('figcaption', '', flowContent);
        add('mark rt rp summary bdi', '', phrasingContent);
        add('canvas', 'width height', flowContent);
        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [
          flowContent,
          'track source'
        ].join(' '));
        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [
          flowContent,
          'track source'
        ].join(' '));
        add('picture', '', 'img source');
        add('source', 'src srcset type media sizes');
        add('track', 'kind src srclang label default');
        add('datalist', '', [
          phrasingContent,
          'option'
        ].join(' '));
        add('article section nav aside main header footer', '', flowContent);
        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
        add('figure', '', [
          flowContent,
          'figcaption'
        ].join(' '));
        add('time', 'datetime', phrasingContent);
        add('dialog', 'open', flowContent);
        add('command', 'type label icon disabled checked radiogroup command');
        add('output', 'for form name', phrasingContent);
        add('progress', 'value max', phrasingContent);
        add('meter', 'value min max low high optimum', phrasingContent);
        add('details', 'open', [
          flowContent,
          'summary'
        ].join(' '));
        add('keygen', 'autofocus challenge disabled form keytype name');
      }
      if (type !== 'html5-strict') {
        addAttrs('script', 'language xml:space');
        addAttrs('style', 'xml:space');
        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
        addAttrs('embed', 'align name hspace vspace');
        addAttrs('param', 'valuetype type');
        addAttrs('a', 'charset name rev shape coords');
        addAttrs('br', 'clear');
        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
        addAttrs('img', 'name longdesc align border hspace vspace');
        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
        addAttrs('font basefont', 'size color face');
        addAttrs('input', 'usemap align');
        addAttrs('select');
        addAttrs('textarea');
        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
        addAttrs('ul', 'type compact');
        addAttrs('li', 'type');
        addAttrs('ol dl menu dir', 'compact');
        addAttrs('pre', 'width xml:space');
        addAttrs('hr', 'align noshade size width');
        addAttrs('isindex', 'prompt');
        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
        addAttrs('col', 'width align char charoff valign');
        addAttrs('colgroup', 'width align char charoff valign');
        addAttrs('thead', 'align char charoff valign');
        addAttrs('tr', 'align char charoff valign bgcolor');
        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
        addAttrs('form', 'accept');
        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
        addAttrs('tfoot', 'align char charoff valign');
        addAttrs('tbody', 'align char charoff valign');
        addAttrs('area', 'nohref');
        addAttrs('body', 'background bgcolor text link vlink alink');
      }
      if (type !== 'html4') {
        addAttrs('input button select textarea', 'autofocus');
        addAttrs('input textarea', 'placeholder');
        addAttrs('a', 'download');
        addAttrs('link script img', 'crossorigin');
        addAttrs('img', 'loading');
        addAttrs('iframe', 'sandbox seamless allowfullscreen loading');
      }
      each$h(split$1('a form meter progress dfn'), function (name) {
        if (schema[name]) {
          delete schema[name].children[name];
        }
      });
      delete schema.caption.children.table;
      delete schema.script;
      mapCache[type] = schema;
      return schema;
    };
    var compileElementMap = function (value, mode) {
      var styles;
      if (value) {
        styles = {};
        if (typeof value === 'string') {
          value = { '*': value };
        }
        each$h(value, function (value, key) {
          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$3(value, /[, ]/);
        });
      }
      return styles;
    };
    var Schema = function (settings) {
      var elements = {};
      var children = {};
      var patternElements = [];
      var customElementsMap = {}, specialElements = {};
      var createLookupTable = function (option, defaultValue, extendWith) {
        var value = settings[option];
        if (!value) {
          value = mapCache[option];
          if (!value) {
            value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
            value = extend$5(value, extendWith);
            mapCache[option] = value;
          }
        } else {
          value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
        }
        return value;
      };
      settings = settings || {};
      var schemaItems = compileSchema(settings.schema);
      if (settings.verify_html === false) {
        settings.valid_elements = '*[*]';
      }
      var validStyles = compileElementMap(settings.valid_styles);
      var invalidStyles = compileElementMap(settings.invalid_styles, 'map');
      var validClasses = compileElementMap(settings.valid_classes, 'map');
      var whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
      var selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
      var shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');
      var boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls');
      var nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
      var nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', shortEndedElementsMap);
      var moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', shortEndedElementsMap);
      var textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
      var blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);
      var textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' + 'dfn code mark q sup sub samp');
      each$h((settings.special || 'script noscript iframe noframes noembed title style textarea xmp').split(' '), function (name) {
        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
      });
      var patternToRegExp = function (str) {
        return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
      };
      var addValidElements = function (validElements) {
        var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;
        var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
        if (validElements) {
          var validElementsArr = split$1(validElements, ',');
          if (elements['@']) {
            globalAttributes = elements['@'].attributes;
            globalAttributesOrder = elements['@'].attributesOrder;
          }
          for (ei = 0, el = validElementsArr.length; ei < el; ei++) {
            matches = elementRuleRegExp.exec(validElementsArr[ei]);
            if (matches) {
              prefix = matches[1];
              elementName = matches[2];
              outputName = matches[3];
              attrData = matches[5];
              attributes = {};
              attributesOrder = [];
              element = {
                attributes: attributes,
                attributesOrder: attributesOrder
              };
              if (prefix === '#') {
                element.paddEmpty = true;
              }
              if (prefix === '-') {
                element.removeEmpty = true;
              }
              if (matches[4] === '!') {
                element.removeEmptyAttrs = true;
              }
              if (globalAttributes) {
                each$j(globalAttributes, function (value, key) {
                  attributes[key] = value;
                });
                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
              }
              if (attrData) {
                attrData = split$1(attrData, '|');
                for (ai = 0, al = attrData.length; ai < al; ai++) {
                  matches = attrRuleRegExp.exec(attrData[ai]);
                  if (matches) {
                    attr = {};
                    attrType = matches[1];
                    attrName = matches[2].replace(/[\\:]:/g, ':');
                    prefix = matches[3];
                    value = matches[4];
                    if (attrType === '!') {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr.required = true;
                    }
                    if (attrType === '-') {
                      delete attributes[attrName];
                      attributesOrder.splice(inArray$2(attributesOrder, attrName), 1);
                      continue;
                    }
                    if (prefix) {
                      if (prefix === '=') {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({
                          name: attrName,
                          value: value
                        });
                        attr.defaultValue = value;
                      }
                      if (prefix === ':') {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({
                          name: attrName,
                          value: value
                        });
                        attr.forcedValue = value;
                      }
                      if (prefix === '<') {
                        attr.validValues = makeMap$2(value, '?');
                      }
                    }
                    if (hasPatternsRegExp.test(attrName)) {
                      element.attributePatterns = element.attributePatterns || [];
                      attr.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attr);
                    } else {
                      if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                      }
                      attributes[attrName] = attr;
                    }
                  }
                }
              }
              if (!globalAttributes && elementName === '@') {
                globalAttributes = attributes;
                globalAttributesOrder = attributesOrder;
              }
              if (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }
              if (hasPatternsRegExp.test(elementName)) {
                element.pattern = patternToRegExp(elementName);
                patternElements.push(element);
              } else {
                elements[elementName] = element;
              }
            }
          }
        }
      };
      var setValidElements = function (validElements) {
        elements = {};
        patternElements = [];
        addValidElements(validElements);
        each$h(schemaItems, function (element, name) {
          children[name] = element.children;
        });
      };
      var addCustomElements = function (customElements) {
        var customElementRegExp = /^(~)?(.+)$/;
        if (customElements) {
          mapCache.text_block_elements = mapCache.block_elements = null;
          each$h(split$1(customElements, ','), function (rule) {
            var matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];
            children[name] = children[cloneName];
            customElementsMap[name] = cloneName;
            if (!inline) {
              blockElementsMap[name.toUpperCase()] = {};
              blockElementsMap[name] = {};
            }
            if (!elements[name]) {
              var customRule = elements[cloneName];
              customRule = extend$5({}, customRule);
              delete customRule.removeEmptyAttrs;
              delete customRule.removeEmpty;
              elements[name] = customRule;
            }
            each$h(children, function (element, elmName) {
              if (element[cloneName]) {
                children[elmName] = element = extend$5({}, children[elmName]);
                element[name] = element[cloneName];
              }
            });
          });
        }
      };
      var addValidChildren = function (validChildren) {
        var childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        mapCache[settings.schema] = null;
        if (validChildren) {
          each$h(split$1(validChildren, ','), function (rule) {
            var matches = childRuleRegExp.exec(rule);
            var parent, prefix;
            if (matches) {
              prefix = matches[1];
              if (prefix) {
                parent = children[matches[2]];
              } else {
                parent = children[matches[2]] = { '#comment': {} };
              }
              parent = children[matches[2]];
              each$h(split$1(matches[3], '|'), function (child) {
                if (prefix === '-') {
                  delete parent[child];
                } else {
                  parent[child] = {};
                }
              });
            }
          });
        }
      };
      var getElementRule = function (name) {
        var element = elements[name], i;
        if (element) {
          return element;
        }
        i = patternElements.length;
        while (i--) {
          element = patternElements[i];
          if (element.pattern.test(name)) {
            return element;
          }
        }
      };
      if (!settings.valid_elements) {
        each$h(schemaItems, function (element, name) {
          elements[name] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };
          children[name] = element.children;
        });
        if (settings.schema !== 'html5') {
          each$h(split$1('strong/b em/i'), function (item) {
            var items = split$1(item, '/');
            elements[items[1]].outputName = items[0];
          });
        }
        each$h(split$1('ol ul sub sup blockquote span font a table tbody strong em b i'), function (name) {
          if (elements[name]) {
            elements[name].removeEmpty = true;
          }
        });
        each$h(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), function (name) {
          elements[name].paddEmpty = true;
        });
        each$h(split$1('span'), function (name) {
          elements[name].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
      }
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren('+ol[ul|ol],+ul[ul|ol]');
      each$h({
        dd: 'dl',
        dt: 'dl',
        li: 'ul ol',
        td: 'tr',
        th: 'tr',
        tr: 'tbody thead tfoot',
        tbody: 'table',
        thead: 'table',
        tfoot: 'table',
        legend: 'fieldset',
        area: 'map',
        param: 'video audio object'
      }, function (parents, item) {
        if (elements[item]) {
          elements[item].parentsRequired = split$1(parents);
        }
      });
      if (settings.invalid_elements) {
        each$h(explode$3(settings.invalid_elements), function (item) {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }
      if (!getElementRule('span')) {
        addValidElements('span[!data-mce-type|*]');
      }
      var getValidStyles = constant(validStyles);
      var getInvalidStyles = constant(invalidStyles);
      var getValidClasses = constant(validClasses);
      var getBoolAttrs = constant(boolAttrMap);
      var getBlockElements = constant(blockElementsMap);
      var getTextBlockElements = constant(textBlockElementsMap);
      var getTextInlineElements = constant(textInlineElementsMap);
      var getShortEndedElements = constant(shortEndedElementsMap);
      var getSelfClosingElements = constant(selfClosingElementsMap);
      var getNonEmptyElements = constant(nonEmptyElementsMap);
      var getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
      var getWhiteSpaceElements = constant(whiteSpaceElementsMap);
      var getSpecialElements = constant(specialElements);
      var isValidChild = function (name, child) {
        var parent = children[name.toLowerCase()];
        return !!(parent && parent[child.toLowerCase()]);
      };
      var isValid = function (name, attr) {
        var attrPatterns, i;
        var rule = getElementRule(name);
        if (rule) {
          if (attr) {
            if (rule.attributes[attr]) {
              return true;
            }
            attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(name)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }
        return false;
      };
      var getCustomElements = constant(customElementsMap);
      return {
        children: children,
        elements: elements,
        getValidStyles: getValidStyles,
        getValidClasses: getValidClasses,
        getBlockElements: getBlockElements,
        getInvalidStyles: getInvalidStyles,
        getShortEndedElements: getShortEndedElements,
        getTextBlockElements: getTextBlockElements,
        getTextInlineElements: getTextInlineElements,
        getBoolAttrs: getBoolAttrs,
        getElementRule: getElementRule,
        getSelfClosingElements: getSelfClosingElements,
        getNonEmptyElements: getNonEmptyElements,
        getMoveCaretBeforeOnEnterElements: getMoveCaretBeforeOnEnterElements,
        getWhiteSpaceElements: getWhiteSpaceElements,
        getSpecialElements: getSpecialElements,
        isValidChild: isValidChild,
        isValid: isValid,
        getCustomElements: getCustomElements,
        addValidElements: addValidElements,
        setValidElements: setValidElements,
        addCustomElements: addCustomElements,
        addValidChildren: addValidChildren
      };
    };

    var toHex = function (match, r, g, b) {
      var hex = function (val) {
        val = parseInt(val, 10).toString(16);
        return val.length > 1 ? val : '0' + val;
      };
      return '#' + hex(r) + hex(g) + hex(b);
    };
    var Styles = function (settings, schema) {
      var _this = this;
      var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
      var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
      var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
      var trimRightRegExp = /\s+$/;
      var i;
      var encodingLookup = {};
      var validStyles;
      var invalidStyles;
      var invisibleChar = zeroWidth;
      settings = settings || {};
      if (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }
      var encodingItems = ('\\" \\\' \\; \\: ; : ' + invisibleChar).split(' ');
      for (i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }
      return {
        toHex: function (color) {
          return color.replace(rgbRegExp, toHex);
        },
        parse: function (css) {
          var styles = {};
          var matches, name, value, isEncoded;
          var urlConverter = settings.url_converter;
          var urlConverterScope = settings.url_converter_scope || _this;
          var compress = function (prefix, suffix, noJoin) {
            var top = styles[prefix + '-top' + suffix];
            if (!top) {
              return;
            }
            var right = styles[prefix + '-right' + suffix];
            if (!right) {
              return;
            }
            var bottom = styles[prefix + '-bottom' + suffix];
            if (!bottom) {
              return;
            }
            var left = styles[prefix + '-left' + suffix];
            if (!left) {
              return;
            }
            var box = [
              top,
              right,
              bottom,
              left
            ];
            i = box.length - 1;
            while (i--) {
              if (box[i] !== box[i + 1]) {
                break;
              }
            }
            if (i > -1 && noJoin) {
              return;
            }
            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
            delete styles[prefix + '-top' + suffix];
            delete styles[prefix + '-right' + suffix];
            delete styles[prefix + '-bottom' + suffix];
            delete styles[prefix + '-left' + suffix];
          };
          var canCompress = function (key) {
            var value = styles[key], i;
            if (!value) {
              return;
            }
            value = value.split(' ');
            i = value.length;
            while (i--) {
              if (value[i] !== value[0]) {
                return false;
              }
            }
            styles[key] = value[0];
            return true;
          };
          var compress2 = function (target, a, b, c) {
            if (!canCompress(a)) {
              return;
            }
            if (!canCompress(b)) {
              return;
            }
            if (!canCompress(c)) {
              return;
            }
            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
            delete styles[a];
            delete styles[b];
            delete styles[c];
          };
          var encode = function (str) {
            isEncoded = true;
            return encodingLookup[str];
          };
          var decode = function (str, keepSlashes) {
            if (isEncoded) {
              str = str.replace(/\uFEFF[0-9]/g, function (str) {
                return encodingLookup[str];
              });
            }
            if (!keepSlashes) {
              str = str.replace(/\\([\'\";:])/g, '$1');
            }
            return str;
          };
          var decodeSingleHexSequence = function (escSeq) {
            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
          };
          var decodeHexSequences = function (value) {
            return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
          };
          var processUrl = function (match, url, url2, url3, str, str2) {
            str = str || str2;
            if (str) {
              str = decode(str);
              return '\'' + str.replace(/\'/g, '\\\'') + '\'';
            }
            url = decode(url || url2 || url3);
            if (!settings.allow_script_urls) {
              var scriptUrl = url.replace(/[\s\r\n]+/g, '');
              if (/(java|vb)script:/i.test(scriptUrl)) {
                return '';
              }
              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                return '';
              }
            }
            if (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, 'style');
            }
            return 'url(\'' + url.replace(/\'/g, '\\\'') + '\')';
          };
          if (css) {
            css = css.replace(/[\u0000-\u001F]/g, '');
            css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function (str) {
              return str.replace(/[;:]/g, encode);
            });
            while (matches = styleRegExp.exec(css)) {
              styleRegExp.lastIndex = matches.index + matches[0].length;
              name = matches[1].replace(trimRightRegExp, '').toLowerCase();
              value = matches[2].replace(trimRightRegExp, '');
              if (name && value) {
                name = decodeHexSequences(name);
                value = decodeHexSequences(value);
                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
                  continue;
                }
                if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
                  continue;
                }
                if (name === 'font-weight' && value === '700') {
                  value = 'bold';
                } else if (name === 'color' || name === 'background-color') {
                  value = value.toLowerCase();
                }
                value = value.replace(rgbRegExp, toHex);
                value = value.replace(urlOrStrRegExp, processUrl);
                styles[name] = isEncoded ? decode(value, true) : value;
              }
            }
            compress('border', '', true);
            compress('border', '-width');
            compress('border', '-color');
            compress('border', '-style');
            compress('padding', '');
            compress('margin', '');
            compress2('border', 'border-width', 'border-style', 'border-color');
            if (styles.border === 'medium none') {
              delete styles.border;
            }
            if (styles['border-image'] === 'none') {
              delete styles['border-image'];
            }
          }
          return styles;
        },
        serialize: function (styles, elementName) {
          var css = '';
          var serializeStyles = function (name) {
            var value;
            var styleList = validStyles[name];
            if (styleList) {
              for (var i_1 = 0, l = styleList.length; i_1 < l; i_1++) {
                name = styleList[i_1];
                value = styles[name];
                if (value) {
                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                }
              }
            }
          };
          var isValid = function (name, elementName) {
            var styleMap = invalidStyles['*'];
            if (styleMap && styleMap[name]) {
              return false;
            }
            styleMap = invalidStyles[elementName];
            return !(styleMap && styleMap[name]);
          };
          if (elementName && validStyles) {
            serializeStyles('*');
            serializeStyles(elementName);
          } else {
            each$j(styles, function (value, name) {
              if (value && (!invalidStyles || isValid(name, elementName))) {
                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
              }
            });
          }
          return css;
        }
      };
    };

    var deprecated = {
      keyLocation: true,
      layerX: true,
      layerY: true,
      returnValue: true,
      webkitMovementX: true,
      webkitMovementY: true,
      keyIdentifier: true,
      mozPressure: true
    };
    var isNativeEvent = function (event) {
      return event instanceof Event || isFunction(event.initEvent);
    };
    var hasIsDefaultPrevented = function (event) {
      return event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    };
    var needsNormalizing = function (event) {
      return isNullable(event.preventDefault) || isNativeEvent(event);
    };
    var clone$2 = function (originalEvent, data) {
      var event = data !== null && data !== void 0 ? data : {};
      for (var name_1 in originalEvent) {
        if (!has$2(deprecated, name_1)) {
          event[name_1] = originalEvent[name_1];
        }
      }
      if (isNonNullable(event.composedPath)) {
        event.composedPath = function () {
          return originalEvent.composedPath();
        };
      }
      return event;
    };
    var normalize$3 = function (type, originalEvent, fallbackTarget, data) {
      var _a;
      var event = clone$2(originalEvent, data);
      event.type = type;
      if (isNullable(event.target)) {
        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
      }
      if (needsNormalizing(originalEvent)) {
        event.preventDefault = function () {
          event.defaultPrevented = true;
          event.isDefaultPrevented = always;
          if (isFunction(originalEvent.preventDefault)) {
            originalEvent.preventDefault();
          } else if (isNativeEvent(originalEvent)) {
            originalEvent.returnValue = false;
          }
        };
        event.stopPropagation = function () {
          event.cancelBubble = true;
          event.isPropagationStopped = always;
          if (isFunction(originalEvent.stopPropagation)) {
            originalEvent.stopPropagation();
          } else if (isNativeEvent(originalEvent)) {
            originalEvent.cancelBubble = true;
          }
        };
        event.stopImmediatePropagation = function () {
          event.isImmediatePropagationStopped = always;
          event.stopPropagation();
        };
        if (!hasIsDefaultPrevented(event)) {
          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
          event.isPropagationStopped = event.cancelBubble === true ? always : never;
          event.isImmediatePropagationStopped = never;
        }
      }
      return event;
    };

    var eventExpandoPrefix = 'mce-data-';
    var mouseEventRe = /^(?:mouse|contextmenu)|click/;
    var addEvent = function (target, name, callback, capture) {
      if (target.addEventListener) {
        target.addEventListener(name, callback, capture || false);
      } else if (target.attachEvent) {
        target.attachEvent('on' + name, callback);
      }
    };
    var removeEvent = function (target, name, callback, capture) {
      if (target.removeEventListener) {
        target.removeEventListener(name, callback, capture || false);
      } else if (target.detachEvent) {
        target.detachEvent('on' + name, callback);
      }
    };
    var isMouseEvent = function (event) {
      return isNonNullable(event) && mouseEventRe.test(event.type);
    };
    var fix = function (originalEvent, data) {
      var event = normalize$3(originalEvent.type, originalEvent, document, data);
      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
        var eventDoc = event.target.ownerDocument || document;
        var doc = eventDoc.documentElement;
        var body = eventDoc.body;
        var mouseEvent = event;
        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      if (isUndefined(event.metaKey)) {
        event.metaKey = false;
      }
      return event;
    };
    var bindOnReady = function (win, callback, eventUtils) {
      var doc = win.document, event = { type: 'ready' };
      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }
      var isDocReady = function () {
        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;
      };
      var readyHandler = function () {
        removeEvent(win, 'DOMContentLoaded', readyHandler);
        removeEvent(win, 'load', readyHandler);
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
        win = null;
      };
      if (isDocReady()) {
        readyHandler();
      } else {
        addEvent(win, 'DOMContentLoaded', readyHandler);
      }
      if (!eventUtils.domLoaded) {
        addEvent(win, 'load', readyHandler);
      }
    };
    var EventUtils = function () {
      function EventUtils() {
        this.domLoaded = false;
        this.events = {};
        this.count = 1;
        this.expando = eventExpandoPrefix + (+new Date()).toString(32);
        this.hasMouseEnterLeave = 'onmouseenter' in document.documentElement;
        this.hasFocusIn = 'onfocusin' in document.documentElement;
        this.count = 1;
      }
      EventUtils.prototype.bind = function (target, names, callback, scope) {
        var self = this;
        var id, callbackList, i, name, fakeName, nativeHandler, capture;
        var win = window;
        var defaultNativeHandler = function (evt) {
          self.executeHandlers(fix(evt || win.event), id);
        };
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return;
        }
        if (!target[self.expando]) {
          id = self.count++;
          target[self.expando] = id;
          self.events[id] = {};
        } else {
          id = target[self.expando];
        }
        scope = scope || target;
        var namesList = names.split(' ');
        i = namesList.length;
        while (i--) {
          name = namesList[i];
          nativeHandler = defaultNativeHandler;
          fakeName = capture = false;
          if (name === 'DOMContentLoaded') {
            name = 'ready';
          }
          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
            callback.call(scope, fix({ type: name }));
            continue;
          }
          if (!self.hasMouseEnterLeave) {
            fakeName = self.mouseEnterLeave[name];
            if (fakeName) {
              nativeHandler = function (evt) {
                var current = evt.currentTarget;
                var related = evt.relatedTarget;
                if (related && current.contains) {
                  related = current.contains(related);
                } else {
                  while (related && related !== current) {
                    related = related.parentNode;
                  }
                }
                if (!related) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';
                  evt.target = current;
                  self.executeHandlers(evt, id);
                }
              };
            }
          }
          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
            capture = true;
            fakeName = name === 'focusin' ? 'focus' : 'blur';
            nativeHandler = function (evt) {
              evt = fix(evt || win.event);
              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';
              self.executeHandlers(evt, id);
            };
          }
          callbackList = self.events[id][name];
          if (!callbackList) {
            self.events[id][name] = callbackList = [{
                func: callback,
                scope: scope
              }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            callbackList.nativeHandler = nativeHandler;
            if (name === 'ready') {
              bindOnReady(target, nativeHandler, self);
            } else {
              addEvent(target, fakeName || name, nativeHandler, capture);
            }
          } else {
            if (name === 'ready' && self.domLoaded) {
              callback(fix({ type: name }));
            } else {
              callbackList.push({
                func: callback,
                scope: scope
              });
            }
          }
        }
        target = callbackList = null;
        return callback;
      };
      EventUtils.prototype.unbind = function (target, names, callback) {
        var callbackList, i, ci, name, eventMap;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        var id = target[this.expando];
        if (id) {
          eventMap = this.events[id];
          if (names) {
            var namesList = names.split(' ');
            i = namesList.length;
            while (i--) {
              name = namesList[i];
              callbackList = eventMap[name];
              if (callbackList) {
                if (callback) {
                  ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      var nativeHandler = callbackList.nativeHandler;
                      var fakeName = callbackList.fakeName, capture = callbackList.capture;
                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      callbackList.nativeHandler = nativeHandler;
                      callbackList.fakeName = fakeName;
                      callbackList.capture = capture;
                      eventMap[name] = callbackList;
                    }
                  }
                }
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name];
                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            each$j(eventMap, function (callbackList, name) {
              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
            });
            eventMap = {};
          }
          for (name in eventMap) {
            if (has$2(eventMap, name)) {
              return this;
            }
          }
          delete this.events[id];
          try {
            delete target[this.expando];
          } catch (ex) {
            target[this.expando] = null;
          }
        }
        return this;
      };
      EventUtils.prototype.fire = function (target, name, args) {
        var id;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        var event = fix({
          type: name,
          target: target
        }, args);
        do {
          id = target[this.expando];
          if (id) {
            this.executeHandlers(event, id);
          }
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !event.isPropagationStopped());
        return this;
      };
      EventUtils.prototype.clean = function (target) {
        var i, children;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        if (target[this.expando]) {
          this.unbind(target);
        }
        if (!target.getElementsByTagName) {
          target = target.document;
        }
        if (target && target.getElementsByTagName) {
          this.unbind(target);
          children = target.getElementsByTagName('*');
          i = children.length;
          while (i--) {
            target = children[i];
            if (target[this.expando]) {
              this.unbind(target);
            }
          }
        }
        return this;
      };
      EventUtils.prototype.destroy = function () {
        this.events = {};
      };
      EventUtils.prototype.cancel = function (e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        return false;
      };
      EventUtils.prototype.executeHandlers = function (evt, id) {
        var container = this.events[id];
        var callbackList = container && container[evt.type];
        if (callbackList) {
          for (var i = 0, l = callbackList.length; i < l; i++) {
            var callback = callbackList[i];
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      };
      EventUtils.Event = new EventUtils();
      return EventUtils;
    }();

    var support, Expr, getText, isXML, tokenize, compile, select$1, outermostContext, sortInput, hasDuplicate, setDocument, document$1, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push$1 = arr.push, slice$1 = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        ID: new RegExp('^#(' + identifier + ')'),
        CLASS: new RegExp('^\\.(' + identifier + ')'),
        TAG: new RegExp('^(' + identifier + '|[*])'),
        ATTR: new RegExp('^' + attributes),
        PSEUDO: new RegExp('^' + pseudos),
        CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        bool: new RegExp('^(?:' + booleans + ')$', 'i'),
        needsContext: new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr$1 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push$1.apply(arr = slice$1.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push$1 = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice$1.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    var Sizzle = function (selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document$1) {
        setDocument(context);
      }
      context = context || document$1;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr$1.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push$1.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push$1.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push$1.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select$1(selector.replace(rtrim, '$1'), context, results, seed);
    };
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key + ' '] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== strundefined && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      function getTop(win) {
        try {
          return win.top;
        } catch (ex) {
        }
        return null;
      }
      if (doc === document$1 || doc.nodeType !== 9 || !doc.documentElement) {
        return document$1;
      }
      document$1 = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent !== getTop(parent)) {
        if (parent.addEventListener) {
          parent.addEventListener('unload', function () {
            setDocument();
          }, false);
        } else if (parent.attachEvent) {
          parent.attachEvent('onunload', function () {
            setDocument();
          });
        }
      }
      support.attributes = true;
      support.getElementsByTagName = true;
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = true;
      Expr.find.ID = function (id, context) {
        if (typeof context.getElementById !== strundefined && documentIsHTML) {
          var m = context.getElementById(id);
          return m && m.parentNode ? [m] : [];
        }
      };
      Expr.filter.ID = function (id) {
        var attrId = id.replace(runescape, funescape);
        return function (elem) {
          return elem.getAttribute('id') === attrId;
        };
      };
      Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      support.disconnectedMatch = true;
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document$1) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document$1, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document$1) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document$1) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        while (node = elem[i++]) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        ATTR: function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        CHILD: function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        PSEUDO: function (match) {
          var excess, unquoted = !match[6] && match[2];
          if (matchExpr.CHILD.test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || '';
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        TAG: function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        CLASS: function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        ATTR: function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        CHILD: function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        PSEUDO: function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        not: markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        has: markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        contains: markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        lang: markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        target: function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        root: function (elem) {
          return elem === docElem;
        },
        focus: function (elem) {
          return elem === document$1.activeElement && (!document$1.hasFocus || document$1.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        enabled: function (elem) {
          return elem.disabled === false;
        },
        disabled: function (elem) {
          return elem.disabled === true;
        },
        checked: function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        selected: function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        empty: function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        parent: function (elem) {
          return !Expr.pseudos.empty(elem);
        },
        header: function (elem) {
          return rheader.test(elem.nodeName);
        },
        input: function (elem) {
          return rinputs.test(elem.nodeName);
        },
        button: function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        text: function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
        },
        first: createPositionalPseudo(function () {
          return [0];
        }),
        last: createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        eq: createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        even: createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        odd: createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        lt: createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        gt: createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos.nth = Expr.pseudos.eq;
    each$k([
      'radio',
      'checkbox',
      'file',
      'password',
      'image'
    ], function (i) {
      Expr.pseudos[i] = createInputPseudo(i);
    });
    each$k([
      'submit',
      'reset'
    ], function (i) {
      Expr.pseudos[i] = createButtonPseudo(i);
    });
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if (!Expr.filter.hasOwnProperty(type)) {
            continue;
          }
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var oldCache, outerCache, newCache = [
            dirruns,
            doneName
          ];
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                outerCache[dir] = newCache;
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push$1.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            outermostContext = context !== document$1 && context;
          }
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push$1.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, match) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select$1 = Sizzle.select = function (selector, context, results, seed) {
      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push$1.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = true;

    var doc = document;
    var push = Array.prototype.push;
    var slice = Array.prototype.slice;
    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
    var Event$1 = EventUtils.Event;
    var skipUniques = Tools.makeMap('children,contents,next,prev');
    var isDefined = function (obj) {
      return typeof obj !== 'undefined';
    };
    var isString = function (obj) {
      return typeof obj === 'string';
    };
    var isWindow = function (obj) {
      return obj && obj === obj.window;
    };
    var createFragment$1 = function (html, fragDoc) {
      fragDoc = fragDoc || doc;
      var container = fragDoc.createElement('div');
      var frag = fragDoc.createDocumentFragment();
      container.innerHTML = html;
      var node;
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    var domManipulate = function (targetNodes, sourceItem, callback, reverse) {
      var i;
      if (isString(sourceItem)) {
        sourceItem = createFragment$1(sourceItem, getElementDocument(targetNodes[0]));
      } else if (sourceItem.length && !sourceItem.nodeType) {
        sourceItem = DomQuery.makeArray(sourceItem);
        if (reverse) {
          for (i = sourceItem.length - 1; i >= 0; i--) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse);
          }
        } else {
          for (i = 0; i < sourceItem.length; i++) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse);
          }
        }
        return targetNodes;
      }
      if (sourceItem.nodeType) {
        i = targetNodes.length;
        while (i--) {
          callback.call(targetNodes[i], sourceItem);
        }
      }
      return targetNodes;
    };
    var hasClass = function (node, className) {
      return node && className && (' ' + node.className + ' ').indexOf(' ' + className + ' ') !== -1;
    };
    var wrap$2 = function (elements, wrapper, all) {
      var lastParent, newWrapper;
      wrapper = DomQuery(wrapper)[0];
      elements.each(function () {
        var self = this;
        if (!all || lastParent !== self.parentNode) {
          lastParent = self.parentNode;
          newWrapper = wrapper.cloneNode(false);
          self.parentNode.insertBefore(newWrapper, self);
          newWrapper.appendChild(self);
        } else {
          newWrapper.appendChild(self);
        }
      });
      return elements;
    };
    var numericCssMap = Tools.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' ');
    var booleanMap = Tools.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' ');
    var propFix = {
      for: 'htmlFor',
      class: 'className',
      readonly: 'readOnly'
    };
    var cssFix = { float: 'cssFloat' };
    var attrHooks = {}, cssHooks = {};
    var DomQueryConstructor = function (selector, context) {
      return new DomQuery.fn.init(selector, context);
    };
    var inArray$1 = function (item, array) {
      var i;
      if (array.indexOf) {
        return array.indexOf(item);
      }
      i = array.length;
      while (i--) {
        if (array[i] === item) {
          return i;
        }
      }
      return -1;
    };
    var whiteSpaceRegExp = /^\s*|\s*$/g;
    var trim$1 = function (str) {
      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp, '');
    };
    var each$g = function (obj, callback) {
      var length, key, i, value;
      if (obj) {
        length = obj.length;
        if (length === undefined) {
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              value = obj[key];
              if (callback.call(value, key, value) === false) {
                break;
              }
            }
          }
        } else {
          for (i = 0; i < length; i++) {
            value = obj[i];
            if (callback.call(value, i, value) === false) {
              break;
            }
          }
        }
      }
      return obj;
    };
    var grep$2 = function (array, callback) {
      var out = [];
      each$g(array, function (i, item) {
        if (callback(item, i)) {
          out.push(item);
        }
      });
      return out;
    };
    var getElementDocument = function (element) {
      if (!element) {
        return doc;
      }
      if (element.nodeType === 9) {
        return element;
      }
      return element.ownerDocument;
    };
    DomQueryConstructor.fn = DomQueryConstructor.prototype = {
      constructor: DomQueryConstructor,
      selector: '',
      context: null,
      length: 0,
      init: function (selector, context) {
        var self = this;
        var match, node;
        if (!selector) {
          return self;
        }
        if (selector.nodeType) {
          self.context = self[0] = selector;
          self.length = 1;
          return self;
        }
        if (context && context.nodeType) {
          self.context = context;
        } else {
          if (context) {
            return DomQuery(selector).attr(context);
          }
          self.context = context = document;
        }
        if (isString(selector)) {
          self.selector = selector;
          if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
            match = [
              null,
              selector,
              null
            ];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match) {
            if (match[1]) {
              node = createFragment$1(selector, getElementDocument(context)).firstChild;
              while (node) {
                push.call(self, node);
                node = node.nextSibling;
              }
            } else {
              node = getElementDocument(context).getElementById(match[2]);
              if (!node) {
                return self;
              }
              if (node.id !== match[2]) {
                return self.find(selector);
              }
              self.length = 1;
              self[0] = node;
            }
          } else {
            return DomQuery(context).find(selector);
          }
        } else {
          this.add(selector, false);
        }
        return self;
      },
      toArray: function () {
        return Tools.toArray(this);
      },
      add: function (items, sort) {
        var self = this;
        var nodes, i;
        if (isString(items)) {
          return self.add(DomQuery(items));
        }
        if (sort !== false) {
          nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));
          self.length = nodes.length;
          for (i = 0; i < nodes.length; i++) {
            self[i] = nodes[i];
          }
        } else {
          push.apply(self, DomQuery.makeArray(items));
        }
        return self;
      },
      attr: function (name, value) {
        var self = this;
        var hook;
        if (typeof name === 'object') {
          each$g(name, function (name, value) {
            self.attr(name, value);
          });
        } else if (isDefined(value)) {
          this.each(function () {
            var hook;
            if (this.nodeType === 1) {
              hook = attrHooks[name];
              if (hook && hook.set) {
                hook.set(this, value);
                return;
              }
              if (value === null) {
                this.removeAttribute(name, 2);
              } else {
                this.setAttribute(name, value, 2);
              }
            }
          });
        } else {
          if (self[0] && self[0].nodeType === 1) {
            hook = attrHooks[name];
            if (hook && hook.get) {
              return hook.get(self[0], name);
            }
            if (booleanMap[name]) {
              return self.prop(name) ? name : undefined;
            }
            value = self[0].getAttribute(name, 2);
            if (value === null) {
              value = undefined;
            }
          }
          return value;
        }
        return self;
      },
      removeAttr: function (name) {
        return this.attr(name, null);
      },
      prop: function (name, value) {
        var self = this;
        name = propFix[name] || name;
        if (typeof name === 'object') {
          each$g(name, function (name, value) {
            self.prop(name, value);
          });
        } else if (isDefined(value)) {
          this.each(function () {
            if (this.nodeType === 1) {
              this[name] = value;
            }
          });
        } else {
          if (self[0] && self[0].nodeType && name in self[0]) {
            return self[0][name];
          }
          return value;
        }
        return self;
      },
      css: function (name, value) {
        var self = this;
        var elm, hook;
        var camel = function (name) {
          return name.replace(/-(\D)/g, function (a, b) {
            return b.toUpperCase();
          });
        };
        var dashed = function (name) {
          return name.replace(/[A-Z]/g, function (a) {
            return '-' + a;
          });
        };
        if (typeof name === 'object') {
          each$g(name, function (name, value) {
            self.css(name, value);
          });
        } else {
          if (isDefined(value)) {
            name = camel(name);
            if (typeof value === 'number' && !numericCssMap[name]) {
              value = value.toString() + 'px';
            }
            self.each(function () {
              var style = this.style;
              hook = cssHooks[name];
              if (hook && hook.set) {
                hook.set(this, value);
                return;
              }
              try {
                this.style[cssFix[name] || name] = value;
              } catch (ex) {
              }
              if (value === null || value === '') {
                if (style.removeProperty) {
                  style.removeProperty(dashed(name));
                } else {
                  style.removeAttribute(name);
                }
              }
            });
          } else {
            elm = self[0];
            hook = cssHooks[name];
            if (hook && hook.get) {
              return hook.get(elm);
            }
            if (elm.ownerDocument.defaultView) {
              try {
                return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));
              } catch (ex) {
                return undefined;
              }
            } else if (elm.currentStyle) {
              return elm.currentStyle[camel(name)];
            } else {
              return '';
            }
          }
        }
        return self;
      },
      remove: function () {
        var self = this;
        var node, i = this.length;
        while (i--) {
          node = self[i];
          Event$1.clean(node);
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
        return this;
      },
      empty: function () {
        var self = this;
        var node, i = this.length;
        while (i--) {
          node = self[i];
          while (node.firstChild) {
            node.removeChild(node.firstChild);
          }
        }
        return this;
      },
      html: function (value) {
        var self = this;
        var i;
        if (isDefined(value)) {
          i = self.length;
          try {
            while (i--) {
              self[i].innerHTML = value;
            }
          } catch (ex) {
            DomQuery(self[i]).empty().append(value);
          }
          return self;
        }
        return self[0] ? self[0].innerHTML : '';
      },
      text: function (value) {
        var self = this;
        var i;
        if (isDefined(value)) {
          i = self.length;
          while (i--) {
            if ('innerText' in self[i]) {
              self[i].innerText = value;
            } else {
              self[0].textContent = value;
            }
          }
          return self;
        }
        return self[0] ? self[0].innerText || self[0].textContent : '';
      },
      append: function () {
        return domManipulate(this, arguments, function (node) {
          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
            this.appendChild(node);
          }
        });
      },
      prepend: function () {
        return domManipulate(this, arguments, function (node) {
          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
            this.insertBefore(node, this.firstChild);
          }
        }, true);
      },
      before: function () {
        var self = this;
        if (self[0] && self[0].parentNode) {
          return domManipulate(self, arguments, function (node) {
            this.parentNode.insertBefore(node, this);
          });
        }
        return self;
      },
      after: function () {
        var self = this;
        if (self[0] && self[0].parentNode) {
          return domManipulate(self, arguments, function (node) {
            this.parentNode.insertBefore(node, this.nextSibling);
          }, true);
        }
        return self;
      },
      appendTo: function (val) {
        DomQuery(val).append(this);
        return this;
      },
      prependTo: function (val) {
        DomQuery(val).prepend(this);
        return this;
      },
      replaceWith: function (content) {
        return this.before(content).remove();
      },
      wrap: function (content) {
        return wrap$2(this, content);
      },
      wrapAll: function (content) {
        return wrap$2(this, content, true);
      },
      wrapInner: function (content) {
        this.each(function () {
          DomQuery(this).contents().wrapAll(content);
        });
        return this;
      },
      unwrap: function () {
        return this.parent().each(function () {
          DomQuery(this).replaceWith(this.childNodes);
        });
      },
      clone: function () {
        var result = [];
        this.each(function () {
          result.push(this.cloneNode(true));
        });
        return DomQuery(result);
      },
      addClass: function (className) {
        return this.toggleClass(className, true);
      },
      removeClass: function (className) {
        return this.toggleClass(className, false);
      },
      toggleClass: function (className, state) {
        var self = this;
        if (typeof className !== 'string') {
          return self;
        }
        if (className.indexOf(' ') !== -1) {
          each$g(className.split(' '), function () {
            self.toggleClass(this, state);
          });
        } else {
          self.each(function (index, node) {
            var classState = hasClass(node, className);
            if (classState !== state) {
              var existingClassName = node.className;
              if (classState) {
                node.className = trim$1((' ' + existingClassName + ' ').replace(' ' + className + ' ', ' '));
              } else {
                node.className += existingClassName ? ' ' + className : className;
              }
            }
          });
        }
        return self;
      },
      hasClass: function (className) {
        return hasClass(this[0], className);
      },
      each: function (callback) {
        return each$g(this, callback);
      },
      on: function (name, callback) {
        return this.each(function () {
          Event$1.bind(this, name, callback);
        });
      },
      off: function (name, callback) {
        return this.each(function () {
          Event$1.unbind(this, name, callback);
        });
      },
      trigger: function (name) {
        return this.each(function () {
          if (typeof name === 'object') {
            Event$1.fire(this, name.type, name);
          } else {
            Event$1.fire(this, name);
          }
        });
      },
      show: function () {
        return this.css('display', '');
      },
      hide: function () {
        return this.css('display', 'none');
      },
      slice: function () {
        return DomQuery(slice.apply(this, arguments));
      },
      eq: function (index) {
        return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
      },
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      find: function (selector) {
        var i, l;
        var ret = [];
        for (i = 0, l = this.length; i < l; i++) {
          DomQuery.find(selector, this[i], ret);
        }
        return DomQuery(ret);
      },
      filter: function (selector) {
        if (typeof selector === 'function') {
          return DomQuery(grep$2(this.toArray(), function (item, i) {
            return selector(i, item);
          }));
        }
        return DomQuery(DomQuery.filter(selector, this.toArray()));
      },
      closest: function (selector) {
        var result = [];
        if (selector instanceof DomQuery) {
          selector = selector[0];
        }
        this.each(function (i, node) {
          while (node) {
            if (typeof selector === 'string' && DomQuery(node).is(selector)) {
              result.push(node);
              break;
            } else if (node === selector) {
              result.push(node);
              break;
            }
            node = node.parentNode;
          }
        });
        return DomQuery(result);
      },
      offset: function (offset) {
        var elm, doc, docElm;
        var x = 0, y = 0, pos;
        if (!offset) {
          elm = this[0];
          if (elm) {
            doc = elm.ownerDocument;
            docElm = doc.documentElement;
            if (elm.getBoundingClientRect) {
              pos = elm.getBoundingClientRect();
              x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
              y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
            }
          }
          return {
            left: x,
            top: y
          };
        }
        return this.css(offset);
      },
      push: push,
      sort: Array.prototype.sort,
      splice: Array.prototype.splice
    };
    Tools.extend(DomQueryConstructor, {
      extend: Tools.extend,
      makeArray: function (object) {
        if (isWindow(object) || object.nodeType) {
          return [object];
        }
        return Tools.toArray(object);
      },
      inArray: inArray$1,
      isArray: Tools.isArray,
      each: each$g,
      trim: trim$1,
      grep: grep$2,
      find: Sizzle,
      expr: Sizzle.selectors,
      unique: Sizzle.uniqueSort,
      text: Sizzle.getText,
      contains: Sizzle.contains,
      filter: function (expr, elems, not) {
        var i = elems.length;
        if (not) {
          expr = ':not(' + expr + ')';
        }
        while (i--) {
          if (elems[i].nodeType !== 1) {
            elems.splice(i, 1);
          }
        }
        if (elems.length === 1) {
          elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
        } else {
          elems = DomQuery.find.matches(expr, elems);
        }
        return elems;
      }
    });
    var dir = function (el, prop, until) {
      var matched = [];
      var cur = el[prop];
      if (typeof until !== 'string' && until instanceof DomQuery) {
        until = until[0];
      }
      while (cur && cur.nodeType !== 9) {
        if (until !== undefined) {
          if (cur === until) {
            break;
          }
          if (typeof until === 'string' && DomQuery(cur).is(until)) {
            break;
          }
        }
        if (cur.nodeType === 1) {
          matched.push(cur);
        }
        cur = cur[prop];
      }
      return matched;
    };
    var sibling$1 = function (node, siblingName, nodeType, until) {
      var result = [];
      if (until instanceof DomQuery) {
        until = until[0];
      }
      for (; node; node = node[siblingName]) {
        if (nodeType && node.nodeType !== nodeType) {
          continue;
        }
        if (until !== undefined) {
          if (node === until) {
            break;
          }
          if (typeof until === 'string' && DomQuery(node).is(until)) {
            break;
          }
        }
        result.push(node);
      }
      return result;
    };
    var firstSibling = function (node, siblingName, nodeType) {
      for (node = node[siblingName]; node; node = node[siblingName]) {
        if (node.nodeType === nodeType) {
          return node;
        }
      }
      return null;
    };
    each$g({
      parent: function (node) {
        var parent = node.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (node) {
        return dir(node, 'parentNode');
      },
      next: function (node) {
        return firstSibling(node, 'nextSibling', 1);
      },
      prev: function (node) {
        return firstSibling(node, 'previousSibling', 1);
      },
      children: function (node) {
        return sibling$1(node.firstChild, 'nextSibling', 1);
      },
      contents: function (node) {
        return Tools.toArray((node.nodeName === 'iframe' ? node.contentDocument || node.contentWindow.document : node).childNodes);
      }
    }, function (name, fn) {
      DomQueryConstructor.fn[name] = function (selector) {
        var self = this;
        var result = [];
        self.each(function () {
          var nodes = fn.call(result, this, selector, result);
          if (nodes) {
            if (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } else {
              result.push(nodes);
            }
          }
        });
        if (this.length > 1) {
          if (!skipUniques[name]) {
            result = DomQuery.unique(result);
          }
          if (name.indexOf('parents') === 0) {
            result = result.reverse();
          }
        }
        var wrappedResult = DomQuery(result);
        if (selector) {
          return wrappedResult.filter(selector);
        }
        return wrappedResult;
      };
    });
    each$g({
      parentsUntil: function (node, until) {
        return dir(node, 'parentNode', until);
      },
      nextUntil: function (node, until) {
        return sibling$1(node, 'nextSibling', 1, until).slice(1);
      },
      prevUntil: function (node, until) {
        return sibling$1(node, 'previousSibling', 1, until).slice(1);
      }
    }, function (name, fn) {
      DomQueryConstructor.fn[name] = function (selector, filter) {
        var self = this;
        var result = [];
        self.each(function () {
          var nodes = fn.call(result, this, selector, result);
          if (nodes) {
            if (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } else {
              result.push(nodes);
            }
          }
        });
        if (this.length > 1) {
          result = DomQuery.unique(result);
          if (name.indexOf('parents') === 0 || name === 'prevUntil') {
            result = result.reverse();
          }
        }
        var wrappedResult = DomQuery(result);
        if (filter) {
          return wrappedResult.filter(filter);
        }
        return wrappedResult;
      };
    });
    DomQueryConstructor.fn.is = function (selector) {
      return !!selector && this.filter(selector).length > 0;
    };
    DomQueryConstructor.fn.init.prototype = DomQueryConstructor.fn;
    DomQueryConstructor.overrideDefaults = function (callback) {
      var defaults;
      var sub = function (selector, context) {
        defaults = defaults || callback();
        if (arguments.length === 0) {
          selector = defaults.element;
        }
        if (!context) {
          context = defaults.context;
        }
        return new sub.fn.init(selector, context);
      };
      DomQuery.extend(sub, this);
      return sub;
    };
    DomQueryConstructor.attrHooks = attrHooks;
    DomQueryConstructor.cssHooks = cssHooks;
    var DomQuery = DomQueryConstructor;

    var each$f = Tools.each;
    var grep$1 = Tools.grep;
    var isIE = Env.ie;
    var simpleSelectorRe = /^([a-z0-9],?)+$/i;
    var setupAttrHooks = function (styles, settings, getContext) {
      var keepValues = settings.keep_values;
      var keepUrlHook = {
        set: function ($elm, value, name) {
          if (settings.url_converter && value !== null) {
            value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, $elm[0]);
          }
          $elm.attr('data-mce-' + name, value).attr(name, value);
        },
        get: function ($elm, name) {
          return $elm.attr('data-mce-' + name) || $elm.attr(name);
        }
      };
      var attrHooks = {
        style: {
          set: function ($elm, value) {
            if (value !== null && typeof value === 'object') {
              $elm.css(value);
              return;
            }
            if (keepValues) {
              $elm.attr('data-mce-style', value);
            }
            if (value !== null && typeof value === 'string') {
              $elm.removeAttr('style');
              $elm.css(styles.parse(value));
            } else {
              $elm.attr('style', value);
            }
          },
          get: function ($elm) {
            var value = $elm.attr('data-mce-style') || $elm.attr('style');
            value = styles.serialize(styles.parse(value), $elm[0].nodeName);
            return value;
          }
        }
      };
      if (keepValues) {
        attrHooks.href = attrHooks.src = keepUrlHook;
      }
      return attrHooks;
    };
    var updateInternalStyleAttr = function (styles, $elm) {
      var rawValue = $elm.attr('style');
      var value = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
      if (!value) {
        value = null;
      }
      $elm.attr('data-mce-style', value);
    };
    var findNodeIndex = function (node, normalized) {
      var idx = 0, lastNodeType, nodeType;
      if (node) {
        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
          nodeType = node.nodeType;
          if (normalized && nodeType === 3) {
            if (nodeType === lastNodeType || !node.nodeValue.length) {
              continue;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }
      return idx;
    };
    var DOMUtils = function (doc, settings) {
      if (settings === void 0) {
        settings = {};
      }
      var addedStyles = {};
      var win = window;
      var files = {};
      var counter = 0;
      var stdMode = true;
      var boxModel = true;
      var styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
        contentCssCors: settings.contentCssCors,
        referrerPolicy: settings.referrerPolicy
      });
      var boundEvents = [];
      var schema = settings.schema ? settings.schema : Schema({});
      var styles = Styles({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope
      }, settings.schema);
      var events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
      var blockElementsMap = schema.getBlockElements();
      var $ = DomQuery.overrideDefaults(function () {
        return {
          context: doc,
          element: self.getRoot()
        };
      });
      var isBlock = function (node) {
        if (typeof node === 'string') {
          return !!blockElementsMap[node];
        } else if (node) {
          var type = node.nodeType;
          if (type) {
            return !!(type === 1 && blockElementsMap[node.nodeName]);
          }
        }
        return false;
      };
      var get = function (elm) {
        return elm && doc && isString$1(elm) ? doc.getElementById(elm) : elm;
      };
      var $$ = function (elm) {
        return $(typeof elm === 'string' ? get(elm) : elm);
      };
      var getAttrib = function (elm, name, defaultVal) {
        var hook, value;
        var $elm = $$(elm);
        if ($elm.length) {
          hook = attrHooks[name];
          if (hook && hook.get) {
            value = hook.get($elm, name);
          } else {
            value = $elm.attr(name);
          }
        }
        if (typeof value === 'undefined') {
          value = defaultVal || '';
        }
        return value;
      };
      var getAttribs = function (elm) {
        var node = get(elm);
        if (!node) {
          return [];
        }
        return node.attributes;
      };
      var setAttrib = function (elm, name, value) {
        if (value === '') {
          value = null;
        }
        var $elm = $$(elm);
        var originalValue = $elm.attr(name);
        if (!$elm.length) {
          return;
        }
        var hook = attrHooks[name];
        if (hook && hook.set) {
          hook.set($elm, value, name);
        } else {
          $elm.attr(name, value);
        }
        if (originalValue !== value && settings.onSetAttrib) {
          settings.onSetAttrib({
            attrElm: $elm,
            attrName: name,
            attrValue: value
          });
        }
      };
      var clone = function (node, deep) {
        if (!isIE || node.nodeType !== 1 || deep) {
          return node.cloneNode(deep);
        } else {
          var clone_1 = doc.createElement(node.nodeName);
          each$f(getAttribs(node), function (attr) {
            setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));
          });
          return clone_1;
        }
      };
      var getRoot = function () {
        return settings.root_element || doc.body;
      };
      var getViewPort = function (argWin) {
        var vp = getBounds(argWin);
        return {
          x: vp.x,
          y: vp.y,
          w: vp.width,
          h: vp.height
        };
      };
      var getPos$1 = function (elm, rootElm) {
        return getPos(doc.body, get(elm), rootElm);
      };
      var setStyle = function (elm, name, value) {
        var $elm = isString$1(name) ? $$(elm).css(name, value) : $$(elm).css(name);
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      };
      var setStyles = function (elm, stylesArg) {
        var $elm = $$(elm).css(stylesArg);
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      };
      var getStyle = function (elm, name, computed) {
        var $elm = $$(elm);
        if (computed) {
          return $elm.css(name);
        }
        name = name.replace(/-(\D)/g, function (a, b) {
          return b.toUpperCase();
        });
        if (name === 'float') {
          name = Env.browser.isIE() ? 'styleFloat' : 'cssFloat';
        }
        return $elm[0] && $elm[0].style ? $elm[0].style[name] : undefined;
      };
      var getSize = function (elm) {
        var w, h;
        elm = get(elm);
        w = getStyle(elm, 'width');
        h = getStyle(elm, 'height');
        if (w.indexOf('px') === -1) {
          w = 0;
        }
        if (h.indexOf('px') === -1) {
          h = 0;
        }
        return {
          w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
          h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
        };
      };
      var getRect = function (elm) {
        elm = get(elm);
        var pos = getPos$1(elm);
        var size = getSize(elm);
        return {
          x: pos.x,
          y: pos.y,
          w: size.w,
          h: size.h
        };
      };
      var is = function (elm, selector) {
        var i;
        if (!elm) {
          return false;
        }
        if (!Array.isArray(elm)) {
          if (selector === '*') {
            return elm.nodeType === 1;
          }
          if (simpleSelectorRe.test(selector)) {
            var selectors = selector.toLowerCase().split(/,/);
            var elmName = elm.nodeName.toLowerCase();
            for (i = selectors.length - 1; i >= 0; i--) {
              if (selectors[i] === elmName) {
                return true;
              }
            }
            return false;
          }
          if (elm.nodeType && elm.nodeType !== 1) {
            return false;
          }
        }
        var elms = !Array.isArray(elm) ? [elm] : elm;
        return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
      };
      var getParents = function (elm, selector, root, collect) {
        var result = [];
        var selectorVal;
        var node = get(elm);
        collect = collect === undefined;
        root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
        if (Tools.is(selector, 'string')) {
          selectorVal = selector;
          if (selector === '*') {
            selector = function (node) {
              return node.nodeType === 1;
            };
          } else {
            selector = function (node) {
              return is(node, selectorVal);
            };
          }
        }
        while (node) {
          if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
            break;
          }
          if (!selector || typeof selector === 'function' && selector(node)) {
            if (collect) {
              result.push(node);
            } else {
              return [node];
            }
          }
          node = node.parentNode;
        }
        return collect ? result : null;
      };
      var getParent = function (node, selector, root) {
        var parents = getParents(node, selector, root, false);
        return parents && parents.length > 0 ? parents[0] : null;
      };
      var _findSib = function (node, selector, name) {
        var func = selector;
        if (node) {
          if (typeof selector === 'string') {
            func = function (node) {
              return is(node, selector);
            };
          }
          for (node = node[name]; node; node = node[name]) {
            if (typeof func === 'function' && func(node)) {
              return node;
            }
          }
        }
        return null;
      };
      var getNext = function (node, selector) {
        return _findSib(node, selector, 'nextSibling');
      };
      var getPrev = function (node, selector) {
        return _findSib(node, selector, 'previousSibling');
      };
      var select = function (selector, scope) {
        return Sizzle(selector, get(scope) || settings.root_element || doc, []);
      };
      var run = function (elm, func, scope) {
        var result;
        var node = typeof elm === 'string' ? get(elm) : elm;
        if (!node) {
          return false;
        }
        if (Tools.isArray(node) && (node.length || node.length === 0)) {
          result = [];
          each$f(node, function (elm, i) {
            if (elm) {
              result.push(func.call(scope, typeof elm === 'string' ? get(elm) : elm, i));
            }
          });
          return result;
        }
        var context = scope ? scope : this;
        return func.call(context, node);
      };
      var setAttribs = function (elm, attrs) {
        $$(elm).each(function (i, node) {
          each$f(attrs, function (value, name) {
            setAttrib(node, name, value);
          });
        });
      };
      var setHTML = function (elm, html) {
        var $elm = $$(elm);
        if (isIE) {
          $elm.each(function (i, target) {
            if (target.canHaveHTML === false) {
              return;
            }
            while (target.firstChild) {
              target.removeChild(target.firstChild);
            }
            try {
              target.innerHTML = '<br>' + html;
              target.removeChild(target.firstChild);
            } catch (ex) {
              DomQuery('<div></div>').html('<br>' + html).contents().slice(1).appendTo(target);
            }
            return html;
          });
        } else {
          $elm.html(html);
        }
      };
      var add = function (parentElm, name, attrs, html, create) {
        return run(parentElm, function (parentElm) {
          var newElm = typeof name === 'string' ? doc.createElement(name) : name;
          setAttribs(newElm, attrs);
          if (html) {
            if (typeof html !== 'string' && html.nodeType) {
              newElm.appendChild(html);
            } else if (typeof html === 'string') {
              setHTML(newElm, html);
            }
          }
          return !create ? parentElm.appendChild(newElm) : newElm;
        });
      };
      var create = function (name, attrs, html) {
        return add(doc.createElement(name), name, attrs, html, true);
      };
      var decode = Entities.decode;
      var encode = Entities.encodeAllRaw;
      var createHTML = function (name, attrs, html) {
        var outHtml = '', key;
        outHtml += '<' + name;
        for (key in attrs) {
          if (hasNonNullableKey(attrs, key)) {
            outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
          }
        }
        if (typeof html !== 'undefined') {
          return outHtml + '>' + html + '</' + name + '>';
        }
        return outHtml + ' />';
      };
      var createFragment = function (html) {
        var node;
        var container = doc.createElement('div');
        var frag = doc.createDocumentFragment();
        frag.appendChild(container);
        if (html) {
          container.innerHTML = html;
        }
        while (node = container.firstChild) {
          frag.appendChild(node);
        }
        frag.removeChild(container);
        return frag;
      };
      var remove = function (node, keepChildren) {
        var $node = $$(node);
        if (keepChildren) {
          $node.each(function () {
            var child;
            while (child = this.firstChild) {
              if (child.nodeType === 3 && child.data.length === 0) {
                this.removeChild(child);
              } else {
                this.parentNode.insertBefore(child, this);
              }
            }
          }).remove();
        } else {
          $node.remove();
        }
        return $node.length > 1 ? $node.toArray() : $node[0];
      };
      var removeAllAttribs = function (e) {
        return run(e, function (e) {
          var i;
          var attrs = e.attributes;
          for (i = attrs.length - 1; i >= 0; i--) {
            e.removeAttributeNode(attrs.item(i));
          }
        });
      };
      var parseStyle = function (cssText) {
        return styles.parse(cssText);
      };
      var serializeStyle = function (stylesArg, name) {
        return styles.serialize(stylesArg, name);
      };
      var addStyle = function (cssText) {
        var head, styleElm;
        if (self !== DOMUtils.DOM && doc === document) {
          if (addedStyles[cssText]) {
            return;
          }
          addedStyles[cssText] = true;
        }
        styleElm = doc.getElementById('mceDefaultStyles');
        if (!styleElm) {
          styleElm = doc.createElement('style');
          styleElm.id = 'mceDefaultStyles';
          styleElm.type = 'text/css';
          head = doc.getElementsByTagName('head')[0];
          if (head.firstChild) {
            head.insertBefore(styleElm, head.firstChild);
          } else {
            head.appendChild(styleElm);
          }
        }
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      };
      var loadCSS = function (urls) {
        if (!urls) {
          urls = '';
        }
        each$k(urls.split(','), function (url) {
          files[url] = true;
          styleSheetLoader.load(url, noop);
        });
      };
      var toggleClass = function (elm, cls, state) {
        $$(elm).toggleClass(cls, state).each(function () {
          if (this.className === '') {
            DomQuery(this).attr('class', null);
          }
        });
      };
      var addClass = function (elm, cls) {
        $$(elm).addClass(cls);
      };
      var removeClass = function (elm, cls) {
        toggleClass(elm, cls, false);
      };
      var hasClass = function (elm, cls) {
        return $$(elm).hasClass(cls);
      };
      var show = function (elm) {
        $$(elm).show();
      };
      var hide = function (elm) {
        $$(elm).hide();
      };
      var isHidden = function (elm) {
        return $$(elm).css('display') === 'none';
      };
      var uniqueId = function (prefix) {
        return (!prefix ? 'mce_' : prefix) + counter++;
      };
      var getOuterHTML = function (elm) {
        var node = typeof elm === 'string' ? get(elm) : elm;
        return isElement$5(node) ? node.outerHTML : DomQuery('<div></div>').append(DomQuery(node).clone()).html();
      };
      var setOuterHTML = function (elm, html) {
        $$(elm).each(function () {
          try {
            if ('outerHTML' in this) {
              this.outerHTML = html;
              return;
            }
          } catch (ex) {
          }
          remove(DomQuery(this).html(html), true);
        });
      };
      var insertAfter = function (node, reference) {
        var referenceNode = get(reference);
        return run(node, function (node) {
          var parent = referenceNode.parentNode;
          var nextSibling = referenceNode.nextSibling;
          if (nextSibling) {
            parent.insertBefore(node, nextSibling);
          } else {
            parent.appendChild(node);
          }
          return node;
        });
      };
      var replace = function (newElm, oldElm, keepChildren) {
        return run(oldElm, function (oldElm) {
          if (Tools.is(oldElm, 'array')) {
            newElm = newElm.cloneNode(true);
          }
          if (keepChildren) {
            each$f(grep$1(oldElm.childNodes), function (node) {
              newElm.appendChild(node);
            });
          }
          return oldElm.parentNode.replaceChild(newElm, oldElm);
        });
      };
      var rename = function (elm, name) {
        var newElm;
        if (elm.nodeName !== name.toUpperCase()) {
          newElm = create(name);
          each$f(getAttribs(elm), function (attrNode) {
            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
          });
          replace(newElm, elm, true);
        }
        return newElm || elm;
      };
      var findCommonAncestor = function (a, b) {
        var ps = a, pe;
        while (ps) {
          pe = b;
          while (pe && ps !== pe) {
            pe = pe.parentNode;
          }
          if (ps === pe) {
            break;
          }
          ps = ps.parentNode;
        }
        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        }
        return ps;
      };
      var toHex = function (rgbVal) {
        return styles.toHex(Tools.trim(rgbVal));
      };
      var isNonEmptyElement = function (node) {
        if (isElement$5(node)) {
          var isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');
          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {
            return true;
          }
        }
        return false;
      };
      var isEmpty = function (node, elements) {
        var type, name, brCount = 0;
        if (isNonEmptyElement(node)) {
          return false;
        }
        node = node.firstChild;
        if (node) {
          var walker = new DomTreeWalker(node, node.parentNode);
          var whitespace = schema ? schema.getWhiteSpaceElements() : {};
          elements = elements || (schema ? schema.getNonEmptyElements() : null);
          do {
            type = node.nodeType;
            if (isElement$5(node)) {
              var bogusVal = node.getAttribute('data-mce-bogus');
              if (bogusVal) {
                node = walker.next(bogusVal === 'all');
                continue;
              }
              name = node.nodeName.toLowerCase();
              if (elements && elements[name]) {
                if (name === 'br') {
                  brCount++;
                  node = walker.next();
                  continue;
                }
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (type === 8) {
              return false;
            }
            if (type === 3 && !isWhitespaceText(node.nodeValue)) {
              return false;
            }
            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {
              return false;
            }
            node = walker.next();
          } while (node);
        }
        return brCount <= 1;
      };
      var createRng = function () {
        return doc.createRange();
      };
      var split = function (parentElm, splitElm, replacementElm) {
        var range = createRng();
        var beforeFragment;
        var afterFragment;
        var parentNode;
        if (parentElm && splitElm) {
          range.setStart(parentElm.parentNode, findNodeIndex(parentElm));
          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
          beforeFragment = range.extractContents();
          range = createRng();
          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
          range.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
          afterFragment = range.extractContents();
          parentNode = parentElm.parentNode;
          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);
          if (replacementElm) {
            parentNode.insertBefore(replacementElm, parentElm);
          } else {
            parentNode.insertBefore(splitElm, parentElm);
          }
          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);
          remove(parentElm);
          return replacementElm || splitElm;
        }
      };
      var bind = function (target, name, func, scope) {
        if (Tools.isArray(target)) {
          var i = target.length;
          var rv = [];
          while (i--) {
            rv[i] = bind(target[i], name, func, scope);
          }
          return rv;
        }
        if (settings.collect && (target === doc || target === win)) {
          boundEvents.push([
            target,
            name,
            func,
            scope
          ]);
        }
        var output = events.bind(target, name, func, scope || self);
        return output;
      };
      var unbind = function (target, name, func) {
        if (Tools.isArray(target)) {
          var i = target.length;
          var rv = [];
          while (i--) {
            rv[i] = unbind(target[i], name, func);
          }
          return rv;
        } else {
          if (boundEvents.length > 0 && (target === doc || target === win)) {
            var i = boundEvents.length;
            while (i--) {
              var item = boundEvents[i];
              if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {
                events.unbind(item[0], item[1], item[2]);
              }
            }
          }
          return events.unbind(target, name, func);
        }
      };
      var fire = function (target, name, evt) {
        return events.fire(target, name, evt);
      };
      var getContentEditable = function (node) {
        if (node && isElement$5(node)) {
          var contentEditable = node.getAttribute('data-mce-contenteditable');
          if (contentEditable && contentEditable !== 'inherit') {
            return contentEditable;
          }
          return node.contentEditable !== 'inherit' ? node.contentEditable : null;
        } else {
          return null;
        }
      };
      var getContentEditableParent = function (node) {
        var root = getRoot();
        var state = null;
        for (; node && node !== root; node = node.parentNode) {
          state = getContentEditable(node);
          if (state !== null) {
            break;
          }
        }
        return state;
      };
      var destroy = function () {
        if (boundEvents.length > 0) {
          var i = boundEvents.length;
          while (i--) {
            var item = boundEvents[i];
            events.unbind(item[0], item[1], item[2]);
          }
        }
        each$j(files, function (_, url) {
          styleSheetLoader.unload(url);
          delete files[url];
        });
        if (Sizzle.setDocument) {
          Sizzle.setDocument();
        }
      };
      var isChildOf = function (node, parent) {
        if (!isIE) {
          return node === parent || parent.contains(node);
        } else {
          while (node) {
            if (parent === node) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }
      };
      var dumpRng = function (r) {
        return 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
      };
      var self = {
        doc: doc,
        settings: settings,
        win: win,
        files: files,
        stdMode: stdMode,
        boxModel: boxModel,
        styleSheetLoader: styleSheetLoader,
        boundEvents: boundEvents,
        styles: styles,
        schema: schema,
        events: events,
        isBlock: isBlock,
        $: $,
        $$: $$,
        root: null,
        clone: clone,
        getRoot: getRoot,
        getViewPort: getViewPort,
        getRect: getRect,
        getSize: getSize,
        getParent: getParent,
        getParents: getParents,
        get: get,
        getNext: getNext,
        getPrev: getPrev,
        select: select,
        is: is,
        add: add,
        create: create,
        createHTML: createHTML,
        createFragment: createFragment,
        remove: remove,
        setStyle: setStyle,
        getStyle: getStyle,
        setStyles: setStyles,
        removeAllAttribs: removeAllAttribs,
        setAttrib: setAttrib,
        setAttribs: setAttribs,
        getAttrib: getAttrib,
        getPos: getPos$1,
        parseStyle: parseStyle,
        serializeStyle: serializeStyle,
        addStyle: addStyle,
        loadCSS: loadCSS,
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        show: show,
        hide: hide,
        isHidden: isHidden,
        uniqueId: uniqueId,
        setHTML: setHTML,
        getOuterHTML: getOuterHTML,
        setOuterHTML: setOuterHTML,
        decode: decode,
        encode: encode,
        insertAfter: insertAfter,
        replace: replace,
        rename: rename,
        findCommonAncestor: findCommonAncestor,
        toHex: toHex,
        run: run,
        getAttribs: getAttribs,
        isEmpty: isEmpty,
        createRng: createRng,
        nodeIndex: findNodeIndex,
        split: split,
        bind: bind,
        unbind: unbind,
        fire: fire,
        getContentEditable: getContentEditable,
        getContentEditableParent: getContentEditableParent,
        destroy: destroy,
        isChildOf: isChildOf,
        dumpRng: dumpRng
      };
      var attrHooks = setupAttrHooks(styles, settings, constant(self));
      return self;
    };
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;

    var DOM$a = DOMUtils.DOM;
    var each$e = Tools.each, grep = Tools.grep;
    var QUEUED = 0;
    var LOADING = 1;
    var LOADED = 2;
    var FAILED = 3;
    var ScriptLoader = function () {
      function ScriptLoader(settings) {
        if (settings === void 0) {
          settings = {};
        }
        this.states = {};
        this.queue = [];
        this.scriptLoadedCallbacks = {};
        this.queueLoadedCallbacks = [];
        this.loading = 0;
        this.settings = settings;
      }
      ScriptLoader.prototype._setReferrerPolicy = function (referrerPolicy) {
        this.settings.referrerPolicy = referrerPolicy;
      };
      ScriptLoader.prototype.loadScript = function (url, success, failure) {
        var dom = DOM$a;
        var elm;
        var cleanup = function () {
          dom.remove(id);
          if (elm) {
            elm.onerror = elm.onload = elm = null;
          }
        };
        var done = function () {
          cleanup();
          success();
        };
        var error = function () {
          cleanup();
          if (isFunction(failure)) {
            failure();
          } else {
            if (typeof console !== 'undefined' && console.log) {
              console.log('Failed to load script: ' + url);
            }
          }
        };
        var id = dom.uniqueId();
        elm = document.createElement('script');
        elm.id = id;
        elm.type = 'text/javascript';
        elm.src = Tools._addCacheSuffix(url);
        if (this.settings.referrerPolicy) {
          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
        }
        elm.onload = done;
        elm.onerror = error;
        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
      };
      ScriptLoader.prototype.isDone = function (url) {
        return this.states[url] === LOADED;
      };
      ScriptLoader.prototype.markDone = function (url) {
        this.states[url] = LOADED;
      };
      ScriptLoader.prototype.add = function (url, success, scope, failure) {
        var state = this.states[url];
        this.queue.push(url);
        if (state === undefined) {
          this.states[url] = QUEUED;
        }
        if (success) {
          if (!this.scriptLoadedCallbacks[url]) {
            this.scriptLoadedCallbacks[url] = [];
          }
          this.scriptLoadedCallbacks[url].push({
            success: success,
            failure: failure,
            scope: scope || this
          });
        }
      };
      ScriptLoader.prototype.load = function (url, success, scope, failure) {
        return this.add(url, success, scope, failure);
      };
      ScriptLoader.prototype.remove = function (url) {
        delete this.states[url];
        delete this.scriptLoadedCallbacks[url];
      };
      ScriptLoader.prototype.loadQueue = function (success, scope, failure) {
        this.loadScripts(this.queue, success, scope, failure);
      };
      ScriptLoader.prototype.loadScripts = function (scripts, success, scope, failure) {
        var self = this;
        var failures = [];
        var execCallbacks = function (name, url) {
          each$e(self.scriptLoadedCallbacks[url], function (callback) {
            if (isFunction(callback[name])) {
              callback[name].call(callback.scope);
            }
          });
          self.scriptLoadedCallbacks[url] = undefined;
        };
        self.queueLoadedCallbacks.push({
          success: success,
          failure: failure,
          scope: scope || this
        });
        var loadScripts = function () {
          var loadingScripts = grep(scripts);
          scripts.length = 0;
          each$e(loadingScripts, function (url) {
            if (self.states[url] === LOADED) {
              execCallbacks('success', url);
              return;
            }
            if (self.states[url] === FAILED) {
              execCallbacks('failure', url);
              return;
            }
            if (self.states[url] !== LOADING) {
              self.states[url] = LOADING;
              self.loading++;
              self.loadScript(url, function () {
                self.states[url] = LOADED;
                self.loading--;
                execCallbacks('success', url);
                loadScripts();
              }, function () {
                self.states[url] = FAILED;
                self.loading--;
                failures.push(url);
                execCallbacks('failure', url);
                loadScripts();
              });
            }
          });
          if (!self.loading) {
            var notifyCallbacks = self.queueLoadedCallbacks.slice(0);
            self.queueLoadedCallbacks.length = 0;
            each$e(notifyCallbacks, function (callback) {
              if (failures.length === 0) {
                if (isFunction(callback.success)) {
                  callback.success.call(callback.scope);
                }
              } else {
                if (isFunction(callback.failure)) {
                  callback.failure.call(callback.scope, failures);
                }
              }
            });
          }
        };
        loadScripts();
      };
      ScriptLoader.ScriptLoader = new ScriptLoader();
      return ScriptLoader;
    }();

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var isRaw = function (str) {
      return isObject(str) && has$2(str, 'raw');
    };
    var isTokenised = function (str) {
      return isArray$1(str) && str.length > 1;
    };
    var data = {};
    var currentCode = Cell('en');
    var getLanguageData = function () {
      return get$9(data, currentCode.get());
    };
    var getData = function () {
      return map$2(data, function (value) {
        return __assign({}, value);
      });
    };
    var setCode = function (newCode) {
      if (newCode) {
        currentCode.set(newCode);
      }
    };
    var getCode = function () {
      return currentCode.get();
    };
    var add$4 = function (code, items) {
      var langData = data[code];
      if (!langData) {
        data[code] = langData = {};
      }
      each$j(items, function (translation, name) {
        langData[name.toLowerCase()] = translation;
      });
    };
    var translate = function (text) {
      var langData = getLanguageData().getOr({});
      var toString = function (obj) {
        if (isFunction(obj)) {
          return Object.prototype.toString.call(obj);
        }
        return !isEmpty(obj) ? '' + obj : '';
      };
      var isEmpty = function (text) {
        return text === '' || text === null || text === undefined;
      };
      var getLangData = function (text) {
        var textstr = toString(text);
        return get$9(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
      };
      var removeContext = function (str) {
        return str.replace(/{context:\w+}$/, '');
      };
      if (isEmpty(text)) {
        return '';
      }
      if (isRaw(text)) {
        return toString(text.raw);
      }
      if (isTokenised(text)) {
        var values_1 = text.slice(1);
        var substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function ($1, $2) {
          return has$2(values_1, $2) ? toString(values_1[$2]) : $1;
        });
        return removeContext(substitued);
      }
      return removeContext(getLangData(text));
    };
    var isRtl$1 = function () {
      return getLanguageData().bind(function (items) {
        return get$9(items, '_dir');
      }).exists(function (dir) {
        return dir === 'rtl';
      });
    };
    var hasCode = function (code) {
      return has$2(data, code);
    };
    var I18n = {
      getData: getData,
      setCode: setCode,
      getCode: getCode,
      add: add$4,
      translate: translate,
      isRtl: isRtl$1,
      hasCode: hasCode
    };

    var AddOnManager = function () {
      var items = [];
      var urls = {};
      var lookup = {};
      var _listeners = [];
      var runListeners = function (name, state) {
        var matchedListeners = filter$4(_listeners, function (listener) {
          return listener.name === name && listener.state === state;
        });
        each$k(matchedListeners, function (listener) {
          return listener.callback();
        });
      };
      var get = function (name) {
        if (lookup[name]) {
          return lookup[name].instance;
        }
        return undefined;
      };
      var dependencies = function (name) {
        var result;
        if (lookup[name]) {
          result = lookup[name].dependencies;
        }
        return result || [];
      };
      var requireLangPack = function (name, languages) {
        if (AddOnManager.languageLoad !== false) {
          waitFor(name, function () {
            var language = I18n.getCode();
            var wrappedLanguages = ',' + (languages || '') + ',';
            if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
              return;
            }
            ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
          }, 'loaded');
        }
      };
      var add = function (id, addOn, dependencies) {
        var addOnConstructor = addOn;
        items.push(addOnConstructor);
        lookup[id] = {
          instance: addOnConstructor,
          dependencies: dependencies
        };
        runListeners(id, 'added');
        return addOnConstructor;
      };
      var remove = function (name) {
        delete urls[name];
        delete lookup[name];
      };
      var createUrl = function (baseUrl, dep) {
        if (typeof dep === 'object') {
          return dep;
        }
        return typeof baseUrl === 'string' ? {
          prefix: '',
          resource: dep,
          suffix: ''
        } : {
          prefix: baseUrl.prefix,
          resource: dep,
          suffix: baseUrl.suffix
        };
      };
      var addComponents = function (pluginName, scripts) {
        var pluginUrl = urls[pluginName];
        each$k(scripts, function (script) {
          ScriptLoader.ScriptLoader.add(pluginUrl + '/' + script);
        });
      };
      var loadDependencies = function (name, addOnUrl, success, scope) {
        var deps = dependencies(name);
        each$k(deps, function (dep) {
          var newUrl = createUrl(addOnUrl, dep);
          load(newUrl.resource, newUrl, undefined, undefined);
        });
        if (success) {
          if (scope) {
            success.call(scope);
          } else {
            success.call(ScriptLoader);
          }
        }
      };
      var load = function (name, addOnUrl, success, scope, failure) {
        if (urls[name]) {
          return;
        }
        var urlString = typeof addOnUrl === 'string' ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
          urlString = AddOnManager.baseURL + '/' + urlString;
        }
        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
        var done = function () {
          runListeners(name, 'loaded');
          loadDependencies(name, addOnUrl, success, scope);
        };
        if (lookup[name]) {
          done();
        } else {
          ScriptLoader.ScriptLoader.add(urlString, done, scope, failure);
        }
      };
      var waitFor = function (name, callback, state) {
        if (state === void 0) {
          state = 'added';
        }
        if (has$2(lookup, name) && state === 'added') {
          callback();
        } else if (has$2(urls, name) && state === 'loaded') {
          callback();
        } else {
          _listeners.push({
            name: name,
            state: state,
            callback: callback
          });
        }
      };
      return {
        items: items,
        urls: urls,
        lookup: lookup,
        _listeners: _listeners,
        get: get,
        dependencies: dependencies,
        requireLangPack: requireLangPack,
        add: add,
        remove: remove,
        createUrl: createUrl,
        addComponents: addComponents,
        load: load,
        waitFor: waitFor
      };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = '';
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var first = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (isNull(timer)) {
          timer = setTimeout(function () {
            timer = null;
            fn.apply(null, args);
          }, rate);
        }
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };
    var last = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        cancel();
        timer = setTimeout(function () {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var read$4 = function (element, attr) {
      var value = get$6(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    var add$3 = function (element, attr, id) {
      var old = read$4(element, attr);
      var nu = old.concat([id]);
      set$1(element, attr, nu.join(' '));
      return true;
    };
    var remove$5 = function (element, attr, id) {
      var nu = filter$4(read$4(element, attr), function (v) {
        return v !== id;
      });
      if (nu.length > 0) {
        set$1(element, attr, nu.join(' '));
      } else {
        remove$6(element, attr);
      }
      return false;
    };

    var supports = function (element) {
      return element.dom.classList !== undefined;
    };
    var get$4 = function (element) {
      return read$4(element, 'class');
    };
    var add$2 = function (element, clazz) {
      return add$3(element, 'class', clazz);
    };
    var remove$4 = function (element, clazz) {
      return remove$5(element, 'class', clazz);
    };

    var add$1 = function (element, clazz) {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$2(element, clazz);
      }
    };
    var cleanClass = function (element) {
      var classList = supports(element) ? element.dom.classList : get$4(element);
      if (classList.length === 0) {
        remove$6(element, 'class');
      }
    };
    var remove$3 = function (element, clazz) {
      if (supports(element)) {
        var classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$4(element, clazz);
      }
      cleanClass(element);
    };
    var has = function (element, clazz) {
      return supports(element) && element.dom.classList.contains(clazz);
    };

    var descendants$1 = function (scope, predicate) {
      var result = [];
      each$k(children(scope), function (x) {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants$1(x, predicate));
      });
      return result;
    };

    var descendants = function (scope, selector) {
      return all(selector, scope);
    };

    var annotation = constant('mce-annotation');
    var dataAnnotation = constant('data-mce-annotation');
    var dataAnnotationId = constant('data-mce-annotation-uid');

    var identify = function (editor, annotationName) {
      var rng = editor.selection.getRng();
      var start = SugarElement.fromDom(rng.startContainer);
      var root = SugarElement.fromDom(editor.getBody());
      var selector = annotationName.fold(function () {
        return '.' + annotation();
      }, function (an) {
        return '[' + dataAnnotation() + '="' + an + '"]';
      });
      var newStart = child$1(start, rng.startOffset).getOr(start);
      var closest = closest$2(newStart, selector, function (n) {
        return eq(n, root);
      });
      var getAttr = function (c, property) {
        if (has$1(c, property)) {
          return Optional.some(get$6(c, property));
        } else {
          return Optional.none();
        }
      };
      return closest.bind(function (c) {
        return getAttr(c, '' + dataAnnotationId()).bind(function (uid) {
          return getAttr(c, '' + dataAnnotation()).map(function (name) {
            var elements = findMarkers(editor, uid);
            return {
              uid: uid,
              name: name,
              elements: elements
            };
          });
        });
      });
    };
    var isAnnotation = function (elem) {
      return isElement$6(elem) && has(elem, annotation());
    };
    var findMarkers = function (editor, uid) {
      var body = SugarElement.fromDom(editor.getBody());
      return descendants(body, '[' + dataAnnotationId() + '="' + uid + '"]');
    };
    var findAll = function (editor, name) {
      var body = SugarElement.fromDom(editor.getBody());
      var markers = descendants(body, '[' + dataAnnotation() + '="' + name + '"]');
      var directory = {};
      each$k(markers, function (m) {
        var uid = get$6(m, dataAnnotationId());
        var nodesAlready = get$9(directory, uid).getOr([]);
        directory[uid] = nodesAlready.concat([m]);
      });
      return directory;
    };

    var setup$n = function (editor, _registry) {
      var changeCallbacks = Cell({});
      var initData = function () {
        return {
          listeners: [],
          previous: value()
        };
      };
      var withCallbacks = function (name, f) {
        updateCallbacks(name, function (data) {
          f(data);
          return data;
        });
      };
      var updateCallbacks = function (name, f) {
        var callbackMap = changeCallbacks.get();
        var data = get$9(callbackMap, name).getOrThunk(initData);
        var outputData = f(data);
        callbackMap[name] = outputData;
        changeCallbacks.set(callbackMap);
      };
      var fireCallbacks = function (name, uid, elements) {
        withCallbacks(name, function (data) {
          each$k(data.listeners, function (f) {
            return f(true, name, {
              uid: uid,
              nodes: map$3(elements, function (elem) {
                return elem.dom;
              })
            });
          });
        });
      };
      var fireNoAnnotation = function (name) {
        withCallbacks(name, function (data) {
          each$k(data.listeners, function (f) {
            return f(false, name);
          });
        });
      };
      var onNodeChange = last(function () {
        var callbackMap = changeCallbacks.get();
        var annotations = sort(keys(callbackMap));
        each$k(annotations, function (name) {
          updateCallbacks(name, function (data) {
            var prev = data.previous.get();
            identify(editor, Optional.some(name)).fold(function () {
              if (prev.isSome()) {
                fireNoAnnotation(name);
                data.previous.clear();
              }
            }, function (_a) {
              var uid = _a.uid, name = _a.name, elements = _a.elements;
              if (!is$1(prev, uid)) {
                fireCallbacks(name, uid, elements);
                data.previous.set(uid);
              }
            });
            return {
              previous: data.previous,
              listeners: data.listeners
            };
          });
        });
      }, 30);
      editor.on('remove', function () {
        onNodeChange.cancel();
      });
      editor.on('NodeChange', function () {
        onNodeChange.throttle();
      });
      var addListener = function (name, f) {
        updateCallbacks(name, function (data) {
          return {
            previous: data.previous,
            listeners: data.listeners.concat([f])
          };
        });
      };
      return { addListener: addListener };
    };

    var setup$m = function (editor, registry) {
      var identifyParserNode = function (span) {
        return Optional.from(span.attr(dataAnnotation())).bind(registry.lookup);
      };
      editor.on('init', function () {
        editor.serializer.addNodeFilter('span', function (spans) {
          each$k(spans, function (span) {
            identifyParserNode(span).each(function (settings) {
              if (settings.persistent === false) {
                span.unwrap();
              }
            });
          });
        });
      });
    };

    var create$7 = function () {
      var annotations = {};
      var register = function (name, settings) {
        annotations[name] = {
          name: name,
          settings: settings
        };
      };
      var lookup = function (name) {
        return get$9(annotations, name).map(function (a) {
          return a.settings;
        });
      };
      return {
        register: register,
        lookup: lookup
      };
    };

    var unique = 0;
    var generate = function (prefix) {
      var date = new Date();
      var time = date.getTime();
      var random = Math.floor(Math.random() * 1000000000);
      unique++;
      return prefix + '_' + random + unique + String(time);
    };

    var add = function (element, classes) {
      each$k(classes, function (x) {
        add$1(element, x);
      });
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      return children(SugarElement.fromDom(div));
    };
    var fromDom$1 = function (nodes) {
      return map$3(nodes, SugarElement.fromDom);
    };

    var get$3 = function (element) {
      return element.dom.innerHTML;
    };
    var set = function (element, content) {
      var owner = owner$1(element);
      var docDom = owner.dom;
      var fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      var contentElements = fromHtml(content, docDom);
      append(fragment, contentElements);
      empty(element);
      append$1(element, fragment);
    };

    var clone$1 = function (original, isDeep) {
      return SugarElement.fromDom(original.dom.cloneNode(isDeep));
    };
    var shallow = function (original) {
      return clone$1(original, false);
    };
    var deep$1 = function (original) {
      return clone$1(original, true);
    };

    var TextWalker = function (startNode, rootNode, isBoundary) {
      if (isBoundary === void 0) {
        isBoundary = never;
      }
      var walker = new DomTreeWalker(startNode, rootNode);
      var walk = function (direction) {
        var next;
        do {
          next = walker[direction]();
        } while (next && !isText$7(next) && !isBoundary(next));
        return Optional.from(next).filter(isText$7);
      };
      return {
        current: function () {
          return Optional.from(walker.current()).filter(isText$7);
        },
        next: function () {
          return walk('next');
        },
        prev: function () {
          return walk('prev');
        },
        prev2: function () {
          return walk('prev2');
        }
      };
    };

    var TextSeeker = function (dom, isBoundary) {
      var isBlockBoundary = isBoundary ? isBoundary : function (node) {
        return dom.isBlock(node) || isBr$5(node) || isContentEditableFalse$b(node);
      };
      var walk = function (node, offset, walker, process) {
        if (isText$7(node)) {
          var newOffset = process(node, offset, node.data);
          if (newOffset !== -1) {
            return Optional.some({
              container: node,
              offset: newOffset
            });
          }
        }
        return walker().bind(function (next) {
          return walk(next.container, next.offset, walker, process);
        });
      };
      var backwards = function (node, offset, process, root) {
        var walker = TextWalker(node, root, isBlockBoundary);
        return walk(node, offset, function () {
          return walker.prev().map(function (prev) {
            return {
              container: prev,
              offset: prev.length
            };
          });
        }, process).getOrNull();
      };
      var forwards = function (node, offset, process, root) {
        var walker = TextWalker(node, root, isBlockBoundary);
        return walk(node, offset, function () {
          return walker.next().map(function (next) {
            return {
              container: next,
              offset: 0
            };
          });
        }, process).getOrNull();
      };
      return {
        backwards: backwards,
        forwards: forwards
      };
    };

    var round$2 = Math.round;
    var clone = function (rect) {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      return {
        left: round$2(rect.left),
        top: round$2(rect.top),
        bottom: round$2(rect.bottom),
        right: round$2(rect.right),
        width: round$2(rect.width),
        height: round$2(rect.height)
      };
    };
    var collapse = function (rect, toStart) {
      rect = clone(rect);
      if (toStart) {
        rect.right = rect.left;
      } else {
        rect.left = rect.left + rect.width;
        rect.right = rect.left;
      }
      rect.width = 0;
      return rect;
    };
    var isEqual = function (rect1, rect2) {
      return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
    };
    var isValidOverflow = function (overflowY, rect1, rect2) {
      return overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    };
    var isAbove$1 = function (rect1, rect2) {
      var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
      if (rect1.bottom - halfHeight < rect2.top) {
        return true;
      }
      if (rect1.top > rect2.bottom) {
        return false;
      }
      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    var isBelow$1 = function (rect1, rect2) {
      if (rect1.top > rect2.bottom) {
        return true;
      }
      if (rect1.bottom < rect2.top) {
        return false;
      }
      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    var containsXY = function (rect, clientX, clientY) {
      return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    };

    var clamp$2 = function (value, min, max) {
      return Math.min(Math.max(value, min), max);
    };

    var getSelectedNode = function (range) {
      var startContainer = range.startContainer, startOffset = range.startOffset;
      if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
        return startContainer.childNodes[startOffset];
      }
      return null;
    };
    var getNode$1 = function (container, offset) {
      if (isElement$5(container) && container.hasChildNodes()) {
        var childNodes = container.childNodes;
        var safeOffset = clamp$2(offset, 0, childNodes.length - 1);
        return childNodes[safeOffset];
      } else {
        return container;
      }
    };
    var getNodeUnsafe = function (container, offset) {
      if (offset < 0 && isElement$5(container) && container.hasChildNodes()) {
        return undefined;
      } else {
        return getNode$1(container, offset);
      }
    };

    var extendingChars = new RegExp('[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a' + '\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0' + '\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c' + '\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3' + '\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc' + '\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57' + '\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56' + '\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44' + '\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9' + '\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97' + '\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074' + '\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5' + '\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18' + '\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34' + '\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9' + '\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9' + '\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1' + '\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1' + '\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc' + '\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1' + '\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]');
    var isExtendingChar = function (ch) {
      return typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    };

    var or = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return function (x) {
        for (var i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }
        return false;
      };
    };
    var and = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return function (x) {
        for (var i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }
        return true;
      };
    };

    var isElement$3 = isElement$5;
    var isCaretCandidate$2 = isCaretCandidate$3;
    var isBlock$1 = matchStyleValues('display', 'block table');
    var isFloated = matchStyleValues('float', 'left right');
    var isValidElementCaretCandidate = and(isElement$3, isCaretCandidate$2, not(isFloated));
    var isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));
    var isText$4 = isText$7;
    var isBr$2 = isBr$5;
    var nodeIndex$1 = DOMUtils.nodeIndex;
    var resolveIndex$1 = getNodeUnsafe;
    var createRange$1 = function (doc) {
      return 'createRange' in doc ? doc.createRange() : DOMUtils.DOM.createRng();
    };
    var isWhiteSpace$1 = function (chr) {
      return chr && /[\r\n\t ]/.test(chr);
    };
    var isRange = function (rng) {
      return !!rng.setStart && !!rng.setEnd;
    };
    var isHiddenWhiteSpaceRange = function (range) {
      var container = range.startContainer;
      var offset = range.startOffset;
      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$7(container)) {
        var text = container.data;
        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {
          return true;
        }
      }
      return false;
    };
    var getBrClientRect = function (brNode) {
      var doc = brNode.ownerDocument;
      var rng = createRange$1(doc);
      var nbsp$1 = doc.createTextNode(nbsp);
      var parentNode = brNode.parentNode;
      parentNode.insertBefore(nbsp$1, brNode);
      rng.setStart(nbsp$1, 0);
      rng.setEnd(nbsp$1, 1);
      var clientRect = clone(rng.getBoundingClientRect());
      parentNode.removeChild(nbsp$1);
      return clientRect;
    };
    var getBoundingClientRectWebKitText = function (rng) {
      var sc = rng.startContainer;
      var ec = rng.endContainer;
      var so = rng.startOffset;
      var eo = rng.endOffset;
      if (sc === ec && isText$7(ec) && so === 0 && eo === 1) {
        var newRng = rng.cloneRange();
        newRng.setEndAfter(ec);
        return getBoundingClientRect$1(newRng);
      } else {
        return null;
      }
    };
    var isZeroRect = function (r) {
      return r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
    };
    var getBoundingClientRect$1 = function (item) {
      var clientRect;
      var clientRects = item.getClientRects();
      if (clientRects.length > 0) {
        clientRect = clone(clientRects[0]);
      } else {
        clientRect = clone(item.getBoundingClientRect());
      }
      if (!isRange(item) && isBr$2(item) && isZeroRect(clientRect)) {
        return getBrClientRect(item);
      }
      if (isZeroRect(clientRect) && isRange(item)) {
        return getBoundingClientRectWebKitText(item);
      }
      return clientRect;
    };
    var collapseAndInflateWidth = function (clientRect, toStart) {
      var newClientRect = collapse(clientRect, toStart);
      newClientRect.width = 1;
      newClientRect.right = newClientRect.left + 1;
      return newClientRect;
    };
    var getCaretPositionClientRects = function (caretPosition) {
      var clientRects = [];
      var addUniqueAndValidRect = function (clientRect) {
        if (clientRect.height === 0) {
          return;
        }
        if (clientRects.length > 0) {
          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }
        clientRects.push(clientRect);
      };
      var addCharacterOffset = function (container, offset) {
        var range = createRange$1(container.ownerDocument);
        if (offset < container.data.length) {
          if (isExtendingChar(container.data[offset])) {
            return clientRects;
          }
          if (isExtendingChar(container.data[offset - 1])) {
            range.setStart(container, offset);
            range.setEnd(container, offset + 1);
            if (!isHiddenWhiteSpaceRange(range)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
              return clientRects;
            }
          }
        }
        if (offset > 0) {
          range.setStart(container, offset - 1);
          range.setEnd(container, offset);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
          }
        }
        if (offset < container.data.length) {
          range.setStart(container, offset);
          range.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
          }
        }
      };
      var container = caretPosition.container();
      var offset = caretPosition.offset();
      if (isText$4(container)) {
        addCharacterOffset(container, offset);
        return clientRects;
      }
      if (isElement$3(container)) {
        if (caretPosition.isAtEnd()) {
          var node = resolveIndex$1(container, offset);
          if (isText$4(node)) {
            addCharacterOffset(node, node.data.length);
          }
          if (isValidElementCaretCandidate(node) && !isBr$2(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
          }
        } else {
          var node = resolveIndex$1(container, offset);
          if (isText$4(node)) {
            addCharacterOffset(node, 0);
          }
          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
            return clientRects;
          }
          var beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr$2(beforeNode)) {
            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
            }
          }
          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
          }
        }
      }
      return clientRects;
    };
    var CaretPosition = function (container, offset, clientRects) {
      var isAtStart = function () {
        if (isText$4(container)) {
          return offset === 0;
        }
        return offset === 0;
      };
      var isAtEnd = function () {
        if (isText$4(container)) {
          return offset >= container.data.length;
        }
        return offset >= container.childNodes.length;
      };
      var toRange = function () {
        var range = createRange$1(container.ownerDocument);
        range.setStart(container, offset);
        range.setEnd(container, offset);
        return range;
      };
      var getClientRects = function () {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
        }
        return clientRects;
      };
      var isVisible = function () {
        return getClientRects().length > 0;
      };
      var isEqual = function (caretPosition) {
        return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
      };
      var getNode = function (before) {
        return resolveIndex$1(container, before ? offset - 1 : offset);
      };
      return {
        container: constant(container),
        offset: constant(offset),
        toRange: toRange,
        getClientRects: getClientRects,
        isVisible: isVisible,
        isAtStart: isAtStart,
        isAtEnd: isAtEnd,
        isEqual: isEqual,
        getNode: getNode
      };
    };
    CaretPosition.fromRangeStart = function (range) {
      return CaretPosition(range.startContainer, range.startOffset);
    };
    CaretPosition.fromRangeEnd = function (range) {
      return CaretPosition(range.endContainer, range.endOffset);
    };
    CaretPosition.after = function (node) {
      return CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    };
    CaretPosition.before = function (node) {
      return CaretPosition(node.parentNode, nodeIndex$1(node));
    };
    CaretPosition.isAbove = function (pos1, pos2) {
      return lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);
    };
    CaretPosition.isBelow = function (pos1, pos2) {
      return lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    };
    CaretPosition.isAtStart = function (pos) {
      return pos ? pos.isAtStart() : false;
    };
    CaretPosition.isAtEnd = function (pos) {
      return pos ? pos.isAtEnd() : false;
    };
    CaretPosition.isTextPosition = function (pos) {
      return pos ? isText$7(pos.container()) : false;
    };
    CaretPosition.isElementPosition = function (pos) {
      return CaretPosition.isTextPosition(pos) === false;
    };

    var trimEmptyTextNode$1 = function (dom, node) {
      if (isText$7(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    var insertNode = function (dom, rng, node) {
      rng.insertNode(node);
      trimEmptyTextNode$1(dom, node.previousSibling);
      trimEmptyTextNode$1(dom, node.nextSibling);
    };
    var insertFragment = function (dom, rng, frag) {
      var firstChild = Optional.from(frag.firstChild);
      var lastChild = Optional.from(frag.lastChild);
      rng.insertNode(frag);
      firstChild.each(function (child) {
        return trimEmptyTextNode$1(dom, child.previousSibling);
      });
      lastChild.each(function (child) {
        return trimEmptyTextNode$1(dom, child.nextSibling);
      });
    };
    var rangeInsertNode = function (dom, rng, node) {
      if (isDocumentFragment(node)) {
        insertFragment(dom, rng, node);
      } else {
        insertNode(dom, rng, node);
      }
    };

    var isText$3 = isText$7;
    var isBogus = isBogus$2;
    var nodeIndex = DOMUtils.nodeIndex;
    var normalizedParent = function (node) {
      var parentNode = node.parentNode;
      if (isBogus(parentNode)) {
        return normalizedParent(parentNode);
      }
      return parentNode;
    };
    var getChildNodes = function (node) {
      if (!node) {
        return [];
      }
      return reduce(node.childNodes, function (result, node) {
        if (isBogus(node) && node.nodeName !== 'BR') {
          result = result.concat(getChildNodes(node));
        } else {
          result.push(node);
        }
        return result;
      }, []);
    };
    var normalizedTextOffset = function (node, offset) {
      while (node = node.previousSibling) {
        if (!isText$3(node)) {
          break;
        }
        offset += node.data.length;
      }
      return offset;
    };
    var equal = function (a) {
      return function (b) {
        return a === b;
      };
    };
    var normalizedNodeIndex = function (node) {
      var nodes, index;
      nodes = getChildNodes(normalizedParent(node));
      index = findIndex$1(nodes, equal(node), node);
      nodes = nodes.slice(0, index + 1);
      var numTextFragments = reduce(nodes, function (result, node, i) {
        if (isText$3(node) && isText$3(nodes[i - 1])) {
          result++;
        }
        return result;
      }, 0);
      nodes = filter$2(nodes, matchNodeNames([node.nodeName]));
      index = findIndex$1(nodes, equal(node), node);
      return index - numTextFragments;
    };
    var createPathItem = function (node) {
      var name;
      if (isText$3(node)) {
        name = 'text()';
      } else {
        name = node.nodeName.toLowerCase();
      }
      return name + '[' + normalizedNodeIndex(node) + ']';
    };
    var parentsUntil$1 = function (root, node, predicate) {
      var parents = [];
      for (node = node.parentNode; node !== root; node = node.parentNode) {
        if (predicate && predicate(node)) {
          break;
        }
        parents.push(node);
      }
      return parents;
    };
    var create$6 = function (root, caretPosition) {
      var container, offset, path = [], outputOffset, childNodes, parents;
      container = caretPosition.container();
      offset = caretPosition.offset();
      if (isText$3(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } else {
        childNodes = container.childNodes;
        if (offset >= childNodes.length) {
          outputOffset = 'after';
          offset = childNodes.length - 1;
        } else {
          outputOffset = 'before';
        }
        container = childNodes[offset];
      }
      path.push(createPathItem(container));
      parents = parentsUntil$1(root, container);
      parents = filter$2(parents, not(isBogus$2));
      path = path.concat(map$1(parents, function (node) {
        return createPathItem(node);
      }));
      return path.reverse().join('/') + ',' + outputOffset;
    };
    var resolvePathItem = function (node, name, index) {
      var nodes = getChildNodes(node);
      nodes = filter$2(nodes, function (node, index) {
        return !isText$3(node) || !isText$3(nodes[index - 1]);
      });
      nodes = filter$2(nodes, matchNodeNames([name]));
      return nodes[index];
    };
    var findTextPosition = function (container, offset) {
      var node = container, targetOffset = 0, dataLen;
      while (isText$3(node)) {
        dataLen = node.data.length;
        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          break;
        }
        if (!isText$3(node.nextSibling)) {
          container = node;
          offset = dataLen;
          break;
        }
        targetOffset += dataLen;
        node = node.nextSibling;
      }
      if (isText$3(container) && offset > container.data.length) {
        offset = container.data.length;
      }
      return CaretPosition(container, offset);
    };
    var resolve$2 = function (root, path) {
      var offset;
      if (!path) {
        return null;
      }
      var parts = path.split(',');
      var paths = parts[0].split('/');
      offset = parts.length > 1 ? parts[1] : 'before';
      var container = reduce(paths, function (result, value) {
        var match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
        if (!match) {
          return null;
        }
        if (match[1] === 'text()') {
          match[1] = '#text';
        }
        return resolvePathItem(result, match[1], parseInt(match[2], 10));
      }, root);
      if (!container) {
        return null;
      }
      if (!isText$3(container)) {
        if (offset === 'after') {
          offset = nodeIndex(container) + 1;
        } else {
          offset = nodeIndex(container);
        }
        return CaretPosition(container.parentNode, offset);
      }
      return findTextPosition(container, parseInt(offset, 10));
    };

    var isContentEditableFalse$9 = isContentEditableFalse$b;
    var getNormalizedTextOffset = function (trim, container, offset) {
      var node, trimmedOffset;
      trimmedOffset = trim(container.data.slice(0, offset)).length;
      for (node = container.previousSibling; node && isText$7(node); node = node.previousSibling) {
        trimmedOffset += trim(node.data).length;
      }
      return trimmedOffset;
    };
    var getPoint = function (dom, trim, normalized, rng, start) {
      var container = rng[start ? 'startContainer' : 'endContainer'];
      var offset = rng[start ? 'startOffset' : 'endOffset'];
      var point = [];
      var childNodes, after = 0;
      var root = dom.getRoot();
      if (isText$7(container)) {
        point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);
      } else {
        childNodes = container.childNodes;
        if (offset >= childNodes.length && childNodes.length) {
          after = 1;
          offset = Math.max(0, childNodes.length - 1);
        }
        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
      }
      for (; container && container !== root; container = container.parentNode) {
        point.push(dom.nodeIndex(container, normalized));
      }
      return point;
    };
    var getLocation = function (trim, selection, normalized, rng) {
      var dom = selection.dom, bookmark = {};
      bookmark.start = getPoint(dom, trim, normalized, rng, true);
      if (!selection.isCollapsed()) {
        bookmark.end = getPoint(dom, trim, normalized, rng, false);
      }
      if (isRangeInCaretContainerBlock(rng)) {
        bookmark.isFakeCaret = true;
      }
      return bookmark;
    };
    var findIndex = function (dom, name, element) {
      var count = 0;
      Tools.each(dom.select(name), function (node) {
        if (node.getAttribute('data-mce-bogus') === 'all') {
          return;
        }
        if (node === element) {
          return false;
        }
        count++;
      });
      return count;
    };
    var moveEndPoint$1 = function (rng, start) {
      var container, offset, childNodes;
      var prefix = start ? 'start' : 'end';
      container = rng[prefix + 'Container'];
      offset = rng[prefix + 'Offset'];
      if (isElement$5(container) && container.nodeName === 'TR') {
        childNodes = container.childNodes;
        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
        if (container) {
          offset = start ? 0 : container.childNodes.length;
          rng['set' + (start ? 'Start' : 'End')](container, offset);
        }
      }
    };
    var normalizeTableCellSelection = function (rng) {
      moveEndPoint$1(rng, true);
      moveEndPoint$1(rng, false);
      return rng;
    };
    var findSibling = function (node, offset) {
      var sibling;
      if (isElement$5(node)) {
        node = getNode$1(node, offset);
        if (isContentEditableFalse$9(node)) {
          return node;
        }
      }
      if (isCaretContainer$2(node)) {
        if (isText$7(node) && isCaretContainerBlock$1(node)) {
          node = node.parentNode;
        }
        sibling = node.previousSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
        sibling = node.nextSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
      }
    };
    var findAdjacentContentEditableFalseElm = function (rng) {
      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    var getOffsetBookmark = function (trim, normalized, selection) {
      var element = selection.getNode();
      var name = element ? element.nodeName : null;
      var rng = selection.getRng();
      if (isContentEditableFalse$9(element) || name === 'IMG') {
        return {
          name: name,
          index: findIndex(selection.dom, name, element)
        };
      }
      var sibling = findAdjacentContentEditableFalseElm(rng);
      if (sibling) {
        name = sibling.tagName;
        return {
          name: name,
          index: findIndex(selection.dom, name, sibling)
        };
      }
      return getLocation(trim, selection, normalized, rng);
    };
    var getCaretBookmark = function (selection) {
      var rng = selection.getRng();
      return {
        start: create$6(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
        end: create$6(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))
      };
    };
    var getRangeBookmark = function (selection) {
      return { rng: selection.getRng() };
    };
    var createBookmarkSpan = function (dom, id, filled) {
      var args = {
        'data-mce-type': 'bookmark',
        id: id,
        'style': 'overflow:hidden;line-height:0px'
      };
      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
    };
    var getPersistentBookmark = function (selection, filled) {
      var dom = selection.dom;
      var rng = selection.getRng();
      var id = dom.uniqueId();
      var collapsed = selection.isCollapsed();
      var element = selection.getNode();
      var name = element.nodeName;
      if (name === 'IMG') {
        return {
          name: name,
          index: findIndex(dom, name, element)
        };
      }
      var rng2 = normalizeTableCellSelection(rng.cloneRange());
      if (!collapsed) {
        rng2.collapse(false);
        var endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
        rangeInsertNode(dom, rng2, endBookmarkNode);
      }
      rng = normalizeTableCellSelection(rng);
      rng.collapse(true);
      var startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
      rangeInsertNode(dom, rng, startBookmarkNode);
      selection.moveToBookmark({
        id: id,
        keep: true
      });
      return { id: id };
    };
    var getBookmark$2 = function (selection, type, normalized) {
      if (type === 2) {
        return getOffsetBookmark(trim$2, normalized, selection);
      } else if (type === 3) {
        return getCaretBookmark(selection);
      } else if (type) {
        return getRangeBookmark(selection);
      } else {
        return getPersistentBookmark(selection, false);
      }
    };
    var getUndoBookmark = curry(getOffsetBookmark, identity, true);

    var DOM$9 = DOMUtils.DOM;
    var defaultPreviewStyles = 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow';
    var getBodySetting = function (editor, name, defaultValue) {
      var value = editor.getParam(name, defaultValue);
      if (value.indexOf('=') !== -1) {
        var bodyObj = editor.getParam(name, '', 'hash');
        return get$9(bodyObj, editor.id).getOr(defaultValue);
      } else {
        return value;
      }
    };
    var getIframeAttrs = function (editor) {
      return editor.getParam('iframe_attrs', {});
    };
    var getDocType = function (editor) {
      return editor.getParam('doctype', '<!DOCTYPE html>');
    };
    var getDocumentBaseUrl = function (editor) {
      return editor.getParam('document_base_url', '');
    };
    var getBodyId = function (editor) {
      return getBodySetting(editor, 'body_id', 'tinymce');
    };
    var getBodyClass = function (editor) {
      return getBodySetting(editor, 'body_class', '');
    };
    var getContentSecurityPolicy = function (editor) {
      return editor.getParam('content_security_policy', '');
    };
    var shouldPutBrInPre$1 = function (editor) {
      return editor.getParam('br_in_pre', true);
    };
    var getForcedRootBlock = function (editor) {
      if (editor.getParam('force_p_newlines', false)) {
        return 'p';
      }
      var block = editor.getParam('forced_root_block', 'p');
      if (block === false) {
        return '';
      } else if (block === true) {
        return 'p';
      } else {
        return block;
      }
    };
    var getForcedRootBlockAttrs = function (editor) {
      return editor.getParam('forced_root_block_attrs', {});
    };
    var getBrNewLineSelector = function (editor) {
      return editor.getParam('br_newline_selector', '.mce-toc h2,figcaption,caption');
    };
    var getNoNewLineSelector = function (editor) {
      return editor.getParam('no_newline_selector', '');
    };
    var shouldKeepStyles = function (editor) {
      return editor.getParam('keep_styles', true);
    };
    var shouldEndContainerOnEmptyBlock = function (editor) {
      return editor.getParam('end_container_on_empty_block', false);
    };
    var getFontStyleValues = function (editor) {
      return Tools.explode(editor.getParam('font_size_style_values', 'xx-small,x-small,small,medium,large,x-large,xx-large'));
    };
    var getFontSizeClasses = function (editor) {
      return Tools.explode(editor.getParam('font_size_classes', ''));
    };
    var getImagesDataImgFilter = function (editor) {
      return editor.getParam('images_dataimg_filter', always, 'function');
    };
    var isAutomaticUploadsEnabled = function (editor) {
      return editor.getParam('automatic_uploads', true, 'boolean');
    };
    var shouldReuseFileName = function (editor) {
      return editor.getParam('images_reuse_filename', false, 'boolean');
    };
    var shouldReplaceBlobUris = function (editor) {
      return editor.getParam('images_replace_blob_uris', true, 'boolean');
    };
    var getIconPackName = function (editor) {
      return editor.getParam('icons', '', 'string');
    };
    var getIconsUrl = function (editor) {
      return editor.getParam('icons_url', '', 'string');
    };
    var getImageUploadUrl = function (editor) {
      return editor.getParam('images_upload_url', '', 'string');
    };
    var getImageUploadBasePath = function (editor) {
      return editor.getParam('images_upload_base_path', '', 'string');
    };
    var getImagesUploadCredentials = function (editor) {
      return editor.getParam('images_upload_credentials', false, 'boolean');
    };
    var getImagesUploadHandler = function (editor) {
      return editor.getParam('images_upload_handler', null, 'function');
    };
    var shouldUseContentCssCors = function (editor) {
      return editor.getParam('content_css_cors', false, 'boolean');
    };
    var getReferrerPolicy = function (editor) {
      return editor.getParam('referrer_policy', '', 'string');
    };
    var getLanguageCode = function (editor) {
      return editor.getParam('language', 'en', 'string');
    };
    var getLanguageUrl = function (editor) {
      return editor.getParam('language_url', '', 'string');
    };
    var shouldIndentUseMargin = function (editor) {
      return editor.getParam('indent_use_margin', false);
    };
    var getIndentation = function (editor) {
      return editor.getParam('indentation', '40px', 'string');
    };
    var getContentCss = function (editor) {
      var contentCss = editor.getParam('content_css');
      if (isString$1(contentCss)) {
        return map$3(contentCss.split(','), trim$4);
      } else if (isArray$1(contentCss)) {
        return contentCss;
      } else if (contentCss === false || editor.inline) {
        return [];
      } else {
        return ['default'];
      }
    };
    var getFontCss = function (editor) {
      var fontCss = editor.getParam('font_css', []);
      return isArray$1(fontCss) ? fontCss : map$3(fontCss.split(','), trim$4);
    };
    var getDirectionality = function (editor) {
      return editor.getParam('directionality', I18n.isRtl() ? 'rtl' : undefined);
    };
    var getInlineBoundarySelector = function (editor) {
      return editor.getParam('inline_boundaries_selector', 'a[href],code,.mce-annotation', 'string');
    };
    var getObjectResizing = function (editor) {
      var selector = editor.getParam('object_resizing');
      if (selector === false || Env.iOS) {
        return false;
      } else {
        return isString$1(selector) ? selector : 'table,img,figure.image,div,video,iframe';
      }
    };
    var getResizeImgProportional = function (editor) {
      return editor.getParam('resize_img_proportional', true, 'boolean');
    };
    var getPlaceholder = function (editor) {
      return editor.getParam('placeholder', DOM$9.getAttrib(editor.getElement(), 'placeholder'), 'string');
    };
    var getEventRoot = function (editor) {
      return editor.getParam('event_root');
    };
    var getServiceMessage = function (editor) {
      return editor.getParam('service_message');
    };
    var getTheme = function (editor) {
      return editor.getParam('theme');
    };
    var shouldValidate = function (editor) {
      return editor.getParam('validate');
    };
    var isInlineBoundariesEnabled = function (editor) {
      return editor.getParam('inline_boundaries') !== false;
    };
    var getFormats = function (editor) {
      return editor.getParam('formats');
    };
    var getPreviewStyles = function (editor) {
      var style = editor.getParam('preview_styles', defaultPreviewStyles);
      if (isString$1(style)) {
        return style;
      } else {
        return '';
      }
    };
    var canFormatEmptyLines = function (editor) {
      return editor.getParam('format_empty_lines', false, 'boolean');
    };
    var getCustomUiSelector = function (editor) {
      return editor.getParam('custom_ui_selector', '', 'string');
    };
    var getThemeUrl = function (editor) {
      return editor.getParam('theme_url');
    };
    var isInline = function (editor) {
      return editor.getParam('inline');
    };
    var hasHiddenInput = function (editor) {
      return editor.getParam('hidden_input');
    };
    var shouldPatchSubmit = function (editor) {
      return editor.getParam('submit_patch');
    };
    var isEncodingXml = function (editor) {
      return editor.getParam('encoding') === 'xml';
    };
    var shouldAddFormSubmitTrigger = function (editor) {
      return editor.getParam('add_form_submit_trigger');
    };
    var shouldAddUnloadTrigger = function (editor) {
      return editor.getParam('add_unload_trigger');
    };
    var hasForcedRootBlock = function (editor) {
      return getForcedRootBlock(editor) !== '';
    };
    var getCustomUndoRedoLevels = function (editor) {
      return editor.getParam('custom_undo_redo_levels', 0, 'number');
    };
    var shouldDisableNodeChange = function (editor) {
      return editor.getParam('disable_nodechange');
    };
    var isReadOnly$1 = function (editor) {
      return editor.getParam('readonly');
    };
    var hasContentCssCors = function (editor) {
      return editor.getParam('content_css_cors');
    };
    var getPlugins = function (editor) {
      return editor.getParam('plugins', '', 'string');
    };
    var getExternalPlugins$1 = function (editor) {
      return editor.getParam('external_plugins');
    };
    var shouldBlockUnsupportedDrop = function (editor) {
      return editor.getParam('block_unsupported_drop', true, 'boolean');
    };
    var isVisualAidsEnabled = function (editor) {
      return editor.getParam('visual', true, 'boolean');
    };
    var getVisualAidsTableClass = function (editor) {
      return editor.getParam('visual_table_class', 'mce-item-table', 'string');
    };
    var getVisualAidsAnchorClass = function (editor) {
      return editor.getParam('visual_anchor_class', 'mce-item-anchor', 'string');
    };
    var getIframeAriaText = function (editor) {
      return editor.getParam('iframe_aria_text', 'Rich Text Area. Press ALT-0 for help.', 'string');
    };

    var isElement$2 = isElement$5;
    var isText$2 = isText$7;
    var removeNode$1 = function (node) {
      var parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };
    var trimCount = function (text) {
      var trimmedText = trim$2(text);
      return {
        count: text.length - trimmedText.length,
        text: trimmedText
      };
    };
    var deleteZwspChars = function (caretContainer) {
      var idx;
      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
        caretContainer.deleteData(idx, 1);
      }
    };
    var removeUnchanged = function (caretContainer, pos) {
      remove$2(caretContainer);
      return pos;
    };
    var removeTextAndReposition = function (caretContainer, pos) {
      var before = trimCount(caretContainer.data.substr(0, pos.offset()));
      var after = trimCount(caretContainer.data.substr(pos.offset()));
      var text = before.text + after.text;
      if (text.length > 0) {
        deleteZwspChars(caretContainer);
        return CaretPosition(caretContainer, pos.offset() - before.count);
      } else {
        return pos;
      }
    };
    var removeElementAndReposition = function (caretContainer, pos) {
      var parentNode = pos.container();
      var newPosition = indexOf$2(from(parentNode.childNodes), caretContainer).map(function (index) {
        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove$2(caretContainer);
      return newPosition;
    };
    var removeTextCaretContainer = function (caretContainer, pos) {
      return isText$2(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };
    var removeElementCaretContainer = function (caretContainer, pos) {
      return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };
    var removeAndReposition = function (container, pos) {
      return CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    };
    var remove$2 = function (caretContainerNode) {
      if (isElement$2(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
        if (hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute('data-mce-caret');
        } else {
          removeNode$1(caretContainerNode);
        }
      }
      if (isText$2(caretContainerNode)) {
        deleteZwspChars(caretContainerNode);
        if (caretContainerNode.data.length === 0) {
          removeNode$1(caretContainerNode);
        }
      }
    };

    var browser$2 = detect().browser;
    var isContentEditableFalse$8 = isContentEditableFalse$b;
    var isMedia$1 = isMedia$2;
    var isTableCell$3 = isTableCell$5;
    var inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';
    var getAbsoluteClientRect = function (root, element, before) {
      var clientRect = collapse(element.getBoundingClientRect(), before);
      var scrollX;
      var scrollY;
      if (root.tagName === 'BODY') {
        var docElm = root.ownerDocument.documentElement;
        scrollX = root.scrollLeft || docElm.scrollLeft;
        scrollY = root.scrollTop || docElm.scrollTop;
      } else {
        var rootRect = root.getBoundingClientRect();
        scrollX = root.scrollLeft - rootRect.left;
        scrollY = root.scrollTop - rootRect.top;
      }
      clientRect.left += scrollX;
      clientRect.right += scrollX;
      clientRect.top += scrollY;
      clientRect.bottom += scrollY;
      clientRect.width = 1;
      var margin = element.offsetWidth - element.clientWidth;
      if (margin > 0) {
        if (before) {
          margin *= -1;
        }
        clientRect.left += margin;
        clientRect.right += margin;
      }
      return clientRect;
    };
    var trimInlineCaretContainers = function (root) {
      var fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
      for (var i = 0; i < fakeCaretTargetNodes.length; i++) {
        var node = fakeCaretTargetNodes[i].dom;
        var sibling = node.previousSibling;
        if (endsWithCaretContainer$1(sibling)) {
          var data = sibling.data;
          if (data.length === 1) {
            sibling.parentNode.removeChild(sibling);
          } else {
            sibling.deleteData(data.length - 1, 1);
          }
        }
        sibling = node.nextSibling;
        if (startsWithCaretContainer$1(sibling)) {
          var data = sibling.data;
          if (data.length === 1) {
            sibling.parentNode.removeChild(sibling);
          } else {
            sibling.deleteData(0, 1);
          }
        }
      }
    };
    var FakeCaret = function (editor, root, isBlock, hasFocus) {
      var lastVisualCaret = value();
      var cursorInterval;
      var caretContainerNode;
      var rootBlock = getForcedRootBlock(editor);
      var caretBlock = rootBlock.length > 0 ? rootBlock : 'p';
      var show = function (before, element) {
        var rng;
        hide();
        if (isTableCell$3(element)) {
          return null;
        }
        if (isBlock(element)) {
          caretContainerNode = insertBlock$1(caretBlock, element, before);
          var clientRect = getAbsoluteClientRect(root, element, before);
          DomQuery(caretContainerNode).css('top', clientRect.top);
          var caret = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(__assign({}, clientRect)).appendTo(root)[0];
          lastVisualCaret.set({
            caret: caret,
            element: element,
            before: before
          });
          if (before) {
            DomQuery(caret).addClass('mce-visual-caret-before');
          }
          startBlink();
          rng = element.ownerDocument.createRange();
          rng.setStart(caretContainerNode, 0);
          rng.setEnd(caretContainerNode, 0);
        } else {
          caretContainerNode = insertInline$1(element, before);
          rng = element.ownerDocument.createRange();
          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }
          return rng;
        }
        return rng;
      };
      var hide = function () {
        trimInlineCaretContainers(root);
        if (caretContainerNode) {
          remove$2(caretContainerNode);
          caretContainerNode = null;
        }
        lastVisualCaret.on(function (caretState) {
          DomQuery(caretState.caret).remove();
          lastVisualCaret.clear();
        });
        if (cursorInterval) {
          Delay.clearInterval(cursorInterval);
          cursorInterval = undefined;
        }
      };
      var startBlink = function () {
        cursorInterval = Delay.setInterval(function () {
          if (hasFocus()) {
            DomQuery('div.mce-visual-caret', root).toggleClass('mce-visual-caret-hidden');
          } else {
            DomQuery('div.mce-visual-caret', root).addClass('mce-visual-caret-hidden');
          }
        }, 500);
      };
      var reposition = function () {
        lastVisualCaret.on(function (caretState) {
          var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
          DomQuery(caretState.caret).css(__assign({}, clientRect));
        });
      };
      var destroy = function () {
        return Delay.clearInterval(cursorInterval);
      };
      var getCss = function () {
        return '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';
      };
      return {
        show: show,
        hide: hide,
        getCss: getCss,
        reposition: reposition,
        destroy: destroy
      };
    };
    var isFakeCaretTableBrowser = function () {
      return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
    };
    var isInlineFakeCaretTarget = function (node) {
      return isContentEditableFalse$8(node) || isMedia$1(node);
    };
    var isFakeCaretTarget = function (node) {
      return isInlineFakeCaretTarget(node) || isTable$3(node) && isFakeCaretTableBrowser();
    };

    var isContentEditableFalse$7 = isContentEditableFalse$b;
    var isMedia = isMedia$2;
    var isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');
    var isCaretContainer = isCaretContainer$2;
    var isCaretContainerBlock = isCaretContainerBlock$1;
    var isElement$1 = isElement$5;
    var isCaretCandidate$1 = isCaretCandidate$3;
    var isForwards = function (direction) {
      return direction > 0;
    };
    var isBackwards = function (direction) {
      return direction < 0;
    };
    var skipCaretContainers = function (walk, shallow) {
      var node;
      while (node = walk(shallow)) {
        if (!isCaretContainerBlock(node)) {
          return node;
        }
      }
      return null;
    };
    var findNode$1 = function (node, direction, predicateFn, rootNode, shallow) {
      var walker = new DomTreeWalker(node, rootNode);
      var isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
      if (isBackwards(direction)) {
        if (isCefOrCaretContainer) {
          node = skipCaretContainers(walker.prev.bind(walker), true);
          if (predicateFn(node)) {
            return node;
          }
        }
        while (node = skipCaretContainers(walker.prev.bind(walker), shallow)) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }
      if (isForwards(direction)) {
        if (isCefOrCaretContainer) {
          node = skipCaretContainers(walker.next.bind(walker), true);
          if (predicateFn(node)) {
            return node;
          }
        }
        while (node = skipCaretContainers(walker.next.bind(walker), shallow)) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }
      return null;
    };
    var getParentBlock$2 = function (node, rootNode) {
      while (node && node !== rootNode) {
        if (isBlockLike(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var isInSameBlock = function (caretPosition1, caretPosition2, rootNode) {
      return getParentBlock$2(caretPosition1.container(), rootNode) === getParentBlock$2(caretPosition2.container(), rootNode);
    };
    var getChildNodeAtRelativeOffset = function (relativeOffset, caretPosition) {
      if (!caretPosition) {
        return null;
      }
      var container = caretPosition.container();
      var offset = caretPosition.offset();
      if (!isElement$1(container)) {
        return null;
      }
      return container.childNodes[offset + relativeOffset];
    };
    var beforeAfter = function (before, node) {
      var range = node.ownerDocument.createRange();
      if (before) {
        range.setStartBefore(node);
        range.setEndBefore(node);
      } else {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
      return range;
    };
    var isNodesInSameBlock = function (root, node1, node2) {
      return getParentBlock$2(node1, root) === getParentBlock$2(node2, root);
    };
    var lean = function (left, root, node) {
      var siblingName = left ? 'previousSibling' : 'nextSibling';
      while (node && node !== root) {
        var sibling = node[siblingName];
        if (isCaretContainer(sibling)) {
          sibling = sibling[siblingName];
        }
        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {
          if (isNodesInSameBlock(root, sibling, node)) {
            return sibling;
          }
          break;
        }
        if (isCaretCandidate$1(sibling)) {
          break;
        }
        node = node.parentNode;
      }
      return null;
    };
    var before$2 = curry(beforeAfter, true);
    var after$2 = curry(beforeAfter, false);
    var normalizeRange = function (direction, root, range) {
      var node;
      var leanLeft = curry(lean, true, root);
      var leanRight = curry(lean, false, root);
      var container = range.startContainer;
      var offset = range.startOffset;
      if (isCaretContainerBlock$1(container)) {
        if (!isElement$1(container)) {
          container = container.parentNode;
        }
        var location_1 = container.getAttribute('data-mce-caret');
        if (location_1 === 'before') {
          node = container.nextSibling;
          if (isFakeCaretTarget(node)) {
            return before$2(node);
          }
        }
        if (location_1 === 'after') {
          node = container.previousSibling;
          if (isFakeCaretTarget(node)) {
            return after$2(node);
          }
        }
      }
      if (!range.collapsed) {
        return range;
      }
      if (isText$7(container)) {
        if (isCaretContainer(container)) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (startsWithCaretContainer$1(container) && offset <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          return range;
        }
        if (offset === container.data.length) {
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
          return range;
        }
        if (offset === 0) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
          return range;
        }
      }
      return range;
    };
    var getRelativeCefElm = function (forward, caretPosition) {
      return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$7);
    };
    var getNormalizedRangeEndPoint = function (direction, root, range) {
      var normalizedRange = normalizeRange(direction, root, range);
      if (direction === -1) {
        return CaretPosition.fromRangeStart(normalizedRange);
      }
      return CaretPosition.fromRangeEnd(normalizedRange);
    };
    var getElementFromPosition = function (pos) {
      return Optional.from(pos.getNode()).map(SugarElement.fromDom);
    };
    var getElementFromPrevPosition = function (pos) {
      return Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    };
    var getVisualCaretPosition = function (walkFn, caretPosition) {
      while (caretPosition = walkFn(caretPosition)) {
        if (caretPosition.isVisible()) {
          return caretPosition;
        }
      }
      return caretPosition;
    };
    var isMoveInsideSameBlock = function (from, to) {
      var inSameBlock = isInSameBlock(from, to);
      if (!inSameBlock && isBr$5(from.getNode())) {
        return true;
      }
      return inSameBlock;
    };

    var HDirection;
    (function (HDirection) {
      HDirection[HDirection['Backwards'] = -1] = 'Backwards';
      HDirection[HDirection['Forwards'] = 1] = 'Forwards';
    }(HDirection || (HDirection = {})));
    var isContentEditableFalse$6 = isContentEditableFalse$b;
    var isText$1 = isText$7;
    var isElement = isElement$5;
    var isBr$1 = isBr$5;
    var isCaretCandidate = isCaretCandidate$3;
    var isAtomic = isAtomic$1;
    var isEditableCaretCandidate = isEditableCaretCandidate$1;
    var getParents$3 = function (node, root) {
      var parents = [];
      while (node && node !== root) {
        parents.push(node);
        node = node.parentNode;
      }
      return parents;
    };
    var nodeAtIndex = function (container, offset) {
      if (container.hasChildNodes() && offset < container.childNodes.length) {
        return container.childNodes[offset];
      }
      return null;
    };
    var getCaretCandidatePosition = function (direction, node) {
      if (isForwards(direction)) {
        if (isCaretCandidate(node.previousSibling) && !isText$1(node.previousSibling)) {
          return CaretPosition.before(node);
        }
        if (isText$1(node)) {
          return CaretPosition(node, 0);
        }
      }
      if (isBackwards(direction)) {
        if (isCaretCandidate(node.nextSibling) && !isText$1(node.nextSibling)) {
          return CaretPosition.after(node);
        }
        if (isText$1(node)) {
          return CaretPosition(node, node.data.length);
        }
      }
      if (isBackwards(direction)) {
        if (isBr$1(node)) {
          return CaretPosition.before(node);
        }
        return CaretPosition.after(node);
      }
      return CaretPosition.before(node);
    };
    var moveForwardFromBr = function (root, nextNode) {
      var nextSibling = nextNode.nextSibling;
      if (nextSibling && isCaretCandidate(nextSibling)) {
        if (isText$1(nextSibling)) {
          return CaretPosition(nextSibling, 0);
        } else {
          return CaretPosition.before(nextSibling);
        }
      } else {
        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);
      }
    };
    var findCaretPosition$1 = function (direction, startPos, root) {
      var node;
      var nextNode;
      var innerNode;
      var caretPosition;
      if (!isElement(root) || !startPos) {
        return null;
      }
      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
        caretPosition = CaretPosition.after(root.lastChild);
        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement(root.lastChild)) {
          return isBr$1(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
        }
      } else {
        caretPosition = startPos;
      }
      var container = caretPosition.container();
      var offset = caretPosition.offset();
      if (isText$1(container)) {
        if (isBackwards(direction) && offset > 0) {
          return CaretPosition(container, --offset);
        }
        if (isForwards(direction) && offset < container.length) {
          return CaretPosition(container, ++offset);
        }
        node = container;
      } else {
        if (isBackwards(direction) && offset > 0) {
          nextNode = nodeAtIndex(container, offset - 1);
          if (isCaretCandidate(nextNode)) {
            if (!isAtomic(nextNode)) {
              innerNode = findNode$1(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$1(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }
                return CaretPosition.after(innerNode);
              }
            }
            if (isText$1(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }
            return CaretPosition.before(nextNode);
          }
        }
        if (isForwards(direction) && offset < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          if (isCaretCandidate(nextNode)) {
            if (isBr$1(nextNode)) {
              return moveForwardFromBr(root, nextNode);
            }
            if (!isAtomic(nextNode)) {
              innerNode = findNode$1(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$1(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }
                return CaretPosition.before(innerNode);
              }
            }
            if (isText$1(nextNode)) {
              return CaretPosition(nextNode, 0);
            }
            return CaretPosition.after(nextNode);
          }
        }
        node = nextNode ? nextNode : caretPosition.getNode();
      }
      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
        node = findNode$1(node, direction, always, root, true);
        if (isEditableCaretCandidate(node, root)) {
          return getCaretCandidatePosition(direction, node);
        }
      }
      nextNode = findNode$1(node, direction, isEditableCaretCandidate, root);
      var rootContentEditableFalseElm = last$1(filter$4(getParents$3(container, root), isContentEditableFalse$6));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }
        return caretPosition;
      }
      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }
      return null;
    };
    var CaretWalker = function (root) {
      return {
        next: function (caretPosition) {
          return findCaretPosition$1(HDirection.Forwards, caretPosition, root);
        },
        prev: function (caretPosition) {
          return findCaretPosition$1(HDirection.Backwards, caretPosition, root);
        }
      };
    };

    var walkToPositionIn = function (forward, root, start) {
      var position = forward ? CaretPosition.before(start) : CaretPosition.after(start);
      return fromPosition(forward, root, position);
    };
    var afterElement = function (node) {
      return isBr$5(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    };
    var isBeforeOrStart = function (position) {
      if (CaretPosition.isTextPosition(position)) {
        return position.offset() === 0;
      } else {
        return isCaretCandidate$3(position.getNode());
      }
    };
    var isAfterOrEnd = function (position) {
      if (CaretPosition.isTextPosition(position)) {
        var container = position.container();
        return position.offset() === container.data.length;
      } else {
        return isCaretCandidate$3(position.getNode(true));
      }
    };
    var isBeforeAfterSameElement = function (from, to) {
      return !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);
    };
    var isAtBr = function (position) {
      return !CaretPosition.isTextPosition(position) && isBr$5(position.getNode());
    };
    var shouldSkipPosition = function (forward, from, to) {
      if (forward) {
        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
      } else {
        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
      }
    };
    var fromPosition = function (forward, root, pos) {
      var walker = CaretWalker(root);
      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    var navigate = function (forward, root, from) {
      return fromPosition(forward, root, from).bind(function (to) {
        if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
          return fromPosition(forward, root, to);
        } else {
          return Optional.some(to);
        }
      });
    };
    var navigateIgnore = function (forward, root, from, ignoreFilter) {
      return navigate(forward, root, from).bind(function (pos) {
        return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos);
      });
    };
    var positionIn = function (forward, element) {
      var startNode = forward ? element.firstChild : element.lastChild;
      if (isText$7(startNode)) {
        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
      } else if (startNode) {
        if (isCaretCandidate$3(startNode)) {
          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
        } else {
          return walkToPositionIn(forward, element, startNode);
        }
      } else {
        return Optional.none();
      }
    };
    var nextPosition = curry(fromPosition, true);
    var prevPosition = curry(fromPosition, false);
    var firstPositionIn = curry(positionIn, true);
    var lastPositionIn = curry(positionIn, false);

    var CARET_ID$1 = '_mce_caret';
    var isCaretNode = function (node) {
      return isElement$5(node) && node.id === CARET_ID$1;
    };
    var getParentCaretContainer = function (body, node) {
      while (node && node !== body) {
        if (node.id === CARET_ID$1) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };

    var isStringPathBookmark = function (bookmark) {
      return isString$1(bookmark.start);
    };
    var isRangeBookmark = function (bookmark) {
      return has$2(bookmark, 'rng');
    };
    var isIdBookmark = function (bookmark) {
      return has$2(bookmark, 'id');
    };
    var isIndexBookmark = function (bookmark) {
      return has$2(bookmark, 'name');
    };
    var isPathBookmark = function (bookmark) {
      return Tools.isArray(bookmark.start);
    };

    var addBogus = function (dom, node) {
      if (isElement$5(node) && dom.isBlock(node) && !node.innerHTML && !Env.ie) {
        node.innerHTML = '<br data-mce-bogus="1" />';
      }
      return node;
    };
    var resolveCaretPositionBookmark = function (dom, bookmark) {
      var pos;
      var rng = dom.createRng();
      pos = resolve$2(dom.getRoot(), bookmark.start);
      rng.setStart(pos.container(), pos.offset());
      pos = resolve$2(dom.getRoot(), bookmark.end);
      rng.setEnd(pos.container(), pos.offset());
      return rng;
    };
    var insertZwsp = function (node, rng) {
      var textNode = node.ownerDocument.createTextNode(ZWSP$1);
      node.appendChild(textNode);
      rng.setStart(textNode, 0);
      rng.setEnd(textNode, 0);
    };
    var isEmpty$1 = function (node) {
      return node.hasChildNodes() === false;
    };
    var tryFindRangePosition = function (node, rng) {
      return lastPositionIn(node).fold(never, function (pos) {
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        return true;
      });
    };
    var padEmptyCaretContainer = function (root, node, rng) {
      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
        insertZwsp(node, rng);
        return true;
      } else {
        return false;
      }
    };
    var setEndPoint = function (dom, start, bookmark, rng) {
      var point = bookmark[start ? 'start' : 'end'];
      var i, node, offset, children;
      var root = dom.getRoot();
      if (point) {
        offset = point[0];
        for (node = root, i = point.length - 1; i >= 1; i--) {
          children = node.childNodes;
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          if (point[i] > children.length - 1) {
            if (padEmptyCaretContainer(root, node, rng)) {
              return true;
            }
            return tryFindRangePosition(node, rng);
          }
          node = children[point[i]];
        }
        if (node.nodeType === 3) {
          offset = Math.min(point[0], node.nodeValue.length);
        }
        if (node.nodeType === 1) {
          offset = Math.min(point[0], node.childNodes.length);
        }
        if (start) {
          rng.setStart(node, offset);
        } else {
          rng.setEnd(node, offset);
        }
      }
      return true;
    };
    var isValidTextNode = function (node) {
      return isText$7(node) && node.data.length > 0;
    };
    var restoreEndPoint = function (dom, suffix, bookmark) {
      var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev;
      var keep = bookmark.keep;
      var container, offset;
      if (marker) {
        node = marker.parentNode;
        if (suffix === 'start') {
          if (!keep) {
            idx = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              node = marker.firstChild;
              idx = 1;
            } else if (isValidTextNode(marker.nextSibling)) {
              node = marker.nextSibling;
              idx = 0;
            } else if (isValidTextNode(marker.previousSibling)) {
              node = marker.previousSibling;
              idx = marker.previousSibling.data.length;
            } else {
              node = marker.parentNode;
              idx = dom.nodeIndex(marker) + 1;
            }
          }
          container = node;
          offset = idx;
        } else {
          if (!keep) {
            idx = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              node = marker.firstChild;
              idx = 1;
            } else if (isValidTextNode(marker.previousSibling)) {
              node = marker.previousSibling;
              idx = marker.previousSibling.data.length;
            } else {
              node = marker.parentNode;
              idx = dom.nodeIndex(marker);
            }
          }
          container = node;
          offset = idx;
        }
        if (!keep) {
          prev = marker.previousSibling;
          next = marker.nextSibling;
          Tools.each(Tools.grep(marker.childNodes), function (node) {
            if (isText$7(node)) {
              node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
            }
          });
          while (marker = dom.get(bookmark.id + '_' + suffix)) {
            dom.remove(marker, true);
          }
          if (prev && next && prev.nodeType === next.nodeType && isText$7(prev) && !Env.opera) {
            idx = prev.nodeValue.length;
            prev.appendData(next.nodeValue);
            dom.remove(next);
            container = prev;
            offset = idx;
          }
        }
        return Optional.some(CaretPosition(container, offset));
      } else {
        return Optional.none();
      }
    };
    var resolvePaths = function (dom, bookmark) {
      var rng = dom.createRng();
      if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {
        return Optional.some(rng);
      } else {
        return Optional.none();
      }
    };
    var resolveId = function (dom, bookmark) {
      var startPos = restoreEndPoint(dom, 'start', bookmark);
      var endPos = restoreEndPoint(dom, 'end', bookmark);
      return lift2(startPos, endPos.or(startPos), function (spos, epos) {
        var rng = dom.createRng();
        rng.setStart(addBogus(dom, spos.container()), spos.offset());
        rng.setEnd(addBogus(dom, epos.container()), epos.offset());
        return rng;
      });
    };
    var resolveIndex = function (dom, bookmark) {
      return Optional.from(dom.select(bookmark.name)[bookmark.index]).map(function (elm) {
        var rng = dom.createRng();
        rng.selectNode(elm);
        return rng;
      });
    };
    var resolve$1 = function (selection, bookmark) {
      var dom = selection.dom;
      if (bookmark) {
        if (isPathBookmark(bookmark)) {
          return resolvePaths(dom, bookmark);
        } else if (isStringPathBookmark(bookmark)) {
          return Optional.some(resolveCaretPositionBookmark(dom, bookmark));
        } else if (isIdBookmark(bookmark)) {
          return resolveId(dom, bookmark);
        } else if (isIndexBookmark(bookmark)) {
          return resolveIndex(dom, bookmark);
        } else if (isRangeBookmark(bookmark)) {
          return Optional.some(bookmark.rng);
        }
      }
      return Optional.none();
    };

    var getBookmark$1 = function (selection, type, normalized) {
      return getBookmark$2(selection, type, normalized);
    };
    var moveToBookmark = function (selection, bookmark) {
      resolve$1(selection, bookmark).each(function (rng) {
        selection.setRng(rng);
      });
    };
    var isBookmarkNode$1 = function (node) {
      return isElement$5(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    var is = function (expected) {
      return function (actual) {
        return expected === actual;
      };
    };
    var isNbsp = is(nbsp);
    var isWhiteSpace = function (chr) {
      return chr !== '' && ' \f\n\r\t\x0B'.indexOf(chr) !== -1;
    };
    var isContent = function (chr) {
      return !isWhiteSpace(chr) && !isNbsp(chr);
    };

    var isNode = function (node) {
      return !!node.nodeType;
    };
    var isInlineBlock = function (node) {
      return node && /^(IMG)$/.test(node.nodeName);
    };
    var moveStart = function (dom, selection, rng) {
      var offset = rng.startOffset;
      var container = rng.startContainer;
      if (container === rng.endContainer) {
        if (isInlineBlock(container.childNodes[offset])) {
          return;
        }
      }
      if (isElement$5(container)) {
        var nodes = container.childNodes;
        var walker = void 0;
        if (offset < nodes.length) {
          container = nodes[offset];
          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));
        } else {
          container = nodes[nodes.length - 1];
          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));
          walker.next(true);
        }
        for (var node = walker.current(); node; node = walker.next()) {
          if (isText$7(node) && !isWhiteSpaceNode$1(node)) {
            rng.setStart(node, 0);
            selection.setRng(rng);
            return;
          }
        }
      }
    };
    var getNonWhiteSpaceSibling = function (node, next, inc) {
      if (node) {
        var nextName = next ? 'nextSibling' : 'previousSibling';
        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
          if (isElement$5(node) || !isWhiteSpaceNode$1(node)) {
            return node;
          }
        }
      }
    };
    var isTextBlock$1 = function (editor, name) {
      if (isNode(name)) {
        name = name.nodeName;
      }
      return !!editor.schema.getTextBlockElements()[name.toLowerCase()];
    };
    var isValid = function (ed, parent, child) {
      return ed.schema.isValidChild(parent, child);
    };
    var isWhiteSpaceNode$1 = function (node, allowSpaces) {
      if (allowSpaces === void 0) {
        allowSpaces = false;
      }
      if (isNonNullable(node) && isText$7(node)) {
        var data = allowSpaces ? node.data.replace(/ /g, '\xA0') : node.data;
        return isWhitespaceText(data);
      } else {
        return false;
      }
    };
    var isEmptyTextNode$1 = function (node) {
      return isNonNullable(node) && isText$7(node) && node.length === 0;
    };
    var replaceVars = function (value, vars) {
      if (isFunction(value)) {
        value = value(vars);
      } else if (isNonNullable(vars)) {
        value = value.replace(/%(\w+)/g, function (str, name) {
          return vars[name] || str;
        });
      }
      return value;
    };
    var isEq$5 = function (str1, str2) {
      str1 = str1 || '';
      str2 = str2 || '';
      str1 = '' + (str1.nodeName || str1);
      str2 = '' + (str2.nodeName || str2);
      return str1.toLowerCase() === str2.toLowerCase();
    };
    var normalizeStyleValue = function (dom, value, name) {
      if (name === 'color' || name === 'backgroundColor') {
        value = dom.toHex(value);
      }
      if (name === 'fontWeight' && value === 700) {
        value = 'bold';
      }
      if (name === 'fontFamily') {
        value = value.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
      }
      return '' + value;
    };
    var getStyle = function (dom, node, name) {
      return normalizeStyleValue(dom, dom.getStyle(node, name), name);
    };
    var getTextDecoration = function (dom, node) {
      var decoration;
      dom.getParent(node, function (n) {
        decoration = dom.getStyle(n, 'text-decoration');
        return decoration && decoration !== 'none';
      });
      return decoration;
    };
    var getParents$2 = function (dom, node, selector) {
      return dom.getParents(node, selector, dom.getRoot());
    };
    var isVariableFormatName = function (editor, formatName) {
      var hasVariableValues = function (format) {
        var isVariableValue = function (val) {
          return val.length > 1 && val.charAt(0) === '%';
        };
        return exists([
          'styles',
          'attributes'
        ], function (key) {
          return get$9(format, key).exists(function (field) {
            var fieldValues = isArray$1(field) ? field : values(field);
            return exists(fieldValues, isVariableValue);
          });
        });
      };
      return exists(editor.formatter.get(formatName), hasVariableValues);
    };
    var areSimilarFormats = function (editor, formatName, otherFormatName) {
      var validKeys = [
        'inline',
        'block',
        'selector',
        'attributes',
        'styles',
        'classes'
      ];
      var filterObj = function (format) {
        return filter$3(format, function (_, key) {
          return exists(validKeys, function (validKey) {
            return validKey === key;
          });
        });
      };
      return exists(editor.formatter.get(formatName), function (fmt1) {
        var filteredFmt1 = filterObj(fmt1);
        return exists(editor.formatter.get(otherFormatName), function (fmt2) {
          var filteredFmt2 = filterObj(fmt2);
          return equal$1(filteredFmt1, filteredFmt2);
        });
      });
    };
    var isBlockFormat = function (format) {
      return hasNonNullableKey(format, 'block');
    };
    var isSelectorFormat = function (format) {
      return hasNonNullableKey(format, 'selector');
    };
    var isInlineFormat = function (format) {
      return hasNonNullableKey(format, 'inline');
    };
    var isMixedFormat = function (format) {
      return isSelectorFormat(format) && isInlineFormat(format) && is$1(get$9(format, 'mixed'), true);
    };
    var shouldExpandToSelector = function (format) {
      return isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
    };

    var isBookmarkNode = isBookmarkNode$1;
    var getParents$1 = getParents$2;
    var isWhiteSpaceNode = isWhiteSpaceNode$1;
    var isTextBlock = isTextBlock$1;
    var isBogusBr = function (node) {
      return isBr$5(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;
    };
    var findParentContentEditable = function (dom, node) {
      var parent = node;
      while (parent) {
        if (isElement$5(parent) && dom.getContentEditable(parent)) {
          return dom.getContentEditable(parent) === 'false' ? parent : node;
        }
        parent = parent.parentNode;
      }
      return node;
    };
    var walkText = function (start, node, offset, predicate) {
      var str = node.data;
      for (var i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {
        if (predicate(str.charAt(i))) {
          return start ? i + 1 : i;
        }
      }
      return -1;
    };
    var findSpace = function (start, node, offset) {
      return walkText(start, node, offset, function (c) {
        return isNbsp(c) || isWhiteSpace(c);
      });
    };
    var findContent = function (start, node, offset) {
      return walkText(start, node, offset, isContent);
    };
    var findWordEndPoint = function (dom, body, container, offset, start, includeTrailingSpaces) {
      var lastTextNode;
      var rootNode = dom.getParent(container, dom.isBlock) || body;
      var walk = function (container, offset, pred) {
        var textSeeker = TextSeeker(dom);
        var walker = start ? textSeeker.backwards : textSeeker.forwards;
        return Optional.from(walker(container, offset, function (text, textOffset) {
          if (isBookmarkNode(text.parentNode)) {
            return -1;
          } else {
            lastTextNode = text;
            return pred(start, text, textOffset);
          }
        }, rootNode));
      };
      var spaceResult = walk(container, offset, findSpace);
      return spaceResult.bind(function (result) {
        return includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result);
      }).orThunk(function () {
        return lastTextNode ? Optional.some({
          container: lastTextNode,
          offset: start ? 0 : lastTextNode.length
        }) : Optional.none();
      });
    };
    var findSelectorEndPoint = function (dom, formatList, rng, container, siblingName) {
      if (isText$7(container) && isEmpty$3(container.data) && container[siblingName]) {
        container = container[siblingName];
      }
      var parents = getParents$1(dom, container);
      for (var i = 0; i < parents.length; i++) {
        for (var y = 0; y < formatList.length; y++) {
          var curFormat = formatList[y];
          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
            continue;
          }
          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {
            return parents[i];
          }
        }
      }
      return container;
    };
    var findBlockEndPoint = function (editor, formatList, container, siblingName) {
      var node = container;
      var dom = editor.dom;
      var root = dom.getRoot();
      var format = formatList[0];
      if (isBlockFormat(format)) {
        node = format.wrapper ? null : dom.getParent(container, format.block, root);
      }
      if (!node) {
        var scopeRoot = dom.getParent(container, 'LI,TD,TH');
        node = dom.getParent(isText$7(container) ? container.parentNode : container, function (node) {
          return node !== root && isTextBlock(editor, node);
        }, scopeRoot);
      }
      if (node && isBlockFormat(format) && format.wrapper) {
        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;
      }
      if (!node) {
        node = container;
        while (node[siblingName] && !dom.isBlock(node[siblingName])) {
          node = node[siblingName];
          if (isEq$5(node, 'br')) {
            break;
          }
        }
      }
      return node || container;
    };
    var isAtBlockBoundary$1 = function (dom, root, container, siblingName) {
      var parent = container.parentNode;
      if (isNonNullable(container[siblingName])) {
        return false;
      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
        return true;
      } else {
        return isAtBlockBoundary$1(dom, root, parent, siblingName);
      }
    };
    var findParentContainer = function (dom, formatList, container, offset, start) {
      var parent = container;
      var siblingName = start ? 'previousSibling' : 'nextSibling';
      var root = dom.getRoot();
      if (isText$7(container) && !isWhiteSpaceNode(container)) {
        if (start ? offset > 0 : offset < container.data.length) {
          return container;
        }
      }
      while (true) {
        if (!formatList[0].block_expand && dom.isBlock(parent)) {
          return parent;
        }
        for (var sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
          var allowSpaces = isText$7(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);
          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {
            return parent;
          }
        }
        if (parent === root || parent.parentNode === root) {
          container = parent;
          break;
        }
        parent = parent.parentNode;
      }
      return container;
    };
    var isSelfOrParentBookmark = function (container) {
      return isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    };
    var expandRng = function (editor, rng, formatList, includeTrailingSpace) {
      if (includeTrailingSpace === void 0) {
        includeTrailingSpace = false;
      }
      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      var dom = editor.dom;
      var format = formatList[0];
      if (isElement$5(startContainer) && startContainer.hasChildNodes()) {
        startContainer = getNode$1(startContainer, startOffset);
        if (isText$7(startContainer)) {
          startOffset = 0;
        }
      }
      if (isElement$5(endContainer) && endContainer.hasChildNodes()) {
        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
        if (isText$7(endContainer)) {
          endOffset = endContainer.nodeValue.length;
        }
      }
      startContainer = findParentContentEditable(dom, startContainer);
      endContainer = findParentContentEditable(dom, endContainer);
      if (isSelfOrParentBookmark(startContainer)) {
        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
        if (rng.collapsed) {
          startContainer = startContainer.previousSibling || startContainer;
        } else {
          startContainer = startContainer.nextSibling || startContainer;
        }
        if (isText$7(startContainer)) {
          startOffset = rng.collapsed ? startContainer.length : 0;
        }
      }
      if (isSelfOrParentBookmark(endContainer)) {
        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
        if (rng.collapsed) {
          endContainer = endContainer.nextSibling || endContainer;
        } else {
          endContainer = endContainer.previousSibling || endContainer;
        }
        if (isText$7(endContainer)) {
          endOffset = rng.collapsed ? 0 : endContainer.length;
        }
      }
      if (rng.collapsed) {
        var startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);
        startPoint.each(function (_a) {
          var container = _a.container, offset = _a.offset;
          startContainer = container;
          startOffset = offset;
        });
        var endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);
        endPoint.each(function (_a) {
          var container = _a.container, offset = _a.offset;
          endContainer = container;
          endOffset = offset;
        });
      }
      if (isInlineFormat(format) || format.block_expand) {
        if (!isInlineFormat(format) || (!isText$7(startContainer) || startOffset === 0)) {
          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
        }
        if (!isInlineFormat(format) || (!isText$7(endContainer) || endOffset === endContainer.nodeValue.length)) {
          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
        }
      }
      if (shouldExpandToSelector(format)) {
        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');
        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');
      }
      if (isBlockFormat(format) || isSelectorFormat(format)) {
        startContainer = findBlockEndPoint(editor, formatList, startContainer, 'previousSibling');
        endContainer = findBlockEndPoint(editor, formatList, endContainer, 'nextSibling');
        if (isBlockFormat(format)) {
          if (!dom.isBlock(startContainer)) {
            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
          }
          if (!dom.isBlock(endContainer)) {
            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
          }
        }
      }
      if (isElement$5(startContainer)) {
        startOffset = dom.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (isElement$5(endContainer)) {
        endOffset = dom.nodeIndex(endContainer) + 1;
        endContainer = endContainer.parentNode;
      }
      return {
        startContainer: startContainer,
        startOffset: startOffset,
        endContainer: endContainer,
        endOffset: endOffset
      };
    };

    var walk$2 = function (dom, rng, callback) {
      var startOffset = rng.startOffset;
      var startContainer = getNode$1(rng.startContainer, startOffset);
      var endOffset = rng.endOffset;
      var endContainer = getNode$1(rng.endContainer, endOffset - 1);
      var exclude = function (nodes) {
        var firstNode = nodes[0];
        if (isText$7(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
          nodes.splice(0, 1);
        }
        var lastNode = nodes[nodes.length - 1];
        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$7(lastNode)) {
          nodes.splice(nodes.length - 1, 1);
        }
        return nodes;
      };
      var collectSiblings = function (node, name, endNode) {
        var siblings = [];
        for (; node && node !== endNode; node = node[name]) {
          siblings.push(node);
        }
        return siblings;
      };
      var findEndPoint = function (node, root) {
        return dom.getParent(node, function (node) {
          return node.parentNode === root;
        }, root);
      };
      var walkBoundary = function (startNode, endNode, next) {
        var siblingName = next ? 'nextSibling' : 'previousSibling';
        for (var node = startNode, parent_1 = node.parentNode; node && node !== endNode; node = parent_1) {
          parent_1 = node.parentNode;
          var siblings_1 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
          if (siblings_1.length) {
            if (!next) {
              siblings_1.reverse();
            }
            callback(exclude(siblings_1));
          }
        }
      };
      if (startContainer === endContainer) {
        return callback(exclude([startContainer]));
      }
      var ancestor = dom.findCommonAncestor(startContainer, endContainer);
      if (dom.isChildOf(startContainer, endContainer)) {
        return walkBoundary(startContainer, ancestor, true);
      }
      if (dom.isChildOf(endContainer, startContainer)) {
        return walkBoundary(endContainer, ancestor);
      }
      var startPoint = findEndPoint(startContainer, ancestor) || startContainer;
      var endPoint = findEndPoint(endContainer, ancestor) || endContainer;
      walkBoundary(startContainer, startPoint, true);
      var siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
      if (siblings.length) {
        callback(exclude(siblings));
      }
      walkBoundary(endContainer, endPoint);
    };

    var getRanges = function (selection) {
      var ranges = [];
      if (selection) {
        for (var i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
      }
      return ranges;
    };
    var getSelectedNodes = function (ranges) {
      return bind(ranges, function (range) {
        var node = getSelectedNode(range);
        return node ? [SugarElement.fromDom(node)] : [];
      });
    };
    var hasMultipleRanges = function (selection) {
      return getRanges(selection).length > 1;
    };

    var getCellsFromRanges = function (ranges) {
      return filter$4(getSelectedNodes(ranges), isTableCell$4);
    };
    var getCellsFromElement = function (elm) {
      return descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');
    };
    var getCellsFromElementOrRanges = function (ranges, element) {
      var selectedCells = getCellsFromElement(element);
      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    var getCellsFromEditor = function (editor) {
      return getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    };
    var getClosestTable = function (cell, isRoot) {
      return ancestor$2(cell, 'table', isRoot);
    };

    var getStartNode = function (rng) {
      var sc = rng.startContainer, so = rng.startOffset;
      if (isText$7(sc)) {
        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
      } else {
        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
      }
    };
    var getEndNode = function (rng) {
      var ec = rng.endContainer, eo = rng.endOffset;
      if (isText$7(ec)) {
        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
      } else {
        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
      }
    };
    var getFirstChildren = function (node) {
      return firstChild(node).fold(constant([node]), function (child) {
        return [node].concat(getFirstChildren(child));
      });
    };
    var getLastChildren$1 = function (node) {
      return lastChild(node).fold(constant([node]), function (child) {
        if (name(child) === 'br') {
          return prevSibling(child).map(function (sibling) {
            return [node].concat(getLastChildren$1(sibling));
          }).getOr([]);
        } else {
          return [node].concat(getLastChildren$1(child));
        }
      });
    };
    var hasAllContentsSelected = function (elm, rng) {
      return lift2(getStartNode(rng), getEndNode(rng), function (startNode, endNode) {
        var start = find$3(getFirstChildren(elm), curry(eq, startNode));
        var end = find$3(getLastChildren$1(elm), curry(eq, endNode));
        return start.isSome() && end.isSome();
      }).getOr(false);
    };
    var moveEndPoint = function (dom, rng, node, start) {
      var root = node, walker = new DomTreeWalker(node, root);
      var moveCaretBeforeOnEnterElementsMap = filter$3(dom.schema.getMoveCaretBeforeOnEnterElements(), function (_, name) {
        return !contains$3([
          'td',
          'th',
          'table'
        ], name.toLowerCase());
      });
      do {
        if (isText$7(node) && Tools.trim(node.nodeValue).length !== 0) {
          if (start) {
            rng.setStart(node, 0);
          } else {
            rng.setEnd(node, node.nodeValue.length);
          }
          return;
        }
        if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {
          if (start) {
            rng.setStartBefore(node);
          } else {
            if (node.nodeName === 'BR') {
              rng.setEndBefore(node);
            } else {
              rng.setEndAfter(node);
            }
          }
          return;
        }
      } while (node = start ? walker.next() : walker.prev());
      if (root.nodeName === 'BODY') {
        if (start) {
          rng.setStart(root, 0);
        } else {
          rng.setEnd(root, root.childNodes.length);
        }
      }
    };
    var hasAnyRanges = function (editor) {
      var sel = editor.selection.getSel();
      return sel && sel.rangeCount > 0;
    };
    var runOnRanges = function (editor, executor) {
      var fakeSelectionNodes = getCellsFromEditor(editor);
      if (fakeSelectionNodes.length > 0) {
        each$k(fakeSelectionNodes, function (elem) {
          var node = elem.dom;
          var fakeNodeRng = editor.dom.createRng();
          fakeNodeRng.setStartBefore(node);
          fakeNodeRng.setEndAfter(node);
          executor(fakeNodeRng, true);
        });
      } else {
        executor(editor.selection.getRng(), false);
      }
    };
    var preserve = function (selection, fillBookmark, executor) {
      var bookmark = getPersistentBookmark(selection, fillBookmark);
      executor(bookmark);
      selection.moveToBookmark(bookmark);
    };

    var NodeValue = function (is, name) {
      var get = function (element) {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      var getOption = function (element) {
        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      };
      var set = function (element, value) {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get: get,
        getOption: getOption,
        set: set
      };
    };

    var api$1 = NodeValue(isText$8, 'text');
    var get$2 = function (element) {
      return api$1.get(element);
    };

    var isZeroWidth = function (elem) {
      return isText$8(elem) && get$2(elem) === ZWSP$1;
    };
    var context = function (editor, elem, wrapName, nodeName) {
      return parent(elem).fold(function () {
        return 'skipping';
      }, function (parent) {
        if (nodeName === 'br' || isZeroWidth(elem)) {
          return 'valid';
        } else if (isAnnotation(elem)) {
          return 'existing';
        } else if (isCaretNode(elem.dom)) {
          return 'caret';
        } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
          return 'invalid-child';
        } else {
          return 'valid';
        }
      });
    };

    var applyWordGrab = function (editor, rng) {
      var r = expandRng(editor, rng, [{ inline: 'span' }]);
      rng.setStart(r.startContainer, r.startOffset);
      rng.setEnd(r.endContainer, r.endOffset);
      editor.selection.setRng(rng);
    };
    var makeAnnotation = function (eDoc, _a, annotationName, decorate) {
      var _b = _a.uid, uid = _b === void 0 ? generate('mce-annotation') : _b, data = __rest(_a, ['uid']);
      var master = SugarElement.fromTag('span', eDoc);
      add$1(master, annotation());
      set$1(master, '' + dataAnnotationId(), uid);
      set$1(master, '' + dataAnnotation(), annotationName);
      var _c = decorate(uid, data), _d = _c.attributes, attributes = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
      setAll$1(master, attributes);
      add(master, classes);
      return master;
    };
    var annotate = function (editor, rng, annotationName, decorate, data) {
      var newWrappers = [];
      var master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);
      var wrapper = value();
      var finishWrapper = function () {
        wrapper.clear();
      };
      var getOrOpenWrapper = function () {
        return wrapper.get().getOrThunk(function () {
          var nu = shallow(master);
          newWrappers.push(nu);
          wrapper.set(nu);
          return nu;
        });
      };
      var processElements = function (elems) {
        each$k(elems, processElement);
      };
      var processElement = function (elem) {
        var ctx = context(editor, elem, 'span', name(elem));
        switch (ctx) {
        case 'invalid-child': {
            finishWrapper();
            var children$1 = children(elem);
            processElements(children$1);
            finishWrapper();
            break;
          }
        case 'valid': {
            var w = getOrOpenWrapper();
            wrap$3(elem, w);
            break;
          }
        }
      };
      var processNodes = function (nodes) {
        var elems = map$3(nodes, SugarElement.fromDom);
        processElements(elems);
      };
      walk$2(editor.dom, rng, function (nodes) {
        finishWrapper();
        processNodes(nodes);
      });
      return newWrappers;
    };
    var annotateWithBookmark = function (editor, name, settings, data) {
      editor.undoManager.transact(function () {
        var selection = editor.selection;
        var initialRng = selection.getRng();
        var hasFakeSelection = getCellsFromEditor(editor).length > 0;
        if (initialRng.collapsed && !hasFakeSelection) {
          applyWordGrab(editor, initialRng);
        }
        if (selection.getRng().collapsed && !hasFakeSelection) {
          var wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);
          set(wrapper, nbsp);
          selection.getRng().insertNode(wrapper.dom);
          selection.select(wrapper.dom);
        } else {
          preserve(selection, false, function () {
            runOnRanges(editor, function (selectionRng) {
              annotate(editor, selectionRng, name, settings.decorate, data);
            });
          });
        }
      });
    };

    var Annotator = function (editor) {
      var registry = create$7();
      setup$m(editor, registry);
      var changes = setup$n(editor);
      return {
        register: function (name, settings) {
          registry.register(name, settings);
        },
        annotate: function (name, data) {
          registry.lookup(name).each(function (settings) {
            annotateWithBookmark(editor, name, settings, data);
          });
        },
        annotationChanged: function (name, callback) {
          changes.addListener(name, callback);
        },
        remove: function (name) {
          identify(editor, Optional.some(name)).each(function (_a) {
            var elements = _a.elements;
            each$k(elements, unwrap);
          });
        },
        getAll: function (name) {
          var directory = findAll(editor, name);
          return map$2(directory, function (elems) {
            return map$3(elems, function (elem) {
              return elem.dom;
            });
          });
        }
      };
    };

    var BookmarkManager = function (selection) {
      return {
        getBookmark: curry(getBookmark$1, selection),
        moveToBookmark: curry(moveToBookmark, selection)
      };
    };
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;

    var getContentEditableRoot$1 = function (root, node) {
      while (node && node !== root) {
        if (isContentEditableTrue$4(node) || isContentEditableFalse$b(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };

    var isXYWithinRange = function (clientX, clientY, range) {
      if (range.collapsed) {
        return false;
      }
      if (Env.browser.isIE() && range.startOffset === range.endOffset - 1 && range.startContainer === range.endContainer) {
        var elm = range.startContainer.childNodes[range.startOffset];
        if (isElement$5(elm)) {
          return exists(elm.getClientRects(), function (rect) {
            return containsXY(rect, clientX, clientY);
          });
        }
      }
      return exists(range.getClientRects(), function (rect) {
        return containsXY(rect, clientX, clientY);
      });
    };

    var firePreProcess = function (editor, args) {
      return editor.fire('PreProcess', args);
    };
    var firePostProcess = function (editor, args) {
      return editor.fire('PostProcess', args);
    };
    var fireRemove = function (editor) {
      return editor.fire('remove');
    };
    var fireDetach = function (editor) {
      return editor.fire('detach');
    };
    var fireSwitchMode = function (editor, mode) {
      return editor.fire('SwitchMode', { mode: mode });
    };
    var fireObjectResizeStart = function (editor, target, width, height, origin) {
      editor.fire('ObjectResizeStart', {
        target: target,
        width: width,
        height: height,
        origin: origin
      });
    };
    var fireObjectResized = function (editor, target, width, height, origin) {
      editor.fire('ObjectResized', {
        target: target,
        width: width,
        height: height,
        origin: origin
      });
    };
    var firePreInit = function (editor) {
      return editor.fire('PreInit');
    };
    var firePostRender = function (editor) {
      return editor.fire('PostRender');
    };
    var fireInit = function (editor) {
      return editor.fire('Init');
    };
    var firePlaceholderToggle = function (editor, state) {
      return editor.fire('PlaceholderToggle', { state: state });
    };
    var fireError = function (editor, errorType, error) {
      return editor.fire(errorType, error);
    };
    var fireFormatApply = function (editor, format, node, vars) {
      return editor.fire('FormatApply', {
        format: format,
        node: node,
        vars: vars
      });
    };
    var fireFormatRemove = function (editor, format, node, vars) {
      return editor.fire('FormatRemove', {
        format: format,
        node: node,
        vars: vars
      });
    };

    var VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: function (e) {
        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
      },
      metaKeyPressed: function (e) {
        return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
      }
    };

    var isContentEditableFalse$5 = isContentEditableFalse$b;
    var ControlSelection = function (selection, editor) {
      var elementSelectionAttr = 'data-mce-selected';
      var dom = editor.dom, each = Tools.each;
      var selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
      var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      var width, height;
      var editableDoc = editor.getDoc(), rootDocument = document;
      var abs = Math.abs, round = Math.round, rootElement = editor.getBody();
      var startScrollWidth, startScrollHeight;
      var resizeHandles = {
        nw: [
          0,
          0,
          -1,
          -1
        ],
        ne: [
          1,
          0,
          1,
          -1
        ],
        se: [
          1,
          1,
          1,
          1
        ],
        sw: [
          0,
          1,
          -1,
          1
        ]
      };
      var isImage = function (elm) {
        return elm && (elm.nodeName === 'IMG' || editor.dom.is(elm, 'figure.image'));
      };
      var isMedia = function (elm) {
        return isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');
      };
      var isEventOnImageOutsideRange = function (evt, range) {
        if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {
          var touch = evt.touches[0];
          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
        } else {
          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
        }
      };
      var contextMenuSelectImage = function (evt) {
        var target = evt.target;
        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
          editor.selection.select(target);
        }
      };
      var getResizeTargets = function (elm) {
        if (dom.is(elm, 'figure.image')) {
          return [elm.querySelector('img')];
        } else if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
          return [
            elm,
            elm.firstElementChild
          ];
        } else {
          return [elm];
        }
      };
      var isResizable = function (elm) {
        var selector = getObjectResizing(editor);
        if (!selector) {
          return false;
        }
        if (elm.getAttribute('data-mce-resize') === 'false') {
          return false;
        }
        if (elm === editor.getBody()) {
          return false;
        }
        if (dom.hasClass(elm, 'mce-preview-object')) {
          return is$2(SugarElement.fromDom(elm.firstElementChild), selector);
        } else {
          return is$2(SugarElement.fromDom(elm), selector);
        }
      };
      var createGhostElement = function (elm) {
        if (isMedia(elm)) {
          return dom.create('img', { src: Env.transparentSrc });
        } else {
          return elm.cloneNode(true);
        }
      };
      var setSizeProp = function (element, name, value) {
        if (isNonNullable(value)) {
          var targets = getResizeTargets(element);
          each$k(targets, function (target) {
            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {
              dom.setStyle(target, name, value);
            } else {
              dom.setAttrib(target, name, '' + value);
            }
          });
        }
      };
      var setGhostElmSize = function (ghostElm, width, height) {
        setSizeProp(ghostElm, 'width', width);
        setSizeProp(ghostElm, 'height', height);
      };
      var resizeGhostElement = function (e) {
        var deltaX, deltaY, proportional;
        var resizeHelperX, resizeHelperY;
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;
        width = deltaX * selectedHandle[2] + startW;
        height = deltaY * selectedHandle[3] + startH;
        width = width < 5 ? 5 : width;
        height = height < 5 ? 5 : height;
        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e);
        }
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height = round(width * ratio);
            width = round(height / ratio);
          } else {
            width = round(height / ratio);
            height = round(width * ratio);
          }
        }
        setGhostElmSize(selectedElmGhost, width, height);
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
        dom.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: 'block'
        });
        resizeHelper.innerHTML = width + ' &times; ' + height;
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
        }
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
        }
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;
        if (deltaX + deltaY !== 0) {
          dom.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }
        if (!resizeStarted) {
          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);
          resizeStarted = true;
        }
      };
      var endGhostResize = function () {
        var wasResizeStarted = resizeStarted;
        resizeStarted = false;
        if (wasResizeStarted) {
          setSizeProp(selectedElm, 'width', width);
          setSizeProp(selectedElm, 'height', height);
        }
        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
        dom.unbind(editableDoc, 'mouseup', endGhostResize);
        if (rootDocument !== editableDoc) {
          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
          dom.unbind(rootDocument, 'mouseup', endGhostResize);
        }
        dom.remove(selectedElmGhost);
        dom.remove(resizeHelper);
        dom.remove(resizeBackdrop);
        showResizeRect(selectedElm);
        if (wasResizeStarted) {
          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);
          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
        }
        editor.nodeChanged();
      };
      var showResizeRect = function (targetElm) {
        unbindResizeHandleEvents();
        var position = dom.getPos(targetElm, rootElement);
        var selectedElmX = position.x;
        var selectedElmY = position.y;
        var rect = targetElm.getBoundingClientRect();
        var targetWidth = rect.width || rect.right - rect.left;
        var targetHeight = rect.height || rect.bottom - rect.top;
        if (selectedElm !== targetElm) {
          hideResizeRect();
          selectedElm = targetElm;
          width = height = 0;
        }
        var e = editor.fire('ObjectSelected', { target: targetElm });
        var selectedValue = dom.getAttrib(selectedElm, elementSelectionAttr, '1');
        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
          each(resizeHandles, function (handle, name) {
            var handleElm;
            var startDrag = function (e) {
              var target = getResizeTargets(selectedElm)[0];
              startX = e.screenX;
              startY = e.screenY;
              startW = target.clientWidth;
              startH = target.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle;
              selectedHandle.name = name;
              selectedHandle.startPos = {
                x: targetWidth * handle[0] + selectedElmX,
                y: targetHeight * handle[1] + selectedElmY
              };
              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;
              resizeBackdrop = dom.add(rootElement, 'div', {
                'class': 'mce-resize-backdrop',
                'data-mce-bogus': 'all'
              });
              dom.setStyles(resizeBackdrop, {
                position: 'fixed',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%'
              });
              selectedElmGhost = createGhostElement(selectedElm);
              dom.addClass(selectedElmGhost, 'mce-clonedresizable');
              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
              selectedElmGhost.contentEditable = 'false';
              dom.setStyles(selectedElmGhost, {
                left: selectedElmX,
                top: selectedElmY,
                margin: 0
              });
              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
              selectedElmGhost.removeAttribute(elementSelectionAttr);
              rootElement.appendChild(selectedElmGhost);
              dom.bind(editableDoc, 'mousemove', resizeGhostElement);
              dom.bind(editableDoc, 'mouseup', endGhostResize);
              if (rootDocument !== editableDoc) {
                dom.bind(rootDocument, 'mousemove', resizeGhostElement);
                dom.bind(rootDocument, 'mouseup', endGhostResize);
              }
              resizeHelper = dom.add(rootElement, 'div', {
                'class': 'mce-resize-helper',
                'data-mce-bogus': 'all'
              }, startW + ' &times; ' + startH);
            };
            handleElm = dom.get('mceResizeHandle' + name);
            if (handleElm) {
              dom.remove(handleElm);
            }
            handleElm = dom.add(rootElement, 'div', {
              'id': 'mceResizeHandle' + name,
              'data-mce-bogus': 'all',
              'class': 'mce-resizehandle',
              'unselectable': true,
              'style': 'cursor:' + name + '-resize; margin:0; padding:0'
            });
            if (Env.ie === 11) {
              handleElm.contentEditable = false;
            }
            dom.bind(handleElm, 'mousedown', function (e) {
              e.stopImmediatePropagation();
              e.preventDefault();
              startDrag(e);
            });
            handle.elm = handleElm;
            dom.setStyles(handleElm, {
              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
            });
          });
        } else {
          hideResizeRect();
        }
        if (!dom.getAttrib(selectedElm, elementSelectionAttr)) {
          selectedElm.setAttribute(elementSelectionAttr, selectedValue);
        }
      };
      var hideResizeRect = function () {
        unbindResizeHandleEvents();
        if (selectedElm) {
          selectedElm.removeAttribute(elementSelectionAttr);
        }
        each$j(resizeHandles, function (value, name) {
          var handleElm = dom.get('mceResizeHandle' + name);
          if (handleElm) {
            dom.unbind(handleElm);
            dom.remove(handleElm);
          }
        });
      };
      var updateResizeRect = function (e) {
        var startElm, controlElm;
        var isChildOrEqual = function (node, parent) {
          if (node) {
            do {
              if (node === parent) {
                return true;
              }
            } while (node = node.parentNode);
          }
        };
        if (resizeStarted || editor.removed) {
          return;
        }
        each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), function (img) {
          img.removeAttribute(elementSelectionAttr);
        });
        controlElm = e.type === 'mousedown' ? e.target : selection.getNode();
        controlElm = dom.$(controlElm).closest('table,img,figure.image,hr,video,span.mce-preview-object')[0];
        if (isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          startElm = selection.getStart(true);
          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            showResizeRect(controlElm);
            return;
          }
        }
        hideResizeRect();
      };
      var isWithinContentEditableFalse = function (elm) {
        return isContentEditableFalse$5(getContentEditableRoot$1(editor.getBody(), elm));
      };
      var unbindResizeHandleEvents = function () {
        each$j(resizeHandles, function (handle) {
          if (handle.elm) {
            dom.unbind(handle.elm);
            delete handle.elm;
          }
        });
      };
      var disableGeckoResize = function () {
        try {
          editor.getDoc().execCommand('enableObjectResizing', false, 'false');
        } catch (ex) {
        }
      };
      editor.on('init', function () {
        disableGeckoResize();
        if (Env.browser.isIE() || Env.browser.isEdge()) {
          editor.on('mousedown click', function (e) {
            var target = e.target, nodeName = target.nodeName;
            if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
              if (e.button !== 2) {
                editor.selection.select(target, nodeName === 'TABLE');
              }
              if (e.type === 'mousedown') {
                editor.nodeChanged();
              }
            }
          });
          var handleMSControlSelect_1 = function (e) {
            var delayedSelect = function (node) {
              Delay.setEditorTimeout(editor, function () {
                return editor.selection.select(node);
              });
            };
            if (isWithinContentEditableFalse(e.target) || isMedia$2(e.target)) {
              e.preventDefault();
              delayedSelect(e.target);
              return;
            }
            if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
              e.preventDefault();
              if (e.target.tagName === 'IMG') {
                delayedSelect(e.target);
              }
            }
          };
          dom.bind(rootElement, 'mscontrolselect', handleMSControlSelect_1);
          editor.on('remove', function () {
            return dom.unbind(rootElement, 'mscontrolselect', handleMSControlSelect_1);
          });
        }
        var throttledUpdateResizeRect = Delay.throttle(function (e) {
          if (!editor.composing) {
            updateResizeRect(e);
          }
        });
        editor.on('nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged', throttledUpdateResizeRect);
        editor.on('keyup compositionend', function (e) {
          if (selectedElm && selectedElm.nodeName === 'TABLE') {
            throttledUpdateResizeRect(e);
          }
        });
        editor.on('hide blur', hideResizeRect);
        editor.on('contextmenu longpress', contextMenuSelectImage, true);
      });
      editor.on('remove', unbindResizeHandleEvents);
      var destroy = function () {
        selectedElm = selectedElmGhost = resizeBackdrop = null;
      };
      return {
        isResizable: isResizable,
        showResizeRect: showResizeRect,
        hideResizeRect: hideResizeRect,
        updateResizeRect: updateResizeRect,
        destroy: destroy
      };
    };

    var hasCeProperty = function (node) {
      return isContentEditableTrue$4(node) || isContentEditableFalse$b(node);
    };
    var findParent$1 = function (node, rootNode, predicate) {
      while (node && node !== rootNode) {
        if (predicate(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var findClosestIeRange = function (clientX, clientY, doc) {
      var rects;
      var element = doc.elementFromPoint(clientX, clientY);
      var rng = doc.body.createTextRange();
      if (!element || element.tagName === 'HTML') {
        element = doc.body;
      }
      rng.moveToElementText(element);
      rects = Tools.toArray(rng.getClientRects());
      rects = rects.sort(function (a, b) {
        a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
        b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
        return a - b;
      });
      if (rects.length > 0) {
        clientY = (rects[0].bottom + rects[0].top) / 2;
        try {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(true);
          return rng;
        } catch (ex) {
        }
      }
      return null;
    };
    var moveOutOfContentEditableFalse = function (rng, rootNode) {
      var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
      return isContentEditableFalse$b(findParent$1(parentElement, rootNode, hasCeProperty)) ? null : rng;
    };
    var fromPoint = function (clientX, clientY, doc) {
      var rng, point;
      var pointDoc = doc;
      if (pointDoc.caretPositionFromPoint) {
        point = pointDoc.caretPositionFromPoint(clientX, clientY);
        if (point) {
          rng = doc.createRange();
          rng.setStart(point.offsetNode, point.offset);
          rng.collapse(true);
        }
      } else if (pointDoc.caretRangeFromPoint) {
        rng = pointDoc.caretRangeFromPoint(clientX, clientY);
      } else if (pointDoc.body.createTextRange) {
        rng = pointDoc.body.createTextRange();
        try {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(true);
        } catch (ex) {
          rng = findClosestIeRange(clientX, clientY, doc);
        }
        return moveOutOfContentEditableFalse(rng, doc.body);
      }
      return rng;
    };

    var isEq$4 = function (rng1, rng2) {
      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };

    var findParent = function (node, rootNode, predicate) {
      while (node && node !== rootNode) {
        if (predicate(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var hasParent$1 = function (node, rootNode, predicate) {
      return findParent(node, rootNode, predicate) !== null;
    };
    var hasParentWithName = function (node, rootNode, name) {
      return hasParent$1(node, rootNode, function (node) {
        return node.nodeName === name;
      });
    };
    var isTable = function (node) {
      return node && node.nodeName === 'TABLE';
    };
    var isTableCell$2 = function (node) {
      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
    };
    var isCeFalseCaretContainer = function (node, rootNode) {
      return isCaretContainer$2(node) && hasParent$1(node, rootNode, isCaretNode) === false;
    };
    var hasBrBeforeAfter = function (dom, node, left) {
      var walker = new DomTreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());
      while (node = walker[left ? 'prev' : 'next']()) {
        if (isBr$5(node)) {
          return true;
        }
      }
    };
    var isPrevNode = function (node, name) {
      return node.previousSibling && node.previousSibling.nodeName === name;
    };
    var hasContentEditableFalseParent = function (body, node) {
      while (node && node !== body) {
        if (isContentEditableFalse$b(node)) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    };
    var findTextNodeRelative = function (dom, isAfterNode, collapsed, left, startNode) {
      var lastInlineElement;
      var body = dom.getRoot();
      var node;
      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      var parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;
      if (left && isBr$5(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
        return Optional.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));
      }
      var walker = new DomTreeWalker(startNode, parentBlockContainer);
      while (node = walker[left ? 'prev' : 'next']()) {
        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
          return Optional.none();
        }
        if (isText$7(node) && node.nodeValue.length > 0) {
          if (hasParentWithName(node, body, 'A') === false) {
            return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));
          }
          return Optional.none();
        }
        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          return Optional.none();
        }
        lastInlineElement = node;
      }
      if (collapsed && lastInlineElement) {
        return Optional.some(CaretPosition(lastInlineElement, 0));
      }
      return Optional.none();
    };
    var normalizeEndPoint = function (dom, collapsed, start, rng) {
      var container, offset;
      var body = dom.getRoot();
      var node;
      var directionLeft, normalized = false;
      container = rng[(start ? 'start' : 'end') + 'Container'];
      offset = rng[(start ? 'start' : 'end') + 'Offset'];
      var isAfterNode = isElement$5(container) && offset === container.childNodes.length;
      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      directionLeft = start;
      if (isCaretContainer$2(container)) {
        return Optional.none();
      }
      if (isElement$5(container) && offset > container.childNodes.length - 1) {
        directionLeft = false;
      }
      if (isDocument$1(container)) {
        container = body;
        offset = 0;
      }
      if (container === body) {
        if (directionLeft) {
          node = container.childNodes[offset > 0 ? offset - 1 : 0];
          if (node) {
            if (isCaretContainer$2(node)) {
              return Optional.none();
            }
            if (nonEmptyElementsMap[node.nodeName] || isTable(node)) {
              return Optional.none();
            }
          }
        }
        if (container.hasChildNodes()) {
          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
          container = container.childNodes[offset];
          offset = isText$7(container) && isAfterNode ? container.data.length : 0;
          if (!collapsed && container === body.lastChild && isTable(container)) {
            return Optional.none();
          }
          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
            return Optional.none();
          }
          if (container.hasChildNodes() && isTable(container) === false) {
            node = container;
            var walker = new DomTreeWalker(container, body);
            do {
              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
                normalized = false;
                break;
              }
              if (isText$7(node) && node.nodeValue.length > 0) {
                offset = directionLeft ? 0 : node.nodeValue.length;
                container = node;
                normalized = true;
                break;
              }
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {
                offset = dom.nodeIndex(node);
                container = node.parentNode;
                if (!directionLeft) {
                  offset++;
                }
                normalized = true;
                break;
              }
            } while (node = directionLeft ? walker.next() : walker.prev());
          }
        }
      }
      if (collapsed) {
        if (isText$7(container) && offset === 0) {
          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(function (pos) {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          });
        }
        if (isElement$5(container)) {
          node = container.childNodes[offset];
          if (!node) {
            node = container.childNodes[offset - 1];
          }
          if (node && isBr$5(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(function (pos) {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
        }
      }
      if (directionLeft && !collapsed && isText$7(container) && offset === container.nodeValue.length) {
        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(function (pos) {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
      return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    var normalize$2 = function (dom, rng) {
      var collapsed = rng.collapsed, normRng = rng.cloneRange();
      var startPos = CaretPosition.fromRangeStart(rng);
      normalizeEndPoint(dom, collapsed, true, normRng).each(function (pos) {
        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
          normRng.setStart(pos.container(), pos.offset());
        }
      });
      if (!collapsed) {
        normalizeEndPoint(dom, collapsed, false, normRng).each(function (pos) {
          normRng.setEnd(pos.container(), pos.offset());
        });
      }
      if (collapsed) {
        normRng.collapse(true);
      }
      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };

    var splitText = function (node, offset) {
      return node.splitText(offset);
    };
    var split = function (rng) {
      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      if (startContainer === endContainer && isText$7(startContainer)) {
        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
          endContainer = splitText(startContainer, startOffset);
          startContainer = endContainer.previousSibling;
          if (endOffset > startOffset) {
            endOffset = endOffset - startOffset;
            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
            endOffset = endContainer.nodeValue.length;
            startOffset = 0;
          } else {
            endOffset = 0;
          }
        }
      } else {
        if (isText$7(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
          startContainer = splitText(startContainer, startOffset);
          startOffset = 0;
        }
        if (isText$7(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
          endContainer = splitText(endContainer, endOffset).previousSibling;
          endOffset = endContainer.nodeValue.length;
        }
      }
      return {
        startContainer: startContainer,
        startOffset: startOffset,
        endContainer: endContainer,
        endOffset: endOffset
      };
    };

    var RangeUtils = function (dom) {
      var walk = function (rng, callback) {
        return walk$2(dom, rng, callback);
      };
      var split$1 = split;
      var normalize = function (rng) {
        return normalize$2(dom, rng).fold(never, function (normalizedRng) {
          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
          return true;
        });
      };
      return {
        walk: walk,
        split: split$1,
        normalize: normalize
      };
    };
    RangeUtils.compareRanges = isEq$4;
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;

    var Dimension = function (name, getOffset) {
      var set = function (element, h) {
        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
        }
        var dom = element.dom;
        if (isSupported(dom)) {
          dom.style[name] = h + 'px';
        }
      };
      var get = function (element) {
        var r = getOffset(element);
        if (r <= 0 || r === null) {
          var css = get$5(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      var getOuter = get;
      var aggregate = function (element, properties) {
        return foldl(properties, function (acc, property) {
          var val = get$5(element, property);
          var value = val === undefined ? 0 : parseInt(val, 10);
          return isNaN(value) ? acc : acc + value;
        }, 0);
      };
      var max = function (element, value, properties) {
        var cumulativeInclusions = aggregate(element, properties);
        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set,
        get: get,
        getOuter: getOuter,
        aggregate: aggregate,
        max: max
      };
    };

    var api = Dimension('height', function (element) {
      var dom = element.dom;
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    var get$1 = function (element) {
      return api.get(element);
    };

    var walkUp = function (navigation, doc) {
      var frame = navigation.view(doc);
      return frame.fold(constant([]), function (f) {
        var parent = navigation.owner(f);
        var rest = walkUp(navigation, parent);
        return [f].concat(rest);
      });
    };
    var pathTo = function (element, navigation) {
      var d = navigation.owner(element);
      return walkUp(navigation, d);
    };

    var view = function (doc) {
      var _a;
      var element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    var owner = function (element) {
      return documentOrOwner(element);
    };

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner
    });

    var find$1 = function (element) {
      var doc = SugarElement.fromDom(document);
      var scroll = get$8(doc);
      var frames = pathTo(element, Navigation);
      var offset = viewport(element);
      var r = foldr(frames, function (b, a) {
        var loc = viewport(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    };

    var excludeFromDescend = function (element) {
      return name(element) === 'textarea';
    };
    var fireScrollIntoViewEvent = function (editor, data) {
      var scrollEvent = editor.fire('ScrollIntoView', data);
      return scrollEvent.isDefaultPrevented();
    };
    var fireAfterScrollIntoViewEvent = function (editor, data) {
      editor.fire('AfterScrollIntoView', data);
    };
    var descend = function (element, offset) {
      var children$1 = children(element);
      if (children$1.length === 0 || excludeFromDescend(element)) {
        return {
          element: element,
          offset: offset
        };
      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {
        return {
          element: children$1[offset],
          offset: 0
        };
      } else {
        var last = children$1[children$1.length - 1];
        if (excludeFromDescend(last)) {
          return {
            element: element,
            offset: offset
          };
        } else {
          if (name(last) === 'img') {
            return {
              element: last,
              offset: 1
            };
          } else if (isText$8(last)) {
            return {
              element: last,
              offset: get$2(last).length
            };
          } else {
            return {
              element: last,
              offset: children(last).length
            };
          }
        }
      }
    };
    var markerInfo = function (element, cleanupFun) {
      var pos = absolute(element);
      var height = get$1(element);
      return {
        element: element,
        bottom: pos.top + height,
        height: height,
        pos: pos,
        cleanup: cleanupFun
      };
    };
    var createMarker = function (element, offset) {
      var startPoint = descend(element, offset);
      var span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + '</span>');
      before$4(startPoint.element, span);
      return markerInfo(span, function () {
        return remove$7(span);
      });
    };
    var elementMarker = function (element) {
      return markerInfo(SugarElement.fromDom(element), noop);
    };
    var withMarker = function (editor, f, rng, alignToTop) {
      preserveWith(editor, function (_s, _e) {
        return applyWithMarker(editor, f, rng, alignToTop);
      }, rng);
    };
    var withScrollEvents = function (editor, doc, f, marker, alignToTop) {
      var data = {
        elm: marker.element.dom,
        alignToTop: alignToTop
      };
      if (fireScrollIntoViewEvent(editor, data)) {
        return;
      }
      var scrollTop = get$8(doc).top;
      f(doc, scrollTop, marker, alignToTop);
      fireAfterScrollIntoViewEvent(editor, data);
    };
    var applyWithMarker = function (editor, f, rng, alignToTop) {
      var body = SugarElement.fromDom(editor.getBody());
      var doc = SugarElement.fromDom(editor.getDoc());
      reflow(body);
      var marker = createMarker(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      withScrollEvents(editor, doc, f, marker, alignToTop);
      marker.cleanup();
    };
    var withElement = function (editor, element, f, alignToTop) {
      var doc = SugarElement.fromDom(editor.getDoc());
      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    var preserveWith = function (editor, f, rng) {
      var startElement = rng.startContainer;
      var startOffset = rng.startOffset;
      var endElement = rng.endContainer;
      var endOffset = rng.endOffset;
      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
      var newRng = editor.dom.createRng();
      newRng.setStart(startElement, startOffset);
      newRng.setEnd(endElement, endOffset);
      editor.selection.setRng(rng);
    };
    var scrollToMarker = function (marker, viewHeight, alignToTop, doc) {
      var pos = marker.pos;
      if (alignToTop) {
        to(pos.left, pos.top, doc);
      } else {
        var y = pos.top - viewHeight + marker.height;
        to(pos.left, y, doc);
      }
    };
    var intoWindowIfNeeded = function (doc, scrollTop, viewHeight, marker, alignToTop) {
      var viewportBottom = viewHeight + scrollTop;
      var markerTop = marker.pos.top;
      var markerBottom = marker.bottom;
      var largerThanViewport = markerBottom - markerTop >= viewHeight;
      if (markerTop < scrollTop) {
        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);
      } else if (markerTop > viewportBottom) {
        var align = largerThanViewport ? alignToTop !== false : alignToTop === true;
        scrollToMarker(marker, viewHeight, align, doc);
      } else if (markerBottom > viewportBottom && !largerThanViewport) {
        scrollToMarker(marker, viewHeight, alignToTop === true, doc);
      }
    };
    var intoWindow = function (doc, scrollTop, marker, alignToTop) {
      var viewHeight = doc.dom.defaultView.innerHeight;
      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);
    };
    var intoFrame = function (doc, scrollTop, marker, alignToTop) {
      var frameViewHeight = doc.dom.defaultView.innerHeight;
      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);
      var op = find$1(marker.element);
      var viewportBounds = getBounds(window);
      if (op.top < viewportBounds.y) {
        intoView(marker.element, alignToTop !== false);
      } else if (op.top > viewportBounds.bottom) {
        intoView(marker.element, alignToTop === true);
      }
    };
    var rangeIntoWindow = function (editor, rng, alignToTop) {
      return withMarker(editor, intoWindow, rng, alignToTop);
    };
    var elementIntoWindow = function (editor, element, alignToTop) {
      return withElement(editor, element, intoWindow, alignToTop);
    };
    var rangeIntoFrame = function (editor, rng, alignToTop) {
      return withMarker(editor, intoFrame, rng, alignToTop);
    };
    var elementIntoFrame = function (editor, element, alignToTop) {
      return withElement(editor, element, intoFrame, alignToTop);
    };
    var scrollElementIntoView = function (editor, element, alignToTop) {
      var scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
      scroller(editor, element, alignToTop);
    };
    var scrollRangeIntoView = function (editor, rng, alignToTop) {
      var scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
      scroller(editor, rng, alignToTop);
    };

    var getDocument = function () {
      return SugarElement.fromDom(document);
    };

    var focus$1 = function (element) {
      return element.dom.focus();
    };
    var hasFocus$1 = function (element) {
      var root = getRootNode(element).dom;
      return element.dom === root.activeElement;
    };
    var active = function (root) {
      if (root === void 0) {
        root = getDocument();
      }
      return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    };
    var search = function (element) {
      return active(getRootNode(element)).filter(function (e) {
        return element.dom.contains(e.dom);
      });
    };

    var create$5 = function (start, soffset, finish, foffset) {
      return {
        start: start,
        soffset: soffset,
        finish: finish,
        foffset: foffset
      };
    };
    var SimRange = { create: create$5 };

    var adt$1 = Adt.generate([
      { before: ['element'] },
      {
        on: [
          'element',
          'offset'
        ]
      },
      { after: ['element'] }
    ]);
    var cata = function (subject, onBefore, onOn, onAfter) {
      return subject.fold(onBefore, onOn, onAfter);
    };
    var getStart$2 = function (situ) {
      return situ.fold(identity, identity, identity);
    };
    var before$1 = adt$1.before;
    var on = adt$1.on;
    var after$1 = adt$1.after;
    var Situ = {
      before: before$1,
      on: on,
      after: after$1,
      cata: cata,
      getStart: getStart$2
    };

    var adt = Adt.generate([
      { domRange: ['rng'] },
      {
        relative: [
          'startSitu',
          'finishSitu'
        ]
      },
      {
        exact: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    var exactFromRange = function (simRange) {
      return adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    };
    var getStart$1 = function (selection) {
      return selection.match({
        domRange: function (rng) {
          return SugarElement.fromDom(rng.startContainer);
        },
        relative: function (startSitu, _finishSitu) {
          return Situ.getStart(startSitu);
        },
        exact: function (start, _soffset, _finish, _foffset) {
          return start;
        }
      });
    };
    var domRange = adt.domRange;
    var relative = adt.relative;
    var exact = adt.exact;
    var getWin = function (selection) {
      var start = getStart$1(selection);
      return defaultView(start);
    };
    var range = SimRange.create;
    var SimSelection = {
      domRange: domRange,
      relative: relative,
      exact: exact,
      exactFromRange: exactFromRange,
      getWin: getWin,
      range: range
    };

    var browser$1 = detect().browser;
    var clamp$1 = function (offset, element) {
      var max = isText$8(element) ? get$2(element).length : children(element).length + 1;
      if (offset > max) {
        return max;
      } else if (offset < 0) {
        return 0;
      }
      return offset;
    };
    var normalizeRng = function (rng) {
      return SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    };
    var isOrContains = function (root, elm) {
      return !isRestrictedNode(elm.dom) && (contains$1(root, elm) || eq(root, elm));
    };
    var isRngInRoot = function (root) {
      return function (rng) {
        return isOrContains(root, rng.start) && isOrContains(root, rng.finish);
      };
    };
    var shouldStore = function (editor) {
      return editor.inline === true || browser$1.isIE();
    };
    var nativeRangeToSelectionRange = function (r) {
      return SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    };
    var readRange = function (win) {
      var selection = win.getSelection();
      var rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
      return rng.map(nativeRangeToSelectionRange);
    };
    var getBookmark = function (root) {
      var win = defaultView(root);
      return readRange(win.dom).filter(isRngInRoot(root));
    };
    var validate = function (root, bookmark) {
      return Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
    };
    var bookmarkToNativeRng = function (bookmark) {
      var rng = document.createRange();
      try {
        rng.setStart(bookmark.start.dom, bookmark.soffset);
        rng.setEnd(bookmark.finish.dom, bookmark.foffset);
        return Optional.some(rng);
      } catch (_) {
        return Optional.none();
      }
    };
    var store = function (editor) {
      var newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    var storeNative = function (editor, rng) {
      var root = SugarElement.fromDom(editor.getBody());
      var range = shouldStore(editor) ? Optional.from(rng) : Optional.none();
      var newBookmark = range.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    var getRng = function (editor) {
      var bookmark = editor.bookmark ? editor.bookmark : Optional.none();
      return bookmark.bind(function (x) {
        return validate(SugarElement.fromDom(editor.getBody()), x);
      }).bind(bookmarkToNativeRng);
    };
    var restore = function (editor) {
      getRng(editor).each(function (rng) {
        return editor.selection.setRng(rng);
      });
    };

    var isEditorUIElement$1 = function (elm) {
      var className = elm.className.toString();
      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
    };
    var FocusManager = { isEditorUIElement: isEditorUIElement$1 };

    var isManualNodeChange = function (e) {
      return e.type === 'nodechange' && e.selectionChange;
    };
    var registerPageMouseUp = function (editor, throttledStore) {
      var mouseUpPage = function () {
        throttledStore.throttle();
      };
      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);
      editor.on('remove', function () {
        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);
      });
    };
    var registerFocusOut = function (editor) {
      editor.on('focusout', function () {
        store(editor);
      });
    };
    var registerMouseUp = function (editor, throttledStore) {
      editor.on('mouseup touchend', function (_e) {
        throttledStore.throttle();
      });
    };
    var registerEditorEvents = function (editor, throttledStore) {
      var browser = detect().browser;
      if (browser.isIE()) {
        registerFocusOut(editor);
      } else {
        registerMouseUp(editor, throttledStore);
      }
      editor.on('keyup NodeChange', function (e) {
        if (!isManualNodeChange(e)) {
          store(editor);
        }
      });
    };
    var register$3 = function (editor) {
      var throttledStore = first(function () {
        store(editor);
      }, 0);
      editor.on('init', function () {
        if (editor.inline) {
          registerPageMouseUp(editor, throttledStore);
        }
        registerEditorEvents(editor, throttledStore);
      });
      editor.on('remove', function () {
        throttledStore.cancel();
      });
    };

    var documentFocusInHandler;
    var DOM$8 = DOMUtils.DOM;
    var isEditorUIElement = function (elm) {
      return FocusManager.isEditorUIElement(elm);
    };
    var isEditorContentAreaElement = function (elm) {
      var classList = elm.classList;
      if (classList !== undefined) {
        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
      } else {
        return false;
      }
    };
    var isUIElement = function (editor, elm) {
      var customSelector = getCustomUiSelector(editor);
      var parent = DOM$8.getParent(elm, function (elm) {
        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);
      });
      return parent !== null;
    };
    var getActiveElement = function (editor) {
      try {
        var root = getRootNode(SugarElement.fromDom(editor.getElement()));
        return active(root).fold(function () {
          return document.body;
        }, function (x) {
          return x.dom;
        });
      } catch (ex) {
        return document.body;
      }
    };
    var registerEvents$1 = function (editorManager, e) {
      var editor = e.editor;
      register$3(editor);
      editor.on('focusin', function () {
        var focusedEditor = editorManager.focusedEditor;
        if (focusedEditor !== editor) {
          if (focusedEditor) {
            focusedEditor.fire('blur', { focusedEditor: editor });
          }
          editorManager.setActive(editor);
          editorManager.focusedEditor = editor;
          editor.fire('focus', { blurredEditor: focusedEditor });
          editor.focus(true);
        }
      });
      editor.on('focusout', function () {
        Delay.setEditorTimeout(editor, function () {
          var focusedEditor = editorManager.focusedEditor;
          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
            editor.fire('blur', { focusedEditor: null });
            editorManager.focusedEditor = null;
          }
        });
      });
      if (!documentFocusInHandler) {
        documentFocusInHandler = function (e) {
          var activeEditor = editorManager.activeEditor;
          if (activeEditor) {
            getOriginalEventTarget(e).each(function (target) {
              if (target.ownerDocument === document) {
                if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.fire('blur', { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            });
          }
        };
        DOM$8.bind(document, 'focusin', documentFocusInHandler);
      }
    };
    var unregisterDocumentEvents = function (editorManager, e) {
      if (editorManager.focusedEditor === e.editor) {
        editorManager.focusedEditor = null;
      }
      if (!editorManager.activeEditor) {
        DOM$8.unbind(document, 'focusin', documentFocusInHandler);
        documentFocusInHandler = null;
      }
    };
    var setup$l = function (editorManager) {
      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));
      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
    };

    var getContentEditableHost = function (editor, node) {
      return editor.dom.getParent(node, function (node) {
        return editor.dom.getContentEditable(node) === 'true';
      });
    };
    var getCollapsedNode = function (rng) {
      return rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    };
    var getFocusInElement = function (root, rng) {
      return getCollapsedNode(rng).bind(function (node) {
        if (isTableSection(node)) {
          return Optional.some(node);
        } else if (contains$1(root, node) === false) {
          return Optional.some(root);
        } else {
          return Optional.none();
        }
      });
    };
    var normalizeSelection$1 = function (editor, rng) {
      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(function (elm) {
        return firstPositionIn(elm.dom);
      }).fold(function () {
        editor.selection.normalize();
        return;
      }, function (caretPos) {
        return editor.selection.setRng(caretPos.toRange());
      });
    };
    var focusBody = function (body) {
      if (body.setActive) {
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    var hasElementFocus = function (elm) {
      return hasFocus$1(elm) || search(elm).isSome();
    };
    var hasIframeFocus = function (editor) {
      return editor.iframeElement && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    };
    var hasInlineFocus = function (editor) {
      var rawBody = editor.getBody();
      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    var hasUiFocus = function (editor) {
      var dos = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active(dos).filter(function (elem) {
        return !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom);
      }).isSome();
    };
    var hasFocus = function (editor) {
      return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    };
    var hasEditorOrUiFocus = function (editor) {
      return hasFocus(editor) || hasUiFocus(editor);
    };
    var focusEditor = function (editor) {
      var selection = editor.selection;
      var body = editor.getBody();
      var rng = selection.getRng();
      editor.quirks.refreshContentEditable();
      if (editor.bookmark !== undefined && hasFocus(editor) === false) {
        getRng(editor).each(function (bookmarkRng) {
          editor.selection.setRng(bookmarkRng);
          rng = bookmarkRng;
        });
      }
      var contentEditableHost = getContentEditableHost(editor, selection.getNode());
      if (editor.$.contains(body, contentEditableHost)) {
        focusBody(contentEditableHost);
        normalizeSelection$1(editor, rng);
        activateEditor(editor);
        return;
      }
      if (!editor.inline) {
        if (!Env.opera) {
          focusBody(body);
        }
        editor.getWin().focus();
      }
      if (Env.gecko || editor.inline) {
        focusBody(body);
        normalizeSelection$1(editor, rng);
      }
      activateEditor(editor);
    };
    var activateEditor = function (editor) {
      return editor.editorManager.setActive(editor);
    };
    var focus = function (editor, skipFocus) {
      if (editor.removed) {
        return;
      }
      if (skipFocus) {
        activateEditor(editor);
      } else {
        focusEditor(editor);
      }
    };

    var getEndpointElement = function (root, rng, start, real, resolve) {
      var container = start ? rng.startContainer : rng.endContainer;
      var offset = start ? rng.startOffset : rng.endOffset;
      return Optional.from(container).map(SugarElement.fromDom).map(function (elm) {
        return !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm;
      }).bind(function (elm) {
        return isElement$6(elm) ? Optional.some(elm) : parent(elm).filter(isElement$6);
      }).map(function (elm) {
        return elm.dom;
      }).getOr(root);
    };
    var getStart = function (root, rng, real) {
      return getEndpointElement(root, rng, true, real, function (elm, offset) {
        return Math.min(childNodesCount(elm), offset);
      });
    };
    var getEnd = function (root, rng, real) {
      return getEndpointElement(root, rng, false, real, function (elm, offset) {
        return offset > 0 ? offset - 1 : offset;
      });
    };
    var skipEmptyTextNodes = function (node, forwards) {
      var orig = node;
      while (node && isText$7(node) && node.length === 0) {
        node = forwards ? node.nextSibling : node.previousSibling;
      }
      return node || orig;
    };
    var getNode = function (root, rng) {
      var elm, startContainer, endContainer;
      if (!rng) {
        return root;
      }
      startContainer = rng.startContainer;
      endContainer = rng.endContainer;
      var startOffset = rng.startOffset;
      var endOffset = rng.endOffset;
      elm = rng.commonAncestorContainer;
      if (!rng.collapsed) {
        if (startContainer === endContainer) {
          if (endOffset - startOffset < 2) {
            if (startContainer.hasChildNodes()) {
              elm = startContainer.childNodes[startOffset];
            }
          }
        }
        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
          if (startContainer.length === startOffset) {
            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
          } else {
            startContainer = startContainer.parentNode;
          }
          if (endOffset === 0) {
            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
          } else {
            endContainer = endContainer.parentNode;
          }
          if (startContainer && startContainer === endContainer) {
            return startContainer;
          }
        }
      }
      if (elm && elm.nodeType === 3) {
        return elm.parentNode;
      }
      return elm;
    };
    var getSelectedBlocks = function (dom, rng, startElm, endElm) {
      var node;
      var selectedBlocks = [];
      var root = dom.getRoot();
      startElm = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);
      endElm = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);
      if (startElm && startElm !== root) {
        selectedBlocks.push(startElm);
      }
      if (startElm && endElm && startElm !== endElm) {
        node = startElm;
        var walker = new DomTreeWalker(startElm, root);
        while ((node = walker.next()) && node !== endElm) {
          if (dom.isBlock(node)) {
            selectedBlocks.push(node);
          }
        }
      }
      if (endElm && startElm !== endElm && endElm !== root) {
        selectedBlocks.push(endElm);
      }
      return selectedBlocks;
    };
    var select = function (dom, node, content) {
      return Optional.from(node).map(function (node) {
        var idx = dom.nodeIndex(node);
        var rng = dom.createRng();
        rng.setStart(node.parentNode, idx);
        rng.setEnd(node.parentNode, idx + 1);
        if (content) {
          moveEndPoint(dom, rng, node, true);
          moveEndPoint(dom, rng, node, false);
        }
        return rng;
      });
    };

    var processRanges = function (editor, ranges) {
      return map$3(ranges, function (range) {
        var evt = editor.fire('GetSelectionRange', { range: range });
        return evt.range !== range ? evt.range : range;
      });
    };

    var typeLookup = {
      '#text': 3,
      '#comment': 8,
      '#cdata': 4,
      '#pi': 7,
      '#doctype': 10,
      '#document-fragment': 11
    };
    var walk$1 = function (node, root, prev) {
      var startName = prev ? 'lastChild' : 'firstChild';
      var siblingName = prev ? 'prev' : 'next';
      if (node[startName]) {
        return node[startName];
      }
      if (node !== root) {
        var sibling = node[siblingName];
        if (sibling) {
          return sibling;
        }
        for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {
          sibling = parent_1[siblingName];
          if (sibling) {
            return sibling;
          }
        }
      }
    };
    var isEmptyTextNode = function (node) {
      if (!isWhitespaceText(node.value)) {
        return false;
      }
      var parentNode = node.parent;
      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {
        return false;
      }
      return true;
    };
    var isNonEmptyElement = function (node) {
      var isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;
    };
    var AstNode = function () {
      function AstNode(name, type) {
        this.name = name;
        this.type = type;
        if (type === 1) {
          this.attributes = [];
          this.attributes.map = {};
        }
      }
      AstNode.create = function (name, attrs) {
        var node = new AstNode(name, typeLookup[name] || 1);
        if (attrs) {
          each$j(attrs, function (value, attrName) {
            node.attr(attrName, value);
          });
        }
        return node;
      };
      AstNode.prototype.replace = function (node) {
        var self = this;
        if (node.parent) {
          node.remove();
        }
        self.insert(node, self);
        self.remove();
        return self;
      };
      AstNode.prototype.attr = function (name, value) {
        var self = this;
        var attrs;
        if (typeof name !== 'string') {
          if (name !== undefined && name !== null) {
            each$j(name, function (value, key) {
              self.attr(key, value);
            });
          }
          return self;
        }
        if (attrs = self.attributes) {
          if (value !== undefined) {
            if (value === null) {
              if (name in attrs.map) {
                delete attrs.map[name];
                var i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name) {
                    attrs.splice(i, 1);
                    return self;
                  }
                }
              }
              return self;
            }
            if (name in attrs.map) {
              var i = attrs.length;
              while (i--) {
                if (attrs[i].name === name) {
                  attrs[i].value = value;
                  break;
                }
              }
            } else {
              attrs.push({
                name: name,
                value: value
              });
            }
            attrs.map[name] = value;
            return self;
          }
          return attrs.map[name];
        }
      };
      AstNode.prototype.clone = function () {
        var self = this;
        var clone = new AstNode(self.name, self.type);
        var selfAttrs;
        if (selfAttrs = self.attributes) {
          var cloneAttrs = [];
          cloneAttrs.map = {};
          for (var i = 0, l = selfAttrs.length; i < l; i++) {
            var selfAttr = selfAttrs[i];
            if (selfAttr.name !== 'id') {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }
          clone.attributes = cloneAttrs;
        }
        clone.value = self.value;
        clone.shortEnded = self.shortEnded;
        return clone;
      };
      AstNode.prototype.wrap = function (wrapper) {
        var self = this;
        self.parent.insert(wrapper, self);
        wrapper.append(self);
        return self;
      };
      AstNode.prototype.unwrap = function () {
        var self = this;
        for (var node = self.firstChild; node;) {
          var next = node.next;
          self.insert(node, self, true);
          node = next;
        }
        self.remove();
      };
      AstNode.prototype.remove = function () {
        var self = this, parent = self.parent, next = self.next, prev = self.prev;
        if (parent) {
          if (parent.firstChild === self) {
            parent.firstChild = next;
            if (next) {
              next.prev = null;
            }
          } else {
            prev.next = next;
          }
          if (parent.lastChild === self) {
            parent.lastChild = prev;
            if (prev) {
              prev.next = null;
            }
          } else {
            next.prev = prev;
          }
          self.parent = self.next = self.prev = null;
        }
        return self;
      };
      AstNode.prototype.append = function (node) {
        var self = this;
        if (node.parent) {
          node.remove();
        }
        var last = self.lastChild;
        if (last) {
          last.next = node;
          node.prev = last;
          self.lastChild = node;
        } else {
          self.lastChild = self.firstChild = node;
        }
        node.parent = self;
        return node;
      };
      AstNode.prototype.insert = function (node, refNode, before) {
        if (node.parent) {
          node.remove();
        }
        var parent = refNode.parent || this;
        if (before) {
          if (refNode === parent.firstChild) {
            parent.firstChild = node;
          } else {
            refNode.prev.next = node;
          }
          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } else {
          if (refNode === parent.lastChild) {
            parent.lastChild = node;
          } else {
            refNode.next.prev = node;
          }
          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }
        node.parent = parent;
        return node;
      };
      AstNode.prototype.getAll = function (name) {
        var self = this;
        var collection = [];
        for (var node = self.firstChild; node; node = walk$1(node, self)) {
          if (node.name === name) {
            collection.push(node);
          }
        }
        return collection;
      };
      AstNode.prototype.children = function () {
        var self = this;
        var collection = [];
        for (var node = self.firstChild; node; node = node.next) {
          collection.push(node);
        }
        return collection;
      };
      AstNode.prototype.empty = function () {
        var self = this;
        if (self.firstChild) {
          var nodes = [];
          for (var node = self.firstChild; node; node = walk$1(node, self)) {
            nodes.push(node);
          }
          var i = nodes.length;
          while (i--) {
            var node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }
        self.firstChild = self.lastChild = null;
        return self;
      };
      AstNode.prototype.isEmpty = function (elements, whitespace, predicate) {
        if (whitespace === void 0) {
          whitespace = {};
        }
        var self = this;
        var node = self.firstChild;
        if (isNonEmptyElement(self)) {
          return false;
        }
        if (node) {
          do {
            if (node.type === 1) {
              if (node.attr('data-mce-bogus')) {
                continue;
              }
              if (elements[node.name]) {
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (node.type === 8) {
              return false;
            }
            if (node.type === 3 && !isEmptyTextNode(node)) {
              return false;
            }
            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {
              return false;
            }
            if (predicate && predicate(node)) {
              return false;
            }
          } while (node = walk$1(node, self));
        }
        return true;
      };
      AstNode.prototype.walk = function (prev) {
        return walk$1(this, null, prev);
      };
      return AstNode;
    }();

    var extractBase64DataUris = function (html) {
      var dataImageUri = /data:[^;]+;base64,([a-z0-9\+\/=\s]+)/gi;
      var chunks = [];
      var uris = {};
      var prefix = generate('img');
      var matches;
      var index = 0;
      var count = 0;
      while (matches = dataImageUri.exec(html)) {
        var uri = matches[0];
        var imageId = prefix + '_' + count++;
        uris[imageId] = uri;
        if (index < matches.index) {
          chunks.push(html.substr(index, matches.index - index));
        }
        chunks.push(imageId);
        index = matches.index + uri.length;
      }
      var re = new RegExp(prefix + '_[0-9]+', 'g');
      if (index === 0) {
        return {
          prefix: prefix,
          uris: uris,
          html: html,
          re: re
        };
      } else {
        if (index < html.length) {
          chunks.push(html.substr(index));
        }
        return {
          prefix: prefix,
          uris: uris,
          html: chunks.join(''),
          re: re
        };
      }
    };
    var restoreDataUris = function (html, result) {
      return html.replace(result.re, function (imageId) {
        return get$9(result.uris, imageId).getOr(imageId);
      });
    };
    var parseDataUri$1 = function (uri) {
      var matches = /data:([^;]+);base64,([a-z0-9\+\/=\s]+)/i.exec(uri);
      if (matches) {
        return Optional.some({
          type: matches[1],
          data: decodeURIComponent(matches[2])
        });
      } else {
        return Optional.none();
      }
    };

    var each$d = Tools.each, trim = Tools.trim;
    var queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');
    var DEFAULT_PORTS = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    };
    var safeSvgDataUrlElements = [
      'img',
      'video'
    ];
    var blockSvgDataUris = function (allowSvgDataUrls, tagName) {
      if (isNonNullable(allowSvgDataUrls)) {
        return !allowSvgDataUrls;
      } else {
        return isNonNullable(tagName) ? !contains$3(safeSvgDataUrlElements, tagName) : true;
      }
    };
    var isInvalidUri = function (settings, uri, tagName) {
      if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(uri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(uri);
      } else {
        return /^data:/i.test(uri);
      }
    };
    var URI = function () {
      function URI(url, settings) {
        url = trim(url);
        this.settings = settings || {};
        var baseUri = this.settings.base_uri;
        var self = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self.source = url;
          return;
        }
        var isProtocolRelative = url.indexOf('//') === 0;
        if (url.indexOf('/') === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
        }
        if (!/^[\w\-]*:?\/\//.test(url)) {
          var baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(document.location.href).directory;
          if (this.settings.base_uri && this.settings.base_uri.protocol == '') {
            url = '//mce_host' + self.toAbsPath(baseUrl, url);
          } else {
            var match = /([^#?]*)([#?]?.*)/.exec(url);
            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
          }
        }
        url = url.replace(/@@/g, '(mce_at)');
        var urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
        each$d(queryParts, function (v, i) {
          var part = urlMatch[i];
          if (part) {
            part = part.replace(/\(mce_at\)/g, '@@');
          }
          self[v] = part;
        });
        if (baseUri) {
          if (!self.protocol) {
            self.protocol = baseUri.protocol;
          }
          if (!self.userInfo) {
            self.userInfo = baseUri.userInfo;
          }
          if (!self.port && self.host === 'mce_host') {
            self.port = baseUri.port;
          }
          if (!self.host || self.host === 'mce_host') {
            self.host = baseUri.host;
          }
          self.source = '';
        }
        if (isProtocolRelative) {
          self.protocol = '';
        }
      }
      URI.parseDataUri = function (uri) {
        var type;
        var uriComponents = decodeURIComponent(uri).split(',');
        var matches = /data:([^;]+)/.exec(uriComponents[0]);
        if (matches) {
          type = matches[1];
        }
        return {
          type: type,
          data: uriComponents[1]
        };
      };
      URI.isDomSafe = function (uri, context, options) {
        if (options === void 0) {
          options = {};
        }
        if (options.allow_script_urls) {
          return true;
        } else {
          var decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');
          try {
            decodedUri = decodeURIComponent(decodedUri);
          } catch (ex) {
            decodedUri = unescape(decodedUri);
          }
          if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
            return false;
          }
          return !isInvalidUri(options, decodedUri, context);
        }
      };
      URI.getDocumentBaseUrl = function (loc) {
        var baseUrl;
        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
          baseUrl = loc.href;
        } else {
          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
        }
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
          baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(baseUrl)) {
            baseUrl += '/';
          }
        }
        return baseUrl;
      };
      URI.prototype.setPath = function (path) {
        var pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
        this.path = pathMatch[0];
        this.directory = pathMatch[1];
        this.file = pathMatch[2];
        this.source = '';
        this.getURI();
      };
      URI.prototype.toRelative = function (uri) {
        var output;
        if (uri === './') {
          return uri;
        }
        var relativeUri = new URI(uri, { base_uri: this });
        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {
          return relativeUri.getURI();
        }
        var tu = this.getURI(), uu = relativeUri.getURI();
        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {
          return tu;
        }
        output = this.toRelPath(this.path, relativeUri.path);
        if (relativeUri.query) {
          output += '?' + relativeUri.query;
        }
        if (relativeUri.anchor) {
          output += '#' + relativeUri.anchor;
        }
        return output;
      };
      URI.prototype.toAbsolute = function (uri, noHost) {
        var absoluteUri = new URI(uri, { base_uri: this });
        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
      };
      URI.prototype.isSameOrigin = function (uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }
          var defaultPort = DEFAULT_PORTS[this.protocol];
          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
            return true;
          }
        }
        return false;
      };
      URI.prototype.toRelPath = function (base, path) {
        var breakPoint = 0, out = '', i, l;
        var normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
        var items = path.split('/');
        if (normalizedBase.length >= items.length) {
          for (i = 0, l = normalizedBase.length; i < l; i++) {
            if (i >= items.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (normalizedBase.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (breakPoint === 1) {
          return path;
        }
        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
          out += '../';
        }
        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i !== breakPoint - 1) {
            out += '/' + items[i];
          } else {
            out += items[i];
          }
        }
        return out;
      };
      URI.prototype.toAbsPath = function (base, path) {
        var i, nb = 0, o = [], outPath;
        var tr = /\/$/.test(path) ? '/' : '';
        var normalizedBase = base.split('/');
        var normalizedPath = path.split('/');
        each$d(normalizedBase, function (k) {
          if (k) {
            o.push(k);
          }
        });
        normalizedBase = o;
        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {
          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
            continue;
          }
          if (normalizedPath[i] === '..') {
            nb++;
            continue;
          }
          if (nb > 0) {
            nb--;
            continue;
          }
          o.push(normalizedPath[i]);
        }
        i = normalizedBase.length - nb;
        if (i <= 0) {
          outPath = reverse(o).join('/');
        } else {
          outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');
        }
        if (outPath.indexOf('/') !== 0) {
          outPath = '/' + outPath;
        }
        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
          outPath += tr;
        }
        return outPath;
      };
      URI.prototype.getURI = function (noProtoHost) {
        if (noProtoHost === void 0) {
          noProtoHost = false;
        }
        var s;
        if (!this.source || noProtoHost) {
          s = '';
          if (!noProtoHost) {
            if (this.protocol) {
              s += this.protocol + '://';
            } else {
              s += '//';
            }
            if (this.userInfo) {
              s += this.userInfo + '@';
            }
            if (this.host) {
              s += this.host;
            }
            if (this.port) {
              s += ':' + this.port;
            }
          }
          if (this.path) {
            s += this.path;
          }
          if (this.query) {
            s += '?' + this.query;
          }
          if (this.anchor) {
            s += '#' + this.anchor;
          }
          this.source = s;
        }
        return this.source;
      };
      return URI;
    }();

    var filteredClobberElements = Tools.makeMap('button,fieldset,form,iframe,img,image,input,object,output,select,textarea');
    var isValidPrefixAttrName = function (name) {
      return name.indexOf('data-') === 0 || name.indexOf('aria-') === 0;
    };
    var findMatchingEndTagIndex = function (schema, html, startIndex) {
      var startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
      var endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
      var shortEndedElements = schema.getShortEndedElements();
      var count = 1, index = startIndex;
      while (count !== 0) {
        startTagRegExp.lastIndex = index;
        while (true) {
          var startMatch = startTagRegExp.exec(html);
          if (startMatch === null) {
            return index;
          } else if (startMatch[1] === '!') {
            if (startsWith(startMatch[2], '--')) {
              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);
            } else {
              index = findCommentEndIndex(html, true, startMatch.index + 1);
            }
            break;
          } else {
            endTagRegExp.lastIndex = startTagRegExp.lastIndex;
            var endMatch = endTagRegExp.exec(html);
            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
              continue;
            }
            if (startMatch[1] === '/') {
              count -= 1;
            } else if (!has$2(shortEndedElements, startMatch[2])) {
              count += 1;
            }
            index = startTagRegExp.lastIndex + endMatch[0].length;
            break;
          }
        }
      }
      return index;
    };
    var isConditionalComment = function (html, startIndex) {
      return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
    };
    var findCommentEndIndex = function (html, isBogus, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      var lcHtml = html.toLowerCase();
      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
        var endIfIndex = lcHtml.indexOf('[endif]', startIndex);
        return lcHtml.indexOf('>', endIfIndex);
      } else {
        if (isBogus) {
          var endIndex = lcHtml.indexOf('>', startIndex);
          return endIndex !== -1 ? endIndex : lcHtml.length;
        } else {
          var endCommentRegexp = /--!?>/g;
          endCommentRegexp.lastIndex = startIndex;
          var match = endCommentRegexp.exec(html);
          return match ? match.index + match[0].length : lcHtml.length;
        }
      }
    };
    var checkBogusAttribute = function (regExp, attrString) {
      var matches = regExp.exec(attrString);
      if (matches) {
        var name_1 = matches[1];
        var value = matches[2];
        return typeof name_1 === 'string' && name_1.toLowerCase() === 'data-mce-bogus' ? value : null;
      } else {
        return null;
      }
    };
    var SaxParser = function (settings, schema) {
      var _a;
      if (schema === void 0) {
        schema = Schema();
      }
      settings = settings || {};
      var doc = (_a = settings.document) !== null && _a !== void 0 ? _a : document;
      var form = doc.createElement('form');
      if (settings.fix_self_closing !== false) {
        settings.fix_self_closing = true;
      }
      var comment = settings.comment ? settings.comment : noop;
      var cdata = settings.cdata ? settings.cdata : noop;
      var text = settings.text ? settings.text : noop;
      var start = settings.start ? settings.start : noop;
      var end = settings.end ? settings.end : noop;
      var pi = settings.pi ? settings.pi : noop;
      var doctype = settings.doctype ? settings.doctype : noop;
      var parseInternal = function (base64Extract, format) {
        if (format === void 0) {
          format = 'html';
        }
        var html = base64Extract.html;
        var matches, index = 0, value, endRegExp;
        var stack = [];
        var attrList, i, textData, name;
        var isInternalElement, isShortEnded;
        var elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
        var attributesRequired, attributesDefault, attributesForced;
        var anyAttributesRequired, attrValue, idCount = 0;
        var decode = Entities.decode;
        var filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
        var parsingMode = format === 'html' ? 0 : 1;
        var processEndTag = function (name) {
          var pos, i;
          pos = stack.length;
          while (pos--) {
            if (stack[pos].name === name) {
              break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--) {
              name = stack[i];
              if (name.valid) {
                end(name.name);
              }
            }
            stack.length = pos;
          }
        };
        var processText = function (value, raw) {
          return text(restoreDataUris(value, base64Extract), raw);
        };
        var processComment = function (value) {
          if (value === '') {
            return;
          }
          if (value.charAt(0) === '>') {
            value = ' ' + value;
          }
          if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {
            value = ' ' + value;
          }
          comment(restoreDataUris(value, base64Extract));
        };
        var processAttr = function (value) {
          return restoreDataUris(value, base64Extract);
        };
        var processMalformedComment = function (value, startIndex) {
          var startTag = value || '';
          var isBogus = !startsWith(startTag, '--');
          var endIndex = findCommentEndIndex(html, isBogus, startIndex);
          value = html.substr(startIndex, endIndex - startIndex);
          processComment(isBogus ? startTag + value : value);
          return endIndex + 1;
        };
        var parseAttribute = function (tagName, name, value, val2, val3) {
          name = name.toLowerCase();
          value = processAttr(name in fillAttrsMap ? name : decode(value || val2 || val3 || ''));
          if (validate && !isInternalElement && isValidPrefixAttrName(name) === false) {
            var attrRule = validAttributesMap[name];
            if (!attrRule && validAttributePatterns) {
              var i_1 = validAttributePatterns.length;
              while (i_1--) {
                attrRule = validAttributePatterns[i_1];
                if (attrRule.pattern.test(name)) {
                  break;
                }
              }
              if (i_1 === -1) {
                attrRule = null;
              }
            }
            if (!attrRule) {
              return;
            }
            if (attrRule.validValues && !(value in attrRule.validValues)) {
              return;
            }
          }
          var isNameOrId = name === 'name' || name === 'id';
          if (isNameOrId && tagName in filteredClobberElements && (value in doc || value in form)) {
            return;
          }
          if (filteredUrlAttrs[name] && !URI.isDomSafe(value, tagName, settings)) {
            return;
          }
          if (isInternalElement && (name in filteredUrlAttrs || name.indexOf('on') === 0)) {
            return;
          }
          attrList.map[name] = value;
          attrList.push({
            name: name,
            value: value
          });
        };
        var tokenRegExp = new RegExp('<(?:' + '(?:!--([\\w\\W]*?)--!?>)|' + '(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + '(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|' + '(?:!(--)?)|' + '(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + '(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|' + '(?:([A-Za-z][A-Za-z0-9\\-_:.]*)(\\s(?:[^\'">]+(?:"[^"]*"|\'[^\']*\'))*[^"\'>]*(?:"[^">]*|\'[^\'>]*)?|\\s*|\\/)>)' + ')', 'g');
        var attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
        var shortEndedElements = schema.getShortEndedElements();
        var selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
        var fillAttrsMap = schema.getBoolAttrs();
        var validate = settings.validate;
        var removeInternalElements = settings.remove_internals;
        var fixSelfClosing = settings.fix_self_closing;
        var specialElements = schema.getSpecialElements();
        var processHtml = html + '>';
        while (matches = tokenRegExp.exec(processHtml)) {
          var matchText = matches[0];
          if (index < matches.index) {
            processText(decode(html.substr(index, matches.index - index)));
          }
          if (value = matches[7]) {
            value = value.toLowerCase();
            if (value.charAt(0) === ':') {
              value = value.substr(1);
            }
            processEndTag(value);
          } else if (value = matches[8]) {
            if (matches.index + matchText.length > html.length) {
              processText(decode(html.substr(matches.index)));
              index = matches.index + matchText.length;
              continue;
            }
            value = value.toLowerCase();
            if (value.charAt(0) === ':') {
              value = value.substr(1);
            }
            isShortEnded = value in shortEndedElements;
            if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
              processEndTag(value);
            }
            var bogusValue = checkBogusAttribute(attrRegExp, matches[9]);
            if (bogusValue !== null) {
              if (bogusValue === 'all') {
                index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);
                tokenRegExp.lastIndex = index;
                continue;
              }
              isValidElement = false;
            }
            if (!validate || (elementRule = schema.getElementRule(value))) {
              isValidElement = true;
              if (validate) {
                validAttributesMap = elementRule.attributes;
                validAttributePatterns = elementRule.attributePatterns;
              }
              if (attribsValue = matches[9]) {
                isInternalElement = attribsValue.indexOf('data-mce-type') !== -1;
                if (isInternalElement && removeInternalElements) {
                  isValidElement = false;
                }
                attrList = [];
                attrList.map = {};
                attribsValue.replace(attrRegExp, function (match, name, val, val2, val3) {
                  parseAttribute(value, name, val, val2, val3);
                  return '';
                });
              } else {
                attrList = [];
                attrList.map = {};
              }
              if (validate && !isInternalElement) {
                attributesRequired = elementRule.attributesRequired;
                attributesDefault = elementRule.attributesDefault;
                attributesForced = elementRule.attributesForced;
                anyAttributesRequired = elementRule.removeEmptyAttrs;
                if (anyAttributesRequired && !attrList.length) {
                  isValidElement = false;
                }
                if (attributesForced) {
                  i = attributesForced.length;
                  while (i--) {
                    attr = attributesForced[i];
                    name = attr.name;
                    attrValue = attr.value;
                    if (attrValue === '{$uid}') {
                      attrValue = 'mce_' + idCount++;
                    }
                    attrList.map[name] = attrValue;
                    attrList.push({
                      name: name,
                      value: attrValue
                    });
                  }
                }
                if (attributesDefault) {
                  i = attributesDefault.length;
                  while (i--) {
                    attr = attributesDefault[i];
                    name = attr.name;
                    if (!(name in attrList.map)) {
                      attrValue = attr.value;
                      if (attrValue === '{$uid}') {
                        attrValue = 'mce_' + idCount++;
                      }
                      attrList.map[name] = attrValue;
                      attrList.push({
                        name: name,
                        value: attrValue
                      });
                    }
                  }
                }
                if (attributesRequired) {
                  i = attributesRequired.length;
                  while (i--) {
                    if (attributesRequired[i] in attrList.map) {
                      break;
                    }
                  }
                  if (i === -1) {
                    isValidElement = false;
                  }
                }
                if (attr = attrList.map['data-mce-bogus']) {
                  if (attr === 'all') {
                    index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    continue;
                  }
                  isValidElement = false;
                }
              }
              if (isValidElement) {
                start(value, attrList, isShortEnded);
              }
            } else {
              isValidElement = false;
            }
            if (endRegExp = specialElements[value]) {
              endRegExp.lastIndex = index = matches.index + matchText.length;
              if (matches = endRegExp.exec(html)) {
                if (isValidElement) {
                  textData = html.substr(index, matches.index - index);
                }
                index = matches.index + matches[0].length;
              } else {
                textData = html.substr(index);
                index = html.length;
              }
              if (isValidElement) {
                if (textData.length > 0) {
                  processText(textData, true);
                }
                end(value);
              }
              tokenRegExp.lastIndex = index;
              continue;
            }
            if (!isShortEnded) {
              if (!attribsValue || attribsValue.indexOf('/') !== attribsValue.length - 1) {
                stack.push({
                  name: value,
                  valid: isValidElement
                });
              } else if (isValidElement) {
                end(value);
              }
            }
          } else if (value = matches[1]) {
            processComment(value);
          } else if (value = matches[2]) {
            var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, '#cdata');
            if (isValidCdataSection) {
              cdata(value);
            } else {
              index = processMalformedComment('', matches.index + 2);
              tokenRegExp.lastIndex = index;
              continue;
            }
          } else if (value = matches[3]) {
            doctype(value);
          } else if ((value = matches[4]) || matchText === '<!') {
            index = processMalformedComment(value, matches.index + matchText.length);
            tokenRegExp.lastIndex = index;
            continue;
          } else if (value = matches[5]) {
            if (parsingMode === 1) {
              pi(value, matches[6]);
            } else {
              index = processMalformedComment('?', matches.index + 2);
              tokenRegExp.lastIndex = index;
              continue;
            }
          }
          index = matches.index + matchText.length;
        }
        if (index < html.length) {
          processText(decode(html.substr(index)));
        }
        for (i = stack.length - 1; i >= 0; i--) {
          value = stack[i];
          if (value.valid) {
            end(value.name);
          }
        }
      };
      var parse = function (html, format) {
        if (format === void 0) {
          format = 'html';
        }
        parseInternal(extractBase64DataUris(html), format);
      };
      return { parse: parse };
    };
    SaxParser.findEndTag = findMatchingEndTagIndex;

    var trimHtml = function (tempAttrs, html) {
      var trimContentRegExp = new RegExp(['\\s?(' + tempAttrs.join('|') + ')="[^"]+"'].join('|'), 'gi');
      return html.replace(trimContentRegExp, '');
    };
    var trimInternal = function (serializer, html) {
      var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
      var schema = serializer.schema;
      var content = trimHtml(serializer.getTempAttrs(), html);
      var shortEndedElements = schema.getShortEndedElements();
      var matches;
      while (matches = bogusAllRegExp.exec(content)) {
        var index = bogusAllRegExp.lastIndex;
        var matchLength = matches[0].length;
        var endTagIndex = void 0;
        if (shortEndedElements[matches[1]]) {
          endTagIndex = index;
        } else {
          endTagIndex = SaxParser.findEndTag(schema, content, index);
        }
        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
        bogusAllRegExp.lastIndex = index - matchLength;
      }
      return trim$2(content);
    };
    var trimExternal = trimInternal;

    var trimEmptyContents = function (editor, html) {
      var blockName = getForcedRootBlock(editor);
      var emptyRegExp = new RegExp('^(<' + blockName + '[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/' + blockName + '>[\r\n]*|<br \\/>[\r\n]*)$');
      return html.replace(emptyRegExp, '');
    };
    var setupArgs$3 = function (args, format) {
      return __assign(__assign({}, args), {
        format: format,
        get: true,
        getInner: true
      });
    };
    var getContentFromBody = function (editor, args, format, body) {
      var defaultedArgs = setupArgs$3(args, format);
      var updatedArgs = args.no_events ? defaultedArgs : editor.fire('BeforeGetContent', defaultedArgs);
      var content;
      if (updatedArgs.format === 'raw') {
        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
      } else if (updatedArgs.format === 'text') {
        content = editor.dom.isEmpty(body) ? '' : trim$2(body.innerText || body.textContent);
      } else if (updatedArgs.format === 'tree') {
        content = editor.serializer.serialize(body, updatedArgs);
      } else {
        content = trimEmptyContents(editor, editor.serializer.serialize(body, updatedArgs));
      }
      if (!contains$3([
          'text',
          'tree'
        ], updatedArgs.format) && !isWsPreserveElement(SugarElement.fromDom(body))) {
        updatedArgs.content = Tools.trim(content);
      } else {
        updatedArgs.content = content;
      }
      if (updatedArgs.no_events) {
        return updatedArgs.content;
      } else {
        return editor.fire('GetContent', updatedArgs).content;
      }
    };
    var getContentInternal = function (editor, args, format) {
      return Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), function (body) {
        return getContentFromBody(editor, args, format, body);
      });
    };

    var each$c = Tools.each;
    var ElementUtils = function (dom) {
      var compare = function (node1, node2) {
        if (node1.nodeName !== node2.nodeName) {
          return false;
        }
        var getAttribs = function (node) {
          var attribs = {};
          each$c(dom.getAttribs(node), function (attr) {
            var name = attr.nodeName.toLowerCase();
            if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {
              attribs[name] = dom.getAttrib(node, name);
            }
          });
          return attribs;
        };
        var compareObjects = function (obj1, obj2) {
          var value, name;
          for (name in obj1) {
            if (has$2(obj1, name)) {
              value = obj2[name];
              if (typeof value === 'undefined') {
                return false;
              }
              if (obj1[name] !== value) {
                return false;
              }
              delete obj2[name];
            }
          }
          for (name in obj2) {
            if (has$2(obj2, name)) {
              return false;
            }
          }
          return true;
        };
        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
          return false;
        }
        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
          return false;
        }
        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
      };
      return { compare: compare };
    };

    var makeMap$1 = Tools.makeMap;
    var Writer = function (settings) {
      var html = [];
      settings = settings || {};
      var indent = settings.indent;
      var indentBefore = makeMap$1(settings.indent_before || '');
      var indentAfter = makeMap$1(settings.indent_after || '');
      var encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
      var htmlOutput = settings.element_format === 'html';
      return {
        start: function (name, attrs, empty) {
          var i, l, attr, value;
          if (indent && indentBefore[name] && html.length > 0) {
            value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
          html.push('<', name);
          if (attrs) {
            for (i = 0, l = attrs.length; i < l; i++) {
              attr = attrs[i];
              html.push(' ', attr.name, '="', encode(attr.value, true), '"');
            }
          }
          if (!empty || htmlOutput) {
            html[html.length] = '>';
          } else {
            html[html.length] = ' />';
          }
          if (empty && indent && indentAfter[name] && html.length > 0) {
            value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        end: function (name) {
          var value;
          html.push('</', name, '>');
          if (indent && indentAfter[name] && html.length > 0) {
            value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        text: function (text, raw) {
          if (text.length > 0) {
            html[html.length] = raw ? text : encode(text);
          }
        },
        cdata: function (text) {
          html.push('<![CDATA[', text, ']]>');
        },
        comment: function (text) {
          html.push('<!--', text, '-->');
        },
        pi: function (name, text) {
          if (text) {
            html.push('<?', name, ' ', encode(text), '?>');
          } else {
            html.push('<?', name, '?>');
          }
          if (indent) {
            html.push('\n');
          }
        },
        doctype: function (text) {
          html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
        },
        reset: function () {
          html.length = 0;
        },
        getContent: function () {
          return html.join('').replace(/\n$/, '');
        }
      };
    };

    var HtmlSerializer = function (settings, schema) {
      if (schema === void 0) {
        schema = Schema();
      }
      var writer = Writer(settings);
      settings = settings || {};
      settings.validate = 'validate' in settings ? settings.validate : true;
      var serialize = function (node) {
        var validate = settings.validate;
        var handlers = {
          3: function (node) {
            writer.text(node.value, node.raw);
          },
          8: function (node) {
            writer.comment(node.value);
          },
          7: function (node) {
            writer.pi(node.name, node.value);
          },
          10: function (node) {
            writer.doctype(node.value);
          },
          4: function (node) {
            writer.cdata(node.value);
          },
          11: function (node) {
            if (node = node.firstChild) {
              do {
                walk(node);
              } while (node = node.next);
            }
          }
        };
        writer.reset();
        var walk = function (node) {
          var handler = handlers[node.type];
          if (!handler) {
            var name_1 = node.name;
            var isEmpty = node.shortEnded;
            var attrs = node.attributes;
            if (validate && attrs && attrs.length > 1) {
              var sortedAttrs = [];
              sortedAttrs.map = {};
              var elementRule = schema.getElementRule(node.name);
              if (elementRule) {
                for (var i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                  var attrName = elementRule.attributesOrder[i];
                  if (attrName in attrs.map) {
                    var attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                for (var i = 0, l = attrs.length; i < l; i++) {
                  var attrName = attrs[i].name;
                  if (!(attrName in sortedAttrs.map)) {
                    var attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                attrs = sortedAttrs;
              }
            }
            writer.start(node.name, attrs, isEmpty);
            if (!isEmpty) {
              if (node = node.firstChild) {
                do {
                  walk(node);
                } while (node = node.next);
              }
              writer.end(name_1);
            }
          } else {
            handler(node);
          }
        };
        if (node.type === 1 && !settings.inner) {
          walk(node);
        } else {
          handlers[11](node);
        }
        return writer.getContent();
      };
      return { serialize: serialize };
    };

    var nonInheritableStyles = new Set();
    (function () {
      var nonInheritableStylesArr = [
        'margin',
        'margin-left',
        'margin-right',
        'margin-top',
        'margin-bottom',
        'padding',
        'padding-left',
        'padding-right',
        'padding-top',
        'padding-bottom',
        'border',
        'border-width',
        'border-style',
        'border-color',
        'background',
        'background-attachment',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'float',
        'position',
        'left',
        'right',
        'top',
        'bottom',
        'z-index',
        'display',
        'transform',
        'width',
        'max-width',
        'min-width',
        'height',
        'max-height',
        'min-height',
        'overflow',
        'overflow-x',
        'overflow-y',
        'text-overflow',
        'vertical-align',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'
      ];
      each$k(nonInheritableStylesArr, function (style) {
        nonInheritableStyles.add(style);
      });
    }());
    var shorthandStyleProps = [
      'font',
      'text-decoration',
      'text-emphasis'
    ];
    var getStyleProps = function (dom, node) {
      return keys(dom.parseStyle(dom.getAttrib(node, 'style')));
    };
    var isNonInheritableStyle = function (style) {
      return nonInheritableStyles.has(style);
    };
    var hasInheritableStyles = function (dom, node) {
      return forall(getStyleProps(dom, node), function (style) {
        return !isNonInheritableStyle(style);
      });
    };
    var getLonghandStyleProps = function (styles) {
      return filter$4(styles, function (style) {
        return exists(shorthandStyleProps, function (prop) {
          return startsWith(style, prop);
        });
      });
    };
    var hasStyleConflict = function (dom, node, parentNode) {
      var nodeStyleProps = getStyleProps(dom, node);
      var parentNodeStyleProps = getStyleProps(dom, parentNode);
      var valueMismatch = function (prop) {
        var nodeValue = dom.getStyle(node, prop);
        var parentValue = dom.getStyle(parentNode, prop);
        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
      };
      return exists(nodeStyleProps, function (nodeStyleProp) {
        var propExists = function (props) {
          return exists(props, function (prop) {
            return prop === nodeStyleProp;
          });
        };
        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
          var longhandProps = getLonghandStyleProps(parentNodeStyleProps);
          return exists(longhandProps, valueMismatch);
        } else {
          return valueMismatch(nodeStyleProp);
        }
      });
    };

    var isChar = function (forward, predicate, pos) {
      return Optional.from(pos.container()).filter(isText$7).exists(function (text) {
        var delta = forward ? 0 : -1;
        return predicate(text.data.charAt(pos.offset() + delta));
      });
    };
    var isBeforeSpace = curry(isChar, true, isWhiteSpace);
    var isAfterSpace = curry(isChar, false, isWhiteSpace);
    var isEmptyText = function (pos) {
      var container = pos.container();
      return isText$7(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    var matchesElementPosition = function (before, predicate) {
      return function (pos) {
        return Optional.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();
      };
    };
    var isImageBlock = function (node) {
      return isImg(node) && get$5(SugarElement.fromDom(node), 'display') === 'block';
    };
    var isCefNode = function (node) {
      return isContentEditableFalse$b(node) && !isBogusAll$1(node);
    };
    var isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    var isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    var isBeforeMedia = matchesElementPosition(true, isMedia$2);
    var isAfterMedia = matchesElementPosition(false, isMedia$2);
    var isBeforeTable = matchesElementPosition(true, isTable$3);
    var isAfterTable = matchesElementPosition(false, isTable$3);
    var isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    var isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

    var getLastChildren = function (elm) {
      var children = [];
      var rawNode = elm.dom;
      while (rawNode) {
        children.push(SugarElement.fromDom(rawNode));
        rawNode = rawNode.lastChild;
      }
      return children;
    };
    var removeTrailingBr = function (elm) {
      var allBrs = descendants(elm, 'br');
      var brs = filter$4(getLastChildren(elm).slice(-1), isBr$4);
      if (allBrs.length === brs.length) {
        each$k(brs, remove$7);
      }
    };
    var fillWithPaddingBr = function (elm) {
      empty(elm);
      append$1(elm, SugarElement.fromHtml('<br data-mce-bogus="1">'));
    };
    var trimBlockTrailingBr = function (elm) {
      lastChild(elm).each(function (lastChild) {
        prevSibling(lastChild).each(function (lastChildPrevSibling) {
          if (isBlock$2(elm) && isBr$4(lastChild) && isBlock$2(lastChildPrevSibling)) {
            remove$7(lastChild);
          }
        });
      });
    };

    var dropLast = function (xs) {
      return xs.slice(0, -1);
    };
    var parentsUntil = function (start, root, predicate) {
      if (contains$1(root, start)) {
        return dropLast(parents$1(start, function (elm) {
          return predicate(elm) || eq(elm, root);
        }));
      } else {
        return [];
      }
    };
    var parents = function (start, root) {
      return parentsUntil(start, root, never);
    };
    var parentsAndSelf = function (start, root) {
      return [start].concat(parents(start, root));
    };

    var navigateIgnoreEmptyTextNodes = function (forward, root, from) {
      return navigateIgnore(forward, root, from, isEmptyText);
    };
    var getClosestBlock$1 = function (root, pos) {
      return find$3(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
    };
    var isAtBeforeAfterBlockBoundary = function (forward, root, pos) {
      return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function (newPos) {
        return getClosestBlock$1(root, pos).fold(function () {
          return isInSameBlock(newPos, pos, root.dom) === false;
        }, function (fromBlock) {
          return isInSameBlock(newPos, pos, root.dom) === false && contains$1(fromBlock, SugarElement.fromDom(newPos.container()));
        });
      });
    };
    var isAtBlockBoundary = function (forward, root, pos) {
      return getClosestBlock$1(root, pos).fold(function () {
        return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function (newPos) {
          return isInSameBlock(newPos, pos, root.dom) === false;
        });
      }, function (parent) {
        return navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone();
      });
    };
    var isAtStartOfBlock = curry(isAtBlockBoundary, false);
    var isAtEndOfBlock = curry(isAtBlockBoundary, true);
    var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

    var isBr = function (pos) {
      return getElementFromPosition(pos).exists(isBr$4);
    };
    var findBr = function (forward, root, pos) {
      var parentBlocks = filter$4(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      var scope = head(parentBlocks).getOr(root);
      return fromPosition(forward, scope.dom, pos).filter(isBr);
    };
    var isBeforeBr$1 = function (root, pos) {
      return getElementFromPosition(pos).exists(isBr$4) || findBr(true, root, pos).isSome();
    };
    var isAfterBr = function (root, pos) {
      return getElementFromPrevPosition(pos).exists(isBr$4) || findBr(false, root, pos).isSome();
    };
    var findPreviousBr = curry(findBr, false);
    var findNextBr = curry(findBr, true);

    var isInMiddleOfText = function (pos) {
      return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    };
    var getClosestBlock = function (root, pos) {
      var parentBlocks = filter$4(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      return head(parentBlocks).getOr(root);
    };
    var hasSpaceBefore = function (root, pos) {
      if (isInMiddleOfText(pos)) {
        return isAfterSpace(pos);
      } else {
        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);
      }
    };
    var hasSpaceAfter = function (root, pos) {
      if (isInMiddleOfText(pos)) {
        return isBeforeSpace(pos);
      } else {
        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);
      }
    };
    var isPreValue = function (value) {
      return contains$3([
        'pre',
        'pre-wrap'
      ], value);
    };
    var isInPre = function (pos) {
      return getElementFromPosition(pos).bind(function (elm) {
        return closest$3(elm, isElement$6);
      }).exists(function (elm) {
        return isPreValue(get$5(elm, 'white-space'));
      });
    };
    var isAtBeginningOfBody = function (root, pos) {
      return prevPosition(root.dom, pos).isNone();
    };
    var isAtEndOfBody = function (root, pos) {
      return nextPosition(root.dom, pos).isNone();
    };
    var isAtLineBoundary = function (root, pos) {
      return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);
    };
    var needsToHaveNbsp = function (root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    var needsToBeNbspLeft = function (root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
      }
    };
    var leanRight = function (pos) {
      var container = pos.container();
      var offset = pos.offset();
      if (isText$7(container) && offset < container.data.length) {
        return CaretPosition(container, offset + 1);
      } else {
        return pos;
      }
    };
    var needsToBeNbspRight = function (root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    var needsToBeNbsp = function (root, pos) {
      return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
    };
    var isNbspAt = function (text, offset) {
      return isNbsp(text.charAt(offset));
    };
    var hasNbsp = function (pos) {
      var container = pos.container();
      return isText$7(container) && contains$2(container.data, nbsp);
    };
    var normalizeNbspMiddle = function (text) {
      var chars = text.split('');
      return map$3(chars, function (chr, i) {
        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
          return ' ';
        } else {
          return chr;
        }
      }).join('');
    };
    var normalizeNbspAtStart = function (root, node) {
      var text = node.data;
      var firstPos = CaretPosition(node, 0);
      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
        node.data = ' ' + text.slice(1);
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbspInMiddleOfTextNode = function (node) {
      var text = node.data;
      var newText = normalizeNbspMiddle(text);
      if (newText !== text) {
        node.data = newText;
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbspAtEnd = function (root, node) {
      var text = node.data;
      var lastPos = CaretPosition(node, text.length - 1);
      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
        node.data = text.slice(0, -1) + ' ';
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbsps = function (root, pos) {
      return Optional.some(pos).filter(hasNbsp).bind(function (pos) {
        var container = pos.container();
        var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);
        return normalized ? Optional.some(pos) : Optional.none();
      });
    };
    var normalizeNbspsInEditor = function (editor) {
      var root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function (pos) {
          editor.selection.setRng(pos.toRange());
        });
      }
    };

    var normalizeContent = function (content, isStartOfContent, isEndOfContent) {
      var result = foldl(content, function (acc, c) {
        if (isWhiteSpace(c) || isNbsp(c)) {
          if (acc.previousCharIsSpace || acc.str === '' && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
            return {
              previousCharIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              previousCharIsSpace: true,
              str: acc.str + ' '
            };
          }
        } else {
          return {
            previousCharIsSpace: false,
            str: acc.str + c
          };
        }
      }, {
        previousCharIsSpace: false,
        str: ''
      });
      return result.str;
    };
    var normalize$1 = function (node, offset, count) {
      if (count === 0) {
        return;
      }
      var elm = SugarElement.fromDom(node);
      var root = ancestor$3(elm, isBlock$2).getOr(elm);
      var whitespace = node.data.slice(offset, offset + count);
      var isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
      var isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
      node.replaceData(offset, count, normalizeContent(whitespace, isStartOfContent, isEndOfContent));
    };
    var normalizeWhitespaceAfter = function (node, offset) {
      var content = node.data.slice(offset);
      var whitespaceCount = content.length - lTrim(content).length;
      normalize$1(node, offset, whitespaceCount);
    };
    var normalizeWhitespaceBefore = function (node, offset) {
      var content = node.data.slice(0, offset);
      var whitespaceCount = content.length - rTrim(content).length;
      normalize$1(node, offset - whitespaceCount, whitespaceCount);
    };
    var mergeTextNodes = function (prevNode, nextNode, normalizeWhitespace, mergeToPrev) {
      if (mergeToPrev === void 0) {
        mergeToPrev = true;
      }
      var whitespaceOffset = rTrim(prevNode.data).length;
      var newNode = mergeToPrev ? prevNode : nextNode;
      var removeNode = mergeToPrev ? nextNode : prevNode;
      if (mergeToPrev) {
        newNode.appendData(removeNode.data);
      } else {
        newNode.insertData(0, removeNode.data);
      }
      remove$7(SugarElement.fromDom(removeNode));
      if (normalizeWhitespace) {
        normalizeWhitespaceAfter(newNode, whitespaceOffset);
      }
      return newNode;
    };

    var needsReposition = function (pos, elm) {
      var container = pos.container();
      var offset = pos.offset();
      return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    var reposition = function (elm, pos) {
      return needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    };
    var beforeOrStartOf = function (node) {
      return isText$7(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    };
    var afterOrEndOf = function (node) {
      return isText$7(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    };
    var getPreviousSiblingCaretPosition = function (elm) {
      if (isCaretCandidate$3(elm.previousSibling)) {
        return Optional.some(afterOrEndOf(elm.previousSibling));
      } else {
        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
      }
    };
    var getNextSiblingCaretPosition = function (elm) {
      if (isCaretCandidate$3(elm.nextSibling)) {
        return Optional.some(beforeOrStartOf(elm.nextSibling));
      } else {
        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
      }
    };
    var findCaretPositionBackwardsFromElm = function (rootElement, elm) {
      var startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
      return prevPosition(rootElement, startPosition).fold(function () {
        return nextPosition(rootElement, CaretPosition.after(elm));
      }, Optional.some);
    };
    var findCaretPositionForwardsFromElm = function (rootElement, elm) {
      return nextPosition(rootElement, CaretPosition.after(elm)).fold(function () {
        return prevPosition(rootElement, CaretPosition.before(elm));
      }, Optional.some);
    };
    var findCaretPositionBackwards = function (rootElement, elm) {
      return getPreviousSiblingCaretPosition(elm).orThunk(function () {
        return getNextSiblingCaretPosition(elm);
      }).orThunk(function () {
        return findCaretPositionBackwardsFromElm(rootElement, elm);
      });
    };
    var findCaretPositionForward = function (rootElement, elm) {
      return getNextSiblingCaretPosition(elm).orThunk(function () {
        return getPreviousSiblingCaretPosition(elm);
      }).orThunk(function () {
        return findCaretPositionForwardsFromElm(rootElement, elm);
      });
    };
    var findCaretPosition = function (forward, rootElement, elm) {
      return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    };
    var findCaretPosOutsideElmAfterDelete = function (forward, rootElement, elm) {
      return findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    };
    var setSelection$1 = function (editor, forward, pos) {
      pos.fold(function () {
        editor.focus();
      }, function (pos) {
        editor.selection.setRng(pos.toRange(), forward);
      });
    };
    var eqRawNode = function (rawNode) {
      return function (elm) {
        return elm.dom === rawNode;
      };
    };
    var isBlock = function (editor, elm) {
      return elm && has$2(editor.schema.getBlockElements(), name(elm));
    };
    var paddEmptyBlock = function (elm) {
      if (isEmpty$2(elm)) {
        var br = SugarElement.fromHtml('<br data-mce-bogus="1">');
        empty(elm);
        append$1(elm, br);
        return Optional.some(CaretPosition.before(br.dom));
      } else {
        return Optional.none();
      }
    };
    var deleteNormalized = function (elm, afterDeletePosOpt, normalizeWhitespace) {
      var prevTextOpt = prevSibling(elm).filter(isText$8);
      var nextTextOpt = nextSibling(elm).filter(isText$8);
      remove$7(elm);
      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function (prev, next, pos) {
        var prevNode = prev.dom, nextNode = next.dom;
        var offset = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
      }).orThunk(function () {
        if (normalizeWhitespace) {
          prevTextOpt.each(function (elm) {
            return normalizeWhitespaceBefore(elm.dom, elm.dom.length);
          });
          nextTextOpt.each(function (elm) {
            return normalizeWhitespaceAfter(elm.dom, 0);
          });
        }
        return afterDeletePosOpt;
      });
    };
    var isInlineElement = function (editor, element) {
      return has$2(editor.schema.getTextInlineElements(), name(element));
    };
    var deleteElement$2 = function (editor, forward, elm, moveCaret) {
      if (moveCaret === void 0) {
        moveCaret = true;
      }
      var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
      var parentBlock = ancestor$3(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
      var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('');
        editor.selection.setCursorLocation();
      } else {
        parentBlock.bind(paddEmptyBlock).fold(function () {
          if (moveCaret) {
            setSelection$1(editor, forward, normalizedAfterDeletePos);
          }
        }, function (paddPos) {
          if (moveCaret) {
            setSelection$1(editor, forward, Optional.some(paddPos));
          }
        });
      }
    };

    var isRootFromElement = function (root) {
      return function (cur) {
        return eq(root, cur);
      };
    };
    var getTableCells = function (table) {
      return descendants(table, 'td,th');
    };
    var getTableDetailsFromRange = function (rng, isRoot) {
      var getTable = function (node) {
        return getClosestTable(SugarElement.fromDom(node), isRoot);
      };
      var startTable = getTable(rng.startContainer);
      var endTable = getTable(rng.endContainer);
      var isStartInTable = startTable.isSome();
      var isEndInTable = endTable.isSome();
      var isSameTable = lift2(startTable, endTable, eq).getOr(false);
      var isMultiTable = !isSameTable && isStartInTable && isEndInTable;
      return {
        startTable: startTable,
        endTable: endTable,
        isStartInTable: isStartInTable,
        isEndInTable: isEndInTable,
        isSameTable: isSameTable,
        isMultiTable: isMultiTable
      };
    };

    var tableCellRng = function (start, end) {
      return {
        start: start,
        end: end
      };
    };
    var tableSelection = function (rng, table, cells) {
      return {
        rng: rng,
        table: table,
        cells: cells
      };
    };
    var deleteAction = Adt.generate([
      {
        singleCellTable: [
          'rng',
          'cell'
        ]
      },
      { fullTable: ['table'] },
      {
        partialTable: [
          'cells',
          'outsideDetails'
        ]
      },
      {
        multiTable: [
          'startTableCells',
          'endTableCells',
          'betweenRng'
        ]
      }
    ]);
    var getClosestCell$1 = function (container, isRoot) {
      return closest$2(SugarElement.fromDom(container), 'td,th', isRoot);
    };
    var isExpandedCellRng = function (cellRng) {
      return !eq(cellRng.start, cellRng.end);
    };
    var getTableFromCellRng = function (cellRng, isRoot) {
      return getClosestTable(cellRng.start, isRoot).bind(function (startParentTable) {
        return getClosestTable(cellRng.end, isRoot).bind(function (endParentTable) {
          return someIf(eq(startParentTable, endParentTable), startParentTable);
        });
      });
    };
    var isSingleCellTable = function (cellRng, isRoot) {
      return !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(function (table) {
        var rows = table.dom.rows;
        return rows.length === 1 && rows[0].cells.length === 1;
      });
    };
    var getCellRng = function (rng, isRoot) {
      var startCell = getClosestCell$1(rng.startContainer, isRoot);
      var endCell = getClosestCell$1(rng.endContainer, isRoot);
      return lift2(startCell, endCell, tableCellRng);
    };
    var getCellRangeFromStartTable = function (isRoot) {
      return function (startCell) {
        return getClosestTable(startCell, isRoot).bind(function (table) {
          return last$2(getTableCells(table)).map(function (endCell) {
            return tableCellRng(startCell, endCell);
          });
        });
      };
    };
    var getCellRangeFromEndTable = function (isRoot) {
      return function (endCell) {
        return getClosestTable(endCell, isRoot).bind(function (table) {
          return head(getTableCells(table)).map(function (startCell) {
            return tableCellRng(startCell, endCell);
          });
        });
      };
    };
    var getTableSelectionFromCellRng = function (isRoot) {
      return function (cellRng) {
        return getTableFromCellRng(cellRng, isRoot).map(function (table) {
          return tableSelection(cellRng, table, getTableCells(table));
        });
      };
    };
    var getTableSelections = function (cellRng, selectionDetails, rng, isRoot) {
      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
        return Optional.none();
      } else if (selectionDetails.isSameTable) {
        var sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: sameTableSelection,
          end: sameTableSelection
        });
      } else {
        var startCell = getClosestCell$1(rng.startContainer, isRoot);
        var endCell = getClosestCell$1(rng.endContainer, isRoot);
        var startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        var endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: startTableSelection,
          end: endTableSelection
        });
      }
    };
    var getCellIndex = function (cells, cell) {
      return findIndex$2(cells, function (x) {
        return eq(x, cell);
      });
    };
    var getSelectedCells = function (tableSelection) {
      return lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), function (startIndex, endIndex) {
        return tableSelection.cells.slice(startIndex, endIndex + 1);
      });
    };
    var isSingleCellTableContentSelected = function (optCellRng, rng, isRoot) {
      return optCellRng.exists(function (cellRng) {
        return isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng);
      });
    };
    var unselectCells = function (rng, selectionDetails) {
      var startTable = selectionDetails.startTable, endTable = selectionDetails.endTable;
      var otherContentRng = rng.cloneRange();
      startTable.each(function (table) {
        return otherContentRng.setStartAfter(table.dom);
      });
      endTable.each(function (table) {
        return otherContentRng.setEndBefore(table.dom);
      });
      return otherContentRng;
    };
    var handleSingleTable = function (cellRng, selectionDetails, rng, isRoot) {
      return getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(function (_a) {
        var start = _a.start, end = _a.end;
        return start.or(end);
      }).bind(function (tableSelection) {
        var isSameTable = selectionDetails.isSameTable;
        var selectedCells = getSelectedCells(tableSelection).getOr([]);
        if (isSameTable && tableSelection.cells.length === selectedCells.length) {
          return Optional.some(deleteAction.fullTable(tableSelection.table));
        } else if (selectedCells.length > 0) {
          if (isSameTable) {
            return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
          } else {
            var otherContentRng = unselectCells(rng, selectionDetails);
            return Optional.some(deleteAction.partialTable(selectedCells, Optional.some(__assign(__assign({}, selectionDetails), { rng: otherContentRng }))));
          }
        } else {
          return Optional.none();
        }
      });
    };
    var handleMultiTable = function (cellRng, selectionDetails, rng, isRoot) {
      return getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(function (_a) {
        var start = _a.start, end = _a.end;
        var startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
        var endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
        if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
          var otherContentRng = unselectCells(rng, selectionDetails);
          return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
        } else {
          return Optional.none();
        }
      });
    };
    var getActionFromRange = function (root, rng) {
      var isRoot = isRootFromElement(root);
      var optCellRng = getCellRng(rng, isRoot);
      var selectionDetails = getTableDetailsFromRange(rng, isRoot);
      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
        return optCellRng.map(function (cellRng) {
          return deleteAction.singleCellTable(rng, cellRng.start);
        });
      } else if (selectionDetails.isMultiTable) {
        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
      } else {
        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
      }
    };

    var freefallRtl = function (root) {
      var child = isComment$1(root) ? prevSibling(root) : lastChild(root);
      return child.bind(freefallRtl).orThunk(function () {
        return Optional.some(root);
      });
    };
    var cleanCells = function (cells) {
      return each$k(cells, function (cell) {
        remove$6(cell, 'contenteditable');
        fillWithPaddingBr(cell);
      });
    };
    var getOutsideBlock = function (editor, container) {
      return Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    };
    var handleEmptyBlock = function (editor, startInTable, emptyBlock) {
      emptyBlock.each(function (block) {
        if (startInTable) {
          remove$7(block);
        } else {
          fillWithPaddingBr(block);
          editor.selection.setCursorLocation(block.dom, 0);
        }
      });
    };
    var deleteContentInsideCell = function (editor, cell, rng, isFirstCellInSelection) {
      var insideTableRng = rng.cloneRange();
      if (isFirstCellInSelection) {
        insideTableRng.setStart(rng.startContainer, rng.startOffset);
        insideTableRng.setEndAfter(cell.dom.lastChild);
      } else {
        insideTableRng.setStartBefore(cell.dom.firstChild);
        insideTableRng.setEnd(rng.endContainer, rng.endOffset);
      }
      deleteCellContents(editor, insideTableRng, cell, false);
    };
    var collapseAndRestoreCellSelection = function (editor) {
      var selectedCells = getCellsFromEditor(editor);
      var selectedNode = SugarElement.fromDom(editor.selection.getNode());
      if (isTableCell$5(selectedNode.dom) && isEmpty$2(selectedNode)) {
        editor.selection.setCursorLocation(selectedNode.dom, 0);
      } else {
        editor.selection.collapse(true);
      }
      if (selectedCells.length > 1 && exists(selectedCells, function (cell) {
          return eq(cell, selectedNode);
        })) {
        set$1(selectedNode, 'data-mce-selected', '1');
      }
    };
    var emptySingleTableCells = function (editor, cells, outsideDetails) {
      var editorRng = editor.selection.getRng();
      var cellsToClean = outsideDetails.bind(function (_a) {
        var rng = _a.rng, isStartInTable = _a.isStartInTable;
        var outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
        rng.deleteContents();
        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
        var endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];
        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
        if (!isEmpty$2(endPointCell)) {
          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));
        } else {
          return Optional.none();
        }
      }).getOr(cells);
      cleanCells(cellsToClean);
      collapseAndRestoreCellSelection(editor);
      return true;
    };
    var emptyMultiTableCells = function (editor, startTableCells, endTableCells, betweenRng) {
      var rng = editor.selection.getRng();
      var startCell = startTableCells[0];
      var endCell = endTableCells[endTableCells.length - 1];
      deleteContentInsideCell(editor, startCell, rng, true);
      deleteContentInsideCell(editor, endCell, rng, false);
      var startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
      var endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
      betweenRng.deleteContents();
      collapseAndRestoreCellSelection(editor);
      return true;
    };
    var deleteCellContents = function (editor, rng, cell, moveSelection) {
      if (moveSelection === void 0) {
        moveSelection = true;
      }
      rng.deleteContents();
      var lastNode = freefallRtl(cell).getOr(cell);
      var lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));
      if (isEmpty$2(lastBlock)) {
        fillWithPaddingBr(lastBlock);
        if (moveSelection) {
          editor.selection.setCursorLocation(lastBlock.dom, 0);
        }
      }
      if (!eq(cell, lastBlock)) {
        var additionalCleanupNodes = is$1(parent(lastBlock), cell) ? [] : siblings(lastBlock);
        each$k(additionalCleanupNodes.concat(children(cell)), function (node) {
          if (!eq(node, lastBlock) && !contains$1(node, lastBlock) && isEmpty$2(node)) {
            remove$7(node);
          }
        });
      }
      return true;
    };
    var deleteTableElement = function (editor, table) {
      deleteElement$2(editor, false, table);
      return true;
    };
    var deleteCellRange = function (editor, rootElm, rng) {
      return getActionFromRange(rootElm, rng).map(function (action) {
        return action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor));
      });
    };
    var deleteCaptionRange = function (editor, caption) {
      return emptyElement(editor, caption);
    };
    var deleteTableRange = function (editor, rootElm, rng, startElm) {
      return getParentCaption(rootElm, startElm).fold(function () {
        return deleteCellRange(editor, rootElm, rng);
      }, function (caption) {
        return deleteCaptionRange(editor, caption);
      }).getOr(false);
    };
    var deleteRange$2 = function (editor, startElm, selectedCells) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var rng = editor.selection.getRng();
      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
    };
    var getParentCell = function (rootElm, elm) {
      return find$3(parentsAndSelf(elm, rootElm), isTableCell$4);
    };
    var getParentCaption = function (rootElm, elm) {
      return find$3(parentsAndSelf(elm, rootElm), isTag('caption'));
    };
    var deleteBetweenCells = function (editor, rootElm, forward, fromCell, from) {
      return navigate(forward, editor.getBody(), from).bind(function (to) {
        return getParentCell(rootElm, SugarElement.fromDom(to.getNode())).map(function (toCell) {
          return eq(toCell, fromCell) === false;
        });
      });
    };
    var emptyElement = function (editor, elm) {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
      return Optional.some(true);
    };
    var isDeleteOfLastCharPos = function (fromCaption, forward, from, to) {
      return firstPositionIn(fromCaption.dom).bind(function (first) {
        return lastPositionIn(fromCaption.dom).map(function (last) {
          return forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first);
        });
      }).getOr(true);
    };
    var emptyCaretCaption = function (editor, elm) {
      return emptyElement(editor, elm);
    };
    var validateCaretCaption = function (rootElm, fromCaption, to) {
      return getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).map(function (toCaption) {
        return eq(toCaption, fromCaption) === false;
      });
    };
    var deleteCaretInsideCaption = function (editor, rootElm, forward, fromCaption, from) {
      return navigate(forward, editor.getBody(), from).bind(function (to) {
        return isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);
      }).or(Optional.some(true));
    };
    var deleteCaretCells = function (editor, forward, rootElm, startElm) {
      var from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getParentCell(rootElm, startElm).bind(function (fromCell) {
        return isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from);
      }).getOr(false);
    };
    var deleteCaretCaption = function (editor, forward, rootElm, fromCaption) {
      var from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
    };
    var isNearTable = function (forward, pos) {
      return forward ? isBeforeTable(pos) : isAfterTable(pos);
    };
    var isBeforeOrAfterTable = function (editor, forward) {
      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(function (pos) {
        return isNearTable(forward, pos);
      });
    };
    var deleteCaret$3 = function (editor, forward, startElm) {
      var rootElm = SugarElement.fromDom(editor.getBody());
      return getParentCaption(rootElm, startElm).fold(function () {
        return deleteCaretCells(editor, forward, rootElm, startElm) || isBeforeOrAfterTable(editor, forward);
      }, function (fromCaption) {
        return deleteCaretCaption(editor, forward, rootElm, fromCaption).getOr(false);
      });
    };
    var backspaceDelete$9 = function (editor, forward) {
      var startElm = SugarElement.fromDom(editor.selection.getStart(true));
      var cells = getCellsFromEditor(editor);
      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$2(editor, startElm, cells);
    };

    var createRange = function (sc, so, ec, eo) {
      var rng = document.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      return rng;
    };
    var normalizeBlockSelectionRange = function (rng) {
      var startPos = CaretPosition.fromRangeStart(rng);
      var endPos = CaretPosition.fromRangeEnd(rng);
      var rootNode = rng.commonAncestorContainer;
      return fromPosition(false, rootNode, endPos).map(function (newEndPos) {
        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
        } else {
          return rng;
        }
      }).getOr(rng);
    };
    var normalize = function (rng) {
      return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
    };

    var hasOnlyOneChild$1 = function (node) {
      return node.firstChild && node.firstChild === node.lastChild;
    };
    var isPaddingNode = function (node) {
      return node.name === 'br' || node.value === nbsp;
    };
    var isPaddedEmptyBlock = function (schema, node) {
      var blockElements = schema.getBlockElements();
      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
    };
    var isEmptyFragmentElement = function (schema, node) {
      var nonEmptyElements = schema.getNonEmptyElements();
      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    var isListFragment = function (schema, fragment) {
      var firstChild = fragment.firstChild;
      var lastChild = fragment.lastChild;
      if (firstChild && firstChild.name === 'meta') {
        firstChild = firstChild.next;
      }
      if (lastChild && lastChild.attr('id') === 'mce_marker') {
        lastChild = lastChild.prev;
      }
      if (isEmptyFragmentElement(schema, lastChild)) {
        lastChild = lastChild.prev;
      }
      if (!firstChild || firstChild !== lastChild) {
        return false;
      }
      return firstChild.name === 'ul' || firstChild.name === 'ol';
    };
    var cleanupDomFragment = function (domFragment) {
      var firstChild = domFragment.firstChild;
      var lastChild = domFragment.lastChild;
      if (firstChild && firstChild.nodeName === 'META') {
        firstChild.parentNode.removeChild(firstChild);
      }
      if (lastChild && lastChild.id === 'mce_marker') {
        lastChild.parentNode.removeChild(lastChild);
      }
      return domFragment;
    };
    var toDomFragment = function (dom, serializer, fragment) {
      var html = serializer.serialize(fragment);
      var domFragment = dom.createFragment(html);
      return cleanupDomFragment(domFragment);
    };
    var listItems = function (elm) {
      return filter$4(elm.childNodes, function (child) {
        return child.nodeName === 'LI';
      });
    };
    var isPadding = function (node) {
      return node.data === nbsp || isBr$5(node);
    };
    var isListItemPadded = function (node) {
      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    var isEmptyOrPadded = function (elm) {
      return !elm.firstChild || isListItemPadded(elm);
    };
    var trimListItems = function (elms) {
      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    var getParentLi = function (dom, node) {
      var parentBlock = dom.getParent(node, dom.isBlock);
      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };
    var isParentBlockLi = function (dom, node) {
      return !!getParentLi(dom, node);
    };
    var getSplit = function (parentNode, rng) {
      var beforeRng = rng.cloneRange();
      var afterRng = rng.cloneRange();
      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);
      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };
    var findFirstIn = function (node, rootNode) {
      var caretPos = CaretPosition.before(node);
      var caretWalker = CaretWalker(rootNode);
      var newCaretPos = caretWalker.next(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    var findLastOf = function (node, rootNode) {
      var caretPos = CaretPosition.after(node);
      var caretWalker = CaretWalker(rootNode);
      var newCaretPos = caretWalker.prev(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    var insertMiddle = function (target, elms, rootNode, rng) {
      var parts = getSplit(target, rng);
      var parentElm = target.parentNode;
      parentElm.insertBefore(parts[0], target);
      Tools.each(elms, function (li) {
        parentElm.insertBefore(li, target);
      });
      parentElm.insertBefore(parts[1], target);
      parentElm.removeChild(target);
      return findLastOf(elms[elms.length - 1], rootNode);
    };
    var insertBefore$1 = function (target, elms, rootNode) {
      var parentElm = target.parentNode;
      Tools.each(elms, function (elm) {
        parentElm.insertBefore(elm, target);
      });
      return findFirstIn(target, rootNode);
    };
    var insertAfter$1 = function (target, elms, rootNode, dom) {
      dom.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };
    var insertAtCaret$1 = function (serializer, dom, rng, fragment) {
      var domFragment = toDomFragment(dom, serializer, fragment);
      var liTarget = getParentLi(dom, rng.startContainer);
      var liElms = trimListItems(listItems(domFragment.firstChild));
      var BEGINNING = 1, END = 2;
      var rootNode = dom.getRoot();
      var isAt = function (location) {
        var caretPos = CaretPosition.fromRangeStart(rng);
        var caretWalker = CaretWalker(dom.getRoot());
        var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
      };
      if (isAt(BEGINNING)) {
        return insertBefore$1(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter$1(liTarget, liElms, rootNode, dom);
      }
      return insertMiddle(liTarget, liElms, rootNode, rng);
    };

    var trimOrPadLeftRight = function (dom, rng, html) {
      var root = SugarElement.fromDom(dom.getRoot());
      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
        html = html.replace(/^ /, '&nbsp;');
      } else {
        html = html.replace(/^&nbsp;/, ' ');
      }
      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
        html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, '&nbsp;');
      } else {
        html = html.replace(/&nbsp;(<br( \/)?>)?$/, ' ');
      }
      return html;
    };

    var isTableCell$1 = isTableCell$5;
    var isTableCellContentSelected = function (dom, rng, cell) {
      if (cell !== null) {
        var endCell = dom.getParent(rng.endContainer, isTableCell$1);
        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
      } else {
        return false;
      }
    };
    var validInsertion = function (editor, value, parentNode) {
      if (parentNode.getAttribute('data-mce-bogus') === 'all') {
        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);
      } else {
        var node = parentNode.firstChild;
        var node2 = parentNode.lastChild;
        if (!node || node === node2 && node.nodeName === 'BR') {
          editor.dom.setHTML(parentNode, value);
        } else {
          editor.selection.setContent(value);
        }
      }
    };
    var trimBrsFromTableCell = function (dom, elm) {
      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);
    };
    var reduceInlineTextElements = function (editor, merge) {
      var textInlineElements = editor.schema.getTextInlineElements();
      var dom = editor.dom;
      if (merge) {
        var root_1 = editor.getBody();
        var elementUtils_1 = ElementUtils(dom);
        Tools.each(dom.select('*[data-mce-fragment]'), function (node) {
          var isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
          if (isInline && hasInheritableStyles(dom, node)) {
            for (var parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root_1; parentNode = parentNode.parentNode) {
              var styleConflict = hasStyleConflict(dom, node, parentNode);
              if (styleConflict) {
                break;
              }
              if (elementUtils_1.compare(parentNode, node)) {
                dom.remove(node, true);
                break;
              }
            }
          }
        });
      }
    };
    var markFragmentElements = function (fragment) {
      var node = fragment;
      while (node = node.walk()) {
        if (node.type === 1) {
          node.attr('data-mce-fragment', '1');
        }
      }
    };
    var unmarkFragmentElements = function (elm) {
      Tools.each(elm.getElementsByTagName('*'), function (elm) {
        elm.removeAttribute('data-mce-fragment');
      });
    };
    var isPartOfFragment = function (node) {
      return !!node.getAttribute('data-mce-fragment');
    };
    var canHaveChildren = function (editor, node) {
      return node && !editor.schema.getShortEndedElements()[node.nodeName];
    };
    var moveSelectionToMarker = function (editor, marker) {
      var nextRng;
      var dom = editor.dom;
      var selection = editor.selection;
      if (!marker) {
        return;
      }
      selection.scrollIntoView(marker);
      var parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
      if (dom.getContentEditable(parentEditableElm) === 'false') {
        dom.remove(marker);
        selection.select(parentEditableElm);
        return;
      }
      var rng = dom.createRng();
      var node = marker.previousSibling;
      if (isText$7(node)) {
        rng.setStart(node, node.nodeValue.length);
        if (!Env.ie) {
          var node2 = marker.nextSibling;
          if (isText$7(node2)) {
            node.appendData(node2.data);
            node2.parentNode.removeChild(node2);
          }
        }
      } else {
        rng.setStartBefore(marker);
        rng.setEndBefore(marker);
      }
      var findNextCaretRng = function (rng) {
        var caretPos = CaretPosition.fromRangeStart(rng);
        var caretWalker = CaretWalker(editor.getBody());
        caretPos = caretWalker.next(caretPos);
        if (caretPos) {
          return caretPos.toRange();
        }
      };
      var parentBlock = dom.getParent(marker, dom.isBlock);
      dom.remove(marker);
      if (parentBlock && dom.isEmpty(parentBlock)) {
        editor.$(parentBlock).empty();
        rng.setStart(parentBlock, 0);
        rng.setEnd(parentBlock, 0);
        if (!isTableCell$1(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
          rng = nextRng;
          dom.remove(parentBlock);
        } else {
          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));
        }
      }
      selection.setRng(rng);
    };
    var deleteSelectedContent = function (editor) {
      var dom = editor.dom;
      var rng = normalize(editor.selection.getRng());
      editor.selection.setRng(rng);
      var startCell = dom.getParent(rng.startContainer, isTableCell$1);
      if (isTableCellContentSelected(dom, rng, startCell)) {
        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
      } else {
        editor.getDoc().execCommand('Delete', false, null);
      }
    };
    var insertHtmlAtCaret = function (editor, value, details) {
      var parentNode;
      var rng, node;
      var selection = editor.selection;
      var dom = editor.dom;
      if (/^ | $/.test(value)) {
        value = trimOrPadLeftRight(dom, selection.getRng(), value);
      }
      var parser = editor.parser;
      var merge = details.merge;
      var serializer = HtmlSerializer({ validate: shouldValidate(editor) }, editor.schema);
      var bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      var args = editor.fire('BeforeSetContent', {
        content: value,
        format: 'html',
        selection: true,
        paste: details.paste
      });
      if (args.isDefaultPrevented()) {
        editor.fire('SetContent', {
          content: args.content,
          format: 'html',
          selection: true,
          paste: details.paste
        });
        return;
      }
      value = args.content;
      if (value.indexOf('{$caret}') === -1) {
        value += '{$caret}';
      }
      value = value.replace(/\{\$caret\}/, bookmarkHtml);
      rng = selection.getRng();
      var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
      var body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
          rng = dom.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }
      if (!selection.isCollapsed()) {
        deleteSelectedContent(editor);
      }
      parentNode = selection.getNode();
      var parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data,
        insert: true
      };
      var fragment = parser.parse(value, parserArgs);
      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {
        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
        selection.setRng(rng);
        editor.fire('SetContent', args);
        return;
      }
      markFragmentElements(fragment);
      node = fragment.lastChild;
      if (node.attr('id') === 'mce_marker') {
        var marker = node;
        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type === 3 || !dom.isBlock(node.name)) {
            if (editor.schema.isValidChild(node.parent.name, 'span')) {
              node.parent.insert(marker, node, node.name === 'br');
            }
            break;
          }
        }
      }
      editor._selectionOverrides.showBlockCaretContainer(parentNode);
      if (!parserArgs.invalid) {
        value = serializer.serialize(fragment);
        validInsertion(editor, value, parentNode);
      } else {
        editor.selection.setContent(bookmarkHtml);
        parentNode = selection.getNode();
        var rootNode = editor.getBody();
        if (parentNode.nodeType === 9) {
          parentNode = node = rootNode;
        } else {
          node = parentNode;
        }
        while (node !== rootNode) {
          parentNode = node;
          node = node.parentNode;
        }
        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
        value = serializer.serialize(parser.parse(value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function () {
          return serializer.serialize(fragment);
        })));
        if (parentNode === rootNode) {
          dom.setHTML(rootNode, value);
        } else {
          dom.setOuterHTML(parentNode, value);
        }
      }
      reduceInlineTextElements(editor, merge);
      moveSelectionToMarker(editor, dom.get('mce_marker'));
      unmarkFragmentElements(editor.getBody());
      trimBrsFromTableCell(dom, selection.getStart());
      editor.fire('SetContent', args);
      editor.addVisual();
    };

    var traverse = function (node, fn) {
      fn(node);
      if (node.firstChild) {
        traverse(node.firstChild, fn);
      }
      if (node.next) {
        traverse(node.next, fn);
      }
    };
    var findMatchingNodes = function (nodeFilters, attributeFilters, node) {
      var nodeMatches = {};
      var attrMatches = {};
      var matches = [];
      if (node.firstChild) {
        traverse(node.firstChild, function (node) {
          each$k(nodeFilters, function (filter) {
            if (filter.name === node.name) {
              if (nodeMatches[filter.name]) {
                nodeMatches[filter.name].nodes.push(node);
              } else {
                nodeMatches[filter.name] = {
                  filter: filter,
                  nodes: [node]
                };
              }
            }
          });
          each$k(attributeFilters, function (filter) {
            if (typeof node.attr(filter.name) === 'string') {
              if (attrMatches[filter.name]) {
                attrMatches[filter.name].nodes.push(node);
              } else {
                attrMatches[filter.name] = {
                  filter: filter,
                  nodes: [node]
                };
              }
            }
          });
        });
      }
      for (var name_1 in nodeMatches) {
        if (has$2(nodeMatches, name_1)) {
          matches.push(nodeMatches[name_1]);
        }
      }
      for (var name_2 in attrMatches) {
        if (has$2(attrMatches, name_2)) {
          matches.push(attrMatches[name_2]);
        }
      }
      return matches;
    };
    var filter$1 = function (nodeFilters, attributeFilters, node) {
      var matches = findMatchingNodes(nodeFilters, attributeFilters, node);
      each$k(matches, function (match) {
        each$k(match.filter.callbacks, function (callback) {
          callback(match.nodes, match.filter.name, {});
        });
      });
    };

    var defaultFormat$1 = 'html';
    var isTreeNode = function (content) {
      return content instanceof AstNode;
    };
    var moveSelection = function (editor) {
      if (hasFocus(editor)) {
        firstPositionIn(editor.getBody()).each(function (pos) {
          var node = pos.getNode();
          var caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    var setEditorHtml = function (editor, html, noSelection) {
      editor.dom.setHTML(editor.getBody(), html);
      if (noSelection !== true) {
        moveSelection(editor);
      }
    };
    var setContentString = function (editor, body, content, args) {
      if (content.length === 0 || /^\s+$/.test(content)) {
        var padd = '<br data-mce-bogus="1">';
        if (body.nodeName === 'TABLE') {
          content = '<tr><td>' + padd + '</td></tr>';
        } else if (/^(UL|OL)$/.test(body.nodeName)) {
          content = '<li>' + padd + '</li>';
        }
        var forcedRootBlockName = getForcedRootBlock(editor);
        if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
          content = padd;
          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
        } else if (!content) {
          content = '<br data-mce-bogus="1">';
        }
        setEditorHtml(editor, content, args.no_selection);
        editor.fire('SetContent', args);
      } else {
        if (args.format !== 'raw') {
          content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
            isRootContent: true,
            insert: true
          }));
        }
        args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
        setEditorHtml(editor, args.content, args.no_selection);
        if (!args.no_events) {
          editor.fire('SetContent', args);
        }
      }
      return args.content;
    };
    var setContentTree = function (editor, body, content, args) {
      filter$1(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
      var html = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);
      args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);
      setEditorHtml(editor, args.content, args.no_selection);
      if (!args.no_events) {
        editor.fire('SetContent', args);
      }
      return content;
    };
    var setupArgs$2 = function (args, content) {
      return __assign(__assign({ format: defaultFormat$1 }, args), {
        set: true,
        content: isTreeNode(content) ? '' : content
      });
    };
    var setContentInternal = function (editor, content, args) {
      var defaultedArgs = setupArgs$2(args, content);
      var updatedArgs = args.no_events ? defaultedArgs : editor.fire('BeforeSetContent', defaultedArgs);
      if (!isTreeNode(content)) {
        content = updatedArgs.content;
      }
      return Optional.from(editor.getBody()).fold(constant(content), function (body) {
        return isTreeNode(content) ? setContentTree(editor, body, content, updatedArgs) : setContentString(editor, body, content, updatedArgs);
      });
    };

    var sibling = function (scope, predicate) {
      return sibling$2(scope, predicate).isSome();
    };

    var ensureIsRoot = function (isRoot) {
      return isFunction(isRoot) ? isRoot : never;
    };
    var ancestor = function (scope, transform, isRoot) {
      var element = scope.dom;
      var stop = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        var transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$1 = function (scope, transform, isRoot) {
      var current = transform(scope);
      var stop = ensureIsRoot(isRoot);
      return current.orThunk(function () {
        return stop(scope) ? Optional.none() : ancestor(scope, transform, stop);
      });
    };

    var isEq$3 = isEq$5;
    var matchesUnInheritedFormatSelector = function (ed, node, name) {
      var formatList = ed.formatter.get(name);
      if (formatList) {
        for (var i = 0; i < formatList.length; i++) {
          var format = formatList[i];
          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
            return true;
          }
        }
      }
      return false;
    };
    var matchParents = function (editor, node, name, vars, similar) {
      var root = editor.dom.getRoot();
      if (node === root) {
        return false;
      }
      node = editor.dom.getParent(node, function (node) {
        if (matchesUnInheritedFormatSelector(editor, node, name)) {
          return true;
        }
        return node.parentNode === root || !!matchNode(editor, node, name, vars, true);
      });
      return !!matchNode(editor, node, name, vars, similar);
    };
    var matchName$1 = function (dom, node, format) {
      if (isEq$3(node, format.inline)) {
        return true;
      }
      if (isEq$3(node, format.block)) {
        return true;
      }
      if (format.selector) {
        return node.nodeType === 1 && dom.is(node, format.selector);
      }
    };
    var matchItems = function (dom, node, format, itemName, similar, vars) {
      var items = format[itemName];
      if (isFunction(format.onmatch)) {
        return format.onmatch(node, format, itemName);
      }
      if (items) {
        if (isUndefined(items.length)) {
          for (var key in items) {
            if (has$2(items, key)) {
              var value = itemName === 'attributes' ? dom.getAttrib(node, key) : getStyle(dom, node, key);
              var expectedValue = replaceVars(items[key], vars);
              var isEmptyValue = isNullable(value) || isEmpty$3(value);
              if (isEmptyValue && isNullable(expectedValue)) {
                continue;
              }
              if (similar && isEmptyValue && !format.exact) {
                return false;
              }
              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(dom, expectedValue, key))) {
                return false;
              }
            }
          }
        } else {
          for (var i = 0; i < items.length; i++) {
            if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
              return true;
            }
          }
        }
      }
      return true;
    };
    var matchNode = function (ed, node, name, vars, similar) {
      var formatList = ed.formatter.get(name);
      var dom = ed.dom;
      if (formatList && node) {
        for (var i = 0; i < formatList.length; i++) {
          var format = formatList[i];
          if (matchName$1(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
            var classes = format.classes;
            if (classes) {
              for (var x = 0; x < classes.length; x++) {
                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                  return;
                }
              }
            }
            return format;
          }
        }
      }
    };
    var match$2 = function (editor, name, vars, node, similar) {
      if (node) {
        return matchParents(editor, node, name, vars, similar);
      }
      node = editor.selection.getNode();
      if (matchParents(editor, node, name, vars, similar)) {
        return true;
      }
      var startNode = editor.selection.getStart();
      if (startNode !== node) {
        if (matchParents(editor, startNode, name, vars, similar)) {
          return true;
        }
      }
      return false;
    };
    var matchAll = function (editor, names, vars) {
      var matchedFormatNames = [];
      var checkedMap = {};
      var startElement = editor.selection.getStart();
      editor.dom.getParent(startElement, function (node) {
        for (var i = 0; i < names.length; i++) {
          var name_1 = names[i];
          if (!checkedMap[name_1] && matchNode(editor, node, name_1, vars)) {
            checkedMap[name_1] = true;
            matchedFormatNames.push(name_1);
          }
        }
      }, editor.dom.getRoot());
      return matchedFormatNames;
    };
    var closest = function (editor, names) {
      var isRoot = function (elm) {
        return eq(elm, SugarElement.fromDom(editor.getBody()));
      };
      var match = function (elm, name) {
        return matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
      };
      return Optional.from(editor.selection.getStart(true)).bind(function (rawElm) {
        return closest$1(SugarElement.fromDom(rawElm), function (elm) {
          return findMap(names, function (name) {
            return match(elm, name);
          });
        }, isRoot);
      }).getOrNull();
    };
    var canApply = function (editor, name) {
      var formatList = editor.formatter.get(name);
      var dom = editor.dom;
      if (formatList) {
        var startNode = editor.selection.getStart();
        var parents = getParents$2(dom, startNode);
        for (var x = formatList.length - 1; x >= 0; x--) {
          var format = formatList[x];
          if (!isSelectorFormat(format) || isNonNullable(format.defaultBlock)) {
            return true;
          }
          for (var i = parents.length - 1; i >= 0; i--) {
            if (dom.is(parents[i], format.selector)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    var matchAllOnNode = function (editor, node, formatNames) {
      return foldl(formatNames, function (acc, name) {
        var matchSimilar = isVariableFormatName(editor, name);
        if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
          return acc.concat([name]);
        } else {
          return acc;
        }
      }, []);
    };

    var ZWSP = ZWSP$1, CARET_ID = '_mce_caret';
    var importNode = function (ownerDocument, node) {
      return ownerDocument.importNode(node, true);
    };
    var getEmptyCaretContainers = function (node) {
      var nodes = [];
      while (node) {
        if (node.nodeType === 3 && node.nodeValue !== ZWSP || node.childNodes.length > 1) {
          return [];
        }
        if (node.nodeType === 1) {
          nodes.push(node);
        }
        node = node.firstChild;
      }
      return nodes;
    };
    var isCaretContainerEmpty = function (node) {
      return getEmptyCaretContainers(node).length > 0;
    };
    var findFirstTextNode = function (node) {
      if (node) {
        var walker = new DomTreeWalker(node, node);
        for (node = walker.current(); node; node = walker.next()) {
          if (isText$7(node)) {
            return node;
          }
        }
      }
      return null;
    };
    var createCaretContainer = function (fill) {
      var caretContainer = SugarElement.fromTag('span');
      setAll$1(caretContainer, {
        'id': CARET_ID,
        'data-mce-bogus': '1',
        'data-mce-type': 'format-caret'
      });
      if (fill) {
        append$1(caretContainer, SugarElement.fromText(ZWSP));
      }
      return caretContainer;
    };
    var trimZwspFromCaretContainer = function (caretContainerNode) {
      var textNode = findFirstTextNode(caretContainerNode);
      if (textNode && textNode.nodeValue.charAt(0) === ZWSP) {
        textNode.deleteData(0, 1);
      }
      return textNode;
    };
    var removeCaretContainerNode = function (editor, node, moveCaret) {
      if (moveCaret === void 0) {
        moveCaret = true;
      }
      var dom = editor.dom, selection = editor.selection;
      if (isCaretContainerEmpty(node)) {
        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);
      } else {
        var rng = selection.getRng();
        var block = dom.getParent(node, dom.isBlock);
        var startContainer = rng.startContainer;
        var startOffset = rng.startOffset;
        var endContainer = rng.endContainer;
        var endOffset = rng.endOffset;
        var textNode = trimZwspFromCaretContainer(node);
        dom.remove(node, true);
        if (startContainer === textNode && startOffset > 0) {
          rng.setStart(textNode, startOffset - 1);
        }
        if (endContainer === textNode && endOffset > 0) {
          rng.setEnd(textNode, endOffset - 1);
        }
        if (block && dom.isEmpty(block)) {
          fillWithPaddingBr(SugarElement.fromDom(block));
        }
        selection.setRng(rng);
      }
    };
    var removeCaretContainer = function (editor, node, moveCaret) {
      if (moveCaret === void 0) {
        moveCaret = true;
      }
      var dom = editor.dom, selection = editor.selection;
      if (!node) {
        node = getParentCaretContainer(editor.getBody(), selection.getStart());
        if (!node) {
          while (node = dom.get(CARET_ID)) {
            removeCaretContainerNode(editor, node, false);
          }
        }
      } else {
        removeCaretContainerNode(editor, node, moveCaret);
      }
    };
    var insertCaretContainerNode = function (editor, caretContainer, formatNode) {
      var dom = editor.dom, block = dom.getParent(formatNode, curry(isTextBlock$1, editor));
      if (block && dom.isEmpty(block)) {
        formatNode.parentNode.replaceChild(caretContainer, formatNode);
      } else {
        removeTrailingBr(SugarElement.fromDom(formatNode));
        if (dom.isEmpty(formatNode)) {
          formatNode.parentNode.replaceChild(caretContainer, formatNode);
        } else {
          dom.insertAfter(caretContainer, formatNode);
        }
      }
    };
    var appendNode = function (parentNode, node) {
      parentNode.appendChild(node);
      return node;
    };
    var insertFormatNodesIntoCaretContainer = function (formatNodes, caretContainer) {
      var innerMostFormatNode = foldr(formatNodes, function (parentNode, formatNode) {
        return appendNode(parentNode, formatNode.cloneNode(false));
      }, caretContainer);
      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP));
    };
    var cleanFormatNode = function (editor, caretContainer, formatNode, name, vars, similar) {
      var formatter = editor.formatter;
      var dom = editor.dom;
      var validFormats = filter$4(keys(formatter.get()), function (formatName) {
        return formatName !== name && !contains$2(formatName, 'removeformat');
      });
      var matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
      var uniqueFormats = filter$4(matchedFormats, function (fmtName) {
        return !areSimilarFormats(editor, fmtName, name);
      });
      if (uniqueFormats.length > 0) {
        var clonedFormatNode = formatNode.cloneNode(false);
        dom.add(caretContainer, clonedFormatNode);
        formatter.remove(name, vars, clonedFormatNode, similar);
        dom.remove(clonedFormatNode);
        return Optional.some(clonedFormatNode);
      } else {
        return Optional.none();
      }
    };
    var applyCaretFormat = function (editor, name, vars) {
      var caretContainer, textNode;
      var selection = editor.selection;
      var selectionRng = selection.getRng();
      var offset = selectionRng.startOffset;
      var container = selectionRng.startContainer;
      var text = container.nodeValue;
      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
      if (caretContainer) {
        textNode = findFirstTextNode(caretContainer);
      }
      var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
        var bookmark = selection.getBookmark();
        selectionRng.collapse(true);
        var rng = expandRng(editor, selectionRng, editor.formatter.get(name));
        rng = split(rng);
        editor.formatter.apply(name, vars, rng);
        selection.moveToBookmark(bookmark);
      } else {
        if (!caretContainer || textNode.nodeValue !== ZWSP) {
          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
          textNode = caretContainer.firstChild;
          selectionRng.insertNode(caretContainer);
          offset = 1;
          editor.formatter.apply(name, vars, caretContainer);
        } else {
          editor.formatter.apply(name, vars, caretContainer);
        }
        selection.setCursorLocation(textNode, offset);
      }
    };
    var removeCaretFormat = function (editor, name, vars, similar) {
      var dom = editor.dom;
      var selection = editor.selection;
      var hasContentAfter, node, formatNode;
      var parents = [];
      var rng = selection.getRng();
      var container = rng.startContainer;
      var offset = rng.startOffset;
      node = container;
      if (container.nodeType === 3) {
        if (offset !== container.nodeValue.length) {
          hasContentAfter = true;
        }
        node = node.parentNode;
      }
      while (node) {
        if (matchNode(editor, node, name, vars, similar)) {
          formatNode = node;
          break;
        }
        if (node.nextSibling) {
          hasContentAfter = true;
        }
        parents.push(node);
        node = node.parentNode;
      }
      if (!formatNode) {
        return;
      }
      if (hasContentAfter) {
        var bookmark = selection.getBookmark();
        rng.collapse(true);
        var expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);
        expandedRng = split(expandedRng);
        editor.formatter.remove(name, vars, expandedRng, similar);
        selection.moveToBookmark(bookmark);
      } else {
        var caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
        var newCaretContainer = createCaretContainer(false).dom;
        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);
        var cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);
        var caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);
        removeCaretContainerNode(editor, caretContainer, false);
        selection.setCursorLocation(caretTextNode, 1);
        if (dom.isEmpty(formatNode)) {
          dom.remove(formatNode);
        }
      }
    };
    var disableCaretContainer = function (editor, keyCode) {
      var selection = editor.selection, body = editor.getBody();
      removeCaretContainer(editor, null, false);
      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
      if (keyCode === 37 || keyCode === 39) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
    };
    var setup$k = function (editor) {
      editor.on('mouseup keydown', function (e) {
        disableCaretContainer(editor, e.keyCode);
      });
    };
    var replaceWithCaretFormat = function (targetNode, formatNodes) {
      var caretContainer = createCaretContainer(false);
      var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
      before$4(SugarElement.fromDom(targetNode), caretContainer);
      remove$7(SugarElement.fromDom(targetNode));
      return CaretPosition(innerMost, 0);
    };
    var isFormatElement = function (editor, element) {
      var inlineElements = editor.schema.getTextInlineElements();
      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
    };
    var isEmptyCaretFormatElement = function (element) {
      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };

    var postProcessHooks = {};
    var filter = filter$2;
    var each$b = each$i;
    var addPostProcessHook = function (name, hook) {
      var hooks = postProcessHooks[name];
      if (!hooks) {
        postProcessHooks[name] = [];
      }
      postProcessHooks[name].push(hook);
    };
    var postProcess$1 = function (name, editor) {
      each$b(postProcessHooks[name], function (hook) {
        hook(editor);
      });
    };
    addPostProcessHook('pre', function (editor) {
      var rng = editor.selection.getRng();
      var blocks;
      var hasPreSibling = function (pre) {
        return isPre(pre.previousSibling) && indexOf$1(blocks, pre.previousSibling) !== -1;
      };
      var joinPre = function (pre1, pre2) {
        DomQuery(pre2).remove();
        DomQuery(pre1).append('<br><br>').append(pre2.childNodes);
      };
      var isPre = matchNodeNames(['pre']);
      if (!rng.collapsed) {
        blocks = editor.selection.getSelectedBlocks();
        each$b(filter(filter(blocks, isPre), hasPreSibling), function (pre) {
          joinPre(pre.previousSibling, pre);
        });
      }
    });

    var each$a = Tools.each;
    var isElementNode$1 = function (node) {
      return isElement$5(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    };
    var findElementSibling = function (node, siblingName) {
      for (var sibling = node; sibling; sibling = sibling[siblingName]) {
        if (isText$7(sibling) && isNotEmpty(sibling.data)) {
          return node;
        }
        if (isElement$5(sibling) && !isBookmarkNode$1(sibling)) {
          return sibling;
        }
      }
      return node;
    };
    var mergeSiblingsNodes = function (dom, prev, next) {
      var elementUtils = ElementUtils(dom);
      if (prev && next) {
        prev = findElementSibling(prev, 'previousSibling');
        next = findElementSibling(next, 'nextSibling');
        if (elementUtils.compare(prev, next)) {
          for (var sibling = prev.nextSibling; sibling && sibling !== next;) {
            var tmpSibling = sibling;
            sibling = sibling.nextSibling;
            prev.appendChild(tmpSibling);
          }
          dom.remove(next);
          Tools.each(Tools.grep(next.childNodes), function (node) {
            prev.appendChild(node);
          });
          return prev;
        }
      }
      return next;
    };
    var mergeSiblings = function (dom, format, vars, node) {
      if (node && format.merge_siblings !== false) {
        var newNode = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);
        mergeSiblingsNodes(dom, newNode, getNonWhiteSpaceSibling(newNode, true));
      }
    };
    var clearChildStyles = function (dom, format, node) {
      if (format.clear_child_styles) {
        var selector = format.links ? '*:not(a)' : '*';
        each$a(dom.select(selector, node), function (node) {
          if (isElementNode$1(node)) {
            each$a(format.styles, function (value, name) {
              dom.setStyle(node, name, '');
            });
          }
        });
      }
    };
    var processChildElements = function (node, filter, process) {
      each$a(node.childNodes, function (node) {
        if (isElementNode$1(node)) {
          if (filter(node)) {
            process(node);
          }
          if (node.hasChildNodes()) {
            processChildElements(node, filter, process);
          }
        }
      });
    };
    var unwrapEmptySpan = function (dom, node) {
      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
        dom.remove(node, true);
      }
    };
    var hasStyle = function (dom, name) {
      return function (node) {
        return !!(node && getStyle(dom, node, name));
      };
    };
    var applyStyle = function (dom, name, value) {
      return function (node) {
        dom.setStyle(node, name, value);
        if (node.getAttribute('style') === '') {
          node.removeAttribute('style');
        }
        unwrapEmptySpan(dom, node);
      };
    };

    var removeResult = Adt.generate([
      { keep: [] },
      { rename: ['name'] },
      { removed: [] }
    ]);
    var MCE_ATTR_RE = /^(src|href|style)$/;
    var each$9 = Tools.each;
    var isEq$2 = isEq$5;
    var isTableCellOrRow = function (node) {
      return /^(TR|TH|TD)$/.test(node.nodeName);
    };
    var isChildOfInlineParent = function (dom, node, parent) {
      return dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
    };
    var getContainer = function (ed, rng, start) {
      var container = rng[start ? 'startContainer' : 'endContainer'];
      var offset = rng[start ? 'startOffset' : 'endOffset'];
      if (isElement$5(container)) {
        var lastIdx = container.childNodes.length - 1;
        if (!start && offset) {
          offset--;
        }
        container = container.childNodes[offset > lastIdx ? lastIdx : offset];
      }
      if (isText$7(container) && start && offset >= container.nodeValue.length) {
        container = new DomTreeWalker(container, ed.getBody()).next() || container;
      }
      if (isText$7(container) && !start && offset === 0) {
        container = new DomTreeWalker(container, ed.getBody()).prev() || container;
      }
      return container;
    };
    var normalizeTableSelection = function (node, start) {
      var prop = start ? 'firstChild' : 'lastChild';
      if (isTableCellOrRow(node) && node[prop]) {
        var childNode = node[prop];
        if (node.nodeName === 'TR') {
          return childNode[prop] || childNode;
        } else {
          return childNode;
        }
      }
      return node;
    };
    var wrap$1 = function (dom, node, name, attrs) {
      var wrapper = dom.create(name, attrs);
      node.parentNode.insertBefore(wrapper, node);
      wrapper.appendChild(node);
      return wrapper;
    };
    var wrapWithSiblings = function (dom, node, next, name, attrs) {
      var start = SugarElement.fromDom(node);
      var wrapper = SugarElement.fromDom(dom.create(name, attrs));
      var siblings = next ? nextSiblings(start) : prevSiblings(start);
      append(wrapper, siblings);
      if (next) {
        before$4(start, wrapper);
        prepend(wrapper, start);
      } else {
        after$3(start, wrapper);
        append$1(wrapper, start);
      }
      return wrapper.dom;
    };
    var matchName = function (dom, node, format) {
      if (isInlineFormat(format) && isEq$2(node, format.inline)) {
        return true;
      }
      if (isBlockFormat(format) && isEq$2(node, format.block)) {
        return true;
      }
      if (isSelectorFormat(format)) {
        return isElement$5(node) && dom.is(node, format.selector);
      }
    };
    var isColorFormatAndAnchor = function (node, format) {
      return format.links && node.nodeName === 'A';
    };
    var find = function (dom, node, next, inc) {
      var sibling = getNonWhiteSpaceSibling(node, next, inc);
      return isNullable(sibling) || sibling.nodeName === 'BR' || dom.isBlock(sibling);
    };
    var removeNode = function (ed, node, format) {
      var parentNode = node.parentNode;
      var rootBlockElm;
      var dom = ed.dom, forcedRootBlock = getForcedRootBlock(ed);
      if (isBlockFormat(format)) {
        if (!forcedRootBlock) {
          if (dom.isBlock(node) && !dom.isBlock(parentNode)) {
            if (!find(dom, node, false) && !find(dom, node.firstChild, true, true)) {
              node.insertBefore(dom.create('br'), node.firstChild);
            }
            if (!find(dom, node, true) && !find(dom, node.lastChild, false, true)) {
              node.appendChild(dom.create('br'));
            }
          }
        } else {
          if (parentNode === dom.getRoot()) {
            if (!format.list_block || !isEq$2(node, format.list_block)) {
              each$k(from(node.childNodes), function (node) {
                if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
                  if (!rootBlockElm) {
                    rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                    dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                  } else {
                    rootBlockElm.appendChild(node);
                  }
                } else {
                  rootBlockElm = null;
                }
              });
            }
          }
        }
      }
      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
        return;
      }
      dom.remove(node, true);
    };
    var removeFormatInternal = function (ed, format, vars, node, compareNode) {
      var stylesModified;
      var dom = ed.dom;
      if (!matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
        return removeResult.keep();
      }
      var elm = node;
      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(format.preserve_attributes)) {
        var attrsToPreserve = filter$4(dom.getAttribs(elm), function (attr) {
          return contains$3(format.preserve_attributes, attr.name.toLowerCase());
        });
        dom.removeAllAttribs(elm);
        each$k(attrsToPreserve, function (attr) {
          return dom.setAttrib(elm, attr.name, attr.value);
        });
        if (attrsToPreserve.length > 0) {
          return removeResult.rename('span');
        }
      }
      if (format.remove !== 'all') {
        each$9(format.styles, function (value, name) {
          value = normalizeStyleValue(dom, replaceVars(value, vars), name + '');
          if (isNumber(name)) {
            name = value;
            compareNode = null;
          }
          if (format.remove_similar || (!compareNode || isEq$2(getStyle(dom, compareNode, name), value))) {
            dom.setStyle(elm, name, '');
          }
          stylesModified = true;
        });
        if (stylesModified && dom.getAttrib(elm, 'style') === '') {
          elm.removeAttribute('style');
          elm.removeAttribute('data-mce-style');
        }
        each$9(format.attributes, function (value, name) {
          var valueOut;
          value = replaceVars(value, vars);
          if (isNumber(name)) {
            name = value;
            compareNode = null;
          }
          if (format.remove_similar || (!compareNode || isEq$2(dom.getAttrib(compareNode, name), value))) {
            if (name === 'class') {
              value = dom.getAttrib(elm, name);
              if (value) {
                valueOut = '';
                each$k(value.split(/\s+/), function (cls) {
                  if (/mce\-\w+/.test(cls)) {
                    valueOut += (valueOut ? ' ' : '') + cls;
                  }
                });
                if (valueOut) {
                  dom.setAttrib(elm, name, valueOut);
                  return;
                }
              }
            }
            if (MCE_ATTR_RE.test(name)) {
              elm.removeAttribute('data-mce-' + name);
            }
            if (name === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {
              elm.removeAttribute(name);
              dom.setStyle(elm, 'list-style-type', 'none');
              return;
            }
            if (name === 'class') {
              elm.removeAttribute('className');
            }
            elm.removeAttribute(name);
          }
        });
        each$9(format.classes, function (value) {
          value = replaceVars(value, vars);
          if (!compareNode || dom.hasClass(compareNode, value)) {
            dom.removeClass(elm, value);
          }
        });
        var attrs = dom.getAttribs(elm);
        for (var i = 0; i < attrs.length; i++) {
          var attrName = attrs[i].nodeName;
          if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {
            return removeResult.keep();
          }
        }
      }
      if (format.remove !== 'none') {
        removeNode(ed, elm, format);
        return removeResult.removed();
      }
      return removeResult.keep();
    };
    var removeFormat$1 = function (ed, format, vars, node, compareNode) {
      return removeFormatInternal(ed, format, vars, node, compareNode).fold(never, function (newName) {
        ed.dom.rename(node, newName);
        return true;
      }, always);
    };
    var findFormatRoot = function (editor, container, name, vars, similar) {
      var formatRoot;
      each$k(getParents$2(editor.dom, container.parentNode).reverse(), function (parent) {
        if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {
          var format = matchNode(editor, parent, name, vars, similar);
          if (format && format.split !== false) {
            formatRoot = parent;
          }
        }
      });
      return formatRoot;
    };
    var removeFormatFromClone = function (editor, format, vars, clone) {
      return removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), function (newName) {
        var fragment = editor.dom.createFragment();
        fragment.appendChild(clone);
        return editor.dom.rename(clone, newName);
      }, constant(null));
    };
    var wrapAndSplit = function (editor, formatList, formatRoot, container, target, split, format, vars) {
      var clone, lastClone, firstClone;
      var dom = editor.dom;
      if (formatRoot) {
        var formatRootParent = formatRoot.parentNode;
        for (var parent_1 = container.parentNode; parent_1 && parent_1 !== formatRootParent; parent_1 = parent_1.parentNode) {
          clone = dom.clone(parent_1, false);
          for (var i = 0; i < formatList.length; i++) {
            clone = removeFormatFromClone(editor, formatList[i], vars, clone);
            if (clone === null) {
              break;
            }
          }
          if (clone) {
            if (lastClone) {
              clone.appendChild(lastClone);
            }
            if (!firstClone) {
              firstClone = clone;
            }
            lastClone = clone;
          }
        }
        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
          container = dom.split(formatRoot, container);
        }
        if (lastClone) {
          target.parentNode.insertBefore(lastClone, target);
          firstClone.appendChild(target);
          if (isInlineFormat(format)) {
            mergeSiblings(dom, format, vars, lastClone);
          }
        }
      }
      return container;
    };
    var remove$1 = function (ed, name, vars, node, similar) {
      var formatList = ed.formatter.get(name);
      var format = formatList[0];
      var contentEditable = true;
      var dom = ed.dom;
      var selection = ed.selection;
      var splitToFormatRoot = function (container) {
        var formatRoot = findFormatRoot(ed, container, name, vars, similar);
        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
      };
      var isRemoveBookmarkNode = function (node) {
        return isBookmarkNode$1(node) && isElement$5(node) && (node.id === '_start' || node.id === '_end');
      };
      var removeNodeFormat = function (node) {
        return exists(formatList, function (fmt) {
          return removeFormat$1(ed, fmt, vars, node, node);
        });
      };
      var process = function (node) {
        var lastContentEditable = true;
        var hasContentEditableState = false;
        if (isElement$5(node) && dom.getContentEditable(node)) {
          lastContentEditable = contentEditable;
          contentEditable = dom.getContentEditable(node) === 'true';
          hasContentEditableState = true;
        }
        var children = from(node.childNodes);
        if (contentEditable && !hasContentEditableState) {
          var removed = removeNodeFormat(node);
          var parentNode = node.parentNode;
          if (!removed && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
            removeNodeFormat(parentNode);
          }
        }
        if (format.deep) {
          if (children.length) {
            for (var i = 0; i < children.length; i++) {
              process(children[i]);
            }
            if (hasContentEditableState) {
              contentEditable = lastContentEditable;
            }
          }
        }
        var textDecorations = [
          'underline',
          'line-through',
          'overline'
        ];
        each$k(textDecorations, function (decoration) {
          if (isElement$5(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {
            removeFormat$1(ed, {
              deep: false,
              exact: true,
              inline: 'span',
              styles: { textDecoration: decoration }
            }, null, node);
          }
        });
      };
      var unwrap = function (start) {
        var node = dom.get(start ? '_start' : '_end');
        var out = node[start ? 'firstChild' : 'lastChild'];
        if (isRemoveBookmarkNode(out)) {
          out = out[start ? 'firstChild' : 'lastChild'];
        }
        if (isText$7(out) && out.data.length === 0) {
          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
        }
        dom.remove(node, true);
        return out;
      };
      var removeRngStyle = function (rng) {
        var startContainer, endContainer;
        var expandedRng = expandRng(ed, rng, formatList, rng.collapsed);
        if (format.split) {
          expandedRng = split(expandedRng);
          startContainer = getContainer(ed, expandedRng, true);
          endContainer = getContainer(ed, expandedRng);
          if (startContainer !== endContainer) {
            startContainer = normalizeTableSelection(startContainer, true);
            endContainer = normalizeTableSelection(endContainer, false);
            if (isChildOfInlineParent(dom, startContainer, endContainer)) {
              var marker = Optional.from(startContainer.firstChild).getOr(startContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {
                'id': '_start',
                'data-mce-type': 'bookmark'
              }));
              unwrap(true);
              return;
            }
            if (isChildOfInlineParent(dom, endContainer, startContainer)) {
              var marker = Optional.from(endContainer.lastChild).getOr(endContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {
                'id': '_end',
                'data-mce-type': 'bookmark'
              }));
              unwrap(false);
              return;
            }
            startContainer = wrap$1(dom, startContainer, 'span', {
              'id': '_start',
              'data-mce-type': 'bookmark'
            });
            endContainer = wrap$1(dom, endContainer, 'span', {
              'id': '_end',
              'data-mce-type': 'bookmark'
            });
            var newRng = dom.createRng();
            newRng.setStartAfter(startContainer);
            newRng.setEndBefore(endContainer);
            walk$2(dom, newRng, function (nodes) {
              each$k(nodes, function (n) {
                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                  splitToFormatRoot(n);
                }
              });
            });
            splitToFormatRoot(startContainer);
            splitToFormatRoot(endContainer);
            startContainer = unwrap(true);
            endContainer = unwrap();
          } else {
            startContainer = endContainer = splitToFormatRoot(startContainer);
          }
          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
          expandedRng.startOffset = dom.nodeIndex(startContainer);
          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
        }
        walk$2(dom, expandedRng, function (nodes) {
          each$k(nodes, process);
        });
      };
      if (node) {
        if (isNode(node)) {
          var rng = dom.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          removeRngStyle(rng);
        } else {
          removeRngStyle(node);
        }
        fireFormatRemove(ed, name, node, vars);
        return;
      }
      if (dom.getContentEditable(selection.getNode()) === 'false') {
        node = selection.getNode();
        for (var i = 0; i < formatList.length; i++) {
          if (formatList[i].ceFalseOverride) {
            if (removeFormat$1(ed, formatList[i], vars, node, node)) {
              break;
            }
          }
        }
        fireFormatRemove(ed, name, node, vars);
        return;
      }
      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
        preserve(selection, true, function () {
          runOnRanges(ed, removeRngStyle);
        });
        if (isInlineFormat(format) && match$2(ed, name, vars, selection.getStart())) {
          moveStart(dom, selection, selection.getRng());
        }
        ed.nodeChanged();
      } else {
        removeCaretFormat(ed, name, vars, similar);
      }
      fireFormatRemove(ed, name, node, vars);
    };

    var each$8 = Tools.each;
    var mergeTextDecorationsAndColor = function (dom, format, vars, node) {
      var processTextDecorationsAndColor = function (n) {
        if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {
          var textDecoration = getTextDecoration(dom, n.parentNode);
          if (dom.getStyle(n, 'color') && textDecoration) {
            dom.setStyle(n, 'text-decoration', textDecoration);
          } else if (dom.getStyle(n, 'text-decoration') === textDecoration) {
            dom.setStyle(n, 'text-decoration', null);
          }
        }
      };
      if (format.styles && (format.styles.color || format.styles.textDecoration)) {
        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');
        processTextDecorationsAndColor(node);
      }
    };
    var mergeBackgroundColorAndFontSize = function (dom, format, vars, node) {
      if (format.styles && format.styles.backgroundColor) {
        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
      }
    };
    var mergeSubSup = function (dom, format, vars, node) {
      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {
        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));
        dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);
      }
    };
    var mergeWithChildren = function (editor, formatList, vars, node) {
      each$8(formatList, function (format) {
        if (isInlineFormat(format)) {
          each$8(editor.dom.select(format.inline, node), function (child) {
            if (!isElementNode$1(child)) {
              return;
            }
            removeFormat$1(editor, format, vars, child, format.exact ? child : null);
          });
        }
        clearChildStyles(editor.dom, format, node);
      });
    };
    var mergeWithParents = function (editor, format, name, vars, node) {
      if (matchNode(editor, node.parentNode, name, vars)) {
        if (removeFormat$1(editor, format, vars, node)) {
          return;
        }
      }
      if (format.merge_with_parents) {
        editor.dom.getParent(node.parentNode, function (parent) {
          if (matchNode(editor, parent, name, vars)) {
            removeFormat$1(editor, format, vars, node);
            return true;
          }
        });
      }
    };

    var each$7 = Tools.each;
    var isElementNode = function (node) {
      return isElement$5(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    };
    var canFormatBR = function (editor, format, node, parentName) {
      if (canFormatEmptyLines(editor) && isInlineFormat(format)) {
        var validBRParentElements = __assign(__assign({}, editor.schema.getTextBlockElements()), {
          td: {},
          th: {},
          li: {},
          dt: {},
          dd: {},
          figcaption: {},
          caption: {},
          details: {},
          summary: {}
        });
        var hasCaretNodeSibling = sibling(SugarElement.fromDom(node), function (sibling) {
          return isCaretNode(sibling.dom);
        });
        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
      } else {
        return false;
      }
    };
    var applyFormat$1 = function (ed, name, vars, node) {
      var formatList = ed.formatter.get(name);
      var format = formatList[0];
      var isCollapsed = !node && ed.selection.isCollapsed();
      var dom = ed.dom;
      var selection = ed.selection;
      var setElementFormat = function (elm, fmt) {
        if (fmt === void 0) {
          fmt = format;
        }
        if (isFunction(fmt.onformat)) {
          fmt.onformat(elm, fmt, vars, node);
        }
        each$7(fmt.styles, function (value, name) {
          dom.setStyle(elm, name, replaceVars(value, vars));
        });
        if (fmt.styles) {
          var styleVal = dom.getAttrib(elm, 'style');
          if (styleVal) {
            dom.setAttrib(elm, 'data-mce-style', styleVal);
          }
        }
        each$7(fmt.attributes, function (value, name) {
          dom.setAttrib(elm, name, replaceVars(value, vars));
        });
        each$7(fmt.classes, function (value) {
          value = replaceVars(value, vars);
          if (!dom.hasClass(elm, value)) {
            dom.addClass(elm, value);
          }
        });
      };
      var applyNodeStyle = function (formatList, node) {
        var found = false;
        each$7(formatList, function (format) {
          if (!isSelectorFormat(format)) {
            return false;
          }
          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {
            return;
          }
          if (dom.is(node, format.selector) && !isCaretNode(node)) {
            setElementFormat(node, format);
            found = true;
            return false;
          }
        });
        return found;
      };
      var createWrapElement = function (wrapName) {
        if (isString$1(wrapName)) {
          var wrapElm = dom.create(wrapName);
          setElementFormat(wrapElm);
          return wrapElm;
        } else {
          return null;
        }
      };
      var applyRngStyle = function (dom, rng, nodeSpecific) {
        var newWrappers = [];
        var contentEditable = true;
        var wrapName = format.inline || format.block;
        var wrapElm = createWrapElement(wrapName);
        walk$2(dom, rng, function (nodes) {
          var currentWrapElm;
          var process = function (node) {
            var hasContentEditableState = false;
            var lastContentEditable = contentEditable;
            var nodeName = node.nodeName.toLowerCase();
            var parentNode = node.parentNode;
            var parentName = parentNode.nodeName.toLowerCase();
            if (isElement$5(node) && dom.getContentEditable(node)) {
              lastContentEditable = contentEditable;
              contentEditable = dom.getContentEditable(node) === 'true';
              hasContentEditableState = true;
            }
            if (isBr$5(node) && !canFormatBR(ed, format, node, parentName)) {
              currentWrapElm = null;
              if (isBlockFormat(format)) {
                dom.remove(node);
              }
              return;
            }
            if (isBlockFormat(format) && format.wrapper && matchNode(ed, node, name, vars)) {
              currentWrapElm = null;
              return;
            }
            if (contentEditable && !hasContentEditableState && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {
              var elm = dom.rename(node, wrapName);
              setElementFormat(elm);
              newWrappers.push(elm);
              currentWrapElm = null;
              return;
            }
            if (isSelectorFormat(format)) {
              var found = applyNodeStyle(formatList, node);
              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                found = applyNodeStyle(formatList, parentNode);
              }
              if (!isInlineFormat(format) || found) {
                currentWrapElm = null;
                return;
              }
            }
            if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && isText$7(node) && isZwsp(node.data)) && !isCaretNode(node) && (!isInlineFormat(format) || !dom.isBlock(node))) {
              if (!currentWrapElm) {
                currentWrapElm = dom.clone(wrapElm, false);
                node.parentNode.insertBefore(currentWrapElm, node);
                newWrappers.push(currentWrapElm);
              }
              currentWrapElm.appendChild(node);
            } else {
              currentWrapElm = null;
              each$k(from(node.childNodes), process);
              if (hasContentEditableState) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm = null;
            }
          };
          each$k(nodes, process);
        });
        if (format.links === true) {
          each$k(newWrappers, function (node) {
            var process = function (node) {
              if (node.nodeName === 'A') {
                setElementFormat(node, format);
              }
              each$k(from(node.childNodes), process);
            };
            process(node);
          });
        }
        each$k(newWrappers, function (node) {
          var getChildCount = function (node) {
            var count = 0;
            each$k(node.childNodes, function (node) {
              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
                count++;
              }
            });
            return count;
          };
          var mergeStyles = function (node) {
            var childElement = find$3(node.childNodes, isElementNode).filter(function (child) {
              return matchName$1(dom, child, format);
            });
            return childElement.map(function (child) {
              var clone = dom.clone(child, false);
              setElementFormat(clone);
              dom.replace(clone, node, true);
              dom.remove(child, true);
              return clone;
            }).getOr(node);
          };
          var childCount = getChildCount(node);
          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
            dom.remove(node, true);
            return;
          }
          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
            if (!format.exact && childCount === 1) {
              node = mergeStyles(node);
            }
            mergeWithChildren(ed, formatList, vars, node);
            mergeWithParents(ed, format, name, vars, node);
            mergeBackgroundColorAndFontSize(dom, format, vars, node);
            mergeTextDecorationsAndColor(dom, format, vars, node);
            mergeSubSup(dom, format, vars, node);
            mergeSiblings(dom, format, vars, node);
          }
        });
      };
      if (dom.getContentEditable(selection.getNode()) === 'false') {
        node = selection.getNode();
        for (var i = 0, l = formatList.length; i < l; i++) {
          var formatItem = formatList[i];
          if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom.is(node, formatItem.selector)) {
            setElementFormat(node, formatItem);
            break;
          }
        }
        fireFormatApply(ed, name, node, vars);
        return;
      }
      if (format) {
        if (node) {
          if (isNode(node)) {
            if (!applyNodeStyle(formatList, node)) {
              var rng = dom.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              applyRngStyle(dom, expandRng(ed, rng, formatList), true);
            }
          } else {
            applyRngStyle(dom, node, true);
          }
        } else {
          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            var curSelNode = selection.getNode();
            var firstFormat = formatList[0];
            if (!ed.settings.forced_root_block && firstFormat.defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {
              applyFormat$1(ed, firstFormat.defaultBlock);
            }
            selection.setRng(normalize(selection.getRng()));
            preserve(selection, true, function () {
              runOnRanges(ed, function (selectionRng, fake) {
                var expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);
                applyRngStyle(dom, expandedRng, false);
              });
            });
            moveStart(dom, selection, selection.getRng());
            ed.nodeChanged();
          } else {
            applyCaretFormat(ed, name, vars);
          }
        }
        postProcess$1(name, ed);
      }
      fireFormatApply(ed, name, node, vars);
    };

    var hasVars = function (value) {
      return has$2(value, 'vars');
    };
    var setup$j = function (registeredFormatListeners, editor) {
      registeredFormatListeners.set({});
      editor.on('NodeChange', function (e) {
        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
      });
      editor.on('FormatApply FormatRemove', function (e) {
        var element = Optional.from(e.node).map(function (nodeOrRange) {
          return isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer;
        }).bind(function (node) {
          return isElement$5(node) ? Optional.some(node) : Optional.from(node.parentElement);
        }).getOrThunk(function () {
          return fallbackElement(editor);
        });
        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
      });
    };
    var fallbackElement = function (editor) {
      return editor.selection.getStart();
    };
    var matchingNode = function (editor, parents, format, similar, vars) {
      var isMatchingNode = function (node) {
        var matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
        return !isUndefined(matchingFormat);
      };
      var isUnableToMatch = function (node) {
        if (matchesUnInheritedFormatSelector(editor, node, format)) {
          return true;
        } else {
          if (!similar) {
            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
          } else {
            return false;
          }
        }
      };
      return findUntil$1(parents, isMatchingNode, isUnableToMatch);
    };
    var getParents = function (editor, elm) {
      var element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
      return filter$4(getParents$2(editor.dom, element), function (node) {
        return isElement$5(node) && !isBogus$2(node);
      });
    };
    var updateAndFireChangeCallbacks = function (editor, elm, registeredCallbacks) {
      var parents = getParents(editor, elm);
      each$j(registeredCallbacks, function (data, format) {
        var runIfChanged = function (spec) {
          var match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);
          var isSet = match.isSome();
          if (spec.state.get() !== isSet) {
            spec.state.set(isSet);
            var node_1 = match.getOr(elm);
            if (hasVars(spec)) {
              spec.callback(isSet, {
                node: node_1,
                format: format,
                parents: parents
              });
            } else {
              each$k(spec.callbacks, function (callback) {
                return callback(isSet, {
                  node: node_1,
                  format: format,
                  parents: parents
                });
              });
            }
          }
        };
        each$k([
          data.withSimilar,
          data.withoutSimilar
        ], runIfChanged);
        each$k(data.withVars, runIfChanged);
      });
    };
    var addListeners = function (editor, registeredFormatListeners, formats, callback, similar, vars) {
      var formatChangeItems = registeredFormatListeners.get();
      each$k(formats.split(','), function (format) {
        var group = get$9(formatChangeItems, format).getOrThunk(function () {
          var base = {
            withSimilar: {
              state: Cell(false),
              similar: true,
              callbacks: []
            },
            withoutSimilar: {
              state: Cell(false),
              similar: false,
              callbacks: []
            },
            withVars: []
          };
          formatChangeItems[format] = base;
          return base;
        });
        var getCurrent = function () {
          var parents = getParents(editor);
          return matchingNode(editor, parents, format, similar, vars).isSome();
        };
        if (isUndefined(vars)) {
          var toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
          toAppendTo.callbacks.push(callback);
          if (toAppendTo.callbacks.length === 1) {
            toAppendTo.state.set(getCurrent());
          }
        } else {
          group.withVars.push({
            state: Cell(getCurrent()),
            similar: similar,
            vars: vars,
            callback: callback
          });
        }
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    var removeListeners = function (registeredFormatListeners, formats, callback) {
      var formatChangeItems = registeredFormatListeners.get();
      each$k(formats.split(','), function (format) {
        return get$9(formatChangeItems, format).each(function (group) {
          formatChangeItems[format] = {
            withSimilar: __assign(__assign({}, group.withSimilar), {
              callbacks: filter$4(group.withSimilar.callbacks, function (cb) {
                return cb !== callback;
              })
            }),
            withoutSimilar: __assign(__assign({}, group.withoutSimilar), {
              callbacks: filter$4(group.withoutSimilar.callbacks, function (cb) {
                return cb !== callback;
              })
            }),
            withVars: filter$4(group.withVars, function (item) {
              return item.callback !== callback;
            })
          };
        });
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    var formatChangedInternal = function (editor, registeredFormatListeners, formats, callback, similar, vars) {
      if (registeredFormatListeners.get() === null) {
        setup$j(registeredFormatListeners, editor);
      }
      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
      return {
        unbind: function () {
          return removeListeners(registeredFormatListeners, formats, callback);
        }
      };
    };

    var toggle = function (editor, name, vars, node) {
      var fmt = editor.formatter.get(name);
      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
        remove$1(editor, name, vars, node);
      } else {
        applyFormat$1(editor, name, vars, node);
      }
    };

    var fromElements = function (elements, scope) {
      var doc = scope || document;
      var fragment = doc.createDocumentFragment();
      each$k(elements, function (element) {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };

    var tableModel = function (element, width, rows) {
      return {
        element: element,
        width: width,
        rows: rows
      };
    };
    var tableRow = function (element, cells) {
      return {
        element: element,
        cells: cells
      };
    };
    var cellPosition = function (x, y) {
      return {
        x: x,
        y: y
      };
    };
    var getSpan = function (td, key) {
      var value = parseInt(get$6(td, key), 10);
      return isNaN(value) ? 1 : value;
    };
    var fillout = function (table, x, y, tr, td) {
      var rowspan = getSpan(td, 'rowspan');
      var colspan = getSpan(td, 'colspan');
      var rows = table.rows;
      for (var y2 = y; y2 < y + rowspan; y2++) {
        if (!rows[y2]) {
          rows[y2] = tableRow(deep$1(tr), []);
        }
        for (var x2 = x; x2 < x + colspan; x2++) {
          var cells = rows[y2].cells;
          cells[x2] = y2 === y && x2 === x ? td : shallow(td);
        }
      }
    };
    var cellExists = function (table, x, y) {
      var rows = table.rows;
      var cells = rows[y] ? rows[y].cells : [];
      return !!cells[x];
    };
    var skipCellsX = function (table, x, y) {
      while (cellExists(table, x, y)) {
        x++;
      }
      return x;
    };
    var getWidth = function (rows) {
      return foldl(rows, function (acc, row) {
        return row.cells.length > acc ? row.cells.length : acc;
      }, 0);
    };
    var findElementPos = function (table, element) {
      var rows = table.rows;
      for (var y = 0; y < rows.length; y++) {
        var cells = rows[y].cells;
        for (var x = 0; x < cells.length; x++) {
          if (eq(cells[x], element)) {
            return Optional.some(cellPosition(x, y));
          }
        }
      }
      return Optional.none();
    };
    var extractRows = function (table, sx, sy, ex, ey) {
      var newRows = [];
      var rows = table.rows;
      for (var y = sy; y <= ey; y++) {
        var cells = rows[y].cells;
        var slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
        newRows.push(tableRow(rows[y].element, slice));
      }
      return newRows;
    };
    var subTable = function (table, startPos, endPos) {
      var sx = startPos.x, sy = startPos.y;
      var ex = endPos.x, ey = endPos.y;
      var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
      return tableModel(table.element, getWidth(newRows), newRows);
    };
    var createDomTable = function (table, rows) {
      var tableElement = shallow(table.element);
      var tableBody = SugarElement.fromTag('tbody');
      append(tableBody, rows);
      append$1(tableElement, tableBody);
      return tableElement;
    };
    var modelRowsToDomRows = function (table) {
      return map$3(table.rows, function (row) {
        var cells = map$3(row.cells, function (cell) {
          var td = deep$1(cell);
          remove$6(td, 'colspan');
          remove$6(td, 'rowspan');
          return td;
        });
        var tr = shallow(row.element);
        append(tr, cells);
        return tr;
      });
    };
    var fromDom = function (tableElm) {
      var table = tableModel(shallow(tableElm), 0, []);
      each$k(descendants(tableElm, 'tr'), function (tr, y) {
        each$k(descendants(tr, 'td,th'), function (td, x) {
          fillout(table, skipCellsX(table, x, y), y, tr, td);
        });
      });
      return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    var toDom = function (table) {
      return createDomTable(table, modelRowsToDomRows(table));
    };
    var subsection = function (table, startElement, endElement) {
      return findElementPos(table, startElement).bind(function (startPos) {
        return findElementPos(table, endElement).map(function (endPos) {
          return subTable(table, startPos, endPos);
        });
      });
    };

    var findParentListContainer = function (parents) {
      return find$3(parents, function (elm) {
        return name(elm) === 'ul' || name(elm) === 'ol';
      });
    };
    var getFullySelectedListWrappers = function (parents, rng) {
      return find$3(parents, function (elm) {
        return name(elm) === 'li' && hasAllContentsSelected(elm, rng);
      }).fold(constant([]), function (_li) {
        return findParentListContainer(parents).map(function (listCont) {
          var listElm = SugarElement.fromTag(name(listCont));
          var listStyles = filter$3(getAllRaw(listCont), function (_style, name) {
            return startsWith(name, 'list-style');
          });
          setAll(listElm, listStyles);
          return [
            SugarElement.fromTag('li'),
            listElm
          ];
        }).getOr([]);
      });
    };
    var wrap = function (innerElm, elms) {
      var wrapped = foldl(elms, function (acc, elm) {
        append$1(elm, acc);
        return elm;
      }, innerElm);
      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    var directListWrappers = function (commonAnchorContainer) {
      if (isListItem(commonAnchorContainer)) {
        return parent(commonAnchorContainer).filter(isList).fold(constant([]), function (listElm) {
          return [
            commonAnchorContainer,
            listElm
          ];
        });
      } else {
        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
      }
    };
    var getWrapElements = function (rootNode, rng) {
      var commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
      var parents = parentsAndSelf(commonAnchorContainer, rootNode);
      var wrapElements = filter$4(parents, function (elm) {
        return isInline$1(elm) || isHeading(elm);
      });
      var listWrappers = getFullySelectedListWrappers(parents, rng);
      var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
      return map$3(allWrappers, shallow);
    };
    var emptyFragment = function () {
      return fromElements([]);
    };
    var getFragmentFromRange = function (rootNode, rng) {
      return wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
    };
    var getParentTable = function (rootElm, cell) {
      return ancestor$2(cell, 'table', curry(eq, rootElm));
    };
    var getTableFragment = function (rootNode, selectedTableCells) {
      return getParentTable(rootNode, selectedTableCells[0]).bind(function (tableElm) {
        var firstCell = selectedTableCells[0];
        var lastCell = selectedTableCells[selectedTableCells.length - 1];
        var fullTableModel = fromDom(tableElm);
        return subsection(fullTableModel, firstCell, lastCell).map(function (sectionedTableModel) {
          return fromElements([toDom(sectionedTableModel)]);
        });
      }).getOrThunk(emptyFragment);
    };
    var getSelectionFragment = function (rootNode, ranges) {
      return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
    };
    var read$3 = function (rootNode, ranges) {
      var selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
    };

    var trimLeadingCollapsibleText = function (text) {
      return text.replace(/^[ \f\n\r\t\v]+/, '');
    };
    var isCollapsibleWhitespace = function (text, index) {
      return index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
    };
    var getInnerText = function (bin, shouldTrim) {
      var text = trim$2(bin.innerText);
      return shouldTrim ? trimLeadingCollapsibleText(text) : text;
    };
    var getContextNodeName = function (parentBlockOpt) {
      return parentBlockOpt.map(function (block) {
        return block.nodeName;
      }).getOr('div').toLowerCase();
    };
    var getTextContent = function (editor) {
      return Optional.from(editor.selection.getRng()).map(function (rng) {
        var parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
        var body = editor.getBody();
        var contextNodeName = getContextNodeName(parentBlockOpt);
        var shouldTrimSpaces = Env.browser.isIE() && contextNodeName !== 'pre';
        var bin = editor.dom.add(body, contextNodeName, {
          'data-mce-bogus': 'all',
          'style': 'overflow: hidden; opacity: 0;'
        }, rng.cloneContents());
        var text = getInnerText(bin, shouldTrimSpaces);
        var nonRenderedText = trim$2(bin.textContent);
        editor.dom.remove(bin);
        if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
          var parentBlock = parentBlockOpt.getOr(body);
          var parentBlockText = getInnerText(parentBlock, shouldTrimSpaces);
          var textIndex = parentBlockText.indexOf(text);
          if (textIndex === -1) {
            return text;
          } else {
            var hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
            var hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
            return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');
          }
        } else {
          return text;
        }
      }).getOr('');
    };
    var getSerializedContent = function (editor, args) {
      var rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
      var sel = editor.selection.getSel();
      var ranges = processRanges(editor, getRanges(sel));
      var fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
      if (fragment) {
        tmpElm.appendChild(fragment);
      }
      return editor.selection.serializer.serialize(tmpElm, args);
    };
    var setupArgs$1 = function (args, format) {
      return __assign(__assign({}, args), {
        format: format,
        get: true,
        selection: true
      });
    };
    var getSelectedContentInternal = function (editor, format, args) {
      if (args === void 0) {
        args = {};
      }
      var defaultedArgs = setupArgs$1(args, format);
      var updatedArgs = editor.fire('BeforeGetContent', defaultedArgs);
      if (updatedArgs.isDefaultPrevented()) {
        editor.fire('GetContent', updatedArgs);
        return updatedArgs.content;
      }
      if (updatedArgs.format === 'text') {
        return getTextContent(editor);
      } else {
        updatedArgs.getInner = true;
        var content = getSerializedContent(editor, updatedArgs);
        if (updatedArgs.format === 'tree') {
          return content;
        } else {
          updatedArgs.content = editor.selection.isCollapsed() ? '' : content;
          editor.fire('GetContent', updatedArgs);
          return updatedArgs.content;
        }
      }
    };

    var KEEP = 0, INSERT = 1, DELETE = 2;
    var diff = function (left, right) {
      var size = left.length + right.length + 2;
      var vDown = new Array(size);
      var vUp = new Array(size);
      var snake = function (start, end, diag) {
        return {
          start: start,
          end: end,
          diag: diag
        };
      };
      var buildScript = function (start1, end1, start2, end2, script) {
        var middle = getMiddleSnake(start1, end1, start2, end2);
        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
          var i = start1;
          var j = start2;
          while (i < end1 || j < end2) {
            if (i < end1 && j < end2 && left[i] === right[j]) {
              script.push([
                KEEP,
                left[i]
              ]);
              ++i;
              ++j;
            } else {
              if (end1 - start1 > end2 - start2) {
                script.push([
                  DELETE,
                  left[i]
                ]);
                ++i;
              } else {
                script.push([
                  INSERT,
                  right[j]
                ]);
                ++j;
              }
            }
          }
        } else {
          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
          for (var i2 = middle.start; i2 < middle.end; ++i2) {
            script.push([
              KEEP,
              left[i2]
            ]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
        }
      };
      var buildSnake = function (start, diag, end1, end2) {
        var end = start;
        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
          ++end;
        }
        return snake(start, end, diag);
      };
      var getMiddleSnake = function (start1, end1, start2, end2) {
        var m = end1 - start1;
        var n = end2 - start2;
        if (m === 0 || n === 0) {
          return null;
        }
        var delta = m - n;
        var sum = n + m;
        var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
        vDown[1 + offset] = start1;
        vUp[1 + offset] = end1 + 1;
        var d, k, i, x, y;
        for (d = 0; d <= offset; ++d) {
          for (k = -d; k <= d; k += 2) {
            i = k + offset;
            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
              vDown[i] = vDown[i + 1];
            } else {
              vDown[i] = vDown[i - 1] + 1;
            }
            x = vDown[i];
            y = x - start1 + start2 - k;
            while (x < end1 && y < end2 && left[x] === right[y]) {
              vDown[i] = ++x;
              ++y;
            }
            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
              if (vUp[i - delta] <= vDown[i]) {
                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
              }
            }
          }
          for (k = delta - d; k <= delta + d; k += 2) {
            i = k + offset - delta;
            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
              vUp[i] = vUp[i + 1] - 1;
            } else {
              vUp[i] = vUp[i - 1];
            }
            x = vUp[i] - 1;
            y = x - start1 + start2 - k;
            while (x >= start1 && y >= start2 && left[x] === right[y]) {
              vUp[i] = x--;
              y--;
            }
            if (delta % 2 === 0 && -d <= k && k <= d) {
              if (vUp[i] <= vDown[i + delta]) {
                return buildSnake(vUp[i], k + start1 - start2, end1, end2);
              }
            }
          }
        }
      };
      var script = [];
      buildScript(0, left.length, 0, right.length, script);
      return script;
    };

    var getOuterHtml = function (elm) {
      if (isElement$5(elm)) {
        return elm.outerHTML;
      } else if (isText$7(elm)) {
        return Entities.encodeRaw(elm.data, false);
      } else if (isComment(elm)) {
        return '<!--' + elm.data + '-->';
      }
      return '';
    };
    var createFragment = function (html) {
      var node;
      var container = document.createElement('div');
      var frag = document.createDocumentFragment();
      if (html) {
        container.innerHTML = html;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    var insertAt = function (elm, html, index) {
      var fragment = createFragment(html);
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        var target = elm.childNodes[index];
        target.parentNode.insertBefore(fragment, target);
      } else {
        elm.appendChild(fragment);
      }
    };
    var removeAt = function (elm, index) {
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        var target = elm.childNodes[index];
        target.parentNode.removeChild(target);
      }
    };
    var applyDiff = function (diff, elm) {
      var index = 0;
      each$k(diff, function (action) {
        if (action[0] === KEEP) {
          index++;
        } else if (action[0] === INSERT) {
          insertAt(elm, action[1], index);
          index++;
        } else if (action[0] === DELETE) {
          removeAt(elm, index);
        }
      });
    };
    var read$2 = function (elm) {
      return filter$4(map$3(from(elm.childNodes), getOuterHtml), function (item) {
        return item.length > 0;
      });
    };
    var write = function (fragments, elm) {
      var currentFragments = map$3(from(elm.childNodes), getOuterHtml);
      applyDiff(diff(currentFragments, fragments), elm);
      return elm;
    };

    var lazyTempDocument = cached(function () {
      return document.implementation.createHTMLDocument('undo');
    });
    var hasIframes = function (html) {
      return html.indexOf('</iframe>') !== -1;
    };
    var createFragmentedLevel = function (fragments) {
      return {
        type: 'fragmented',
        fragments: fragments,
        content: '',
        bookmark: null,
        beforeBookmark: null
      };
    };
    var createCompleteLevel = function (content) {
      return {
        type: 'complete',
        fragments: null,
        content: content,
        bookmark: null,
        beforeBookmark: null
      };
    };
    var createFromEditor = function (editor) {
      var fragments = read$2(editor.getBody());
      var trimmedFragments = bind(fragments, function (html) {
        var trimmed = trimInternal(editor.serializer, html);
        return trimmed.length > 0 ? [trimmed] : [];
      });
      var content = trimmedFragments.join('');
      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };
    var applyToEditor = function (editor, level, before) {
      var bookmark = before ? level.beforeBookmark : level.bookmark;
      if (level.type === 'fragmented') {
        write(level.fragments, editor.getBody());
      } else {
        editor.setContent(level.content, {
          format: 'raw',
          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
        });
      }
      editor.selection.moveToBookmark(bookmark);
    };
    var getLevelContent = function (level) {
      return level.type === 'fragmented' ? level.fragments.join('') : level.content;
    };
    var getCleanLevelContent = function (level) {
      var elm = SugarElement.fromTag('body', lazyTempDocument());
      set(elm, getLevelContent(level));
      each$k(descendants(elm, '*[data-mce-bogus]'), unwrap);
      return get$3(elm);
    };
    var hasEqualContent = function (level1, level2) {
      return getLevelContent(level1) === getLevelContent(level2);
    };
    var hasEqualCleanedContent = function (level1, level2) {
      return getCleanLevelContent(level1) === getCleanLevelContent(level2);
    };
    var isEq$1 = function (level1, level2) {
      if (!level1 || !level2) {
        return false;
      } else if (hasEqualContent(level1, level2)) {
        return true;
      } else {
        return hasEqualCleanedContent(level1, level2);
      }
    };

    var isUnlocked = function (locks) {
      return locks.get() === 0;
    };

    var setTyping = function (undoManager, typing, locks) {
      if (isUnlocked(locks)) {
        undoManager.typing = typing;
      }
    };
    var endTyping = function (undoManager, locks) {
      if (undoManager.typing) {
        setTyping(undoManager, false, locks);
        undoManager.add();
      }
    };
    var endTypingLevelIgnoreLocks = function (undoManager) {
      if (undoManager.typing) {
        undoManager.typing = false;
        undoManager.add();
      }
    };

    var beforeChange$1 = function (editor, locks, beforeBookmark) {
      if (isUnlocked(locks)) {
        beforeBookmark.set(getUndoBookmark(editor.selection));
      }
    };
    var addUndoLevel$1 = function (editor, undoManager, index, locks, beforeBookmark, level, event) {
      var currentLevel = createFromEditor(editor);
      level = level || {};
      level = Tools.extend(level, currentLevel);
      if (isUnlocked(locks) === false || editor.removed) {
        return null;
      }
      var lastLevel = undoManager.data[index.get()];
      if (editor.fire('BeforeAddUndo', {
          level: level,
          lastLevel: lastLevel,
          originalEvent: event
        }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel && isEq$1(lastLevel, level)) {
        return null;
      }
      if (undoManager.data[index.get()]) {
        beforeBookmark.get().each(function (bm) {
          undoManager.data[index.get()].beforeBookmark = bm;
        });
      }
      var customUndoRedoLevels = getCustomUndoRedoLevels(editor);
      if (customUndoRedoLevels) {
        if (undoManager.data.length > customUndoRedoLevels) {
          for (var i = 0; i < undoManager.data.length - 1; i++) {
            undoManager.data[i] = undoManager.data[i + 1];
          }
          undoManager.data.length--;
          index.set(undoManager.data.length);
        }
      }
      level.bookmark = getUndoBookmark(editor.selection);
      if (index.get() < undoManager.data.length - 1) {
        undoManager.data.length = index.get() + 1;
      }
      undoManager.data.push(level);
      index.set(undoManager.data.length - 1);
      var args = {
        level: level,
        lastLevel: lastLevel,
        originalEvent: event
      };
      if (index.get() > 0) {
        editor.setDirty(true);
        editor.fire('AddUndo', args);
        editor.fire('change', args);
      } else {
        editor.fire('AddUndo', args);
      }
      return level;
    };
    var clear$1 = function (editor, undoManager, index) {
      undoManager.data = [];
      index.set(0);
      undoManager.typing = false;
      editor.fire('ClearUndos');
    };
    var extra$1 = function (editor, undoManager, index, callback1, callback2) {
      if (undoManager.transact(callback1)) {
        var bookmark = undoManager.data[index.get()].bookmark;
        var lastLevel = undoManager.data[index.get() - 1];
        applyToEditor(editor, lastLevel, true);
        if (undoManager.transact(callback2)) {
          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
        }
      }
    };
    var redo$1 = function (editor, index, data) {
      var level;
      if (index.get() < data.length - 1) {
        index.set(index.get() + 1);
        level = data[index.get()];
        applyToEditor(editor, level, false);
        editor.setDirty(true);
        editor.fire('Redo', { level: level });
      }
      return level;
    };
    var undo$1 = function (editor, undoManager, locks, index) {
      var level;
      if (undoManager.typing) {
        undoManager.add();
        undoManager.typing = false;
        setTyping(undoManager, false, locks);
      }
      if (index.get() > 0) {
        index.set(index.get() - 1);
        level = undoManager.data[index.get()];
        applyToEditor(editor, level, true);
        editor.setDirty(true);
        editor.fire('Undo', { level: level });
      }
      return level;
    };
    var reset$1 = function (undoManager) {
      undoManager.clear();
      undoManager.add();
    };
    var hasUndo$1 = function (editor, undoManager, index) {
      return index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
    };
    var hasRedo$1 = function (undoManager, index) {
      return index.get() < undoManager.data.length - 1 && !undoManager.typing;
    };
    var transact$1 = function (undoManager, locks, callback) {
      endTyping(undoManager, locks);
      undoManager.beforeChange();
      undoManager.ignore(callback);
      return undoManager.add();
    };
    var ignore$1 = function (locks, callback) {
      try {
        locks.set(locks.get() + 1);
        callback();
      } finally {
        locks.set(locks.get() - 1);
      }
    };

    var addVisualInternal = function (editor, elm) {
      var dom = editor.dom;
      var scope = isNonNullable(elm) ? elm : editor.getBody();
      if (isUndefined(editor.hasVisual)) {
        editor.hasVisual = isVisualAidsEnabled(editor);
      }
      each$k(dom.select('table,a', scope), function (matchedElm) {
        switch (matchedElm.nodeName) {
        case 'TABLE':
          var cls = getVisualAidsTableClass(editor);
          var value = dom.getAttrib(matchedElm, 'border');
          if ((!value || value === '0') && editor.hasVisual) {
            dom.addClass(matchedElm, cls);
          } else {
            dom.removeClass(matchedElm, cls);
          }
          break;
        case 'A':
          if (!dom.getAttrib(matchedElm, 'href')) {
            var value_1 = dom.getAttrib(matchedElm, 'name') || matchedElm.id;
            var cls_1 = getVisualAidsAnchorClass(editor);
            if (value_1 && editor.hasVisual) {
              dom.addClass(matchedElm, cls_1);
            } else {
              dom.removeClass(matchedElm, cls_1);
            }
          }
          break;
        }
      });
      editor.fire('VisualAid', {
        element: elm,
        hasVisual: editor.hasVisual
      });
    };

    var makePlainAdaptor = function (editor) {
      return {
        undoManager: {
          beforeChange: function (locks, beforeBookmark) {
            return beforeChange$1(editor, locks, beforeBookmark);
          },
          add: function (undoManager, index, locks, beforeBookmark, level, event) {
            return addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event);
          },
          undo: function (undoManager, locks, index) {
            return undo$1(editor, undoManager, locks, index);
          },
          redo: function (index, data) {
            return redo$1(editor, index, data);
          },
          clear: function (undoManager, index) {
            return clear$1(editor, undoManager, index);
          },
          reset: function (undoManager) {
            return reset$1(undoManager);
          },
          hasUndo: function (undoManager, index) {
            return hasUndo$1(editor, undoManager, index);
          },
          hasRedo: function (undoManager, index) {
            return hasRedo$1(undoManager, index);
          },
          transact: function (undoManager, locks, callback) {
            return transact$1(undoManager, locks, callback);
          },
          ignore: function (locks, callback) {
            return ignore$1(locks, callback);
          },
          extra: function (undoManager, index, callback1, callback2) {
            return extra$1(editor, undoManager, index, callback1, callback2);
          }
        },
        formatter: {
          match: function (name, vars, node, similar) {
            return match$2(editor, name, vars, node, similar);
          },
          matchAll: function (names, vars) {
            return matchAll(editor, names, vars);
          },
          matchNode: function (node, name, vars, similar) {
            return matchNode(editor, node, name, vars, similar);
          },
          canApply: function (name) {
            return canApply(editor, name);
          },
          closest: function (names) {
            return closest(editor, names);
          },
          apply: function (name, vars, node) {
            return applyFormat$1(editor, name, vars, node);
          },
          remove: function (name, vars, node, similar) {
            return remove$1(editor, name, vars, node, similar);
          },
          toggle: function (name, vars, node) {
            return toggle(editor, name, vars, node);
          },
          formatChanged: function (registeredFormatListeners, formats, callback, similar, vars) {
            return formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars);
          }
        },
        editor: {
          getContent: function (args, format) {
            return getContentInternal(editor, args, format);
          },
          setContent: function (content, args) {
            return setContentInternal(editor, content, args);
          },
          insertContent: function (value, details) {
            return insertHtmlAtCaret(editor, value, details);
          },
          addVisual: function (elm) {
            return addVisualInternal(editor, elm);
          }
        },
        selection: {
          getContent: function (format, args) {
            return getSelectedContentInternal(editor, format, args);
          }
        },
        raw: {
          getModel: function () {
            return Optional.none();
          }
        }
      };
    };
    var makeRtcAdaptor = function (rtcEditor) {
      var defaultVars = function (vars) {
        return isObject(vars) ? vars : {};
      };
      var undoManager = rtcEditor.undoManager, formatter = rtcEditor.formatter, editor = rtcEditor.editor, selection = rtcEditor.selection, raw = rtcEditor.raw;
      return {
        undoManager: {
          beforeChange: undoManager.beforeChange,
          add: undoManager.add,
          undo: undoManager.undo,
          redo: undoManager.redo,
          clear: undoManager.clear,
          reset: undoManager.reset,
          hasUndo: undoManager.hasUndo,
          hasRedo: undoManager.hasRedo,
          transact: function (_undoManager, _locks, fn) {
            return undoManager.transact(fn);
          },
          ignore: function (_locks, callback) {
            return undoManager.ignore(callback);
          },
          extra: function (_undoManager, _index, callback1, callback2) {
            return undoManager.extra(callback1, callback2);
          }
        },
        formatter: {
          match: function (name, vars, _node, similar) {
            return formatter.match(name, defaultVars(vars), similar);
          },
          matchAll: formatter.matchAll,
          matchNode: formatter.matchNode,
          canApply: function (name) {
            return formatter.canApply(name);
          },
          closest: function (names) {
            return formatter.closest(names);
          },
          apply: function (name, vars, _node) {
            return formatter.apply(name, defaultVars(vars));
          },
          remove: function (name, vars, _node, _similar) {
            return formatter.remove(name, defaultVars(vars));
          },
          toggle: function (name, vars, _node) {
            return formatter.toggle(name, defaultVars(vars));
          },
          formatChanged: function (_rfl, formats, callback, similar, vars) {
            return formatter.formatChanged(formats, callback, similar, vars);
          }
        },
        editor: {
          getContent: function (args, _format) {
            return editor.getContent(args);
          },
          setContent: function (content, args) {
            return editor.setContent(content, args);
          },
          insertContent: function (content, _details) {
            return editor.insertContent(content);
          },
          addVisual: editor.addVisual
        },
        selection: {
          getContent: function (_format, args) {
            return selection.getContent(args);
          }
        },
        raw: {
          getModel: function () {
            return Optional.some(raw.getRawModel());
          }
        }
      };
    };
    var makeNoopAdaptor = function () {
      var nul = constant(null);
      var empty = constant('');
      return {
        undoManager: {
          beforeChange: noop,
          add: nul,
          undo: nul,
          redo: nul,
          clear: noop,
          reset: noop,
          hasUndo: never,
          hasRedo: never,
          transact: nul,
          ignore: noop,
          extra: noop
        },
        formatter: {
          match: never,
          matchAll: constant([]),
          matchNode: constant(undefined),
          canApply: never,
          closest: empty,
          apply: noop,
          remove: noop,
          toggle: noop,
          formatChanged: constant({ unbind: noop })
        },
        editor: {
          getContent: empty,
          setContent: empty,
          insertContent: noop,
          addVisual: noop
        },
        selection: { getContent: empty },
        raw: { getModel: constant(Optional.none()) }
      };
    };
    var isRtc = function (editor) {
      return has$2(editor.plugins, 'rtc');
    };
    var getRtcSetup = function (editor) {
      return get$9(editor.plugins, 'rtc').bind(function (rtcPlugin) {
        return Optional.from(rtcPlugin.setup);
      });
    };
    var setup$i = function (editor) {
      var editorCast = editor;
      return getRtcSetup(editor).fold(function () {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      }, function (setup) {
        editorCast.rtcInstance = makeNoopAdaptor();
        return Optional.some(function () {
          return setup().then(function (rtcEditor) {
            editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
            return rtcEditor.rtc.isRemote;
          });
        });
      });
    };
    var getRtcInstanceWithFallback = function (editor) {
      return editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    };
    var getRtcInstanceWithError = function (editor) {
      var rtcInstance = editor.rtcInstance;
      if (!rtcInstance) {
        throw new Error('Failed to get RTC instance not yet initialized.');
      } else {
        return rtcInstance;
      }
    };
    var beforeChange = function (editor, locks, beforeBookmark) {
      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    var addUndoLevel = function (editor, undoManager, index, locks, beforeBookmark, level, event) {
      return getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    };
    var undo = function (editor, undoManager, locks, index) {
      return getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    };
    var redo = function (editor, index, data) {
      return getRtcInstanceWithError(editor).undoManager.redo(index, data);
    };
    var clear = function (editor, undoManager, index) {
      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    var reset = function (editor, undoManager) {
      getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    var hasUndo = function (editor, undoManager, index) {
      return getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    };
    var hasRedo = function (editor, undoManager, index) {
      return getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    };
    var transact = function (editor, undoManager, locks, callback) {
      return getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    };
    var ignore = function (editor, locks, callback) {
      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    var extra = function (editor, undoManager, index, callback1, callback2) {
      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    var matchFormat = function (editor, name, vars, node, similar) {
      return getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
    };
    var matchAllFormats = function (editor, names, vars) {
      return getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    };
    var matchNodeFormat = function (editor, node, name, vars, similar) {
      return getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);
    };
    var canApplyFormat = function (editor, name) {
      return getRtcInstanceWithError(editor).formatter.canApply(name);
    };
    var closestFormat = function (editor, names) {
      return getRtcInstanceWithError(editor).formatter.closest(names);
    };
    var applyFormat = function (editor, name, vars, node) {
      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
    };
    var removeFormat = function (editor, name, vars, node, similar) {
      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
    };
    var toggleFormat = function (editor, name, vars, node) {
      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
    };
    var formatChanged = function (editor, registeredFormatListeners, formats, callback, similar, vars) {
      return getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    };
    var getContent$2 = function (editor, args, format) {
      return getRtcInstanceWithFallback(editor).editor.getContent(args, format);
    };
    var setContent$2 = function (editor, content, args) {
      return getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    };
    var insertContent = function (editor, value, details) {
      return getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
    };
    var getSelectedContent = function (editor, format, args) {
      return getRtcInstanceWithError(editor).selection.getContent(format, args);
    };
    var addVisual$1 = function (editor, elm) {
      return getRtcInstanceWithError(editor).editor.addVisual(elm);
    };

    var getContent$1 = function (editor, args) {
      if (args === void 0) {
        args = {};
      }
      var format = args.format ? args.format : 'html';
      return getSelectedContent(editor, format, args);
    };

    var removeEmpty = function (text) {
      if (text.dom.length === 0) {
        remove$7(text);
        return Optional.none();
      } else {
        return Optional.some(text);
      }
    };
    var walkPastBookmark = function (node, start) {
      return node.filter(function (elm) {
        return BookmarkManager.isBookmarkNode(elm.dom);
      }).bind(start ? nextSibling : prevSibling);
    };
    var merge = function (outer, inner, rng, start) {
      var outerElm = outer.dom;
      var innerElm = inner.dom;
      var oldLength = start ? outerElm.length : innerElm.length;
      if (start) {
        mergeTextNodes(outerElm, innerElm, false, !start);
        rng.setStart(innerElm, oldLength);
      } else {
        mergeTextNodes(innerElm, outerElm, false, !start);
        rng.setEnd(innerElm, oldLength);
      }
    };
    var normalizeTextIfRequired = function (inner, start) {
      parent(inner).each(function (root) {
        var text = inner.dom;
        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {
          normalizeWhitespaceAfter(text, 0);
        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {
          normalizeWhitespaceBefore(text, text.length);
        }
      });
    };
    var mergeAndNormalizeText = function (outerNode, innerNode, rng, start) {
      outerNode.bind(function (outer) {
        var normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
        normalizer(outer.dom, start ? outer.dom.length : 0);
        return innerNode.filter(isText$8).map(function (inner) {
          return merge(outer, inner, rng, start);
        });
      }).orThunk(function () {
        var innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$8);
        return innerTextNode.map(function (inner) {
          return normalizeTextIfRequired(inner, start);
        });
      });
    };
    var rngSetContent = function (rng, fragment) {
      var firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
      var lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
      rng.deleteContents();
      rng.insertNode(fragment);
      var prevText = firstChild.bind(prevSibling).filter(isText$8).bind(removeEmpty);
      var nextText = lastChild.bind(nextSibling).filter(isText$8).bind(removeEmpty);
      mergeAndNormalizeText(prevText, firstChild, rng, true);
      mergeAndNormalizeText(nextText, lastChild, rng, false);
      rng.collapse(false);
    };
    var setupArgs = function (args, content) {
      return __assign(__assign({ format: 'html' }, args), {
        set: true,
        selection: true,
        content: content
      });
    };
    var cleanContent = function (editor, args) {
      if (args.format !== 'raw') {
        var rng = editor.selection.getRng();
        var contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
        var contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
        var node = editor.parser.parse(args.content, __assign(__assign({
          isRootContent: true,
          forced_root_block: false
        }, contextArgs), args));
        return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node);
      } else {
        return args.content;
      }
    };
    var setContent$1 = function (editor, content, args) {
      if (args === void 0) {
        args = {};
      }
      var defaultedArgs = setupArgs(args, content);
      var updatedArgs = defaultedArgs;
      if (!defaultedArgs.no_events) {
        var eventArgs = editor.fire('BeforeSetContent', defaultedArgs);
        if (eventArgs.isDefaultPrevented()) {
          editor.fire('SetContent', eventArgs);
          return;
        } else {
          updatedArgs = eventArgs;
        }
      }
      updatedArgs.content = cleanContent(editor, updatedArgs);
      var rng = editor.selection.getRng();
      rngSetContent(rng, rng.createContextualFragment(updatedArgs.content));
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
      if (!updatedArgs.no_events) {
        editor.fire('SetContent', updatedArgs);
      }
    };

    var deleteFromCallbackMap = function (callbackMap, selector, callback) {
      if (callbackMap && has$2(callbackMap, selector)) {
        var newCallbacks = filter$4(callbackMap[selector], function (cb) {
          return cb !== callback;
        });
        if (newCallbacks.length === 0) {
          delete callbackMap[selector];
        } else {
          callbackMap[selector] = newCallbacks;
        }
      }
    };
    function SelectorChanged (dom, editor) {
      var selectorChangedData;
      var currentSelectors;
      var findMatchingNode = function (selector, nodes) {
        return find$3(nodes, function (node) {
          return dom.is(node, selector);
        });
      };
      var getParents = function (elem) {
        return dom.getParents(elem, null, dom.getRoot());
      };
      return {
        selectorChangedWithUnbind: function (selector, callback) {
          if (!selectorChangedData) {
            selectorChangedData = {};
            currentSelectors = {};
            editor.on('NodeChange', function (e) {
              var node = e.element;
              var parents = getParents(node);
              var matchedSelectors = {};
              Tools.each(selectorChangedData, function (callbacks, selector) {
                findMatchingNode(selector, parents).each(function (node) {
                  if (!currentSelectors[selector]) {
                    each$k(callbacks, function (callback) {
                      callback(true, {
                        node: node,
                        selector: selector,
                        parents: parents
                      });
                    });
                    currentSelectors[selector] = callbacks;
                  }
                  matchedSelectors[selector] = callbacks;
                });
              });
              Tools.each(currentSelectors, function (callbacks, selector) {
                if (!matchedSelectors[selector]) {
                  delete currentSelectors[selector];
                  Tools.each(callbacks, function (callback) {
                    callback(false, {
                      node: node,
                      selector: selector,
                      parents: parents
                    });
                  });
                }
              });
            });
          }
          if (!selectorChangedData[selector]) {
            selectorChangedData[selector] = [];
          }
          selectorChangedData[selector].push(callback);
          findMatchingNode(selector, getParents(editor.selection.getStart())).each(function () {
            currentSelectors[selector] = selectorChangedData[selector];
          });
          return {
            unbind: function () {
              deleteFromCallbackMap(selectorChangedData, selector, callback);
              deleteFromCallbackMap(currentSelectors, selector, callback);
            }
          };
        }
      };
    }

    var isNativeIeSelection = function (rng) {
      return !!rng.select;
    };
    var isAttachedToDom = function (node) {
      return !!(node && node.ownerDocument) && contains$1(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    var isValidRange = function (rng) {
      if (!rng) {
        return false;
      } else if (isNativeIeSelection(rng)) {
        return true;
      } else {
        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
      }
    };
    var EditorSelection = function (dom, win, serializer, editor) {
      var selectedRange;
      var explicitRange;
      var selectorChangedWithUnbind = SelectorChanged(dom, editor).selectorChangedWithUnbind;
      var setCursorLocation = function (node, offset) {
        var rng = dom.createRng();
        if (isNonNullable(node) && isNonNullable(offset)) {
          rng.setStart(node, offset);
          rng.setEnd(node, offset);
          setRng(rng);
          collapse(false);
        } else {
          moveEndPoint(dom, rng, editor.getBody(), true);
          setRng(rng);
        }
      };
      var getContent = function (args) {
        return getContent$1(editor, args);
      };
      var setContent = function (content, args) {
        return setContent$1(editor, content, args);
      };
      var getStart$1 = function (real) {
        return getStart(editor.getBody(), getRng$1(), real);
      };
      var getEnd$1 = function (real) {
        return getEnd(editor.getBody(), getRng$1(), real);
      };
      var getBookmark = function (type, normalized) {
        return bookmarkManager.getBookmark(type, normalized);
      };
      var moveToBookmark = function (bookmark) {
        return bookmarkManager.moveToBookmark(bookmark);
      };
      var select$1 = function (node, content) {
        select(dom, node, content).each(setRng);
        return node;
      };
      var isCollapsed = function () {
        var rng = getRng$1(), sel = getSel();
        if (!rng || rng.item) {
          return false;
        }
        if (rng.compareEndPoints) {
          return rng.compareEndPoints('StartToEnd', rng) === 0;
        }
        return !sel || rng.collapsed;
      };
      var collapse = function (toStart) {
        var rng = getRng$1();
        rng.collapse(!!toStart);
        setRng(rng);
      };
      var getSel = function () {
        return win.getSelection ? win.getSelection() : win.document.selection;
      };
      var getRng$1 = function () {
        var selection, rng, elm;
        var tryCompareBoundaryPoints = function (how, sourceRange, destinationRange) {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            return -1;
          }
        };
        var doc = win.document;
        if (editor.bookmark !== undefined && hasFocus(editor) === false) {
          var bookmark = getRng(editor);
          if (bookmark.isSome()) {
            return bookmark.map(function (r) {
              return processRanges(editor, [r])[0];
            }).getOr(doc.createRange());
          }
        }
        try {
          if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = selection.createRange ? selection.createRange() : doc.createRange();
            }
            rng = processRanges(editor, [rng])[0];
          }
        } catch (ex) {
        }
        if (!rng) {
          rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
        }
        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
          elm = dom.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }
        if (selectedRange && explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
            rng = explicitRange;
          } else {
            selectedRange = null;
            explicitRange = null;
          }
        }
        return rng;
      };
      var setRng = function (rng, forward) {
        var node;
        if (!isValidRange(rng)) {
          return;
        }
        var ieRange = isNativeIeSelection(rng) ? rng : null;
        if (ieRange) {
          explicitRange = null;
          try {
            ieRange.select();
          } catch (ex) {
          }
          return;
        }
        var sel = getSel();
        var evt = editor.fire('SetSelectionRange', {
          range: rng,
          forward: forward
        });
        rng = evt.range;
        if (sel) {
          explicitRange = rng;
          try {
            sel.removeAllRanges();
            sel.addRange(rng);
          } catch (ex) {
          }
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }
          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }
        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.tagName === 'IMG') {
                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }
        editor.fire('AfterSetSelectionRange', {
          range: rng,
          forward: forward
        });
      };
      var setNode = function (elm) {
        setContent(dom.getOuterHTML(elm));
        return elm;
      };
      var getNode$1 = function () {
        return getNode(editor.getBody(), getRng$1());
      };
      var getSelectedBlocks$1 = function (startElm, endElm) {
        return getSelectedBlocks(dom, getRng$1(), startElm, endElm);
      };
      var isForward = function () {
        var sel = getSel();
        var anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
        var focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
          return true;
        }
        var anchorRange = dom.createRng();
        anchorRange.setStart(anchorNode, sel.anchorOffset);
        anchorRange.collapse(true);
        var focusRange = dom.createRng();
        focusRange.setStart(focusNode, sel.focusOffset);
        focusRange.collapse(true);
        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      };
      var normalize = function () {
        var rng = getRng$1();
        var sel = getSel();
        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
          var normRng = normalize$2(dom, rng);
          normRng.each(function (normRng) {
            setRng(normRng, isForward());
          });
          return normRng.getOr(rng);
        }
        return rng;
      };
      var selectorChanged = function (selector, callback) {
        selectorChangedWithUnbind(selector, callback);
        return exports;
      };
      var getScrollContainer = function () {
        var scrollContainer;
        var node = dom.getRoot();
        while (node && node.nodeName !== 'BODY') {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
          node = node.parentNode;
        }
        return scrollContainer;
      };
      var scrollIntoView = function (elm, alignToTop) {
        if (isNonNullable(elm)) {
          scrollElementIntoView(editor, elm, alignToTop);
        } else {
          scrollRangeIntoView(editor, getRng$1(), alignToTop);
        }
      };
      var placeCaretAt = function (clientX, clientY) {
        return setRng(fromPoint(clientX, clientY, editor.getDoc()));
      };
      var getBoundingClientRect = function () {
        var rng = getRng$1();
        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
      };
      var destroy = function () {
        win = selectedRange = explicitRange = null;
        controlSelection.destroy();
      };
      var exports = {
        bookmarkManager: null,
        controlSelection: null,
        dom: dom,
        win: win,
        serializer: serializer,
        editor: editor,
        collapse: collapse,
        setCursorLocation: setCursorLocation,
        getContent: getContent,
        setContent: setContent,
        getBookmark: getBookmark,
        moveToBookmark: moveToBookmark,
        select: select$1,
        isCollapsed: isCollapsed,
        isForward: isForward,
        setNode: setNode,
        getNode: getNode$1,
        getSel: getSel,
        setRng: setRng,
        getRng: getRng$1,
        getStart: getStart$1,
        getEnd: getEnd$1,
        getSelectedBlocks: getSelectedBlocks$1,
        normalize: normalize,
        selectorChanged: selectorChanged,
        selectorChangedWithUnbind: selectorChangedWithUnbind,
        getScrollContainer: getScrollContainer,
        scrollIntoView: scrollIntoView,
        placeCaretAt: placeCaretAt,
        getBoundingClientRect: getBoundingClientRect,
        destroy: destroy
      };
      var bookmarkManager = BookmarkManager(exports);
      var controlSelection = ControlSelection(exports, editor);
      exports.bookmarkManager = bookmarkManager;
      exports.controlSelection = controlSelection;
      return exports;
    };

    var removeAttrs = function (node, names) {
      each$k(names, function (name) {
        node.attr(name, null);
      });
    };
    var addFontToSpansFilter = function (domParser, styles, fontSizes) {
      domParser.addNodeFilter('font', function (nodes) {
        each$k(nodes, function (node) {
          var props = styles.parse(node.attr('style'));
          var color = node.attr('color');
          var face = node.attr('face');
          var size = node.attr('size');
          if (color) {
            props.color = color;
          }
          if (face) {
            props['font-family'] = face;
          }
          if (size) {
            props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];
          }
          node.name = 'span';
          node.attr('style', styles.serialize(props));
          removeAttrs(node, [
            'color',
            'face',
            'size'
          ]);
        });
      });
    };
    var addStrikeToSpanFilter = function (domParser, styles) {
      domParser.addNodeFilter('strike', function (nodes) {
        each$k(nodes, function (node) {
          var props = styles.parse(node.attr('style'));
          props['text-decoration'] = 'line-through';
          node.name = 'span';
          node.attr('style', styles.serialize(props));
        });
      });
    };
    var addFilters = function (domParser, settings) {
      var styles = Styles();
      if (settings.convert_fonts_to_spans) {
        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
      }
      addStrikeToSpanFilter(domParser, styles);
    };
    var register$2 = function (domParser, settings) {
      if (settings.inline_styles) {
        addFilters(domParser, settings);
      }
    };

    var blobUriToBlob = function (url) {
      return new promiseObj(function (resolve, reject) {
        var rejectWithError = function () {
          reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');
        };
        try {
          var xhr_1 = new XMLHttpRequest();
          xhr_1.open('GET', url, true);
          xhr_1.responseType = 'blob';
          xhr_1.onload = function () {
            if (xhr_1.status === 200) {
              resolve(xhr_1.response);
            } else {
              rejectWithError();
            }
          };
          xhr_1.onerror = rejectWithError;
          xhr_1.send();
        } catch (ex) {
          rejectWithError();
        }
      });
    };
    var parseDataUri = function (uri) {
      var type;
      var uriParts = decodeURIComponent(uri).split(',');
      var matches = /data:([^;]+)/.exec(uriParts[0]);
      if (matches) {
        type = matches[1];
      }
      return {
        type: type,
        data: uriParts[1]
      };
    };
    var buildBlob = function (type, data) {
      var str;
      try {
        str = atob(data);
      } catch (e) {
        return Optional.none();
      }
      var arr = new Uint8Array(str.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }
      return Optional.some(new Blob([arr], { type: type }));
    };
    var dataUriToBlob = function (uri) {
      return new promiseObj(function (resolve) {
        var _a = parseDataUri(uri), type = _a.type, data = _a.data;
        buildBlob(type, data).fold(function () {
          return resolve(new Blob([]));
        }, resolve);
      });
    };
    var uriToBlob = function (url) {
      if (url.indexOf('blob:') === 0) {
        return blobUriToBlob(url);
      }
      if (url.indexOf('data:') === 0) {
        return dataUriToBlob(url);
      }
      return null;
    };
    var blobToDataUri = function (blob) {
      return new promiseObj(function (resolve) {
        var reader = new FileReader();
        reader.onloadend = function () {
          resolve(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    };

    var count$1 = 0;
    var uniqueId = function (prefix) {
      return (prefix || 'blobid') + count$1++;
    };
    var imageToBlobInfo = function (blobCache, img, resolve, reject) {
      var base64, blobInfo;
      if (img.src.indexOf('blob:') === 0) {
        blobInfo = blobCache.getByUri(img.src);
        if (blobInfo) {
          resolve({
            image: img,
            blobInfo: blobInfo
          });
        } else {
          uriToBlob(img.src).then(function (blob) {
            blobToDataUri(blob).then(function (dataUri) {
              base64 = parseDataUri(dataUri).data;
              blobInfo = blobCache.create(uniqueId(), blob, base64);
              blobCache.add(blobInfo);
              resolve({
                image: img,
                blobInfo: blobInfo
              });
            });
          }, function (err) {
            reject(err);
          });
        }
        return;
      }
      var _a = parseDataUri(img.src), data = _a.data, type = _a.type;
      base64 = data;
      blobInfo = blobCache.getByData(base64, type);
      if (blobInfo) {
        resolve({
          image: img,
          blobInfo: blobInfo
        });
      } else {
        uriToBlob(img.src).then(function (blob) {
          blobInfo = blobCache.create(uniqueId(), blob, base64);
          blobCache.add(blobInfo);
          resolve({
            image: img,
            blobInfo: blobInfo
          });
        }, function (err) {
          reject(err);
        });
      }
    };
    var getAllImages = function (elm) {
      return elm ? from(elm.getElementsByTagName('img')) : [];
    };
    var ImageScanner = function (uploadStatus, blobCache) {
      var cachedPromises = {};
      var findAll = function (elm, predicate) {
        if (!predicate) {
          predicate = always;
        }
        var images = filter$4(getAllImages(elm), function (img) {
          var src = img.src;
          if (!Env.fileApi) {
            return false;
          }
          if (img.hasAttribute('data-mce-bogus')) {
            return false;
          }
          if (img.hasAttribute('data-mce-placeholder')) {
            return false;
          }
          if (!src || src === Env.transparentSrc) {
            return false;
          }
          if (src.indexOf('blob:') === 0) {
            return !uploadStatus.isUploaded(src) && predicate(img);
          }
          if (src.indexOf('data:') === 0) {
            return predicate(img);
          }
          return false;
        });
        var promises = map$3(images, function (img) {
          if (cachedPromises[img.src] !== undefined) {
            return new promiseObj(function (resolve) {
              cachedPromises[img.src].then(function (imageInfo) {
                if (typeof imageInfo === 'string') {
                  return imageInfo;
                }
                resolve({
                  image: img,
                  blobInfo: imageInfo.blobInfo
                });
              });
            });
          }
          var newPromise = new promiseObj(function (resolve, reject) {
            imageToBlobInfo(blobCache, img, resolve, reject);
          }).then(function (result) {
            delete cachedPromises[result.image.src];
            return result;
          }).catch(function (error) {
            delete cachedPromises[img.src];
            return error;
          });
          cachedPromises[img.src] = newPromise;
          return newPromise;
        });
        return promiseObj.all(promises);
      };
      return { findAll: findAll };
    };

    var paddEmptyNode = function (settings, args, blockElements, node) {
      var brPreferred = settings.padd_empty_with_br || args.insert;
      if (brPreferred && blockElements[node.name]) {
        node.empty().append(new AstNode('br', 1)).shortEnded = true;
      } else {
        node.empty().append(new AstNode('#text', 3)).value = nbsp;
      }
    };
    var isPaddedWithNbsp = function (node) {
      return hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;
    };
    var hasOnlyChild = function (node, name) {
      return node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;
    };
    var isPadded = function (schema, node) {
      var rule = schema.getElementRule(node.name);
      return rule && rule.paddEmpty;
    };
    var isEmpty = function (schema, nonEmptyElements, whitespaceElements, node) {
      return node.isEmpty(nonEmptyElements, whitespaceElements, function (node) {
        return isPadded(schema, node);
      });
    };
    var isLineBreakNode = function (node, blockElements) {
      return node && (has$2(blockElements, node.name) || node.name === 'br');
    };

    var isBogusImage = function (img) {
      return isNonNullable(img.attr('data-mce-bogus'));
    };
    var isInternalImageSource = function (img) {
      return img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
    };
    var isValidDataImg = function (img, settings) {
      if (settings.images_dataimg_filter) {
        var imgElem_1 = new Image();
        imgElem_1.src = img.attr('src');
        each$j(img.attributes.map, function (value, key) {
          imgElem_1.setAttribute(key, value);
        });
        return settings.images_dataimg_filter(imgElem_1);
      } else {
        return true;
      }
    };
    var registerBase64ImageFilter = function (parser, settings) {
      var blobCache = settings.blob_cache;
      var processImage = function (img) {
        var inputSrc = img.attr('src');
        if (isInternalImageSource(img) || isBogusImage(img)) {
          return;
        }
        parseDataUri$1(inputSrc).filter(function () {
          return isValidDataImg(img, settings);
        }).bind(function (_a) {
          var type = _a.type, data = _a.data;
          return Optional.from(blobCache.getByData(data, type)).orThunk(function () {
            return buildBlob(type, data).map(function (blob) {
              var blobInfo = blobCache.create(uniqueId(), blob, data);
              blobCache.add(blobInfo);
              return blobInfo;
            });
          });
        }).each(function (blobInfo) {
          img.attr('src', blobInfo.blobUri());
        });
      };
      if (blobCache) {
        parser.addAttributeFilter('src', function (nodes) {
          return each$k(nodes, processImage);
        });
      }
    };
    var register$1 = function (parser, settings) {
      var schema = parser.schema;
      if (settings.remove_trailing_brs) {
        parser.addNodeFilter('br', function (nodes, _, args) {
          var i;
          var l = nodes.length;
          var node;
          var blockElements = Tools.extend({}, schema.getBlockElements());
          var nonEmptyElements = schema.getNonEmptyElements();
          var parent, lastParent, prev, prevName;
          var whiteSpaceElements = schema.getWhiteSpaceElements();
          var elementRule, textNode;
          blockElements.body = 1;
          for (i = 0; i < l; i++) {
            node = nodes[i];
            parent = node.parent;
            if (blockElements[node.parent.name] && node === parent.lastChild) {
              prev = node.prev;
              while (prev) {
                prevName = prev.name;
                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
                  if (prevName === 'br') {
                    node = null;
                  }
                  break;
                }
                prev = prev.prev;
              }
              if (node) {
                node.remove();
                if (isEmpty(schema, nonEmptyElements, whiteSpaceElements, parent)) {
                  elementRule = schema.getElementRule(parent.name);
                  if (elementRule) {
                    if (elementRule.removeEmpty) {
                      parent.remove();
                    } else if (elementRule.paddEmpty) {
                      paddEmptyNode(settings, args, blockElements, parent);
                    }
                  }
                }
              }
            } else {
              lastParent = node;
              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
                lastParent = parent;
                if (blockElements[parent.name]) {
                  break;
                }
                parent = parent.parent;
              }
              if (lastParent === parent && settings.padd_empty_with_br !== true) {
                textNode = new AstNode('#text', 3);
                textNode.value = nbsp;
                node.replace(textNode);
              }
            }
          }
        });
      }
      parser.addAttributeFilter('href', function (nodes) {
        var i = nodes.length;
        var appendRel = function (rel) {
          var parts = rel.split(' ').filter(function (p) {
            return p.length > 0;
          });
          return parts.concat(['noopener']).sort().join(' ');
        };
        var addNoOpener = function (rel) {
          var newRel = rel ? Tools.trim(rel) : '';
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };
        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            var node = nodes[i];
            if (node.name === 'a' && node.attr('target') === '_blank') {
              node.attr('rel', addNoOpener(node.attr('rel')));
            }
          }
        }
      });
      if (!settings.allow_html_in_named_anchor) {
        parser.addAttributeFilter('id,name', function (nodes) {
          var i = nodes.length, sibling, prevSibling, parent, node;
          while (i--) {
            node = nodes[i];
            if (node.name === 'a' && node.firstChild && !node.attr('href')) {
              parent = node.parent;
              sibling = node.lastChild;
              do {
                prevSibling = sibling.prev;
                parent.insert(sibling, node);
                sibling = prevSibling;
              } while (sibling);
            }
          }
        });
      }
      if (settings.fix_list_elements) {
        parser.addNodeFilter('ul,ol', function (nodes) {
          var i = nodes.length, node, parentNode;
          while (i--) {
            node = nodes[i];
            parentNode = node.parent;
            if (parentNode.name === 'ul' || parentNode.name === 'ol') {
              if (node.prev && node.prev.name === 'li') {
                node.prev.append(node);
              } else {
                var li = new AstNode('li', 1);
                li.attr('style', 'list-style-type: none');
                node.wrap(li);
              }
            }
          }
        });
      }
      if (settings.validate && schema.getValidClasses()) {
        parser.addAttributeFilter('class', function (nodes) {
          var validClasses = schema.getValidClasses();
          var i = nodes.length;
          while (i--) {
            var node = nodes[i];
            var classList = node.attr('class').split(' ');
            var classValue = '';
            for (var ci = 0; ci < classList.length; ci++) {
              var className = classList[ci];
              var valid = false;
              var validClassesMap = validClasses['*'];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              if (valid) {
                if (classValue) {
                  classValue += ' ';
                }
                classValue += className;
              }
            }
            if (!classValue.length) {
              classValue = null;
            }
            node.attr('class', classValue);
          }
        });
      }
      registerBase64ImageFilter(parser, settings);
    };

    var makeMap = Tools.makeMap, each$6 = Tools.each, explode$2 = Tools.explode, extend$4 = Tools.extend;
    var DomParser = function (settings, schema) {
      if (schema === void 0) {
        schema = Schema();
      }
      var nodeFilters = {};
      var attributeFilters = [];
      var matchedNodes = {};
      var matchedAttributes = {};
      settings = settings || {};
      settings.validate = 'validate' in settings ? settings.validate : true;
      settings.root_name = settings.root_name || 'body';
      var fixInvalidChildren = function (nodes) {
        var nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');
        var nonEmptyElements = schema.getNonEmptyElements();
        var whitespaceElements = schema.getWhiteSpaceElements();
        var textBlockElements = schema.getTextBlockElements();
        var specialElements = schema.getSpecialElements();
        var removeOrUnwrapInvalidNode = function (node, originalNodeParent) {
          if (originalNodeParent === void 0) {
            originalNodeParent = node.parent;
          }
          if (specialElements[node.name]) {
            node.empty().remove();
          } else {
            var children = node.children();
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
              var childNode = children_1[_i];
              if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {
                removeOrUnwrapInvalidNode(childNode, originalNodeParent);
              }
            }
            node.unwrap();
          }
        };
        for (var ni = 0; ni < nodes.length; ni++) {
          var node = nodes[ni];
          var parent_1 = void 0, newParent = void 0, tempNode = void 0;
          if (!node.parent || node.fixed) {
            continue;
          }
          if (textBlockElements[node.name] && node.parent.name === 'li') {
            var sibling = node.next;
            while (sibling) {
              if (textBlockElements[sibling.name]) {
                sibling.name = 'li';
                sibling.fixed = true;
                node.parent.insert(sibling, node.parent);
              } else {
                break;
              }
              sibling = sibling.next;
            }
            node.unwrap();
            continue;
          }
          var parents = [node];
          for (parent_1 = node.parent; parent_1 && !schema.isValidChild(parent_1.name, node.name) && !nonSplitableElements[parent_1.name]; parent_1 = parent_1.parent) {
            parents.push(parent_1);
          }
          if (parent_1 && parents.length > 1) {
            if (schema.isValidChild(parent_1.name, node.name)) {
              parents.reverse();
              newParent = filterNode(parents[0].clone());
              var currentNode = newParent;
              for (var i = 0; i < parents.length - 1; i++) {
                if (schema.isValidChild(currentNode.name, parents[i].name)) {
                  tempNode = filterNode(parents[i].clone());
                  currentNode.append(tempNode);
                } else {
                  tempNode = currentNode;
                }
                for (var childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
                  var nextNode = childNode.next;
                  tempNode.append(childNode);
                  childNode = nextNode;
                }
                currentNode = tempNode;
              }
              if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
                parent_1.insert(newParent, parents[0], true);
                parent_1.insert(node, newParent);
              } else {
                parent_1.insert(node, parents[0], true);
              }
              parent_1 = parents[0];
              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent_1) || hasOnlyChild(parent_1, 'br')) {
                parent_1.empty().remove();
              }
            } else {
              removeOrUnwrapInvalidNode(node);
            }
          } else if (node.parent) {
            if (node.name === 'li') {
              var sibling = node.prev;
              if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
                sibling.append(node);
                continue;
              }
              sibling = node.next;
              if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
                sibling.insert(node, sibling.firstChild, true);
                continue;
              }
              node.wrap(filterNode(new AstNode('ul', 1)));
              continue;
            }
            if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
              node.wrap(filterNode(new AstNode('div', 1)));
            } else {
              removeOrUnwrapInvalidNode(node);
            }
          }
        }
      };
      var filterNode = function (node) {
        var name = node.name;
        if (name in nodeFilters) {
          var list = matchedNodes[name];
          if (list) {
            list.push(node);
          } else {
            matchedNodes[name] = [node];
          }
        }
        var i = attributeFilters.length;
        while (i--) {
          var attrName = attributeFilters[i].name;
          if (attrName in node.attributes.map) {
            var list = matchedAttributes[attrName];
            if (list) {
              list.push(node);
            } else {
              matchedAttributes[attrName] = [node];
            }
          }
        }
        return node;
      };
      var addNodeFilter = function (name, callback) {
        each$6(explode$2(name), function (name) {
          var list = nodeFilters[name];
          if (!list) {
            nodeFilters[name] = list = [];
          }
          list.push(callback);
        });
      };
      var getNodeFilters = function () {
        var out = [];
        for (var name_1 in nodeFilters) {
          if (has$2(nodeFilters, name_1)) {
            out.push({
              name: name_1,
              callbacks: nodeFilters[name_1]
            });
          }
        }
        return out;
      };
      var addAttributeFilter = function (name, callback) {
        each$6(explode$2(name), function (name) {
          var i;
          for (i = 0; i < attributeFilters.length; i++) {
            if (attributeFilters[i].name === name) {
              attributeFilters[i].callbacks.push(callback);
              return;
            }
          }
          attributeFilters.push({
            name: name,
            callbacks: [callback]
          });
        });
      };
      var getAttributeFilters = function () {
        return [].concat(attributeFilters);
      };
      var parse = function (html, args) {
        var nodes, i, l, fi, fl, list, name;
        var invalidChildren = [];
        var node;
        var getRootBlockName = function (name) {
          if (name === false) {
            return '';
          } else if (name === true) {
            return 'p';
          } else {
            return name;
          }
        };
        args = args || {};
        matchedNodes = {};
        matchedAttributes = {};
        var blockElements = extend$4(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
        var nonEmptyElements = schema.getNonEmptyElements();
        var children = schema.children;
        var validate = settings.validate;
        var forcedRootBlockName = 'forced_root_block' in args ? args.forced_root_block : settings.forced_root_block;
        var rootBlockName = getRootBlockName(forcedRootBlockName);
        var whiteSpaceElements = schema.getWhiteSpaceElements();
        var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
        var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
        var isInWhiteSpacePreservedElement = has$2(whiteSpaceElements, args.context) || has$2(whiteSpaceElements, settings.root_name);
        var addRootBlocks = function () {
          var node = rootNode.firstChild, rootBlockNode = null;
          var trim = function (rootBlock) {
            if (rootBlock) {
              node = rootBlock.firstChild;
              if (node && node.type === 3) {
                node.value = node.value.replace(startWhiteSpaceRegExp, '');
              }
              node = rootBlock.lastChild;
              if (node && node.type === 3) {
                node.value = node.value.replace(endWhiteSpaceRegExp, '');
              }
            }
          };
          if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
            return;
          }
          while (node) {
            var next = node.next;
            if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type')) {
              if (!rootBlockNode) {
                rootBlockNode = createNode(rootBlockName, 1);
                rootBlockNode.attr(settings.forced_root_block_attrs);
                rootNode.insert(rootBlockNode, node);
                rootBlockNode.append(node);
              } else {
                rootBlockNode.append(node);
              }
            } else {
              trim(rootBlockNode);
              rootBlockNode = null;
            }
            node = next;
          }
          trim(rootBlockNode);
        };
        var createNode = function (name, type) {
          var node = new AstNode(name, type);
          var list;
          if (name in nodeFilters) {
            list = matchedNodes[name];
            if (list) {
              list.push(node);
            } else {
              matchedNodes[name] = [node];
            }
          }
          return node;
        };
        var removeWhitespaceBefore = function (node) {
          var blockElements = schema.getBlockElements();
          for (var textNode = node.prev; textNode && textNode.type === 3;) {
            var textVal = textNode.value.replace(endWhiteSpaceRegExp, '');
            if (textVal.length > 0) {
              textNode.value = textVal;
              return;
            }
            var textNodeNext = textNode.next;
            if (textNodeNext) {
              if (textNodeNext.type === 3 && textNodeNext.value.length) {
                textNode = textNode.prev;
                continue;
              }
              if (!blockElements[textNodeNext.name] && textNodeNext.name !== 'script' && textNodeNext.name !== 'style') {
                textNode = textNode.prev;
                continue;
              }
            }
            var sibling = textNode.prev;
            textNode.remove();
            textNode = sibling;
          }
        };
        var cloneAndExcludeBlocks = function (input) {
          var output = {};
          for (var name_2 in input) {
            if (name_2 !== 'li' && name_2 !== 'p') {
              output[name_2] = input[name_2];
            }
          }
          return output;
        };
        var parser = SaxParser({
          validate: validate,
          document: settings.document,
          allow_html_data_urls: settings.allow_html_data_urls,
          allow_svg_data_urls: settings.allow_svg_data_urls,
          allow_script_urls: settings.allow_script_urls,
          allow_conditional_comments: settings.allow_conditional_comments,
          preserve_cdata: settings.preserve_cdata,
          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
          cdata: function (text) {
            node.append(createNode('#cdata', 4)).value = text;
          },
          text: function (text, raw) {
            var textNode;
            if (!isInWhiteSpacePreservedElement) {
              text = text.replace(allWhiteSpaceRegExp, ' ');
              if (isLineBreakNode(node.lastChild, blockElements)) {
                text = text.replace(startWhiteSpaceRegExp, '');
              }
            }
            if (text.length !== 0) {
              textNode = createNode('#text', 3);
              textNode.raw = !!raw;
              node.append(textNode).value = text;
            }
          },
          comment: function (text) {
            node.append(createNode('#comment', 8)).value = text;
          },
          pi: function (name, text) {
            node.append(createNode(name, 7)).value = text;
            removeWhitespaceBefore(node);
          },
          doctype: function (text) {
            var newNode = node.append(createNode('#doctype', 10));
            newNode.value = text;
            removeWhitespaceBefore(node);
          },
          start: function (name, attrs, empty) {
            var elementRule = validate ? schema.getElementRule(name) : {};
            if (elementRule) {
              var newNode = createNode(elementRule.outputName || name, 1);
              newNode.attributes = attrs;
              newNode.shortEnded = empty;
              node.append(newNode);
              var parent_2 = children[node.name];
              if (parent_2 && children[newNode.name] && !parent_2[newNode.name]) {
                invalidChildren.push(newNode);
              }
              var attrFiltersLen = attributeFilters.length;
              while (attrFiltersLen--) {
                var attrName = attributeFilters[attrFiltersLen].name;
                if (attrName in attrs.map) {
                  list = matchedAttributes[attrName];
                  if (list) {
                    list.push(newNode);
                  } else {
                    matchedAttributes[attrName] = [newNode];
                  }
                }
              }
              if (blockElements[name]) {
                removeWhitespaceBefore(newNode);
              }
              if (!empty) {
                node = newNode;
              }
              if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = true;
              }
            }
          },
          end: function (name) {
            var textNode, text, sibling, tempNode;
            var elementRule = validate ? schema.getElementRule(name) : {};
            if (elementRule) {
              if (blockElements[name]) {
                if (!isInWhiteSpacePreservedElement) {
                  textNode = node.firstChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(startWhiteSpaceRegExp, '');
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.next;
                    } else {
                      sibling = textNode.next;
                      textNode.remove();
                      textNode = sibling;
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling = textNode.next;
                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }
                        textNode = sibling;
                      }
                    }
                  }
                  textNode = node.lastChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(endWhiteSpaceRegExp, '');
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.prev;
                    } else {
                      sibling = textNode.prev;
                      textNode.remove();
                      textNode = sibling;
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling = textNode.prev;
                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }
                        textNode = sibling;
                      }
                    }
                  }
                }
              }
              if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = false;
              }
              if (elementRule.removeEmpty && isEmpty(schema, nonEmptyElements, whiteSpaceElements, node)) {
                tempNode = node.parent;
                if (blockElements[node.name]) {
                  node.empty().remove();
                } else {
                  node.unwrap();
                }
                node = tempNode;
                return;
              }
              if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isEmpty(schema, nonEmptyElements, whiteSpaceElements, node))) {
                paddEmptyNode(settings, args, blockElements, node);
              }
              node = node.parent;
            }
          }
        }, schema);
        var rootNode = node = new AstNode(args.context || settings.root_name, 11);
        parser.parse(html, args.format);
        if (validate && invalidChildren.length) {
          if (!args.context) {
            fixInvalidChildren(invalidChildren);
          } else {
            args.invalid = true;
          }
        }
        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
          addRootBlocks();
        }
        if (!args.invalid) {
          for (name in matchedNodes) {
            if (!has$2(matchedNodes, name)) {
              continue;
            }
            list = nodeFilters[name];
            nodes = matchedNodes[name];
            fi = nodes.length;
            while (fi--) {
              if (!nodes[fi].parent) {
                nodes.splice(fi, 1);
              }
            }
            for (i = 0, l = list.length; i < l; i++) {
              list[i](nodes, name, args);
            }
          }
          for (i = 0, l = attributeFilters.length; i < l; i++) {
            list = attributeFilters[i];
            if (list.name in matchedAttributes) {
              nodes = matchedAttributes[list.name];
              fi = nodes.length;
              while (fi--) {
                if (!nodes[fi].parent) {
                  nodes.splice(fi, 1);
                }
              }
              for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
                list.callbacks[fi](nodes, list.name, args);
              }
            }
          }
        }
        return rootNode;
      };
      var exports = {
        schema: schema,
        addAttributeFilter: addAttributeFilter,
        getAttributeFilters: getAttributeFilters,
        addNodeFilter: addNodeFilter,
        getNodeFilters: getNodeFilters,
        filterNode: filterNode,
        parse: parse
      };
      register$1(exports, settings);
      register$2(exports, settings);
      return exports;
    };

    var register = function (htmlParser, settings, dom) {
      htmlParser.addAttributeFilter('data-mce-tabindex', function (nodes, name) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          node.attr('tabindex', node.attr('data-mce-tabindex'));
          node.attr(name, null);
        }
      });
      htmlParser.addAttributeFilter('src,href,style', function (nodes, name) {
        var internalName = 'data-mce-' + name;
        var urlConverter = settings.url_converter;
        var urlConverterScope = settings.url_converter_scope;
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          var value = node.attr(internalName);
          if (value !== undefined) {
            node.attr(name, value.length > 0 ? value : null);
            node.attr(internalName, null);
          } else {
            value = node.attr(name);
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
            } else if (urlConverter) {
              value = urlConverter.call(urlConverterScope, value, name, node.name);
            }
            node.attr(name, value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('class', function (nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          var value = node.attr('class');
          if (value) {
            value = node.attr('class').replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
            node.attr('class', value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', function (nodes, name, args) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
            var hasChildren = Optional.from(node.firstChild).exists(function (firstChild) {
              return !isZwsp(firstChild.value);
            });
            if (hasChildren) {
              node.unwrap();
            } else {
              node.remove();
            }
          }
        }
      });
      htmlParser.addNodeFilter('noscript', function (nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i].firstChild;
          if (node) {
            node.value = Entities.decode(node.value);
          }
        }
      });
      htmlParser.addNodeFilter('script,style', function (nodes, name) {
        var trim = function (value) {
          return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n').replace(/^[\r\n]*|[\r\n]*$/g, '').replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '').replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
        };
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          var value = node.firstChild ? node.firstChild.value : '';
          if (name === 'script') {
            var type = node.attr('type');
            if (type) {
              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
            }
            if (settings.element_format === 'xhtml' && value.length > 0) {
              node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
            }
          } else {
            if (settings.element_format === 'xhtml' && value.length > 0) {
              node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
            }
          }
        }
      });
      htmlParser.addNodeFilter('#comment', function (nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {
            node.name = '#cdata';
            node.type = 4;
            node.value = dom.decode(node.value.replace(/^\[CDATA\[|\]\]$/g, ''));
          } else if (node.value.indexOf('mce:protected ') === 0) {
            node.name = '#text';
            node.type = 3;
            node.raw = true;
            node.value = unescape(node.value).substr(14);
          }
        }
      });
      htmlParser.addNodeFilter('xml:namespace,input', function (nodes, name) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name === 'input' && !node.attr('type')) {
              node.attr('type', 'text');
            }
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', function (nodes) {
        each$k(nodes, function (node) {
          if (node.attr('data-mce-type') === 'format-caret') {
            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
              node.remove();
            } else {
              node.unwrap();
            }
          }
        });
      });
      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', function (nodes, name) {
        var i = nodes.length;
        while (i--) {
          nodes[i].attr(name, null);
        }
      });
    };
    var trimTrailingBr = function (rootNode) {
      var isBr = function (node) {
        return node && node.name === 'br';
      };
      var brNode1 = rootNode.lastChild;
      if (isBr(brNode1)) {
        var brNode2 = brNode1.prev;
        if (isBr(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    };

    var preProcess = function (editor, node, args) {
      var oldDoc;
      var dom = editor.dom;
      var clonedNode = node.cloneNode(true);
      var impl = document.implementation;
      if (impl.createHTMLDocument) {
        var doc_1 = impl.createHTMLDocument('');
        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], function (node) {
          doc_1.body.appendChild(doc_1.importNode(node, true));
        });
        if (clonedNode.nodeName !== 'BODY') {
          clonedNode = doc_1.body.firstChild;
        } else {
          clonedNode = doc_1.body;
        }
        oldDoc = dom.doc;
        dom.doc = doc_1;
      }
      firePreProcess(editor, __assign(__assign({}, args), { node: clonedNode }));
      if (oldDoc) {
        dom.doc = oldDoc;
      }
      return clonedNode;
    };
    var shouldFireEvent = function (editor, args) {
      return editor && editor.hasEventListeners('PreProcess') && !args.no_events;
    };
    var process = function (editor, node, args) {
      return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;
    };

    var addTempAttr = function (htmlParser, tempAttrs, name) {
      if (Tools.inArray(tempAttrs, name) === -1) {
        htmlParser.addAttributeFilter(name, function (nodes, name) {
          var i = nodes.length;
          while (i--) {
            nodes[i].attr(name, null);
          }
        });
        tempAttrs.push(name);
      }
    };
    var postProcess = function (editor, args, content) {
      if (!args.no_events && editor) {
        var outArgs = firePostProcess(editor, __assign(__assign({}, args), { content: content }));
        return outArgs.content;
      } else {
        return content;
      }
    };
    var getHtmlFromNode = function (dom, node, args) {
      var html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    var parseHtml = function (htmlParser, html, args) {
      var parserArgs = args.selection ? __assign({ forced_root_block: false }, args) : args;
      var rootNode = htmlParser.parse(html, parserArgs);
      trimTrailingBr(rootNode);
      return rootNode;
    };
    var serializeNode = function (settings, schema, node) {
      var htmlSerializer = HtmlSerializer(settings, schema);
      return htmlSerializer.serialize(node);
    };
    var toHtml = function (editor, settings, schema, rootNode, args) {
      var content = serializeNode(settings, schema, rootNode);
      return postProcess(editor, args, content);
    };
    var DomSerializerImpl = function (settings, editor) {
      var tempAttrs = ['data-mce-selected'];
      var dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
      var schema = editor && editor.schema ? editor.schema : Schema(settings);
      settings.entity_encoding = settings.entity_encoding || 'named';
      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;
      var htmlParser = DomParser(settings, schema);
      register(htmlParser, settings, dom);
      var serialize = function (node, parserArgs) {
        if (parserArgs === void 0) {
          parserArgs = {};
        }
        var args = __assign({ format: 'html' }, parserArgs);
        var targetNode = process(editor, node, args);
        var html = getHtmlFromNode(dom, targetNode, args);
        var rootNode = parseHtml(htmlParser, html, args);
        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);
      };
      return {
        schema: schema,
        addNodeFilter: htmlParser.addNodeFilter,
        addAttributeFilter: htmlParser.addAttributeFilter,
        serialize: serialize,
        addRules: schema.addValidElements,
        setRules: schema.setValidElements,
        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
        getTempAttrs: constant(tempAttrs),
        getNodeFilters: htmlParser.getNodeFilters,
        getAttributeFilters: htmlParser.getAttributeFilters
      };
    };

    var DomSerializer = function (settings, editor) {
      var domSerializer = DomSerializerImpl(settings, editor);
      return {
        schema: domSerializer.schema,
        addNodeFilter: domSerializer.addNodeFilter,
        addAttributeFilter: domSerializer.addAttributeFilter,
        serialize: domSerializer.serialize,
        addRules: domSerializer.addRules,
        setRules: domSerializer.setRules,
        addTempAttr: domSerializer.addTempAttr,
        getTempAttrs: domSerializer.getTempAttrs,
        getNodeFilters: domSerializer.getNodeFilters,
        getAttributeFilters: domSerializer.getAttributeFilters
      };
    };

    var defaultFormat = 'html';
    var getContent = function (editor, args) {
      if (args === void 0) {
        args = {};
      }
      var format = args.format ? args.format : defaultFormat;
      return getContent$2(editor, args, format);
    };

    var setContent = function (editor, content, args) {
      if (args === void 0) {
        args = {};
      }
      return setContent$2(editor, content, args);
    };

    var DOM$7 = DOMUtils.DOM;
    var restoreOriginalStyles = function (editor) {
      DOM$7.setStyle(editor.id, 'display', editor.orgDisplay);
    };
    var safeDestroy = function (x) {
      return Optional.from(x).each(function (x) {
        return x.destroy();
      });
    };
    var clearDomReferences = function (editor) {
      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
      editor.iframeElement = editor.targetElm = null;
      if (editor.selection) {
        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
      }
    };
    var restoreForm = function (editor) {
      var form = editor.formElement;
      if (form) {
        if (form._mceOldSubmit) {
          form.submit = form._mceOldSubmit;
          form._mceOldSubmit = null;
        }
        DOM$7.unbind(form, 'submit reset', editor.formEventDelegate);
      }
    };
    var remove = function (editor) {
      if (!editor.removed) {
        var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
        var body = editor.getBody();
        var element = editor.getElement();
        if (body) {
          editor.save({ is_removing: true });
        }
        editor.removed = true;
        editor.unbindAllNativeEvents();
        if (editor.hasHiddenInput && element) {
          DOM$7.remove(element.nextSibling);
        }
        fireRemove(editor);
        editor.editorManager.remove(editor);
        if (!editor.inline && body) {
          restoreOriginalStyles(editor);
        }
        fireDetach(editor);
        DOM$7.remove(editor.getContainer());
        safeDestroy(_selectionOverrides);
        safeDestroy(editorUpload);
        editor.destroy();
      }
    };
    var destroy = function (editor, automatic) {
      var selection = editor.selection, dom = editor.dom;
      if (editor.destroyed) {
        return;
      }
      if (!automatic && !editor.removed) {
        editor.remove();
        return;
      }
      if (!automatic) {
        editor.editorManager.off('beforeunload', editor._beforeUnload);
        if (editor.theme && editor.theme.destroy) {
          editor.theme.destroy();
        }
        safeDestroy(selection);
        safeDestroy(dom);
      }
      restoreForm(editor);
      clearDomReferences(editor);
      editor.destroyed = true;
    };

    var deep = function (old, nu) {
      var bothObjects = isObject(old) && isObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    var baseMerge = function (merger) {
      return function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        if (objects.length === 0) {
          throw new Error('Can\'t merge zero objects');
        }
        var ret = {};
        for (var j = 0; j < objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (has$2(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var deepMerge = baseMerge(deep);

    var deprecatedSettings = ('autoresize_on_init,content_editable_state,convert_fonts_to_spans,inline_styles,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');
    var deprecatedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');
    var movedToPremiumPlugins = 'imagetools,toc'.split(',');
    var getDeprecatedSettings = function (settings) {
      var settingNames = filter$4(deprecatedSettings, function (setting) {
        return has$2(settings, setting);
      });
      var forcedRootBlock = settings.forced_root_block;
      if (forcedRootBlock === false || forcedRootBlock === '') {
        settingNames.push('forced_root_block (false only)');
      }
      return sort(settingNames);
    };
    var getDeprecatedPlugins = function (settings) {
      var plugins = Tools.makeMap(settings.plugins, ' ');
      var hasPlugin = function (plugin) {
        return has$2(plugins, plugin);
      };
      var pluginNames = __spreadArray(__spreadArray([], filter$4(deprecatedPlugins, hasPlugin), true), bind(movedToPremiumPlugins, function (plugin) {
        return hasPlugin(plugin) ? [plugin + ' (moving to premium)'] : [];
      }), true);
      return sort(pluginNames);
    };
    var logDeprecationsWarning = function (rawSettings, finalSettings) {
      var deprecatedSettings = getDeprecatedSettings(rawSettings);
      var deprecatedPlugins = getDeprecatedPlugins(finalSettings);
      var hasDeprecatedPlugins = deprecatedPlugins.length > 0;
      var hasDeprecatedSettings = deprecatedSettings.length > 0;
      var isLegacyMobileTheme = finalSettings.theme === 'mobile';
      if (hasDeprecatedPlugins || hasDeprecatedSettings || isLegacyMobileTheme) {
        var listJoiner = '\n- ';
        var themesMessage = isLegacyMobileTheme ? '\n\nThemes:' + listJoiner + 'mobile' : '';
        var pluginsMessage = hasDeprecatedPlugins ? '\n\nPlugins:' + listJoiner + deprecatedPlugins.join(listJoiner) : '';
        var settingsMessage = hasDeprecatedSettings ? '\n\nSettings:' + listJoiner + deprecatedSettings.join(listJoiner) : '';
        console.warn('The following deprecated features are currently enabled, these will be removed in TinyMCE 6.0. ' + 'See https://www.tiny.cloud/docs/release-notes/6.0-upcoming-changes/ for more information.' + themesMessage + pluginsMessage + settingsMessage);
      }
    };

    var sectionResult = function (sections, settings) {
      return {
        sections: constant(sections),
        settings: constant(settings)
      };
    };
    var deviceDetection = detect().deviceType;
    var isTouch = deviceDetection.isTouch();
    var isPhone = deviceDetection.isPhone();
    var isTablet = deviceDetection.isTablet();
    var legacyMobilePlugins = [
      'lists',
      'autolink',
      'autosave'
    ];
    var defaultTouchSettings = {
      table_grid: false,
      object_resizing: false,
      resize: false
    };
    var normalizePlugins = function (plugins) {
      var pluginNames = isArray$1(plugins) ? plugins.join(' ') : plugins;
      var trimmedPlugins = map$3(isString$1(pluginNames) ? pluginNames.split(' ') : [], trim$4);
      return filter$4(trimmedPlugins, function (item) {
        return item.length > 0;
      });
    };
    var filterLegacyMobilePlugins = function (plugins) {
      return filter$4(plugins, curry(contains$3, legacyMobilePlugins));
    };
    var extractSections = function (keys, settings) {
      var result = bifilter(settings, function (value, key) {
        return contains$3(keys, key);
      });
      return sectionResult(result.t, result.f);
    };
    var getSection = function (sectionResult, name, defaults) {
      if (defaults === void 0) {
        defaults = {};
      }
      var sections = sectionResult.sections();
      var sectionSettings = get$9(sections, name).getOr({});
      return Tools.extend({}, defaults, sectionSettings);
    };
    var hasSection = function (sectionResult, name) {
      return has$2(sectionResult.sections(), name);
    };
    var isSectionTheme = function (sectionResult, name, theme) {
      var section = sectionResult.sections();
      return hasSection(sectionResult, name) && section[name].theme === theme;
    };
    var getSectionConfig = function (sectionResult, name) {
      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
    };
    var getToolbarMode = function (settings, defaultVal) {
      return get$9(settings, 'toolbar_mode').orThunk(function () {
        return get$9(settings, 'toolbar_drawer').map(function (val) {
          return val === false ? 'wrap' : val;
        });
      }).getOr(defaultVal);
    };
    var getDefaultSettings = function (settings, id, documentBaseUrl, isTouch, editor) {
      var baseDefaults = {
        id: id,
        theme: 'silver',
        toolbar_mode: getToolbarMode(settings, 'floating'),
        plugins: '',
        document_base_url: documentBaseUrl,
        add_form_submit_trigger: true,
        submit_patch: true,
        add_unload_trigger: true,
        convert_urls: true,
        relative_urls: true,
        remove_script_host: true,
        object_resizing: true,
        doctype: '<!DOCTYPE html>',
        visual: true,
        font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%',
        forced_root_block: 'p',
        hidden_input: true,
        inline_styles: true,
        convert_fonts_to_spans: true,
        indent: true,
        indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
        indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
        entity_encoding: 'named',
        url_converter: editor.convertURL,
        url_converter_scope: editor
      };
      return __assign(__assign({}, baseDefaults), isTouch ? defaultTouchSettings : {});
    };
    var getDefaultMobileSettings = function (mobileSettings, isPhone) {
      var defaultMobileSettings = {
        resize: false,
        toolbar_mode: getToolbarMode(mobileSettings, 'scrolling'),
        toolbar_sticky: false
      };
      var defaultPhoneSettings = { menubar: false };
      return __assign(__assign(__assign({}, defaultTouchSettings), defaultMobileSettings), isPhone ? defaultPhoneSettings : {});
    };
    var getExternalPlugins = function (overrideSettings, settings) {
      var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
      if (overrideSettings && overrideSettings.external_plugins) {
        return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
      } else {
        return userDefinedExternalPlugins;
      }
    };
    var combinePlugins = function (forcedPlugins, plugins) {
      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
    };
    var getPlatformPlugins = function (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) {
      if (isMobileDevice && isSectionTheme(sectionResult, 'mobile', 'mobile')) {
        return filterLegacyMobilePlugins(mobilePlugins);
      } else if (isMobileDevice && hasSection(sectionResult, 'mobile')) {
        return mobilePlugins;
      } else {
        return desktopPlugins;
      }
    };
    var processPlugins = function (isMobileDevice, sectionResult, defaultOverrideSettings, settings) {
      var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
      var desktopPlugins = normalizePlugins(settings.plugins);
      var mobileConfig = getSectionConfig(sectionResult, 'mobile');
      var mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
      var platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);
      var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
      if (Env.browser.isIE() && contains$3(combinedPlugins, 'rtc')) {
        throw new Error('RTC plugin is not supported on IE 11.');
      }
      return Tools.extend(settings, { plugins: combinedPlugins.join(' ') });
    };
    var isOnMobile = function (isMobileDevice, sectionResult) {
      return isMobileDevice && hasSection(sectionResult, 'mobile');
    };
    var combineSettings = function (isMobileDevice, isPhone, defaultSettings, defaultOverrideSettings, settings) {
      var defaultDeviceSettings = isMobileDevice ? { mobile: getDefaultMobileSettings(settings.mobile || {}, isPhone) } : {};
      var sectionResult = extractSections(['mobile'], deepMerge(defaultDeviceSettings, settings));
      var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult.settings(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {
        validate: true,
        external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult.settings())
      });
      return processPlugins(isMobileDevice, sectionResult, defaultOverrideSettings, extendedSettings);
    };
    var getEditorSettings = function (editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
      var defaultSettings = getDefaultSettings(settings, id, documentBaseUrl, isTouch, editor);
      var finalSettings = combineSettings(isPhone || isTablet, isPhone, defaultSettings, defaultOverrideSettings, settings);
      if (finalSettings.deprecation_warnings !== false) {
        logDeprecationsWarning(settings, finalSettings);
      }
      return finalSettings;
    };
    var getFiltered = function (predicate, editor, name) {
      return Optional.from(editor.settings[name]).filter(predicate);
    };
    var getParamObject = function (value) {
      var output = {};
      if (typeof value === 'string') {
        each$k(value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(','), function (val) {
          var arr = val.split('=');
          if (arr.length > 1) {
            output[Tools.trim(arr[0])] = Tools.trim(arr[1]);
          } else {
            output[Tools.trim(arr[0])] = Tools.trim(arr[0]);
          }
        });
      } else {
        output = value;
      }
      return output;
    };
    var isArrayOf = function (p) {
      return function (a) {
        return isArray$1(a) && forall(a, p);
      };
    };
    var getParam = function (editor, name, defaultVal, type) {
      var value = name in editor.settings ? editor.settings[name] : defaultVal;
      if (type === 'hash') {
        return getParamObject(value);
      } else if (type === 'string') {
        return getFiltered(isString$1, editor, name).getOr(defaultVal);
      } else if (type === 'number') {
        return getFiltered(isNumber, editor, name).getOr(defaultVal);
      } else if (type === 'boolean') {
        return getFiltered(isBoolean, editor, name).getOr(defaultVal);
      } else if (type === 'object') {
        return getFiltered(isObject, editor, name).getOr(defaultVal);
      } else if (type === 'array') {
        return getFiltered(isArray$1, editor, name).getOr(defaultVal);
      } else if (type === 'string[]') {
        return getFiltered(isArrayOf(isString$1), editor, name).getOr(defaultVal);
      } else if (type === 'function') {
        return getFiltered(isFunction, editor, name).getOr(defaultVal);
      } else {
        return value;
      }
    };

    var CreateIconManager = function () {
      var lookup = {};
      var add = function (id, iconPack) {
        lookup[id] = iconPack;
      };
      var get = function (id) {
        if (lookup[id]) {
          return lookup[id];
        }
        return { icons: {} };
      };
      var has = function (id) {
        return has$2(lookup, id);
      };
      return {
        add: add,
        get: get,
        has: has
      };
    };
    var IconManager = CreateIconManager();

    var getProp = function (propName, elm) {
      var rawElm = elm.dom;
      return rawElm[propName];
    };
    var getComputedSizeProp = function (propName, elm) {
      return parseInt(get$5(elm, propName), 10);
    };
    var getClientWidth = curry(getProp, 'clientWidth');
    var getClientHeight = curry(getProp, 'clientHeight');
    var getMarginTop = curry(getComputedSizeProp, 'margin-top');
    var getMarginLeft = curry(getComputedSizeProp, 'margin-left');
    var getBoundingClientRect = function (elm) {
      return elm.dom.getBoundingClientRect();
    };
    var isInsideElementContentArea = function (bodyElm, clientX, clientY) {
      var clientWidth = getClientWidth(bodyElm);
      var clientHeight = getClientHeight(bodyElm);
      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    var transpose = function (inline, elm, clientX, clientY) {
      var clientRect = getBoundingClientRect(elm);
      var deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
      var deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
      var x = clientX - deltaX;
      var y = clientY - deltaY;
      return {
        x: x,
        y: y
      };
    };
    var isXYInContentArea = function (editor, clientX, clientY) {
      var bodyElm = SugarElement.fromDom(editor.getBody());
      var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
      var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    var fromDomSafe = function (node) {
      return Optional.from(node).map(SugarElement.fromDom);
    };
    var isEditorAttachedToDom = function (editor) {
      var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
      return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };

    var NotificationManagerImpl = function () {
      var unimplemented = function () {
        throw new Error('Theme did not provide a NotificationManager implementation.');
      };
      return {
        open: unimplemented,
        close: unimplemented,
        reposition: unimplemented,
        getArgs: unimplemented
      };
    };

    var NotificationManager = function (editor) {
      var notifications = [];
      var getImplementation = function () {
        var theme = editor.theme;
        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
      };
      var getTopNotification = function () {
        return Optional.from(notifications[0]);
      };
      var isEqual = function (a, b) {
        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
      };
      var reposition = function () {
        if (notifications.length > 0) {
          getImplementation().reposition(notifications);
        }
      };
      var addNotification = function (notification) {
        notifications.push(notification);
      };
      var closeNotification = function (notification) {
        findIndex$2(notifications, function (otherNotification) {
          return otherNotification === notification;
        }).each(function (index) {
          notifications.splice(index, 1);
        });
      };
      var open = function (spec, fireEvent) {
        if (fireEvent === void 0) {
          fireEvent = true;
        }
        if (editor.removed || !isEditorAttachedToDom(editor)) {
          return;
        }
        if (fireEvent) {
          editor.fire('BeforeOpenNotification', { notification: spec });
        }
        return find$3(notifications, function (notification) {
          return isEqual(getImplementation().getArgs(notification), spec);
        }).getOrThunk(function () {
          editor.editorManager.setActive(editor);
          var notification = getImplementation().open(spec, function () {
            closeNotification(notification);
            reposition();
            getTopNotification().fold(function () {
              return editor.focus();
            }, function (top) {
              return focus$1(SugarElement.fromDom(top.getEl()));
            });
          });
          addNotification(notification);
          reposition();
          editor.fire('OpenNotification', { notification: __assign({}, notification) });
          return notification;
        });
      };
      var close = function () {
        getTopNotification().each(function (notification) {
          getImplementation().close(notification);
          closeNotification(notification);
          reposition();
        });
      };
      var getNotifications = constant(notifications);
      var registerEvents = function (editor) {
        editor.on('SkinLoaded', function () {
          var serviceMessage = getServiceMessage(editor);
          if (serviceMessage) {
            open({
              text: serviceMessage,
              type: 'warning',
              timeout: 0
            }, false);
          }
          reposition();
        });
        editor.on('show ResizeEditor ResizeWindow NodeChange', function () {
          Delay.requestAnimationFrame(reposition);
        });
        editor.on('remove', function () {
          each$k(notifications.slice(), function (notification) {
            getImplementation().close(notification);
          });
        });
      };
      registerEvents(editor);
      return {
        open: open,
        close: close,
        getNotifications: getNotifications
      };
    };

    var PluginManager = AddOnManager.PluginManager;

    var ThemeManager = AddOnManager.ThemeManager;

    function WindowManagerImpl () {
      var unimplemented = function () {
        throw new Error('Theme did not provide a WindowManager implementation.');
      };
      return {
        open: unimplemented,
        openUrl: unimplemented,
        alert: unimplemented,
        confirm: unimplemented,
        close: unimplemented,
        getParams: unimplemented,
        setParams: unimplemented
      };
    }

    var WindowManager = function (editor) {
      var dialogs = [];
      var getImplementation = function () {
        var theme = editor.theme;
        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
      };
      var funcBind = function (scope, f) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return f ? f.apply(scope, args) : undefined;
        };
      };
      var fireOpenEvent = function (dialog) {
        editor.fire('OpenWindow', { dialog: dialog });
      };
      var fireCloseEvent = function (dialog) {
        editor.fire('CloseWindow', { dialog: dialog });
      };
      var addDialog = function (dialog) {
        dialogs.push(dialog);
        fireOpenEvent(dialog);
      };
      var closeDialog = function (dialog) {
        fireCloseEvent(dialog);
        dialogs = filter$4(dialogs, function (otherDialog) {
          return otherDialog !== dialog;
        });
        if (dialogs.length === 0) {
          editor.focus();
        }
      };
      var getTopDialog = function () {
        return Optional.from(dialogs[dialogs.length - 1]);
      };
      var storeSelectionAndOpenDialog = function (openDialog) {
        editor.editorManager.setActive(editor);
        store(editor);
        var dialog = openDialog();
        addDialog(dialog);
        return dialog;
      };
      var open = function (args, params) {
        return storeSelectionAndOpenDialog(function () {
          return getImplementation().open(args, params, closeDialog);
        });
      };
      var openUrl = function (args) {
        return storeSelectionAndOpenDialog(function () {
          return getImplementation().openUrl(args, closeDialog);
        });
      };
      var alert = function (message, callback, scope) {
        var windowManagerImpl = getImplementation();
        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      var confirm = function (message, callback, scope) {
        var windowManagerImpl = getImplementation();
        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      var close = function () {
        getTopDialog().each(function (dialog) {
          getImplementation().close(dialog);
          closeDialog(dialog);
        });
      };
      editor.on('remove', function () {
        each$k(dialogs, function (dialog) {
          getImplementation().close(dialog);
        });
      });
      return {
        open: open,
        openUrl: openUrl,
        alert: alert,
        confirm: confirm,
        close: close
      };
    };

    var displayNotification = function (editor, message) {
      editor.notificationManager.open({
        type: 'error',
        text: message
      });
    };
    var displayError = function (editor, message) {
      if (editor._skinLoaded) {
        displayNotification(editor, message);
      } else {
        editor.on('SkinLoaded', function () {
          displayNotification(editor, message);
        });
      }
    };
    var uploadError = function (editor, message) {
      displayError(editor, I18n.translate([
        'Failed to upload image: {0}',
        message
      ]));
    };
    var logError = function (editor, errorType, msg) {
      fireError(editor, errorType, { message: msg });
      console.error(msg);
    };
    var createLoadError = function (type, url, name) {
      return name ? 'Failed to load ' + type + ': ' + name + ' from url ' + url : 'Failed to load ' + type + ' url: ' + url;
    };
    var pluginLoadError = function (editor, url, name) {
      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
    };
    var iconsLoadError = function (editor, url, name) {
      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
    };
    var languageLoadError = function (editor, url, name) {
      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
    };
    var pluginInitError = function (editor, name, err) {
      var message = I18n.translate([
        'Failed to initialize plugin: {0}',
        name
      ]);
      fireError(editor, 'PluginLoadError', { message: message });
      initError(message, err);
      displayError(editor, message);
    };
    var initError = function (message) {
      var x = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        x[_i - 1] = arguments[_i];
      }
      var console = window.console;
      if (console) {
        if (console.error) {
          console.error.apply(console, __spreadArray([message], x, false));
        } else {
          console.log.apply(console, __spreadArray([message], x, false));
        }
      }
    };

    var isContentCssSkinName = function (url) {
      return /^[a-z0-9\-]+$/i.test(url);
    };
    var getContentCssUrls = function (editor) {
      return transformToUrls(editor, getContentCss(editor));
    };
    var getFontCssUrls = function (editor) {
      return transformToUrls(editor, getFontCss(editor));
    };
    var transformToUrls = function (editor, cssLinks) {
      var skinUrl = editor.editorManager.baseURL + '/skins/content';
      var suffix = editor.editorManager.suffix;
      var contentCssFile = 'content' + suffix + '.css';
      var inline = editor.inline === true;
      return map$3(cssLinks, function (url) {
        if (isContentCssSkinName(url) && !inline) {
          return skinUrl + '/' + url + '/' + contentCssFile;
        } else {
          return editor.documentBaseURI.toAbsolute(url);
        }
      });
    };
    var appendContentCssFromSettings = function (editor) {
      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };

    var UploadStatus = function () {
      var PENDING = 1, UPLOADED = 2;
      var blobUriStatuses = {};
      var createStatus = function (status, resultUri) {
        return {
          status: status,
          resultUri: resultUri
        };
      };
      var hasBlobUri = function (blobUri) {
        return blobUri in blobUriStatuses;
      };
      var getResultUri = function (blobUri) {
        var result = blobUriStatuses[blobUri];
        return result ? result.resultUri : null;
      };
      var isPending = function (blobUri) {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
      };
      var isUploaded = function (blobUri) {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
      };
      var markPending = function (blobUri) {
        blobUriStatuses[blobUri] = createStatus(PENDING, null);
      };
      var markUploaded = function (blobUri, resultUri) {
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      };
      var removeFailed = function (blobUri) {
        delete blobUriStatuses[blobUri];
      };
      var destroy = function () {
        blobUriStatuses = {};
      };
      return {
        hasBlobUri: hasBlobUri,
        getResultUri: getResultUri,
        isPending: isPending,
        isUploaded: isUploaded,
        markPending: markPending,
        markUploaded: markUploaded,
        removeFailed: removeFailed,
        destroy: destroy
      };
    };

    var count = 0;
    var seed = function () {
      var rnd = function () {
        return Math.round(Math.random() * 4294967295).toString(36);
      };
      var now = new Date().getTime();
      return 's' + now.toString(36) + rnd() + rnd() + rnd();
    };
    var uuid = function (prefix) {
      return prefix + count++ + seed();
    };

    var BlobCache = function () {
      var cache = [];
      var mimeToExt = function (mime) {
        var mimes = {
          'image/jpeg': 'jpg',
          'image/jpg': 'jpg',
          'image/gif': 'gif',
          'image/png': 'png',
          'image/apng': 'apng',
          'image/avif': 'avif',
          'image/svg+xml': 'svg',
          'image/webp': 'webp',
          'image/bmp': 'bmp',
          'image/tiff': 'tiff'
        };
        return mimes[mime.toLowerCase()] || 'dat';
      };
      var create = function (o, blob, base64, name, filename) {
        if (isString$1(o)) {
          var id = o;
          return toBlobInfo({
            id: id,
            name: name,
            filename: filename,
            blob: blob,
            base64: base64
          });
        } else if (isObject(o)) {
          return toBlobInfo(o);
        } else {
          throw new Error('Unknown input type');
        }
      };
      var toBlobInfo = function (o) {
        if (!o.blob || !o.base64) {
          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
        }
        var id = o.id || uuid('blobid');
        var name = o.name || id;
        var blob = o.blob;
        return {
          id: constant(id),
          name: constant(name),
          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),
          blob: constant(blob),
          base64: constant(o.base64),
          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
          uri: constant(o.uri)
        };
      };
      var add = function (blobInfo) {
        if (!get(blobInfo.id())) {
          cache.push(blobInfo);
        }
      };
      var findFirst = function (predicate) {
        return find$3(cache, predicate).getOrUndefined();
      };
      var get = function (id) {
        return findFirst(function (cachedBlobInfo) {
          return cachedBlobInfo.id() === id;
        });
      };
      var getByUri = function (blobUri) {
        return findFirst(function (blobInfo) {
          return blobInfo.blobUri() === blobUri;
        });
      };
      var getByData = function (base64, type) {
        return findFirst(function (blobInfo) {
          return blobInfo.base64() === base64 && blobInfo.blob().type === type;
        });
      };
      var removeByUri = function (blobUri) {
        cache = filter$4(cache, function (blobInfo) {
          if (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            return false;
          }
          return true;
        });
      };
      var destroy = function () {
        each$k(cache, function (cachedBlobInfo) {
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });
        cache = [];
      };
      return {
        create: create,
        add: add,
        get: get,
        getByUri: getByUri,
        getByData: getByData,
        findFirst: findFirst,
        removeByUri: removeByUri,
        destroy: destroy
      };
    };

    var Uploader = function (uploadStatus, settings) {
      var pendingPromises = {};
      var pathJoin = function (path1, path2) {
        if (path1) {
          return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
        }
        return path2;
      };
      var defaultHandler = function (blobInfo, success, failure, progress) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = function (e) {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = function () {
          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
        };
        xhr.onload = function () {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure('HTTP Error: ' + xhr.status);
            return;
          }
          var json = JSON.parse(xhr.responseText);
          if (!json || typeof json.location !== 'string') {
            failure('Invalid JSON: ' + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        var formData = new FormData();
        formData.append('file', blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      };
      var noUpload = function () {
        return new promiseObj(function (resolve) {
          resolve([]);
        });
      };
      var handlerSuccess = function (blobInfo, url) {
        return {
          url: url,
          blobInfo: blobInfo,
          status: true
        };
      };
      var handlerFailure = function (blobInfo, message, options) {
        return {
          url: '',
          blobInfo: blobInfo,
          status: false,
          error: {
            message: message,
            options: options
          }
        };
      };
      var resolvePending = function (blobUri, result) {
        Tools.each(pendingPromises[blobUri], function (resolve) {
          resolve(result);
        });
        delete pendingPromises[blobUri];
      };
      var uploadBlobInfo = function (blobInfo, handler, openNotification) {
        uploadStatus.markPending(blobInfo.blobUri());
        return new promiseObj(function (resolve) {
          var notification, progress;
          try {
            var closeNotification_1 = function () {
              if (notification) {
                notification.close();
                progress = noop;
              }
            };
            var success = function (url) {
              closeNotification_1();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve(handlerSuccess(blobInfo, url));
            };
            var failure = function (error, options) {
              var failureOptions = options ? options : {};
              closeNotification_1();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error, failureOptions));
              resolve(handlerFailure(blobInfo, error, failureOptions));
            };
            progress = function (percent) {
              if (percent < 0 || percent > 100) {
                return;
              }
              Optional.from(notification).orThunk(function () {
                return Optional.from(openNotification).map(apply);
              }).each(function (n) {
                notification = n;
                n.progressBar.value(percent);
              });
            };
            handler(blobInfo, success, failure, progress);
          } catch (ex) {
            resolve(handlerFailure(blobInfo, ex.message, {}));
          }
        });
      };
      var isDefaultHandler = function (handler) {
        return handler === defaultHandler;
      };
      var pendingUploadBlobInfo = function (blobInfo) {
        var blobUri = blobInfo.blobUri();
        return new promiseObj(function (resolve) {
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve);
        });
      };
      var uploadBlobs = function (blobInfos, openNotification) {
        blobInfos = Tools.grep(blobInfos, function (blobInfo) {
          return !uploadStatus.isUploaded(blobInfo.blobUri());
        });
        return promiseObj.all(Tools.map(blobInfos, function (blobInfo) {
          return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
        }));
      };
      var upload = function (blobInfos, openNotification) {
        return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
      };
      if (isFunction(settings.handler) === false) {
        settings.handler = defaultHandler;
      }
      return { upload: upload };
    };

    var openNotification = function (editor) {
      return function () {
        return editor.notificationManager.open({
          text: editor.translate('Image uploading...'),
          type: 'info',
          timeout: -1,
          progressBar: true
        });
      };
    };
    var createUploader = function (editor, uploadStatus) {
      return Uploader(uploadStatus, {
        url: getImageUploadUrl(editor),
        basePath: getImageUploadBasePath(editor),
        credentials: getImagesUploadCredentials(editor),
        handler: getImagesUploadHandler(editor)
      });
    };
    var ImageUploader = function (editor) {
      var uploadStatus = UploadStatus();
      var uploader = createUploader(editor, uploadStatus);
      return {
        upload: function (blobInfos, showNotification) {
          if (showNotification === void 0) {
            showNotification = true;
          }
          return uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined);
        }
      };
    };

    var UploadChangeHandler = function (editor) {
      var lastChangedLevel = Cell(null);
      editor.on('change AddUndo', function (e) {
        lastChangedLevel.set(__assign({}, e.level));
      });
      var fireIfChanged = function () {
        var data = editor.undoManager.data;
        last$2(data).filter(function (level) {
          return !isEq$1(lastChangedLevel.get(), level);
        }).each(function (level) {
          editor.setDirty(true);
          editor.fire('change', {
            level: level,
            lastLevel: get$a(data, data.length - 2).getOrNull()
          });
        });
      };
      return { fireIfChanged: fireIfChanged };
    };
    var EditorUpload = function (editor) {
      var blobCache = BlobCache();
      var uploader, imageScanner;
      var uploadStatus = UploadStatus();
      var urlFilters = [];
      var changeHandler = UploadChangeHandler(editor);
      var aliveGuard = function (callback) {
        return function (result) {
          if (editor.selection) {
            return callback(result);
          }
          return [];
        };
      };
      var cacheInvalidator = function (url) {
        return url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();
      };
      var replaceString = function (content, search, replace) {
        var index = 0;
        do {
          index = content.indexOf(search, index);
          if (index !== -1) {
            content = content.substring(0, index) + replace + content.substr(index + search.length);
            index += replace.length - search.length + 1;
          }
        } while (index !== -1);
        return content;
      };
      var replaceImageUrl = function (content, targetUrl, replacementUrl) {
        var replacementString = 'src="' + replacementUrl + '"' + (replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : '');
        content = replaceString(content, 'src="' + targetUrl + '"', replacementString);
        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
        return content;
      };
      var replaceUrlInUndoStack = function (targetUrl, replacementUrl) {
        each$k(editor.undoManager.data, function (level) {
          if (level.type === 'fragmented') {
            level.fragments = map$3(level.fragments, function (fragment) {
              return replaceImageUrl(fragment, targetUrl, replacementUrl);
            });
          } else {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      };
      var replaceImageUriInView = function (image, resultUri) {
        var src = editor.convertURL(resultUri, 'src');
        replaceUrlInUndoStack(image.src, resultUri);
        editor.$(image).attr({
          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
          'data-mce-src': src
        });
      };
      var uploadImages = function (callback) {
        if (!uploader) {
          uploader = createUploader(editor, uploadStatus);
        }
        return scanForImages().then(aliveGuard(function (imageInfos) {
          var blobInfos = map$3(imageInfos, function (imageInfo) {
            return imageInfo.blobInfo;
          });
          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(function (result) {
            var imagesToRemove = [];
            var filteredResult = map$3(result, function (uploadInfo, index) {
              var blobInfo = imageInfos[index].blobInfo;
              var image = imageInfos[index].image;
              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                blobCache.removeByUri(image.src);
                if (isRtc(editor)) ; else {
                  replaceImageUriInView(image, uploadInfo.url);
                }
              } else if (uploadInfo.error) {
                if (uploadInfo.error.options.remove) {
                  replaceUrlInUndoStack(image.getAttribute('src'), Env.transparentSrc);
                  imagesToRemove.push(image);
                }
                uploadError(editor, uploadInfo.error.message);
              }
              return {
                element: image,
                status: uploadInfo.status,
                uploadUri: uploadInfo.url,
                blobInfo: blobInfo
              };
            });
            if (filteredResult.length > 0) {
              changeHandler.fireIfChanged();
            }
            if (imagesToRemove.length > 0) {
              if (isRtc(editor)) {
                console.error('Removing images on failed uploads is currently unsupported for RTC');
              } else {
                editor.undoManager.transact(function () {
                  each$k(imagesToRemove, function (element) {
                    editor.dom.remove(element);
                    blobCache.removeByUri(element.src);
                  });
                });
              }
            }
            if (callback) {
              callback(filteredResult);
            }
            return filteredResult;
          }));
        }));
      };
      var uploadImagesAuto = function (callback) {
        if (isAutomaticUploadsEnabled(editor)) {
          return uploadImages(callback);
        }
      };
      var isValidDataUriImage = function (imgElm) {
        if (forall(urlFilters, function (filter) {
            return filter(imgElm);
          }) === false) {
          return false;
        }
        if (imgElm.getAttribute('src').indexOf('data:') === 0) {
          var dataImgFilter = getImagesDataImgFilter(editor);
          return dataImgFilter(imgElm);
        }
        return true;
      };
      var addFilter = function (filter) {
        urlFilters.push(filter);
      };
      var scanForImages = function () {
        if (!imageScanner) {
          imageScanner = ImageScanner(uploadStatus, blobCache);
        }
        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function (result) {
          result = filter$4(result, function (resultItem) {
            if (typeof resultItem === 'string') {
              displayError(editor, resultItem);
              return false;
            }
            return true;
          });
          if (isRtc(editor)) ; else {
            each$k(result, function (resultItem) {
              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
              resultItem.image.src = resultItem.blobInfo.blobUri();
              resultItem.image.removeAttribute('data-mce-src');
            });
          }
          return result;
        }));
      };
      var destroy = function () {
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = null;
      };
      var replaceBlobUris = function (content) {
        return content.replace(/src="(blob:[^"]+)"/g, function (match, blobUri) {
          var resultUri = uploadStatus.getResultUri(blobUri);
          if (resultUri) {
            return 'src="' + resultUri + '"';
          }
          var blobInfo = blobCache.getByUri(blobUri);
          if (!blobInfo) {
            blobInfo = foldl(editor.editorManager.get(), function (result, editor) {
              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
            }, null);
          }
          if (blobInfo) {
            var blob = blobInfo.blob();
            return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
          }
          return match;
        });
      };
      editor.on('SetContent', function () {
        if (isAutomaticUploadsEnabled(editor)) {
          uploadImagesAuto();
        } else {
          scanForImages();
        }
      });
      editor.on('RawSaveContent', function (e) {
        e.content = replaceBlobUris(e.content);
      });
      editor.on('GetContent', function (e) {
        if (e.source_view || e.format === 'raw' || e.format === 'tree') {
          return;
        }
        e.content = replaceBlobUris(e.content);
      });
      editor.on('PostRender', function () {
        editor.parser.addNodeFilter('img', function (images) {
          each$k(images, function (img) {
            var src = img.attr('src');
            if (blobCache.getByUri(src)) {
              return;
            }
            var resultUri = uploadStatus.getResultUri(src);
            if (resultUri) {
              img.attr('src', resultUri);
            }
          });
        });
      });
      return {
        blobCache: blobCache,
        addFilter: addFilter,
        uploadImages: uploadImages,
        uploadImagesAuto: uploadImagesAuto,
        scanForImages: scanForImages,
        destroy: destroy
      };
    };

    var get = function (dom) {
      var formats = {
        valigntop: [{
            selector: 'td,th',
            styles: { verticalAlign: 'top' }
          }],
        valignmiddle: [{
            selector: 'td,th',
            styles: { verticalAlign: 'middle' }
          }],
        valignbottom: [{
            selector: 'td,th',
            styles: { verticalAlign: 'bottom' }
          }],
        alignleft: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-left',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
            styles: { textAlign: 'left' },
            inherit: false,
            preview: false,
            defaultBlock: 'div'
          },
          {
            selector: 'img,table,audio,video',
            collapsed: false,
            styles: { float: 'left' },
            preview: 'font-family font-size'
          }
        ],
        aligncenter: [
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
            styles: { textAlign: 'center' },
            inherit: false,
            preview: 'font-family font-size',
            defaultBlock: 'div'
          },
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-center',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: {
              display: 'block',
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: 'font-family font-size'
          }
        ],
        alignright: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-right',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
            styles: { textAlign: 'right' },
            inherit: false,
            preview: 'font-family font-size',
            defaultBlock: 'div'
          },
          {
            selector: 'img,table,audio,video',
            collapsed: false,
            styles: { float: 'right' },
            preview: 'font-family font-size'
          }
        ],
        alignjustify: [{
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
            styles: { textAlign: 'justify' },
            inherit: false,
            defaultBlock: 'div',
            preview: 'font-family font-size'
          }],
        bold: [
          {
            inline: 'strong',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontWeight: 'bold' }
          },
          {
            inline: 'b',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        italic: [
          {
            inline: 'em',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontStyle: 'italic' }
          },
          {
            inline: 'i',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        underline: [
          {
            inline: 'span',
            styles: { textDecoration: 'underline' },
            exact: true
          },
          {
            inline: 'u',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        strikethrough: [
          {
            inline: 'span',
            styles: { textDecoration: 'line-through' },
            exact: true
          },
          {
            inline: 'strike',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 's',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        forecolor: {
          inline: 'span',
          styles: { color: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        hilitecolor: {
          inline: 'span',
          styles: { backgroundColor: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        fontname: {
          inline: 'span',
          toggle: false,
          styles: { fontFamily: '%value' },
          clear_child_styles: true
        },
        fontsize: {
          inline: 'span',
          toggle: false,
          styles: { fontSize: '%value' },
          clear_child_styles: true
        },
        lineheight: {
          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',
          defaultBlock: 'p',
          styles: { lineHeight: '%value' }
        },
        fontsize_class: {
          inline: 'span',
          attributes: { class: '%value' }
        },
        blockquote: {
          block: 'blockquote',
          wrapper: true,
          remove: 'all'
        },
        subscript: { inline: 'sub' },
        superscript: { inline: 'sup' },
        code: { inline: 'code' },
        link: {
          inline: 'a',
          selector: 'a',
          remove: 'all',
          split: true,
          deep: true,
          onmatch: function (node, _fmt, _itemName) {
            return isElement$5(node) && node.hasAttribute('href');
          },
          onformat: function (elm, _fmt, vars) {
            Tools.each(vars, function (value, key) {
              dom.setAttrib(elm, key, value);
            });
          }
        },
        lang: {
          inline: 'span',
          clear_child_styles: true,
          remove_similar: true,
          attributes: {
            'lang': '%value',
            'data-mce-lang': function (vars) {
              var _a;
              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        },
        removeformat: [
          {
            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',
            remove: 'all',
            split: true,
            expand: false,
            block_expand: true,
            deep: true
          },
          {
            selector: 'span',
            attributes: [
              'style',
              'class'
            ],
            remove: 'empty',
            split: true,
            expand: false,
            deep: true
          },
          {
            selector: '*',
            attributes: [
              'style',
              'class'
            ],
            split: false,
            expand: false,
            deep: true
          }
        ]
      };
      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\s/), function (name) {
        formats[name] = {
          block: name,
          remove: 'all'
        };
      });
      return formats;
    };

    var FormatRegistry = function (editor) {
      var formats = {};
      var get$1 = function (name) {
        return isNonNullable(name) ? formats[name] : formats;
      };
      var has = function (name) {
        return has$2(formats, name);
      };
      var register = function (name, format) {
        if (name) {
          if (!isString$1(name)) {
            each$j(name, function (format, name) {
              register(name, format);
            });
          } else {
            if (!isArray$1(format)) {
              format = [format];
            }
            each$k(format, function (format) {
              if (isUndefined(format.deep)) {
                format.deep = !isSelectorFormat(format);
              }
              if (isUndefined(format.split)) {
                format.split = !isSelectorFormat(format) || isInlineFormat(format);
              }
              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {
                format.remove = 'none';
              }
              if (isSelectorFormat(format) && isInlineFormat(format)) {
                format.mixed = true;
                format.block_expand = true;
              }
              if (isString$1(format.classes)) {
                format.classes = format.classes.split(/\s+/);
              }
            });
            formats[name] = format;
          }
        }
      };
      var unregister = function (name) {
        if (name && formats[name]) {
          delete formats[name];
        }
        return formats;
      };
      register(get(editor.dom));
      register(getFormats(editor));
      return {
        get: get$1,
        has: has,
        register: register,
        unregister: unregister
      };
    };

    var each$5 = Tools.each;
    var dom = DOMUtils.DOM;
    var parsedSelectorToHtml = function (ancestry, editor) {
      var elm, item, fragment;
      var schema = editor && editor.schema || Schema({});
      var decorate = function (elm, item) {
        if (item.classes.length) {
          dom.addClass(elm, item.classes.join(' '));
        }
        dom.setAttribs(elm, item.attrs);
      };
      var createElement = function (sItem) {
        item = typeof sItem === 'string' ? {
          name: sItem,
          classes: [],
          attrs: {}
        } : sItem;
        var elm = dom.create(item.name);
        decorate(elm, item);
        return elm;
      };
      var getRequiredParent = function (elm, candidate) {
        var name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;
        var elmRule = schema.getElementRule(name);
        var parentsRequired = elmRule && elmRule.parentsRequired;
        if (parentsRequired && parentsRequired.length) {
          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
        } else {
          return false;
        }
      };
      var wrapInHtml = function (elm, ancestry, siblings) {
        var parent, parentCandidate;
        var ancestor = ancestry.length > 0 && ancestry[0];
        var ancestorName = ancestor && ancestor.name;
        var parentRequired = getRequiredParent(elm, ancestorName);
        if (parentRequired) {
          if (ancestorName === parentRequired) {
            parentCandidate = ancestry[0];
            ancestry = ancestry.slice(1);
          } else {
            parentCandidate = parentRequired;
          }
        } else if (ancestor) {
          parentCandidate = ancestry[0];
          ancestry = ancestry.slice(1);
        } else if (!siblings) {
          return elm;
        }
        if (parentCandidate) {
          parent = createElement(parentCandidate);
          parent.appendChild(elm);
        }
        if (siblings) {
          if (!parent) {
            parent = dom.create('div');
            parent.appendChild(elm);
          }
          Tools.each(siblings, function (sibling) {
            var siblingElm = createElement(sibling);
            parent.insertBefore(siblingElm, elm);
          });
        }
        return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);
      };
      if (ancestry && ancestry.length) {
        item = ancestry[0];
        elm = createElement(item);
        fragment = dom.create('div');
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
        return fragment;
      } else {
        return '';
      }
    };
    var parseSelectorItem = function (item) {
      var tagName;
      var obj = {
        classes: [],
        attrs: {}
      };
      item = obj.selector = Tools.trim(item);
      if (item !== '*') {
        tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function ($0, $1, $2, $3, $4) {
          switch ($1) {
          case '#':
            obj.attrs.id = $2;
            break;
          case '.':
            obj.classes.push($2);
            break;
          case ':':
            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
              obj.attrs[$2] = $2;
            }
            break;
          }
          if ($3 === '[') {
            var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return '';
        });
      }
      obj.name = tagName || 'div';
      return obj;
    };
    var parseSelector = function (selector) {
      if (!selector || typeof selector !== 'string') {
        return [];
      }
      selector = selector.split(/\s*,\s*/)[0];
      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function (item) {
        var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
        var obj = siblings.pop();
        if (siblings.length) {
          obj.siblings = siblings;
        }
        return obj;
      }).reverse();
    };
    var getCssText = function (editor, format) {
      var name, previewFrag;
      var previewCss = '', parentFontSize;
      var previewStyles = getPreviewStyles(editor);
      if (previewStyles === '') {
        return '';
      }
      var removeVars = function (val) {
        return val.replace(/%(\w+)/g, '');
      };
      if (typeof format === 'string') {
        format = editor.formatter.get(format);
        if (!format) {
          return;
        }
        format = format[0];
      }
      if ('preview' in format) {
        var previewOpt = get$9(format, 'preview');
        if (is$1(previewOpt, false)) {
          return '';
        } else {
          previewStyles = previewOpt.getOr(previewStyles);
        }
      }
      name = format.block || format.inline || 'span';
      var items = parseSelector(format.selector);
      if (items.length) {
        if (!items[0].name) {
          items[0].name = name;
        }
        name = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } else {
        previewFrag = parsedSelectorToHtml([name], editor);
      }
      var previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
      each$5(format.styles, function (value, name) {
        var newValue = removeVars(value);
        if (newValue) {
          dom.setStyle(previewElm, name, newValue);
        }
      });
      each$5(format.attributes, function (value, name) {
        var newValue = removeVars(value);
        if (newValue) {
          dom.setAttrib(previewElm, name, newValue);
        }
      });
      each$5(format.classes, function (value) {
        var newValue = removeVars(value);
        if (!dom.hasClass(previewElm, newValue)) {
          dom.addClass(previewElm, newValue);
        }
      });
      editor.fire('PreviewFormats');
      dom.setStyles(previewFrag, {
        position: 'absolute',
        left: -65535
      });
      editor.getBody().appendChild(previewFrag);
      parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);
      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
      each$5(previewStyles.split(' '), function (name) {
        var value = dom.getStyle(previewElm, name, true);
        if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
          value = dom.getStyle(editor.getBody(), name, true);
          if (dom.toHex(value).toLowerCase() === '#ffffff') {
            return;
          }
        }
        if (name === 'color') {
          if (dom.toHex(value).toLowerCase() === '#000000') {
            return;
          }
        }
        if (name === 'font-size') {
          if (/em|%$/.test(value)) {
            if (parentFontSize === 0) {
              return;
            }
            var numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
            value = numValue * parentFontSize + 'px';
          }
        }
        if (name === 'border' && value) {
          previewCss += 'padding:0 2px;';
        }
        previewCss += name + ':' + value + ';';
      });
      editor.fire('AfterPreviewFormats');
      dom.remove(previewFrag);
      return previewCss;
    };

    var setup$h = function (editor) {
      editor.addShortcut('meta+b', '', 'Bold');
      editor.addShortcut('meta+i', '', 'Italic');
      editor.addShortcut('meta+u', '', 'Underline');
      for (var i = 1; i <= 6; i++) {
        editor.addShortcut('access+' + i, '', [
          'FormatBlock',
          false,
          'h' + i
        ]);
      }
      editor.addShortcut('access+7', '', [
        'FormatBlock',
        false,
        'p'
      ]);
      editor.addShortcut('access+8', '', [
        'FormatBlock',
        false,
        'div'
      ]);
      editor.addShortcut('access+9', '', [
        'FormatBlock',
        false,
        'address'
      ]);
    };

    var Formatter = function (editor) {
      var formats = FormatRegistry(editor);
      var formatChangeState = Cell(null);
      setup$h(editor);
      setup$k(editor);
      return {
        get: formats.get,
        has: formats.has,
        register: formats.register,
        unregister: formats.unregister,
        apply: function (name, vars, node) {
          applyFormat(editor, name, vars, node);
        },
        remove: function (name, vars, node, similar) {
          removeFormat(editor, name, vars, node, similar);
        },
        toggle: function (name, vars, node) {
          toggleFormat(editor, name, vars, node);
        },
        match: function (name, vars, node, similar) {
          return matchFormat(editor, name, vars, node, similar);
        },
        closest: function (names) {
          return closestFormat(editor, names);
        },
        matchAll: function (names, vars) {
          return matchAllFormats(editor, names, vars);
        },
        matchNode: function (node, name, vars, similar) {
          return matchNodeFormat(editor, node, name, vars, similar);
        },
        canApply: function (name) {
          return canApplyFormat(editor, name);
        },
        formatChanged: function (formats, callback, similar, vars) {
          return formatChanged(editor, formatChangeState, formats, callback, similar, vars);
        },
        getCssText: curry(getCssText, editor)
      };
    };

    var shouldIgnoreCommand = function (cmd) {
      switch (cmd.toLowerCase()) {
      case 'undo':
      case 'redo':
      case 'mcerepaint':
      case 'mcefocus':
        return true;
      default:
        return false;
      }
    };
    var registerEvents = function (editor, undoManager, locks) {
      var isFirstTypedCharacter = Cell(false);
      var addNonTypingUndoLevel = function (e) {
        setTyping(undoManager, false, locks);
        undoManager.add({}, e);
      };
      editor.on('init', function () {
        undoManager.add();
      });
      editor.on('BeforeExecCommand', function (e) {
        var cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
        }
      });
      editor.on('ExecCommand', function (e) {
        var cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('ObjectResizeStart cut', function () {
        undoManager.beforeChange();
      });
      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
      editor.on('dragend', addNonTypingUndoLevel);
      editor.on('keyup', function (e) {
        var keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }
        if (keyCode === 46 || keyCode === 8) {
          editor.nodeChanged();
        }
        if (isFirstTypedCharacter.get() && undoManager.typing && isEq$1(createFromEditor(editor), undoManager.data[0]) === false) {
          if (editor.isDirty() === false) {
            editor.setDirty(true);
            editor.fire('change', {
              level: undoManager.data[0],
              lastLevel: null
            });
          }
          editor.fire('TypingUndo');
          isFirstTypedCharacter.set(false);
          editor.nodeChanged();
        }
      });
      editor.on('keydown', function (e) {
        var keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
          if (undoManager.typing) {
            addNonTypingUndoLevel(e);
          }
          return;
        }
        var modKey = e.ctrlKey && !e.altKey || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
          undoManager.beforeChange();
          setTyping(undoManager, true, locks);
          undoManager.add({}, e);
          isFirstTypedCharacter.set(true);
        }
      });
      editor.on('mousedown', function (e) {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
      });
      var isInsertReplacementText = function (event) {
        return event.inputType === 'insertReplacementText';
      };
      var isInsertTextDataNull = function (event) {
        return event.inputType === 'insertText' && event.data === null;
      };
      var isInsertFromPasteOrDrop = function (event) {
        return event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';
      };
      editor.on('input', function (e) {
        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('AddUndo Undo Redo ClearUndos', function (e) {
        if (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });
    };
    var addKeyboardShortcuts = function (editor) {
      editor.addShortcut('meta+z', '', 'Undo');
      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
    };

    var UndoManager = function (editor) {
      var beforeBookmark = value();
      var locks = Cell(0);
      var index = Cell(0);
      var undoManager = {
        data: [],
        typing: false,
        beforeChange: function () {
          beforeChange(editor, locks, beforeBookmark);
        },
        add: function (level, event) {
          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        undo: function () {
          return undo(editor, undoManager, locks, index);
        },
        redo: function () {
          return redo(editor, index, undoManager.data);
        },
        clear: function () {
          clear(editor, undoManager, index);
        },
        reset: function () {
          reset(editor, undoManager);
        },
        hasUndo: function () {
          return hasUndo(editor, undoManager, index);
        },
        hasRedo: function () {
          return hasRedo(editor, undoManager, index);
        },
        transact: function (callback) {
          return transact(editor, undoManager, locks, callback);
        },
        ignore: function (callback) {
          ignore(editor, locks, callback);
        },
        extra: function (callback1, callback2) {
          extra(editor, undoManager, index, callback1, callback2);
        }
      };
      if (!isRtc(editor)) {
        registerEvents(editor, undoManager, locks);
      }
      addKeyboardShortcuts(editor);
      return undoManager;
    };

    var nonTypingKeycodes = [
      9,
      27,
      VK.HOME,
      VK.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      VK.DOWN,
      VK.UP,
      VK.LEFT,
      VK.RIGHT
    ].concat(Env.browser.isFirefox() ? [224] : []);
    var placeholderAttr = 'data-mce-placeholder';
    var isKeyboardEvent = function (e) {
      return e.type === 'keydown' || e.type === 'keyup';
    };
    var isDeleteEvent = function (e) {
      var keyCode = e.keyCode;
      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    var isNonTypingKeyboardEvent = function (e) {
      if (isKeyboardEvent(e)) {
        var keyCode = e.keyCode;
        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$3(nonTypingKeycodes, keyCode));
      } else {
        return false;
      }
    };
    var isTypingKeyboardEvent = function (e) {
      return isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
    };
    var isVisuallyEmpty = function (dom, rootElm, forcedRootBlock) {
      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
        var isForcedRootBlockFalse = forcedRootBlock === '';
        var firstElement = rootElm.firstElementChild;
        if (!firstElement) {
          return true;
        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
          return false;
        } else {
          return isForcedRootBlockFalse ? !dom.isBlock(firstElement) : forcedRootBlock === firstElement.nodeName.toLowerCase();
        }
      } else {
        return false;
      }
    };
    var setup$g = function (editor) {
      var dom = editor.dom;
      var rootBlock = getForcedRootBlock(editor);
      var placeholder = getPlaceholder(editor);
      var updatePlaceholder = function (e, initial) {
        if (isNonTypingKeyboardEvent(e)) {
          return;
        }
        var body = editor.getBody();
        var showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
        var isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
        if (isPlaceholderShown !== showPlaceholder || initial) {
          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);
          firePlaceholderToggle(editor, showPlaceholder);
          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
        }
      };
      if (placeholder) {
        editor.on('init', function (e) {
          updatePlaceholder(e, true);
          editor.on('change SetContent ExecCommand', updatePlaceholder);
          editor.on('paste', function (e) {
            return Delay.setEditorTimeout(editor, function () {
              return updatePlaceholder(e);
            });
          });
        });
      }
    };

    var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    var hasStrongRtl = function (text) {
      return strongRtl.test(text);
    };

    var isInlineTarget = function (editor, elm) {
      return is$2(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));
    };
    var isRtl = function (element) {
      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);
    };
    var findInlineParents = function (isInlineTarget, rootNode, pos) {
      return filter$4(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
    };
    var findRootInline = function (isInlineTarget, rootNode, pos) {
      var parents = findInlineParents(isInlineTarget, rootNode, pos);
      return Optional.from(parents[parents.length - 1]);
    };
    var hasSameParentBlock = function (rootNode, node1, node2) {
      var block1 = getParentBlock$2(node1, rootNode);
      var block2 = getParentBlock$2(node2, rootNode);
      return block1 && block1 === block2;
    };
    var isAtZwsp = function (pos) {
      return isBeforeInline(pos) || isAfterInline(pos);
    };
    var normalizePosition = function (forward, pos) {
      if (!pos) {
        return pos;
      }
      var container = pos.container(), offset = pos.offset();
      if (forward) {
        if (isCaretContainerInline(container)) {
          if (isText$7(container.nextSibling)) {
            return CaretPosition(container.nextSibling, 0);
          } else {
            return CaretPosition.after(container);
          }
        } else {
          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
        }
      } else {
        if (isCaretContainerInline(container)) {
          if (isText$7(container.previousSibling)) {
            return CaretPosition(container.previousSibling, container.previousSibling.data.length);
          } else {
            return CaretPosition.before(container);
          }
        } else {
          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
        }
      }
    };
    var normalizeForwards = curry(normalizePosition, true);
    var normalizeBackwards = curry(normalizePosition, false);

    var isBeforeRoot = function (rootNode) {
      return function (elm) {
        return eq(rootNode, SugarElement.fromDom(elm.dom.parentNode));
      };
    };
    var isTextBlockOrListItem = function (element) {
      return isTextBlock$2(element) || isListItem(element);
    };
    var getParentBlock$1 = function (rootNode, elm) {
      if (contains$1(rootNode, elm)) {
        return closest$3(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
      } else {
        return Optional.none();
      }
    };
    var placeCaretInEmptyBody = function (editor) {
      var body = editor.getBody();
      var node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
      editor.selection.setCursorLocation(node, 0);
    };
    var paddEmptyBody = function (editor) {
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('');
        placeCaretInEmptyBody(editor);
      }
    };
    var willDeleteLastPositionInElement = function (forward, fromPos, elm) {
      return lift2(firstPositionIn(elm), lastPositionIn(elm), function (firstPos, lastPos) {
        var normalizedFirstPos = normalizePosition(true, firstPos);
        var normalizedLastPos = normalizePosition(false, lastPos);
        var normalizedFromPos = normalizePosition(false, fromPos);
        if (forward) {
          return nextPosition(elm, normalizedFromPos).exists(function (nextPos) {
            return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
          });
        } else {
          return prevPosition(elm, normalizedFromPos).exists(function (prevPos) {
            return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
          });
        }
      }).getOr(true);
    };

    var blockPosition = function (block, position) {
      return {
        block: block,
        position: position
      };
    };
    var blockBoundary = function (from, to) {
      return {
        from: from,
        to: to
      };
    };
    var getBlockPosition = function (rootNode, pos) {
      var rootElm = SugarElement.fromDom(rootNode);
      var containerElm = SugarElement.fromDom(pos.container());
      return getParentBlock$1(rootElm, containerElm).map(function (block) {
        return blockPosition(block, pos);
      });
    };
    var isDifferentBlocks = function (blockBoundary) {
      return eq(blockBoundary.from.block, blockBoundary.to.block) === false;
    };
    var hasSameParent = function (blockBoundary) {
      return parent(blockBoundary.from.block).bind(function (parent1) {
        return parent(blockBoundary.to.block).filter(function (parent2) {
          return eq(parent1, parent2);
        });
      }).isSome();
    };
    var isEditable$1 = function (blockBoundary) {
      return isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;
    };
    var skipLastBr = function (rootNode, forward, blockPosition) {
      if (isBr$5(blockPosition.position.getNode()) && isEmpty$2(blockPosition.block) === false) {
        return positionIn(false, blockPosition.block.dom).bind(function (lastPositionInBlock) {
          if (lastPositionInBlock.isEqual(blockPosition.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind(function (to) {
              return getBlockPosition(rootNode, to);
            });
          } else {
            return Optional.some(blockPosition);
          }
        }).getOr(blockPosition);
      } else {
        return blockPosition;
      }
    };
    var readFromRange = function (rootNode, forward, rng) {
      var fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      var toBlockPos = fromBlockPos.bind(function (blockPos) {
        return fromPosition(forward, rootNode, blockPos.position).bind(function (to) {
          return getBlockPosition(rootNode, to).map(function (blockPos) {
            return skipLastBr(rootNode, forward, blockPos);
          });
        });
      });
      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(function (blockBoundary) {
        return isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable$1(blockBoundary);
      });
    };
    var read$1 = function (rootNode, forward, rng) {
      return rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
    };

    var getChildrenUntilBlockBoundary = function (block) {
      var children$1 = children(block);
      return findIndex$2(children$1, isBlock$2).fold(constant(children$1), function (index) {
        return children$1.slice(0, index);
      });
    };
    var extractChildren = function (block) {
      var children = getChildrenUntilBlockBoundary(block);
      each$k(children, remove$7);
      return children;
    };
    var removeEmptyRoot = function (rootNode, block) {
      var parents = parentsAndSelf(block, rootNode);
      return find$3(parents.reverse(), function (element) {
        return isEmpty$2(element);
      }).each(remove$7);
    };
    var isEmptyBefore = function (el) {
      return filter$4(prevSiblings(el), function (el) {
        return !isEmpty$2(el);
      }).length === 0;
    };
    var nestedBlockMerge = function (rootNode, fromBlock, toBlock, insertionPoint) {
      if (isEmpty$2(toBlock)) {
        fillWithPaddingBr(toBlock);
        return firstPositionIn(toBlock.dom);
      }
      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {
        before$4(insertionPoint, SugarElement.fromTag('br'));
      }
      var position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
      each$k(extractChildren(fromBlock), function (child) {
        before$4(insertionPoint, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    var sidelongBlockMerge = function (rootNode, fromBlock, toBlock) {
      if (isEmpty$2(toBlock)) {
        remove$7(toBlock);
        if (isEmpty$2(fromBlock)) {
          fillWithPaddingBr(fromBlock);
        }
        return firstPositionIn(fromBlock.dom);
      }
      var position = lastPositionIn(toBlock.dom);
      each$k(extractChildren(fromBlock), function (child) {
        append$1(toBlock, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    var findInsertionPoint = function (toBlock, block) {
      var parentsAndSelf$1 = parentsAndSelf(block, toBlock);
      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    var getInsertionPoint = function (fromBlock, toBlock) {
      return contains$1(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    };
    var trimBr = function (first, block) {
      positionIn(first, block.dom).map(function (position) {
        return position.getNode();
      }).map(SugarElement.fromDom).filter(isBr$4).each(remove$7);
    };
    var mergeBlockInto = function (rootNode, fromBlock, toBlock) {
      trimBr(true, fromBlock);
      trimBr(false, toBlock);
      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
    };
    var mergeBlocks = function (rootNode, forward, block1, block2) {
      return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
    };

    var backspaceDelete$8 = function (editor, forward) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var position = read$1(rootNode.dom, forward, editor.selection.getRng()).bind(function (blockBoundary) {
        return mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block);
      });
      position.each(function (pos) {
        editor.selection.setRng(pos.toRange());
      });
      return position.isSome();
    };

    var deleteRangeMergeBlocks = function (rootNode, selection) {
      var rng = selection.getRng();
      return lift2(getParentBlock$1(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$1(rootNode, SugarElement.fromDom(rng.endContainer)), function (block1, block2) {
        if (eq(block1, block2) === false) {
          rng.deleteContents();
          mergeBlocks(rootNode, true, block1, block2).each(function (pos) {
            selection.setRng(pos.toRange());
          });
          return true;
        } else {
          return false;
        }
      }).getOr(false);
    };
    var isRawNodeInTable = function (root, rawNode) {
      var node = SugarElement.fromDom(rawNode);
      var isRoot = curry(eq, root);
      return ancestor$3(node, isTableCell$4, isRoot).isSome();
    };
    var isSelectionInTable = function (root, rng) {
      return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    };
    var isEverythingSelected = function (root, rng) {
      var noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
      var noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
      return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    var emptyEditor = function (editor) {
      editor.setContent('');
      editor.selection.setCursorLocation();
      return true;
    };
    var deleteRange$1 = function (editor) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var rng = editor.selection.getRng();
      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
    };
    var backspaceDelete$7 = function (editor, _forward) {
      return editor.selection.isCollapsed() ? false : deleteRange$1(editor);
    };

    var isContentEditableTrue$2 = isContentEditableTrue$4;
    var isContentEditableFalse$4 = isContentEditableFalse$b;
    var showCaret = function (direction, editor, node, before, scrollIntoView) {
      return Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));
    };
    var getNodeRange = function (node) {
      var rng = node.ownerDocument.createRange();
      rng.selectNode(node);
      return rng;
    };
    var selectNode = function (editor, node) {
      var e = editor.fire('BeforeObjectSelected', { target: node });
      if (e.isDefaultPrevented()) {
        return Optional.none();
      }
      return Optional.some(getNodeRange(node));
    };
    var renderCaretAtRange = function (editor, range, scrollIntoView) {
      var normalizedRange = normalizeRange(1, editor.getBody(), range);
      var caretPosition = CaretPosition.fromRangeStart(normalizedRange);
      var caretPositionNode = caretPosition.getNode();
      if (isInlineFakeCaretTarget(caretPositionNode)) {
        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
      }
      var caretPositionBeforeNode = caretPosition.getNode(true);
      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
        return showCaret(1, editor, caretPositionBeforeNode, false, false);
      }
      var ceRoot = editor.dom.getParent(caretPosition.getNode(), function (node) {
        return isContentEditableFalse$4(node) || isContentEditableTrue$2(node);
      });
      if (isInlineFakeCaretTarget(ceRoot)) {
        return showCaret(1, editor, ceRoot, false, scrollIntoView);
      }
      return Optional.none();
    };
    var renderRangeCaret = function (editor, range, scrollIntoView) {
      return range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;
    };

    var isBeforeBoundary = function (pos) {
      return isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    };
    var isAfterBoundary = function (pos) {
      return isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    };
    var trimEmptyTextNode = function (dom, node) {
      if (isText$7(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    var deleteContentAndShowCaret = function (editor, range, node, direction, forward, peekCaretPosition) {
      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(function (caretRange) {
        if (range.collapsed) {
          var deleteRange = range.cloneRange();
          if (forward) {
            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
          } else {
            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
          }
          deleteRange.deleteContents();
        } else {
          range.deleteContents();
        }
        editor.selection.setRng(caretRange);
      });
      trimEmptyTextNode(editor.dom, node);
      return true;
    };
    var deleteBoundaryText = function (editor, forward) {
      var range = editor.selection.getRng();
      if (!isText$7(range.commonAncestorContainer)) {
        return false;
      }
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var caretWalker = CaretWalker(editor.getBody());
      var getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
      var isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      var nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));
      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {
        return false;
      } else if (isBeforeFn(nextCaretPosition)) {
        return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition);
      }
      var peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition);
        }
      }
      return false;
    };
    var backspaceDelete$6 = function (editor, forward) {
      return deleteBoundaryText(editor, forward);
    };

    var isCompoundElement = function (node) {
      return isTableCell$4(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));
    };
    var DeleteAction = Adt.generate([
      { remove: ['element'] },
      { moveToElement: ['element'] },
      { moveToPosition: ['position'] }
    ]);
    var isAtContentEditableBlockCaret = function (forward, from) {
      var elm = from.getNode(forward === false);
      var caretLocation = forward ? 'after' : 'before';
      return isElement$5(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
    };
    var isDeleteFromCefDifferentBlocks = function (root, forward, from, to) {
      var inSameBlock = function (elm) {
        return isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);
      };
      return getRelativeCefElm(!forward, from).fold(function () {
        return getRelativeCefElm(forward, to).fold(never, inSameBlock);
      }, inSameBlock);
    };
    var deleteEmptyBlockOrMoveToCef = function (root, forward, from, to) {
      var toCefElm = to.getNode(forward === false);
      return getParentBlock$1(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(function (blockElm) {
        return isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm);
      }).orThunk(function () {
        return Optional.some(DeleteAction.moveToElement(toCefElm));
      });
    };
    var findCefPosition = function (root, forward, from) {
      return fromPosition(forward, root, from).bind(function (to) {
        if (isCompoundElement(to.getNode())) {
          return Optional.none();
        } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {
          return Optional.none();
        } else if (forward && isContentEditableFalse$b(to.getNode())) {
          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
        } else if (forward === false && isContentEditableFalse$b(to.getNode(true))) {
          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
        } else if (forward && isAfterContentEditableFalse(from)) {
          return Optional.some(DeleteAction.moveToPosition(to));
        } else if (forward === false && isBeforeContentEditableFalse(from)) {
          return Optional.some(DeleteAction.moveToPosition(to));
        } else {
          return Optional.none();
        }
      });
    };
    var getContentEditableBlockAction = function (forward, elm) {
      if (forward && isContentEditableFalse$b(elm.nextSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
      } else if (forward === false && isContentEditableFalse$b(elm.previousSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
      } else {
        return Optional.none();
      }
    };
    var skipMoveToActionFromInlineCefToContent = function (root, from, deleteAction) {
      return deleteAction.fold(function (elm) {
        return Optional.some(DeleteAction.remove(elm));
      }, function (elm) {
        return Optional.some(DeleteAction.moveToElement(elm));
      }, function (to) {
        if (isInSameBlock(from, to, root)) {
          return Optional.none();
        } else {
          return Optional.some(DeleteAction.moveToPosition(to));
        }
      });
    };
    var getContentEditableAction = function (root, forward, from) {
      if (isAtContentEditableBlockCaret(forward, from)) {
        return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(function () {
          return findCefPosition(root, forward, from);
        }, Optional.some);
      } else {
        return findCefPosition(root, forward, from).bind(function (deleteAction) {
          return skipMoveToActionFromInlineCefToContent(root, from, deleteAction);
        });
      }
    };
    var read = function (root, forward, rng) {
      var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
      var from = CaretPosition.fromRangeStart(normalizedRange);
      var rootElement = SugarElement.fromDom(root);
      if (forward === false && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode(true)));
      } else if (forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode()));
      } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {
        return findPreviousBr(rootElement, from).map(function (br) {
          return DeleteAction.remove(br.getNode());
        });
      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {
        return findNextBr(rootElement, from).map(function (br) {
          return DeleteAction.remove(br.getNode());
        });
      } else {
        return getContentEditableAction(root, forward, from);
      }
    };

    var deleteElement$1 = function (editor, forward) {
      return function (element) {
        editor._selectionOverrides.hideFakeCaret();
        deleteElement$2(editor, forward, SugarElement.fromDom(element));
        return true;
      };
    };
    var moveToElement = function (editor, forward) {
      return function (element) {
        var pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
        editor.selection.setRng(pos.toRange());
        return true;
      };
    };
    var moveToPosition = function (editor) {
      return function (pos) {
        editor.selection.setRng(pos.toRange());
        return true;
      };
    };
    var getAncestorCe = function (editor, node) {
      return Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    };
    var backspaceDeleteCaret = function (editor, forward) {
      var selectedNode = editor.selection.getNode();
      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(function () {
        return read(editor.getBody(), forward, editor.selection.getRng()).exists(function (deleteAction) {
          return deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
        });
      }, always);
    };
    var deleteOffscreenSelection = function (rootElement) {
      each$k(descendants(rootElement, '.mce-offscreen-selection'), remove$7);
    };
    var backspaceDeleteRange = function (editor, forward) {
      var selectedNode = editor.selection.getNode();
      if (isContentEditableFalse$b(selectedNode) && !isTableCell$5(selectedNode)) {
        var hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);
        return hasCefAncestor.fold(function () {
          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
          paddEmptyBody(editor);
          return true;
        }, always);
      }
      return false;
    };
    var paddEmptyElement = function (editor) {
      var dom = editor.dom, selection = editor.selection;
      var ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
      if (isContentEditableTrue$4(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {
        var br = dom.create('br', { 'data-mce-bogus': '1' });
        dom.setHTML(ceRoot, '');
        ceRoot.appendChild(br);
        selection.setRng(CaretPosition.before(br).toRange());
      }
      return true;
    };
    var backspaceDelete$5 = function (editor, forward) {
      if (editor.selection.isCollapsed()) {
        return backspaceDeleteCaret(editor, forward);
      } else {
        return backspaceDeleteRange(editor, forward);
      }
    };

    var deleteCaret$2 = function (editor, forward) {
      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return fromPosition(forward, editor.getBody(), fromPos).filter(function (pos) {
        return forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos);
      }).bind(function (pos) {
        return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos));
      }).exists(function (elm) {
        editor.selection.select(elm);
        return true;
      });
    };
    var backspaceDelete$4 = function (editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : false;
    };

    var isText = isText$7;
    var startsWithCaretContainer = function (node) {
      return isText(node) && node.data[0] === ZWSP$1;
    };
    var endsWithCaretContainer = function (node) {
      return isText(node) && node.data[node.data.length - 1] === ZWSP$1;
    };
    var createZwsp = function (node) {
      return node.ownerDocument.createTextNode(ZWSP$1);
    };
    var insertBefore = function (node) {
      if (isText(node.previousSibling)) {
        if (endsWithCaretContainer(node.previousSibling)) {
          return node.previousSibling;
        } else {
          node.previousSibling.appendData(ZWSP$1);
          return node.previousSibling;
        }
      } else if (isText(node)) {
        if (startsWithCaretContainer(node)) {
          return node;
        } else {
          node.insertData(0, ZWSP$1);
          return node;
        }
      } else {
        var newNode = createZwsp(node);
        node.parentNode.insertBefore(newNode, node);
        return newNode;
      }
    };
    var insertAfter = function (node) {
      if (isText(node.nextSibling)) {
        if (startsWithCaretContainer(node.nextSibling)) {
          return node.nextSibling;
        } else {
          node.nextSibling.insertData(0, ZWSP$1);
          return node.nextSibling;
        }
      } else if (isText(node)) {
        if (endsWithCaretContainer(node)) {
          return node;
        } else {
          node.appendData(ZWSP$1);
          return node;
        }
      } else {
        var newNode = createZwsp(node);
        if (node.nextSibling) {
          node.parentNode.insertBefore(newNode, node.nextSibling);
        } else {
          node.parentNode.appendChild(newNode);
        }
        return newNode;
      }
    };
    var insertInline = function (before, node) {
      return before ? insertBefore(node) : insertAfter(node);
    };
    var insertInlineBefore = curry(insertInline, true);
    var insertInlineAfter = curry(insertInline, false);

    var insertInlinePos = function (pos, before) {
      if (isText$7(pos.container())) {
        return insertInline(before, pos.container());
      } else {
        return insertInline(before, pos.getNode());
      }
    };
    var isPosCaretContainer = function (pos, caret) {
      var caretNode = caret.get();
      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    var renderCaret = function (caret, location) {
      return location.fold(function (element) {
        remove$2(caret.get());
        var text = insertInlineBefore(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, text.length - 1));
      }, function (element) {
        return firstPositionIn(element).map(function (pos) {
          if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            var text = insertInlinePos(pos, true);
            caret.set(text);
            return CaretPosition(text, 1);
          } else {
            return CaretPosition(caret.get(), 1);
          }
        });
      }, function (element) {
        return lastPositionIn(element).map(function (pos) {
          if (!isPosCaretContainer(pos, caret)) {
            remove$2(caret.get());
            var text = insertInlinePos(pos, false);
            caret.set(text);
            return CaretPosition(text, text.length - 1);
          } else {
            return CaretPosition(caret.get(), caret.get().length - 1);
          }
        });
      }, function (element) {
        remove$2(caret.get());
        var text = insertInlineAfter(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, 1));
      });
    };

    var evaluateUntil = function (fns, args) {
      for (var i = 0; i < fns.length; i++) {
        var result = fns[i].apply(null, args);
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    };

    var Location = Adt.generate([
      { before: ['element'] },
      { start: ['element'] },
      { end: ['element'] },
      { after: ['element'] }
    ]);
    var rescope$1 = function (rootNode, node) {
      var parentBlock = getParentBlock$2(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    var before = function (isInlineTarget, rootNode, pos) {
      var nPos = normalizeForwards(pos);
      var scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(function () {
        return nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(function (inline) {
          return Location.before(inline);
        });
      }, Optional.none);
    };
    var isNotInsideFormatCaretContainer = function (rootNode, elm) {
      return getParentCaretContainer(rootNode, elm) === null;
    };
    var findInsideRootInline = function (isInlineTarget, rootNode, pos) {
      return findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    };
    var start$1 = function (isInlineTarget, rootNode, pos) {
      var nPos = normalizeBackwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
        var prevPos = prevPosition(inline, nPos);
        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
      });
    };
    var end = function (isInlineTarget, rootNode, pos) {
      var nPos = normalizeForwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
        var nextPos = nextPosition(inline, nPos);
        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
      });
    };
    var after = function (isInlineTarget, rootNode, pos) {
      var nPos = normalizeBackwards(pos);
      var scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(function () {
        return prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(function (inline) {
          return Location.after(inline);
        });
      }, Optional.none);
    };
    var isValidLocation = function (location) {
      return isRtl(getElement(location)) === false;
    };
    var readLocation = function (isInlineTarget, rootNode, pos) {
      var location = evaluateUntil([
        before,
        start$1,
        end,
        after
      ], [
        isInlineTarget,
        rootNode,
        pos
      ]);
      return location.filter(isValidLocation);
    };
    var getElement = function (location) {
      return location.fold(identity, identity, identity, identity);
    };
    var getName = function (location) {
      return location.fold(constant('before'), constant('start'), constant('end'), constant('after'));
    };
    var outside = function (location) {
      return location.fold(Location.before, Location.before, Location.after, Location.after);
    };
    var inside = function (location) {
      return location.fold(Location.start, Location.start, Location.end, Location.end);
    };
    var isEq = function (location1, location2) {
      return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    };
    var betweenInlines = function (forward, isInlineTarget, rootNode, from, to, location) {
      return lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), function (fromInline, toInline) {
        if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
          return Location.after(forward ? fromInline : toInline);
        } else {
          return location;
        }
      }).getOr(location);
    };
    var skipNoMovement = function (fromLocation, toLocation) {
      return fromLocation.fold(always, function (fromLocation) {
        return !isEq(fromLocation, toLocation);
      });
    };
    var findLocationTraverse = function (forward, isInlineTarget, rootNode, fromLocation, pos) {
      var from = normalizePosition(forward, pos);
      var to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));
      var location = to.fold(function () {
        return fromLocation.map(outside);
      }, function (to) {
        return readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation));
      });
      return location.filter(isValidLocation);
    };
    var findLocationSimple = function (forward, location) {
      if (forward) {
        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
      } else {
        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
      }
    };
    var findLocation$1 = function (forward, isInlineTarget, rootNode, pos) {
      var from = normalizePosition(forward, pos);
      var fromLocation = readLocation(isInlineTarget, rootNode, from);
      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(function () {
        return findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos);
      });
    };
    curry(findLocation$1, false);
    curry(findLocation$1, true);

    var hasSelectionModifyApi = function (editor) {
      return isFunction(editor.selection.getSel().modify);
    };
    var moveRel = function (forward, selection, pos) {
      var delta = forward ? 1 : -1;
      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
      return true;
    };
    var moveByWord = function (forward, editor) {
      var rng = editor.selection.getRng();
      var pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      if (!hasSelectionModifyApi(editor)) {
        return false;
      } else if (forward && isBeforeInline(pos)) {
        return moveRel(true, editor.selection, pos);
      } else if (!forward && isAfterInline(pos)) {
        return moveRel(false, editor.selection, pos);
      } else {
        return false;
      }
    };

    var BreakType;
    (function (BreakType) {
      BreakType[BreakType['Br'] = 0] = 'Br';
      BreakType[BreakType['Block'] = 1] = 'Block';
      BreakType[BreakType['Wrap'] = 2] = 'Wrap';
      BreakType[BreakType['Eol'] = 3] = 'Eol';
    }(BreakType || (BreakType = {})));
    var flip = function (direction, positions) {
      return direction === HDirection.Backwards ? reverse(positions) : positions;
    };
    var walk = function (direction, caretWalker, pos) {
      return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
    };
    var getBreakType = function (scope, direction, currentPos, nextPos) {
      if (isBr$5(nextPos.getNode(direction === HDirection.Forwards))) {
        return BreakType.Br;
      } else if (isInSameBlock(currentPos, nextPos) === false) {
        return BreakType.Block;
      } else {
        return BreakType.Wrap;
      }
    };
    var getPositionsUntil = function (predicate, direction, scope, start) {
      var caretWalker = CaretWalker(scope);
      var currentPos = start;
      var positions = [];
      while (currentPos) {
        var nextPos = walk(direction, caretWalker, currentPos);
        if (!nextPos) {
          break;
        }
        if (isBr$5(nextPos.getNode(false))) {
          if (direction === HDirection.Forwards) {
            return {
              positions: flip(direction, positions).concat([nextPos]),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          } else {
            return {
              positions: flip(direction, positions),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          }
        }
        if (!nextPos.isVisible()) {
          currentPos = nextPos;
          continue;
        }
        if (predicate(currentPos, nextPos)) {
          var breakType = getBreakType(scope, direction, currentPos, nextPos);
          return {
            positions: flip(direction, positions),
            breakType: breakType,
            breakAt: Optional.some(nextPos)
          };
        }
        positions.push(nextPos);
        currentPos = nextPos;
      }
      return {
        positions: flip(direction, positions),
        breakType: BreakType.Eol,
        breakAt: Optional.none()
      };
    };
    var getAdjacentLinePositions = function (direction, getPositionsUntilBreak, scope, start) {
      return getPositionsUntilBreak(scope, start).breakAt.map(function (pos) {
        var positions = getPositionsUntilBreak(scope, pos).positions;
        return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
      }).getOr([]);
    };
    var findClosestHorizontalPositionFromPoint = function (positions, x) {
      return foldl(positions, function (acc, newPos) {
        return acc.fold(function () {
          return Optional.some(newPos);
        }, function (lastPos) {
          return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function (lastRect, newRect) {
            var lastDist = Math.abs(x - lastRect.left);
            var newDist = Math.abs(x - newRect.left);
            return newDist <= lastDist ? newPos : lastPos;
          }).or(acc);
        });
      }, Optional.none());
    };
    var findClosestHorizontalPosition = function (positions, pos) {
      return head(pos.getClientRects()).bind(function (targetRect) {
        return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
      });
    };
    var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    var isAtFirstLine = function (scope, pos) {
      return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    };
    var isAtLastLine = function (scope, pos) {
      return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    };
    var getFirstLinePositions = function (scope) {
      return firstPositionIn(scope).map(function (pos) {
        return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
      }).getOr([]);
    };
    var getLastLinePositions = function (scope) {
      return lastPositionIn(scope).map(function (pos) {
        return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
      }).getOr([]);
    };

    var getNodeClientRects = function (node) {
      var toArrayWithNode = function (clientRects) {
        return map$3(clientRects, function (rect) {
          var clientRect = clone(rect);
          clientRect.node = node;
          return clientRect;
        });
      };
      if (isElement$5(node)) {
        return toArrayWithNode(node.getClientRects());
      }
      if (isText$7(node)) {
        var rng = node.ownerDocument.createRange();
        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);
        return toArrayWithNode(rng.getClientRects());
      }
    };
    var getClientRects = function (nodes) {
      return bind(nodes, getNodeClientRects);
    };

    var VDirection;
    (function (VDirection) {
      VDirection[VDirection['Up'] = -1] = 'Up';
      VDirection[VDirection['Down'] = 1] = 'Down';
    }(VDirection || (VDirection = {})));
    var findUntil = function (direction, root, predicateFn, node) {
      while (node = findNode$1(node, direction, isEditableCaretCandidate$1, root)) {
        if (predicateFn(node)) {
          return;
        }
      }
    };
    var walkUntil$1 = function (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
      var line = 0;
      var result = [];
      var add = function (node) {
        var clientRects = getClientRects([node]);
        if (direction === -1) {
          clientRects = clientRects.reverse();
        }
        for (var i = 0; i < clientRects.length; i++) {
          var clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }
          if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {
            line++;
          }
          clientRect.line = line;
          if (predicateFn(clientRect)) {
            return true;
          }
          result.push(clientRect);
        }
      };
      var targetClientRect = last$1(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }
      var node = caretPosition.getNode();
      add(node);
      findUntil(direction, root, add, node);
      return result;
    };
    var aboveLineNumber = function (lineNumber, clientRect) {
      return clientRect.line > lineNumber;
    };
    var isLineNumber = function (lineNumber, clientRect) {
      return clientRect.line === lineNumber;
    };
    var upUntil = curry(walkUntil$1, VDirection.Up, isAbove$1, isBelow$1);
    var downUntil = curry(walkUntil$1, VDirection.Down, isBelow$1, isAbove$1);
    var positionsUntil = function (direction, root, predicateFn, node) {
      var caretWalker = CaretWalker(root);
      var walkFn;
      var isBelowFn;
      var isAboveFn;
      var caretPosition;
      var result = [];
      var line = 0;
      var getClientRect = function (caretPosition) {
        if (direction === 1) {
          return last$1(caretPosition.getClientRects());
        }
        return last$1(caretPosition.getClientRects());
      };
      if (direction === 1) {
        walkFn = caretWalker.next;
        isBelowFn = isBelow$1;
        isAboveFn = isAbove$1;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = isAbove$1;
        isAboveFn = isBelow$1;
        caretPosition = CaretPosition.before(node);
      }
      var targetClientRect = getClientRect(caretPosition);
      do {
        if (!caretPosition.isVisible()) {
          continue;
        }
        var rect = getClientRect(caretPosition);
        if (isAboveFn(rect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isBelowFn(rect, last$1(result))) {
          line++;
        }
        var clientRect = clone(rect);
        clientRect.position = caretPosition;
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return result;
        }
        result.push(clientRect);
      } while (caretPosition = walkFn(caretPosition));
      return result;
    };
    var isAboveLine = function (lineNumber) {
      return function (clientRect) {
        return aboveLineNumber(lineNumber, clientRect);
      };
    };
    var isLine = function (lineNumber) {
      return function (clientRect) {
        return isLineNumber(lineNumber, clientRect);
      };
    };

    var isContentEditableFalse$3 = isContentEditableFalse$b;
    var findNode = findNode$1;
    var distanceToRectLeft = function (clientRect, clientX) {
      return Math.abs(clientRect.left - clientX);
    };
    var distanceToRectRight = function (clientRect, clientX) {
      return Math.abs(clientRect.right - clientX);
    };
    var isInsideX = function (clientX, clientRect) {
      return clientX >= clientRect.left && clientX <= clientRect.right;
    };
    var isInsideY = function (clientY, clientRect) {
      return clientY >= clientRect.top && clientY <= clientRect.bottom;
    };
    var isNodeClientRect = function (rect) {
      return hasNonNullableKey(rect, 'node');
    };
    var findClosestClientRect = function (clientRects, clientX, allowInside) {
      if (allowInside === void 0) {
        allowInside = always;
      }
      return reduce(clientRects, function (oldClientRect, clientRect) {
        if (isInsideX(clientX, clientRect)) {
          return allowInside(clientRect) ? clientRect : oldClientRect;
        }
        if (isInsideX(clientX, oldClientRect)) {
          return allowInside(oldClientRect) ? oldClientRect : clientRect;
        }
        var oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
        var newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
        if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$3(clientRect.node)) {
          return clientRect;
        }
        if (newDistance < oldDistance) {
          return clientRect;
        }
        return oldClientRect;
      });
    };
    var walkUntil = function (direction, root, predicateFn, startNode, includeChildren) {
      var node = findNode(startNode, direction, isEditableCaretCandidate$1, root, !includeChildren);
      do {
        if (!node || predicateFn(node)) {
          return;
        }
      } while (node = findNode(node, direction, isEditableCaretCandidate$1, root));
    };
    var findLineNodeRects = function (root, targetNodeRect, includeChildren) {
      if (includeChildren === void 0) {
        includeChildren = true;
      }
      var clientRects = [];
      var collect = function (checkPosFn, node) {
        var lineRects = filter$4(getClientRects([node]), function (clientRect) {
          return !checkPosFn(clientRect, targetNodeRect);
        });
        clientRects = clientRects.concat(lineRects);
        return lineRects.length === 0;
      };
      clientRects.push(targetNodeRect);
      walkUntil(VDirection.Up, root, curry(collect, isAbove$1), targetNodeRect.node, includeChildren);
      walkUntil(VDirection.Down, root, curry(collect, isBelow$1), targetNodeRect.node, includeChildren);
      return clientRects;
    };
    var getFakeCaretTargets = function (root) {
      return filter$4(from(root.getElementsByTagName('*')), isFakeCaretTarget);
    };
    var caretInfo = function (clientRect, clientX) {
      return {
        node: clientRect.node,
        before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
      };
    };
    var closestFakeCaret = function (root, clientX, clientY) {
      var fakeTargetNodeRects = getClientRects(getFakeCaretTargets(root));
      var targetNodeRects = filter$4(fakeTargetNodeRects, curry(isInsideY, clientY));
      var checkInside = function (clientRect) {
        return !isTable$3(clientRect.node) && !isMedia$2(clientRect.node);
      };
      var closestNodeRect = findClosestClientRect(targetNodeRects, clientX, checkInside);
      if (closestNodeRect) {
        var includeChildren = checkInside(closestNodeRect);
        closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect, includeChildren), clientX, checkInside);
        if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
          return caretInfo(closestNodeRect, clientX);
        }
      }
      return null;
    };

    var moveToRange = function (editor, rng) {
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, editor.selection.getRng());
    };
    var renderRangeCaretOpt = function (editor, range, scrollIntoView) {
      return Optional.some(renderRangeCaret(editor, range, scrollIntoView));
    };
    var moveHorizontally = function (editor, direction, range, isBefore, isAfter, isElement) {
      var forwards = direction === HDirection.Forwards;
      var caretWalker = CaretWalker(editor.getBody());
      var getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
      var isBeforeFn = forwards ? isBefore : isAfter;
      if (!range.collapsed) {
        var node = getSelectedNode(range);
        if (isElement(node)) {
          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
        }
      }
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      if (isBeforeFn(caretPosition)) {
        return selectNode(editor, caretPosition.getNode(!forwards));
      }
      var nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));
      var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
      if (!nextCaretPosition) {
        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
      }
      if (isBeforeFn(nextCaretPosition)) {
        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
      }
      var peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
        }
      }
      if (rangeIsInContainerBlock) {
        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
      }
      return Optional.none();
    };
    var moveVertically = function (editor, direction, range, isBefore, isAfter, isElement) {
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      var caretClientRect = last$1(caretPosition.getClientRects());
      var forwards = direction === VDirection.Down;
      if (!caretClientRect) {
        return Optional.none();
      }
      var walkerFn = forwards ? downUntil : upUntil;
      var linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
      var nextLinePositions = filter$4(linePositions, isLine(1));
      var clientX = caretClientRect.left;
      var nextLineRect = findClosestClientRect(nextLinePositions, clientX);
      if (nextLineRect && isElement(nextLineRect.node)) {
        var dist1 = Math.abs(clientX - nextLineRect.left);
        var dist2 = Math.abs(clientX - nextLineRect.right);
        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
      }
      var currentNode;
      if (isBefore(caretPosition)) {
        currentNode = caretPosition.getNode();
      } else if (isAfter(caretPosition)) {
        currentNode = caretPosition.getNode(true);
      } else {
        currentNode = getSelectedNode(range);
      }
      if (currentNode) {
        var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);
        var closestNextLineRect = findClosestClientRect(filter$4(caretPositions, isLine(1)), clientX);
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
        closestNextLineRect = last$1(filter$4(caretPositions, isLine(0)));
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
      }
      if (nextLinePositions.length === 0) {
        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(function (pos) {
          return renderRangeCaret(editor, pos.toRange(), false);
        });
      }
      return Optional.none();
    };
    var getLineEndPoint = function (editor, forward) {
      var rng = editor.selection.getRng();
      var body = editor.getBody();
      if (forward) {
        var from = CaretPosition.fromRangeEnd(rng);
        var result = getPositionsUntilNextLine(body, from);
        return last$2(result.positions);
      } else {
        var from = CaretPosition.fromRangeStart(rng);
        var result = getPositionsUntilPreviousLine(body, from);
        return head(result.positions);
      }
    };
    var moveToLineEndPoint$3 = function (editor, forward, isElementPosition) {
      return getLineEndPoint(editor, forward).filter(isElementPosition).exists(function (pos) {
        editor.selection.setRng(pos.toRange());
        return true;
      });
    };

    var setCaretPosition = function (editor, pos) {
      var rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };
    var setSelected = function (state, elm) {
      if (state) {
        elm.setAttribute('data-mce-selected', 'inline-boundary');
      } else {
        elm.removeAttribute('data-mce-selected');
      }
    };
    var renderCaretLocation = function (editor, caret, location) {
      return renderCaret(caret, location).map(function (pos) {
        setCaretPosition(editor, pos);
        return location;
      });
    };
    var findLocation = function (editor, caret, forward) {
      var rootNode = editor.getBody();
      var from = CaretPosition.fromRangeStart(editor.selection.getRng());
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
      return location.bind(function (location) {
        return renderCaretLocation(editor, caret, location);
      });
    };
    var toggleInlines = function (isInlineTarget, dom, elms) {
      var inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected="inline-boundary"]'), function (e) {
        return e.dom;
      });
      var selectedInlines = filter$4(inlineBoundaries, isInlineTarget);
      var targetInlines = filter$4(elms, isInlineTarget);
      each$k(difference(selectedInlines, targetInlines), curry(setSelected, false));
      each$k(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    var safeRemoveCaretContainer = function (editor, caret) {
      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {
        var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {
          setCaretPosition(editor, removeAndReposition(caret.get(), pos));
          caret.set(null);
        }
      }
    };
    var renderInsideInlineCaret = function (isInlineTarget, editor, caret, elms) {
      if (editor.selection.isCollapsed()) {
        var inlines = filter$4(elms, isInlineTarget);
        each$k(inlines, function (_inline) {
          var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          readLocation(isInlineTarget, editor.getBody(), pos).bind(function (location) {
            return renderCaretLocation(editor, caret, location);
          });
        });
      }
    };
    var move$2 = function (editor, caret, forward) {
      return isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    };
    var moveWord = function (forward, editor, _caret) {
      return isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    };
    var setupSelectedState = function (editor) {
      var caret = Cell(null);
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.on('NodeChange', function (e) {
        if (isInlineBoundariesEnabled(editor) && !(Env.browser.isIE() && e.initial)) {
          toggleInlines(isInlineTarget$1, editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
        }
      });
      return caret;
    };
    var moveNextWord = curry(moveWord, true);
    var movePrevWord = curry(moveWord, false);
    var moveToLineEndPoint$2 = function (editor, forward, caret) {
      if (isInlineBoundariesEnabled(editor)) {
        var linePoint = getLineEndPoint(editor, forward).getOrThunk(function () {
          var rng = editor.selection.getRng();
          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        });
        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(function (loc) {
          var outsideLoc = outside(loc);
          return renderCaret(caret, outsideLoc).exists(function (pos) {
            setCaretPosition(editor, pos);
            return true;
          });
        });
      } else {
        return false;
      }
    };

    var rangeFromPositions = function (from, to) {
      var range = document.createRange();
      range.setStart(from.container(), from.offset());
      range.setEnd(to.container(), to.offset());
      return range;
    };
    var hasOnlyTwoOrLessPositionsLeft = function (elm) {
      return lift2(firstPositionIn(elm), lastPositionIn(elm), function (firstPos, lastPos) {
        var normalizedFirstPos = normalizePosition(true, firstPos);
        var normalizedLastPos = normalizePosition(false, lastPos);
        return nextPosition(elm, normalizedFirstPos).forall(function (pos) {
          return pos.isEqual(normalizedLastPos);
        });
      }).getOr(true);
    };
    var setCaretLocation = function (editor, caret) {
      return function (location) {
        return renderCaret(caret, location).exists(function (pos) {
          setCaretPosition(editor, pos);
          return true;
        });
      };
    };
    var deleteFromTo = function (editor, caret, from, to) {
      var rootNode = editor.getBody();
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.undoManager.ignore(function () {
        editor.selection.setRng(rangeFromPositions(from, to));
        editor.execCommand('Delete');
        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).map(setCaretLocation(editor, caret));
      });
      editor.nodeChanged();
    };
    var rescope = function (rootNode, node) {
      var parentBlock = getParentBlock$2(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    var backspaceDeleteCollapsed = function (editor, caret, forward, from) {
      var rootNode = rescope(editor.getBody(), from.container());
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var fromLocation = readLocation(isInlineTarget$1, rootNode, from);
      return fromLocation.bind(function (location) {
        if (forward) {
          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
        } else {
          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
        }
      }).map(setCaretLocation(editor, caret)).getOrThunk(function () {
        var toPosition = navigate(forward, rootNode, from);
        var toLocation = toPosition.bind(function (pos) {
          return readLocation(isInlineTarget$1, rootNode, pos);
        });
        return lift2(fromLocation, toLocation, function () {
          return findRootInline(isInlineTarget$1, rootNode, from).exists(function (elm) {
            if (hasOnlyTwoOrLessPositionsLeft(elm)) {
              deleteElement$2(editor, forward, SugarElement.fromDom(elm));
              return true;
            } else {
              return false;
            }
          });
        }).orThunk(function () {
          return toLocation.bind(function (_) {
            return toPosition.map(function (to) {
              if (forward) {
                deleteFromTo(editor, caret, from, to);
              } else {
                deleteFromTo(editor, caret, to, from);
              }
              return true;
            });
          });
        }).getOr(false);
      });
    };
    var backspaceDelete$3 = function (editor, caret, forward) {
      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
        var from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return backspaceDeleteCollapsed(editor, caret, forward, from);
      }
      return false;
    };

    var getParentInlines = function (rootElm, startElm) {
      var parents = parentsAndSelf(startElm, rootElm);
      return findIndex$2(parents, isBlock$2).fold(constant(parents), function (index) {
        return parents.slice(0, index);
      });
    };
    var hasOnlyOneChild = function (elm) {
      return childNodesCount(elm) === 1;
    };
    var deleteLastPosition = function (forward, editor, target, parentInlines) {
      var isFormatElement$1 = curry(isFormatElement, editor);
      var formatNodes = map$3(filter$4(parentInlines, isFormatElement$1), function (elm) {
        return elm.dom;
      });
      if (formatNodes.length === 0) {
        deleteElement$2(editor, forward, target);
      } else {
        var pos = replaceWithCaretFormat(target.dom, formatNodes);
        editor.selection.setRng(pos.toRange());
      }
    };
    var deleteCaret$1 = function (editor, forward) {
      var rootElm = SugarElement.fromDom(editor.getBody());
      var startElm = SugarElement.fromDom(editor.selection.getStart());
      var parentInlines = filter$4(getParentInlines(rootElm, startElm), hasOnlyOneChild);
      return last$2(parentInlines).exists(function (target) {
        var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
          deleteLastPosition(forward, editor, target, parentInlines);
          return true;
        } else {
          return false;
        }
      });
    };
    var backspaceDelete$2 = function (editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
    };

    var deleteElement = function (editor, forward, element) {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement$2(editor, forward, SugarElement.fromDom(element));
      return true;
    };
    var deleteCaret = function (editor, forward) {
      var isNearMedia = forward ? isBeforeMedia : isAfterMedia;
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
      if (isNearMedia(fromPos)) {
        return deleteElement(editor, forward, fromPos.getNode(!forward));
      } else {
        return Optional.from(normalizePosition(forward, fromPos)).filter(function (pos) {
          return isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos);
        }).exists(function (pos) {
          return deleteElement(editor, forward, pos.getNode(!forward));
        });
      }
    };
    var deleteRange = function (editor, forward) {
      var selectedNode = editor.selection.getNode();
      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : false;
    };
    var backspaceDelete$1 = function (editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);
    };

    var isEditable = function (target) {
      return closest$3(target, function (elm) {
        return isContentEditableTrue$4(elm.dom) || isContentEditableFalse$b(elm.dom);
      }).exists(function (elm) {
        return isContentEditableTrue$4(elm.dom);
      });
    };
    var parseIndentValue = function (value) {
      var number = parseInt(value, 10);
      return isNaN(number) ? 0 : number;
    };
    var getIndentStyleName = function (useMargin, element) {
      var indentStyleName = useMargin || isTable$2(element) ? 'margin' : 'padding';
      var suffix = get$5(element, 'direction') === 'rtl' ? '-right' : '-left';
      return indentStyleName + suffix;
    };
    var indentElement = function (dom, command, useMargin, value, unit, element) {
      var indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
      if (command === 'outdent') {
        var styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);
        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
      } else {
        var styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;
        dom.setStyle(element, indentStyleName, styleValue);
      }
    };
    var validateBlocks = function (editor, blocks) {
      return forall(blocks, function (block) {
        var indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
        var intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
        var contentEditable = editor.dom.getContentEditable(block.dom);
        return contentEditable !== 'false' && intentValue > 0;
      });
    };
    var canOutdent = function (editor) {
      var blocks = getBlocksToIndent(editor);
      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
    };
    var isListComponent = function (el) {
      return isList(el) || isListItem(el);
    };
    var parentIsListComponent = function (el) {
      return parent(el).exists(isListComponent);
    };
    var getBlocksToIndent = function (editor) {
      return filter$4(fromDom$1(editor.selection.getSelectedBlocks()), function (el) {
        return !isListComponent(el) && !parentIsListComponent(el) && isEditable(el);
      });
    };
    var handle = function (editor, command) {
      var dom = editor.dom, selection = editor.selection, formatter = editor.formatter;
      var indentation = getIndentation(editor);
      var indentUnit = /[a-z%]+$/i.exec(indentation)[0];
      var indentValue = parseInt(indentation, 10);
      var useMargin = shouldIndentUseMargin(editor);
      var forcedRootBlock = getForcedRootBlock(editor);
      if (!editor.queryCommandState('InsertUnorderedList') && !editor.queryCommandState('InsertOrderedList')) {
        if (forcedRootBlock === '' && !dom.getParent(selection.getNode(), dom.isBlock)) {
          formatter.apply('div');
        }
      }
      each$k(getBlocksToIndent(editor), function (block) {
        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);
      });
    };

    var backspaceDelete = function (editor, _forward) {
      if (editor.selection.isCollapsed() && canOutdent(editor)) {
        var dom = editor.dom;
        var rng = editor.selection.getRng();
        var pos = CaretPosition.fromRangeStart(rng);
        var block = dom.getParent(rng.startContainer, dom.isBlock);
        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
          handle(editor, 'outdent');
          return true;
        }
      }
      return false;
    };

    var nativeCommand = function (editor, command) {
      editor.getDoc().execCommand(command, false, null);
    };
    var deleteCommand = function (editor, caret) {
      if (backspaceDelete(editor)) {
        return;
      } else if (backspaceDelete$5(editor, false)) {
        return;
      } else if (backspaceDelete$6(editor, false)) {
        return;
      } else if (backspaceDelete$3(editor, caret, false)) {
        return;
      } else if (backspaceDelete$8(editor, false)) {
        return;
      } else if (backspaceDelete$9(editor)) {
        return;
      } else if (backspaceDelete$4(editor, false)) {
        return;
      } else if (backspaceDelete$1(editor, false)) {
        return;
      } else if (backspaceDelete$7(editor)) {
        return;
      } else if (backspaceDelete$2(editor, false)) {
        return;
      } else {
        nativeCommand(editor, 'Delete');
        paddEmptyBody(editor);
      }
    };
    var forwardDeleteCommand = function (editor, caret) {
      if (backspaceDelete$5(editor, true)) {
        return;
      } else if (backspaceDelete$6(editor, true)) {
        return;
      } else if (backspaceDelete$3(editor, caret, true)) {
        return;
      } else if (backspaceDelete$8(editor, true)) {
        return;
      } else if (backspaceDelete$9(editor)) {
        return;
      } else if (backspaceDelete$4(editor, true)) {
        return;
      } else if (backspaceDelete$1(editor, true)) {
        return;
      } else if (backspaceDelete$7(editor)) {
        return;
      } else if (backspaceDelete$2(editor, true)) {
        return;
      } else {
        nativeCommand(editor, 'ForwardDelete');
      }
    };
    var setup$f = function (editor, caret) {
      editor.addCommand('delete', function () {
        deleteCommand(editor, caret);
      });
      editor.addCommand('forwardDelete', function () {
        forwardDeleteCommand(editor, caret);
      });
    };

    var SIGNIFICANT_MOVE = 5;
    var LONGPRESS_DELAY = 400;
    var getTouch = function (event) {
      if (event.touches === undefined || event.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(event.touches[0]);
    };
    var isFarEnough = function (touch, data) {
      var distX = Math.abs(touch.clientX - data.x);
      var distY = Math.abs(touch.clientY - data.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    var setup$e = function (editor) {
      var startData = value();
      var longpressFired = Cell(false);
      var debounceLongpress = last(function (e) {
        editor.fire('longpress', __assign(__assign({}, e), { type: 'longpress' }));
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      editor.on('touchstart', function (e) {
        getTouch(e).each(function (touch) {
          debounceLongpress.cancel();
          var data = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(data);
        });
      }, true);
      editor.on('touchmove', function (e) {
        debounceLongpress.cancel();
        getTouch(e).each(function (touch) {
          startData.on(function (data) {
            if (isFarEnough(touch, data)) {
              startData.clear();
              longpressFired.set(false);
              editor.fire('longpresscancel');
            }
          });
        });
      }, true);
      editor.on('touchend touchcancel', function (e) {
        debounceLongpress.cancel();
        if (e.type === 'touchcancel') {
          return;
        }
        startData.get().filter(function (data) {
          return data.target.isEqualNode(e.target);
        }).each(function () {
          if (longpressFired.get()) {
            e.preventDefault();
          } else {
            editor.fire('tap', __assign(__assign({}, e), { type: 'tap' }));
          }
        });
      }, true);
    };

    var isBlockElement = function (blockElements, node) {
      return has$2(blockElements, node.nodeName);
    };
    var isValidTarget = function (blockElements, node) {
      if (isText$7(node)) {
        return true;
      } else if (isElement$5(node)) {
        return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);
      } else {
        return false;
      }
    };
    var hasBlockParent = function (blockElements, root, node) {
      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), function (elm) {
        return isBlockElement(blockElements, elm.dom);
      });
    };
    var shouldRemoveTextNode = function (blockElements, node) {
      if (isText$7(node)) {
        if (node.nodeValue.length === 0) {
          return true;
        } else if (/^\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
          return true;
        }
      }
      return false;
    };
    var addRootBlocks = function (editor) {
      var dom = editor.dom, selection = editor.selection;
      var schema = editor.schema, blockElements = schema.getBlockElements();
      var node = selection.getStart();
      var rootNode = editor.getBody();
      var rootBlockNode, tempNode, wrapped;
      var forcedRootBlock = getForcedRootBlock(editor);
      if (!node || !isElement$5(node) || !forcedRootBlock) {
        return;
      }
      var rootNodeName = rootNode.nodeName.toLowerCase();
      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {
        return;
      }
      var rng = selection.getRng();
      var startContainer = rng.startContainer;
      var startOffset = rng.startOffset;
      var endContainer = rng.endContainer;
      var endOffset = rng.endOffset;
      var restoreSelection = hasFocus(editor);
      node = rootNode.firstChild;
      while (node) {
        if (isValidTarget(blockElements, node)) {
          if (shouldRemoveTextNode(blockElements, node)) {
            tempNode = node;
            node = node.nextSibling;
            dom.remove(tempNode);
            continue;
          }
          if (!rootBlockNode) {
            rootBlockNode = dom.create(forcedRootBlock, getForcedRootBlockAttrs(editor));
            node.parentNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }
          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }
      if (wrapped && restoreSelection) {
        rng.setStart(startContainer, startOffset);
        rng.setEnd(endContainer, endOffset);
        selection.setRng(rng);
        editor.nodeChanged();
      }
    };
    var setup$d = function (editor) {
      if (getForcedRootBlock(editor)) {
        editor.on('NodeChange', curry(addRootBlocks, editor));
      }
    };

    var findBlockCaretContainer = function (editor) {
      return descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(function (elm) {
        return elm.dom;
      }).getOrNull();
    };
    var removeIeControlRect = function (editor) {
      editor.selection.setRng(editor.selection.getRng());
    };
    var showBlockCaretContainer = function (editor, blockCaretContainer) {
      if (blockCaretContainer.hasAttribute('data-mce-caret')) {
        showCaretContainerBlock(blockCaretContainer);
        removeIeControlRect(editor);
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };
    var handleBlockContainer = function (editor, e) {
      var blockCaretContainer = findBlockCaretContainer(editor);
      if (!blockCaretContainer) {
        return;
      }
      if (e.type === 'compositionstart') {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(editor, blockCaretContainer);
        return;
      }
      if (hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
        editor.undoManager.add();
      }
    };
    var setup$c = function (editor) {
      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
    };

    var isContentEditableFalse$2 = isContentEditableFalse$b;
    var moveToCeFalseHorizontally = function (direction, editor, range) {
      return moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$2);
    };
    var moveToCeFalseVertically = function (direction, editor, range) {
      var isBefore = function (caretPosition) {
        return isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
      };
      var isAfter = function (caretPosition) {
        return isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
      };
      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$2);
    };
    var createTextBlock = function (editor) {
      var textBlock = editor.dom.create(getForcedRootBlock(editor));
      if (!Env.ie || Env.ie >= 11) {
        textBlock.innerHTML = '<br data-mce-bogus="1">';
      }
      return textBlock;
    };
    var exitPreBlock = function (editor, direction, range) {
      var caretWalker = CaretWalker(editor.getBody());
      var getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
      if (range.collapsed && hasForcedRootBlock(editor)) {
        var pre = editor.dom.getParent(range.startContainer, 'PRE');
        if (!pre) {
          return;
        }
        var caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));
        if (!caretPos) {
          var newBlock = createTextBlock(editor);
          if (direction === 1) {
            editor.$(pre).after(newBlock);
          } else {
            editor.$(pre).before(newBlock);
          }
          editor.selection.select(newBlock, true);
          editor.selection.collapse();
        }
      }
    };
    var getHorizontalRange = function (editor, forward) {
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var range = editor.selection.getRng();
      return moveToCeFalseHorizontally(direction, editor, range).orThunk(function () {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    var getVerticalRange = function (editor, down) {
      var direction = down ? 1 : -1;
      var range = editor.selection.getRng();
      return moveToCeFalseVertically(direction, editor, range).orThunk(function () {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    var moveH$2 = function (editor, forward) {
      return getHorizontalRange(editor, forward).exists(function (newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveV$3 = function (editor, down) {
      return getVerticalRange(editor, down).exists(function (newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveToLineEndPoint$1 = function (editor, forward) {
      var isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
      return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };

    var isTarget = function (node) {
      return contains$3(['figcaption'], name(node));
    };
    var rangeBefore = function (target) {
      var rng = document.createRange();
      rng.setStartBefore(target.dom);
      rng.setEndBefore(target.dom);
      return rng;
    };
    var insertElement = function (root, elm, forward) {
      if (forward) {
        append$1(root, elm);
      } else {
        prepend(root, elm);
      }
    };
    var insertBr = function (root, forward) {
      var br = SugarElement.fromTag('br');
      insertElement(root, br, forward);
      return rangeBefore(br);
    };
    var insertBlock = function (root, forward, blockName, attrs) {
      var block = SugarElement.fromTag(blockName);
      var br = SugarElement.fromTag('br');
      setAll$1(block, attrs);
      append$1(block, br);
      insertElement(root, block, forward);
      return rangeBefore(br);
    };
    var insertEmptyLine = function (root, rootBlockName, attrs, forward) {
      if (rootBlockName === '') {
        return insertBr(root, forward);
      } else {
        return insertBlock(root, forward, rootBlockName, attrs);
      }
    };
    var getClosestTargetBlock = function (pos, root) {
      var isRoot = curry(eq, root);
      return closest$3(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);
    };
    var isAtFirstOrLastLine = function (root, forward, pos) {
      return forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    };
    var moveCaretToNewEmptyLine = function (editor, forward) {
      var root = SugarElement.fromDom(editor.getBody());
      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      var rootBlock = getForcedRootBlock(editor);
      var rootBlockAttrs = getForcedRootBlockAttrs(editor);
      return getClosestTargetBlock(pos, root).exists(function () {
        if (isAtFirstOrLastLine(root, forward, pos)) {
          var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);
          editor.selection.setRng(rng);
          return true;
        } else {
          return false;
        }
      });
    };
    var moveV$2 = function (editor, forward) {
      if (editor.selection.isCollapsed()) {
        return moveCaretToNewEmptyLine(editor, forward);
      } else {
        return false;
      }
    };

    var defaultPatterns = function (patterns) {
      return map$3(patterns, function (pattern) {
        return __assign({
          shiftKey: false,
          altKey: false,
          ctrlKey: false,
          metaKey: false,
          keyCode: 0,
          action: noop
        }, pattern);
      });
    };
    var matchesEvent = function (pattern, evt) {
      return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
    };
    var match$1 = function (patterns, evt) {
      return bind(defaultPatterns(patterns), function (pattern) {
        return matchesEvent(pattern, evt) ? [pattern] : [];
      });
    };
    var action = function (f) {
      var x = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        x[_i - 1] = arguments[_i];
      }
      return function () {
        return f.apply(null, x);
      };
    };
    var execute = function (patterns, evt) {
      return find$3(match$1(patterns, evt), function (pattern) {
        return pattern.action();
      });
    };

    var moveH$1 = function (editor, forward) {
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var range = editor.selection.getRng();
      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(function (newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveV$1 = function (editor, down) {
      var direction = down ? 1 : -1;
      var range = editor.selection.getRng();
      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(function (newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveToLineEndPoint = function (editor, forward) {
      var isNearMedia = forward ? isAfterMedia : isBeforeMedia;
      return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };

    var deflate = function (rect, delta) {
      return {
        left: rect.left - delta,
        top: rect.top - delta,
        right: rect.right + delta * 2,
        bottom: rect.bottom + delta * 2,
        width: rect.width + delta,
        height: rect.height + delta
      };
    };
    var getCorners = function (getYAxisValue, tds) {
      return bind(tds, function (td) {
        var rect = deflate(clone(td.getBoundingClientRect()), -1);
        return [
          {
            x: rect.left,
            y: getYAxisValue(rect),
            cell: td
          },
          {
            x: rect.right,
            y: getYAxisValue(rect),
            cell: td
          }
        ];
      });
    };
    var findClosestCorner = function (corners, x, y) {
      return foldl(corners, function (acc, newCorner) {
        return acc.fold(function () {
          return Optional.some(newCorner);
        }, function (oldCorner) {
          var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
          var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
          return Optional.some(newDist < oldDist ? newCorner : oldCorner);
        });
      }, Optional.none());
    };
    var getClosestCell = function (getYAxisValue, isTargetCorner, table, x, y) {
      var cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(function (e) {
        return e.dom;
      });
      var corners = filter$4(getCorners(getYAxisValue, cells), function (corner) {
        return isTargetCorner(corner, y);
      });
      return findClosestCorner(corners, x, y).map(function (corner) {
        return corner.cell;
      });
    };
    var getBottomValue = function (rect) {
      return rect.bottom;
    };
    var getTopValue = function (rect) {
      return rect.top;
    };
    var isAbove = function (corner, y) {
      return corner.y < y;
    };
    var isBelow = function (corner, y) {
      return corner.y > y;
    };
    var getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    var getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    var findClosestPositionInAboveCell = function (table, pos) {
      return head(pos.getClientRects()).bind(function (rect) {
        return getClosestCellAbove(table, rect.left, rect.top);
      }).bind(function (cell) {
        return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
      });
    };
    var findClosestPositionInBelowCell = function (table, pos) {
      return last$2(pos.getClientRects()).bind(function (rect) {
        return getClosestCellBelow(table, rect.left, rect.top);
      }).bind(function (cell) {
        return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
      });
    };

    var hasNextBreak = function (getPositionsUntil, scope, lineInfo) {
      return lineInfo.breakAt.exists(function (breakPos) {
        return getPositionsUntil(scope, breakPos).breakAt.isSome();
      });
    };
    var startsWithWrapBreak = function (lineInfo) {
      return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    };
    var startsWithBrBreak = function (lineInfo) {
      return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    };
    var isAtTableCellLine = function (getPositionsUntil, scope, pos) {
      var lineInfo = getPositionsUntil(scope, pos);
      if (startsWithWrapBreak(lineInfo) || !isBr$5(pos.getNode()) && startsWithBrBreak(lineInfo)) {
        return !hasNextBreak(getPositionsUntil, scope, lineInfo);
      } else {
        return lineInfo.breakAt.isNone();
      }
    };
    var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    var isCaretAtStartOrEndOfTable = function (forward, rng, table) {
      var caretPos = CaretPosition.fromRangeStart(rng);
      return positionIn(!forward, table).exists(function (pos) {
        return pos.isEqual(caretPos);
      });
    };
    var navigateHorizontally = function (editor, forward, table, _td) {
      var rng = editor.selection.getRng();
      var direction = forward ? 1 : -1;
      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
        showCaret(direction, editor, table, !forward, false).each(function (newRng) {
          moveToRange(editor, newRng);
        });
        return true;
      }
      return false;
    };
    var getClosestAbovePosition = function (root, table, start) {
      return findClosestPositionInAboveCell(table, start).orThunk(function () {
        return head(start.getClientRects()).bind(function (rect) {
          return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left);
        });
      }).getOr(CaretPosition.before(table));
    };
    var getClosestBelowPosition = function (root, table, start) {
      return findClosestPositionInBelowCell(table, start).orThunk(function () {
        return head(start.getClientRects()).bind(function (rect) {
          return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left);
        });
      }).getOr(CaretPosition.after(table));
    };
    var getTable = function (previous, pos) {
      var node = pos.getNode(previous);
      return isElement$5(node) && node.nodeName === 'TABLE' ? Optional.some(node) : Optional.none();
    };
    var renderBlock = function (down, editor, table, pos) {
      var forcedRootBlock = getForcedRootBlock(editor);
      if (forcedRootBlock) {
        editor.undoManager.transact(function () {
          var element = SugarElement.fromTag(forcedRootBlock);
          setAll$1(element, getForcedRootBlockAttrs(editor));
          append$1(element, SugarElement.fromTag('br'));
          if (down) {
            after$3(SugarElement.fromDom(table), element);
          } else {
            before$4(SugarElement.fromDom(table), element);
          }
          var rng = editor.dom.createRng();
          rng.setStart(element.dom, 0);
          rng.setEnd(element.dom, 0);
          moveToRange(editor, rng);
        });
      } else {
        moveToRange(editor, pos.toRange());
      }
    };
    var moveCaret = function (editor, down, pos) {
      var table = down ? getTable(true, pos) : getTable(false, pos);
      var last = down === false;
      table.fold(function () {
        return moveToRange(editor, pos.toRange());
      }, function (table) {
        return positionIn(last, editor.getBody()).filter(function (lastPos) {
          return lastPos.isEqual(pos);
        }).fold(function () {
          return moveToRange(editor, pos.toRange());
        }, function (_) {
          return renderBlock(down, editor, table, pos);
        });
      });
    };
    var navigateVertically = function (editor, down, table, td) {
      var rng = editor.selection.getRng();
      var pos = CaretPosition.fromRangeStart(rng);
      var root = editor.getBody();
      if (!down && isAtFirstTableCellLine(td, pos)) {
        var newPos = getClosestAbovePosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else if (down && isAtLastTableCellLine(td, pos)) {
        var newPos = getClosestBelowPosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else {
        return false;
      }
    };
    var move$1 = function (editor, forward, mover) {
      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(function (td) {
        return Optional.from(editor.dom.getParent(td, 'table')).map(function (table) {
          return mover(editor, forward, table, td);
        });
      }).getOr(false);
    };
    var moveH = function (editor, forward) {
      return move$1(editor, forward, navigateHorizontally);
    };
    var moveV = function (editor, forward) {
      return move$1(editor, forward, navigateVertically);
    };

    var executeKeydownOverride$3 = function (editor, caret, evt) {
      var os = detect().os;
      execute([
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(move$2, editor, caret, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(move$2, editor, caret, false)
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !os.isOSX(),
          altKey: os.isOSX(),
          action: action(moveNextWord, editor, caret)
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !os.isOSX(),
          altKey: os.isOSX(),
          action: action(movePrevWord, editor, caret)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true)
        }
      ], evt).each(function (_) {
        evt.preventDefault();
      });
    };
    var setup$b = function (editor, caret) {
      editor.on('keydown', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$3(editor, caret, evt);
        }
      });
    };

    var executeKeydownOverride$2 = function (editor, caret, evt) {
      execute([
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor, false)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, caret, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, caret, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$9, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$1, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true)
        }
      ], evt).each(function (_) {
        evt.preventDefault();
      });
    };
    var executeKeyupOverride = function (editor, evt) {
      execute([
        {
          keyCode: VK.BACKSPACE,
          action: action(paddEmptyElement, editor)
        },
        {
          keyCode: VK.DELETE,
          action: action(paddEmptyElement, editor)
        }
      ], evt);
    };
    var setup$a = function (editor, caret) {
      editor.on('keydown', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$2(editor, caret, evt);
        }
      });
      editor.on('keyup', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeyupOverride(editor, evt);
        }
      });
    };

    var firstNonWhiteSpaceNodeSibling = function (node) {
      while (node) {
        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\r\n\s]/.test(node.data)) {
          return node;
        }
        node = node.nextSibling;
      }
    };
    var moveToCaretPosition = function (editor, root) {
      var node, lastNode = root;
      var dom = editor.dom;
      var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
      if (!root) {
        return;
      }
      if (/^(LI|DT|DD)$/.test(root.nodeName)) {
        var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
        }
      }
      var rng = dom.createRng();
      root.normalize();
      if (root.hasChildNodes()) {
        var walker = new DomTreeWalker(root, root);
        while (node = walker.current()) {
          if (isText$7(node)) {
            rng.setStart(node, 0);
            rng.setEnd(node, 0);
            break;
          }
          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
            rng.setStartBefore(node);
            rng.setEndBefore(node);
            break;
          }
          lastNode = node;
          node = walker.next();
        }
        if (!node) {
          rng.setStart(lastNode, 0);
          rng.setEnd(lastNode, 0);
        }
      } else {
        if (isBr$5(root)) {
          if (root.nextSibling && dom.isBlock(root.nextSibling)) {
            rng.setStartBefore(root);
            rng.setEndBefore(root);
          } else {
            rng.setStartAfter(root);
            rng.setEndAfter(root);
          }
        } else {
          rng.setStart(root, 0);
          rng.setEnd(root, 0);
        }
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    var getEditableRoot$1 = function (dom, node) {
      var root = dom.getRoot();
      var parent, editableRoot;
      parent = node;
      while (parent !== root && dom.getContentEditable(parent) !== 'false') {
        if (dom.getContentEditable(parent) === 'true') {
          editableRoot = parent;
        }
        parent = parent.parentNode;
      }
      return parent !== root ? editableRoot : root;
    };
    var getParentBlock = function (editor) {
      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    var getParentBlockName = function (editor) {
      return getParentBlock(editor).fold(constant(''), function (parentBlock) {
        return parentBlock.nodeName.toUpperCase();
      });
    };
    var isListItemParentBlock = function (editor) {
      return getParentBlock(editor).filter(function (elm) {
        return isListItem(SugarElement.fromDom(elm));
      }).isSome();
    };

    var hasFirstChild = function (elm, name) {
      return elm.firstChild && elm.firstChild.nodeName === name;
    };
    var isFirstChild = function (elm) {
      var _a;
      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    var hasParent = function (elm, parentName) {
      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
    };
    var isListBlock = function (elm) {
      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    var isNestedList = function (elm) {
      return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    var getContainerBlock = function (containerBlock) {
      var containerBlockParent = containerBlock.parentNode;
      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
        return containerBlockParent;
      }
      return containerBlock;
    };
    var isFirstOrLastLi = function (containerBlock, parentBlock, first) {
      var node = containerBlock[first ? 'firstChild' : 'lastChild'];
      while (node) {
        if (isElement$5(node)) {
          break;
        }
        node = node[first ? 'nextSibling' : 'previousSibling'];
      }
      return node === parentBlock;
    };
    var insert$3 = function (editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
      var dom = editor.dom;
      var rng = editor.selection.getRng();
      if (containerBlock === editor.getBody()) {
        return;
      }
      if (isNestedList(containerBlock)) {
        newBlockName = 'LI';
      }
      var newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');
      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
        if (hasParent(containerBlock, 'LI')) {
          var containerBlockParent = getContainerBlock(containerBlock);
          dom.insertAfter(newBlock, containerBlockParent);
          if (isFirstChild(containerBlock)) {
            dom.remove(containerBlockParent);
          } else {
            dom.remove(containerBlock);
          }
        } else {
          dom.replace(newBlock, containerBlock);
        }
      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
        if (hasParent(containerBlock, 'LI')) {
          dom.insertAfter(newBlock, getContainerBlock(containerBlock));
          newBlock.appendChild(dom.doc.createTextNode(' '));
          newBlock.appendChild(containerBlock);
        } else {
          containerBlock.parentNode.insertBefore(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
        dom.insertAfter(newBlock, getContainerBlock(containerBlock));
        dom.remove(parentBlock);
      } else {
        containerBlock = getContainerBlock(containerBlock);
        var tmpRng = rng.cloneRange();
        tmpRng.setStartAfter(parentBlock);
        tmpRng.setEndAfter(containerBlock);
        var fragment = tmpRng.extractContents();
        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
          newBlock = fragment.firstChild;
          dom.insertAfter(fragment, containerBlock);
        } else {
          dom.insertAfter(fragment, containerBlock);
          dom.insertAfter(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };

    var trimZwsp = function (fragment) {
      each$k(descendants$1(SugarElement.fromDom(fragment), isText$8), function (text) {
        var rawNode = text.dom;
        rawNode.nodeValue = trim$2(rawNode.nodeValue);
      });
    };
    var isEmptyAnchor = function (dom, elm) {
      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
    };
    var isTableCell = function (node) {
      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
    };
    var emptyBlock = function (elm) {
      elm.innerHTML = '<br data-mce-bogus="1">';
    };
    var containerAndSiblingName = function (container, nodeName) {
      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
    };
    var canSplitBlock = function (dom, node) {
      return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';
    };
    var trimInlineElementsOnLeftSideOfBlock = function (dom, nonEmptyElementsMap, block) {
      var node = block;
      var firstChilds = [];
      var i;
      if (!node) {
        return;
      }
      while (node = node.firstChild) {
        if (dom.isBlock(node)) {
          return;
        }
        if (isElement$5(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          firstChilds.push(node);
        }
      }
      i = firstChilds.length;
      while (i--) {
        node = firstChilds[i];
        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {
          dom.remove(node);
        } else {
          if (isEmptyAnchor(dom, node)) {
            dom.remove(node);
          }
        }
      }
    };
    var normalizeZwspOffset = function (start, container, offset) {
      if (isText$7(container) === false) {
        return offset;
      } else if (start) {
        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
      } else {
        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
      }
    };
    var includeZwspInRange = function (rng) {
      var newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
      return newRng;
    };
    var trimLeadingLineBreaks = function (node) {
      do {
        if (isText$7(node)) {
          node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, '');
        }
        node = node.firstChild;
      } while (node);
    };
    var getEditableRoot = function (dom, node) {
      var root = dom.getRoot();
      var parent, editableRoot;
      parent = node;
      while (parent !== root && dom.getContentEditable(parent) !== 'false') {
        if (dom.getContentEditable(parent) === 'true') {
          editableRoot = parent;
        }
        parent = parent.parentNode;
      }
      return parent !== root ? editableRoot : root;
    };
    var applyAttributes = function (editor, node, forcedRootBlockAttrs) {
      var dom = editor.dom;
      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(function (attrStyles) {
        var currentStyles = getAllRaw(SugarElement.fromDom(node));
        var newStyles = __assign(__assign({}, currentStyles), attrStyles);
        dom.setStyles(node, newStyles);
      });
      var attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(function (attrClasses) {
        return attrClasses.split(/\s+/);
      });
      var currentClassesOpt = Optional.from(node.className).map(function (currentClasses) {
        return filter$4(currentClasses.split(/\s+/), function (clazz) {
          return clazz !== '';
        });
      });
      lift2(attrClassesOpt, currentClassesOpt, function (attrClasses, currentClasses) {
        var filteredClasses = filter$4(currentClasses, function (clazz) {
          return !contains$3(attrClasses, clazz);
        });
        var newClasses = __spreadArray(__spreadArray([], attrClasses, true), filteredClasses, true);
        dom.setAttrib(node, 'class', newClasses.join(' '));
      });
      var appliedAttrs = [
        'style',
        'class'
      ];
      var remainingAttrs = filter$3(forcedRootBlockAttrs, function (_, attrs) {
        return !contains$3(appliedAttrs, attrs);
      });
      dom.setAttribs(node, remainingAttrs);
    };
    var setForcedBlockAttrs = function (editor, node) {
      var forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
        var forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
        applyAttributes(editor, node, forcedRootBlockAttrs);
      }
    };
    var wrapSelfAndSiblingsInDefaultBlock = function (editor, newBlockName, rng, container, offset) {
      var newBlock, parentBlock, startNode, node, next, rootBlockName;
      var blockName = newBlockName || 'P';
      var dom = editor.dom, editableRoot = getEditableRoot(dom, container);
      parentBlock = dom.getParent(container, dom.isBlock);
      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
        parentBlock = parentBlock || editableRoot;
        if (parentBlock === editor.getBody() || isTableCell(parentBlock)) {
          rootBlockName = parentBlock.nodeName.toLowerCase();
        } else {
          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
        }
        if (!parentBlock.hasChildNodes()) {
          newBlock = dom.create(blockName);
          setForcedBlockAttrs(editor, newBlock);
          parentBlock.appendChild(newBlock);
          rng.setStart(newBlock, 0);
          rng.setEnd(newBlock, 0);
          return newBlock;
        }
        node = container;
        while (node.parentNode !== parentBlock) {
          node = node.parentNode;
        }
        while (node && !dom.isBlock(node)) {
          startNode = node;
          node = node.previousSibling;
        }
        if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
          newBlock = dom.create(blockName);
          setForcedBlockAttrs(editor, newBlock);
          startNode.parentNode.insertBefore(newBlock, startNode);
          node = startNode;
          while (node && !dom.isBlock(node)) {
            next = node.nextSibling;
            newBlock.appendChild(node);
            node = next;
          }
          rng.setStart(container, offset);
          rng.setEnd(container, offset);
        }
      }
      return container;
    };
    var addBrToBlockIfNeeded = function (dom, block) {
      block.normalize();
      var lastChild = block.lastChild;
      if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {
        dom.add(block, 'br');
      }
    };
    var insert$2 = function (editor, evt) {
      var tmpRng, container, offset, parentBlock;
      var newBlock, fragment, containerBlock, parentBlockName, newBlockName, isAfterLastNodeInContainer;
      var dom = editor.dom;
      var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
      var rng = editor.selection.getRng();
      var createNewBlock = function (name) {
        var node = container, block, clonedNode, caretNode;
        var textInlineElements = schema.getTextInlineElements();
        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
          block = dom.create(name || newBlockName);
        } else {
          block = parentBlock.cloneNode(false);
        }
        caretNode = block;
        if (shouldKeepStyles(editor) === false) {
          dom.setAttrib(block, 'style', null);
          dom.setAttrib(block, 'class', null);
        } else {
          do {
            if (textInlineElements[node.nodeName]) {
              if (isCaretNode(node) || isBookmarkNode$1(node)) {
                continue;
              }
              clonedNode = node.cloneNode(false);
              dom.setAttrib(clonedNode, 'id', '');
              if (block.hasChildNodes()) {
                clonedNode.appendChild(block.firstChild);
                block.appendChild(clonedNode);
              } else {
                caretNode = clonedNode;
                block.appendChild(clonedNode);
              }
            }
          } while ((node = node.parentNode) && node !== editableRoot);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
      };
      var isCaretAtStartOrEndOfBlock = function (start) {
        var node, name;
        var normalizedOffset = normalizeZwspOffset(start, container, offset);
        if (isText$7(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
          return false;
        }
        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {
          return true;
        }
        if (start && isElement$5(container) && container === parentBlock.firstChild) {
          return true;
        }
        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {
          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;
        }
        var walker = new DomTreeWalker(container, parentBlock);
        if (isText$7(container)) {
          if (start && normalizedOffset === 0) {
            walker.prev();
          } else if (!start && normalizedOffset === container.nodeValue.length) {
            walker.next();
          }
        }
        while (node = walker.current()) {
          if (isElement$5(node)) {
            if (!node.getAttribute('data-mce-bogus')) {
              name = node.nodeName.toLowerCase();
              if (nonEmptyElementsMap[name] && name !== 'br') {
                return false;
              }
            }
          } else if (isText$7(node) && !isWhitespaceText(node.nodeValue)) {
            return false;
          }
          if (start) {
            walker.prev();
          } else {
            walker.next();
          }
        }
        return true;
      };
      var insertNewBlockAfter = function () {
        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
          newBlock = createNewBlock(newBlockName);
        } else {
          newBlock = createNewBlock();
        }
        if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {
          newBlock = dom.split(containerBlock, parentBlock);
        } else {
          dom.insertAfter(newBlock, parentBlock);
        }
        moveToCaretPosition(editor, newBlock);
      };
      normalize$2(dom, rng).each(function (normRng) {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      container = rng.startContainer;
      offset = rng.startOffset;
      newBlockName = getForcedRootBlock(editor);
      var shiftKey = !!(evt && evt.shiftKey);
      var ctrlKey = !!(evt && evt.ctrlKey);
      if (isElement$5(container) && container.hasChildNodes()) {
        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$7(container)) {
          offset = container.nodeValue.length;
        } else {
          offset = 0;
        }
      }
      var editableRoot = getEditableRoot(dom, container);
      if (!editableRoot) {
        return;
      }
      if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
      }
      parentBlock = dom.getParent(container, dom.isBlock);
      containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';
      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      if (containerBlockName === 'LI' && !ctrlKey) {
        parentBlock = containerBlock;
        containerBlock = containerBlock.parentNode;
        parentBlockName = containerBlockName;
      }
      if (/^(LI|DT|DD)$/.test(parentBlockName)) {
        if (dom.isEmpty(parentBlock)) {
          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
          return;
        }
      }
      if (newBlockName && parentBlock === editor.getBody()) {
        return;
      }
      newBlockName = newBlockName || 'P';
      if (isCaretContainerBlock$1(parentBlock)) {
        newBlock = showCaretContainerBlock(parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      } else if (isCaretAtStartOrEndOfBlock()) {
        insertNewBlockAfter();
      } else if (isCaretAtStartOrEndOfBlock(true)) {
        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);
      } else {
        tmpRng = includeZwspInRange(rng).cloneRange();
        tmpRng.setEndAfter(parentBlock);
        fragment = tmpRng.extractContents();
        trimZwsp(fragment);
        trimLeadingLineBreaks(fragment);
        newBlock = fragment.firstChild;
        dom.insertAfter(fragment, parentBlock);
        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
        addBrToBlockIfNeeded(dom, parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        newBlock.normalize();
        if (dom.isEmpty(newBlock)) {
          dom.remove(newBlock);
          insertNewBlockAfter();
        } else {
          setForcedBlockAttrs(editor, newBlock);
          moveToCaretPosition(editor, newBlock);
        }
      }
      dom.setAttrib(newBlock, 'id', '');
      editor.fire('NewBlock', { newBlock: newBlock });
    };

    var hasRightSideContent = function (schema, container, parentBlock) {
      var walker = new DomTreeWalker(container, parentBlock);
      var node;
      var nonEmptyElementsMap = schema.getNonEmptyElements();
      while (node = walker.next()) {
        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
          return true;
        }
      }
    };
    var moveSelectionToBr = function (editor, brElm, extraBr) {
      var rng = editor.dom.createRng();
      if (!extraBr) {
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
      } else {
        rng.setStartBefore(brElm);
        rng.setEndBefore(brElm);
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    var insertBrAtCaret = function (editor, evt) {
      var selection = editor.selection;
      var dom = editor.dom;
      var rng = selection.getRng();
      var brElm;
      var extraBr;
      normalize$2(dom, rng).each(function (normRng) {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      var offset = rng.startOffset;
      var container = rng.startContainer;
      if (container.nodeType === 1 && container.hasChildNodes()) {
        var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && container.nodeType === 3) {
          offset = container.nodeValue.length;
        } else {
          offset = 0;
        }
      }
      var parentBlock = dom.getParent(container, dom.isBlock);
      var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      var isControlKey = !!(evt && evt.ctrlKey);
      if (containerBlockName === 'LI' && !isControlKey) {
        parentBlock = containerBlock;
      }
      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
        if (!hasRightSideContent(editor.schema, container, parentBlock)) {
          brElm = dom.create('br');
          rng.insertNode(brElm);
          rng.setStartAfter(brElm);
          rng.setEndAfter(brElm);
          extraBr = true;
        }
      }
      brElm = dom.create('br');
      rangeInsertNode(dom, rng, brElm);
      moveSelectionToBr(editor, brElm, extraBr);
      editor.undoManager.add();
    };
    var insertBrBefore = function (editor, inline) {
      var br = SugarElement.fromTag('br');
      before$4(SugarElement.fromDom(inline), br);
      editor.undoManager.add();
    };
    var insertBrAfter = function (editor, inline) {
      if (!hasBrAfter(editor.getBody(), inline)) {
        after$3(SugarElement.fromDom(inline), SugarElement.fromTag('br'));
      }
      var br = SugarElement.fromTag('br');
      after$3(SugarElement.fromDom(inline), br);
      moveSelectionToBr(editor, br.dom, false);
      editor.undoManager.add();
    };
    var isBeforeBr = function (pos) {
      return isBr$5(pos.getNode());
    };
    var hasBrAfter = function (rootNode, startNode) {
      if (isBeforeBr(CaretPosition.after(startNode))) {
        return true;
      } else {
        return nextPosition(rootNode, CaretPosition.after(startNode)).map(function (pos) {
          return isBr$5(pos.getNode());
        }).getOr(false);
      }
    };
    var isAnchorLink = function (elm) {
      return elm && elm.nodeName === 'A' && 'href' in elm;
    };
    var isInsideAnchor = function (location) {
      return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    var readInlineAnchorLocation = function (editor) {
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var position = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    var insertBrOutsideAnchor = function (editor, location) {
      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    var insert$1 = function (editor, evt) {
      var anchorLocation = readInlineAnchorLocation(editor);
      if (anchorLocation.isSome()) {
        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
      } else {
        insertBrAtCaret(editor, evt);
      }
    };

    var matchesSelector = function (editor, selector) {
      return getParentBlock(editor).filter(function (parentBlock) {
        return selector.length > 0 && is$2(SugarElement.fromDom(parentBlock), selector);
      }).isSome();
    };
    var shouldInsertBr = function (editor) {
      return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    var shouldBlockNewLine$1 = function (editor) {
      return matchesSelector(editor, getNoNewLineSelector(editor));
    };

    var newLineAction = Adt.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]);
    var shouldBlockNewLine = function (editor, _shiftKey) {
      return shouldBlockNewLine$1(editor);
    };
    var isBrMode = function (requiredState) {
      return function (editor, _shiftKey) {
        var brMode = getForcedRootBlock(editor) === '';
        return brMode === requiredState;
      };
    };
    var inListBlock = function (requiredState) {
      return function (editor, _shiftKey) {
        return isListItemParentBlock(editor) === requiredState;
      };
    };
    var inBlock = function (blockName, requiredState) {
      return function (editor, _shiftKey) {
        var state = getParentBlockName(editor) === blockName.toUpperCase();
        return state === requiredState;
      };
    };
    var inPreBlock = function (requiredState) {
      return inBlock('pre', requiredState);
    };
    var inSummaryBlock = function () {
      return inBlock('summary', true);
    };
    var shouldPutBrInPre = function (requiredState) {
      return function (editor, _shiftKey) {
        return shouldPutBrInPre$1(editor) === requiredState;
      };
    };
    var inBrContext = function (editor, _shiftKey) {
      return shouldInsertBr(editor);
    };
    var hasShiftKey = function (_editor, shiftKey) {
      return shiftKey;
    };
    var canInsertIntoEditableRoot = function (editor) {
      var forcedRootBlock = getForcedRootBlock(editor);
      var rootEditable = getEditableRoot$1(editor.dom, editor.selection.getStart());
      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : 'P');
    };
    var match = function (predicates, action) {
      return function (editor, shiftKey) {
        var isMatch = foldl(predicates, function (res, p) {
          return res && p(editor, shiftKey);
        }, true);
        return isMatch ? Optional.some(action) : Optional.none();
      };
    };
    var getAction = function (editor, evt) {
      return evaluateUntil([
        match([shouldBlockNewLine], newLineAction.none()),
        match([inSummaryBlock()], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false),
          hasShiftKey
        ], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false)
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true),
          hasShiftKey
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true)
        ], newLineAction.br()),
        match([
          inListBlock(true),
          hasShiftKey
        ], newLineAction.br()),
        match([inListBlock(true)], newLineAction.block()),
        match([
          isBrMode(true),
          hasShiftKey,
          canInsertIntoEditableRoot
        ], newLineAction.block()),
        match([isBrMode(true)], newLineAction.br()),
        match([inBrContext], newLineAction.br()),
        match([
          isBrMode(false),
          hasShiftKey
        ], newLineAction.br()),
        match([canInsertIntoEditableRoot], newLineAction.block())
      ], [
        editor,
        !!(evt && evt.shiftKey)
      ]).getOr(newLineAction.none());
    };

    var insert = function (editor, evt) {
      getAction(editor, evt).fold(function () {
        insert$1(editor, evt);
      }, function () {
        insert$2(editor, evt);
      }, noop);
    };

    var handleEnterKeyEvent = function (editor, event) {
      if (event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      endTypingLevelIgnoreLocks(editor.undoManager);
      editor.undoManager.transact(function () {
        if (editor.selection.isCollapsed() === false) {
          editor.execCommand('Delete');
        }
        insert(editor, event);
      });
    };
    var setup$9 = function (editor) {
      editor.on('keydown', function (event) {
        if (event.keyCode === VK.ENTER) {
          handleEnterKeyEvent(editor, event);
        }
      });
    };

    var executeKeydownOverride$1 = function (editor, caret, evt) {
      execute([
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        }
      ], evt).each(function (_) {
        evt.preventDefault();
      });
    };
    var setup$8 = function (editor, caret) {
      editor.on('keydown', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$1(editor, caret, evt);
        }
      });
    };

    var browser = detect().browser;
    var setupIeInput = function (editor) {
      var keypressThrotter = first(function () {
        if (!editor.composing) {
          normalizeNbspsInEditor(editor);
        }
      }, 0);
      if (browser.isIE()) {
        editor.on('keypress', function (_e) {
          keypressThrotter.throttle();
        });
        editor.on('remove', function (_e) {
          keypressThrotter.cancel();
        });
      }
    };
    var setup$7 = function (editor) {
      setupIeInput(editor);
      editor.on('input', function (e) {
        if (e.isComposing === false) {
          normalizeNbspsInEditor(editor);
        }
      });
    };

    var platform = detect();
    var executeKeyupAction = function (editor, caret, evt) {
      execute([
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        }
      ], evt);
    };
    var stopImmediatePropagation = function (e) {
      return e.stopImmediatePropagation();
    };
    var isPageUpDown = function (evt) {
      return evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    };
    var setNodeChangeBlocker = function (blocked, editor, block) {
      if (block && !blocked.get()) {
        editor.on('NodeChange', stopImmediatePropagation, true);
      } else if (!block && blocked.get()) {
        editor.off('NodeChange', stopImmediatePropagation);
      }
      blocked.set(block);
    };
    var setup$6 = function (editor, caret) {
      if (platform.os.isOSX()) {
        return;
      }
      var blocked = Cell(false);
      editor.on('keydown', function (evt) {
        if (isPageUpDown(evt)) {
          setNodeChangeBlocker(blocked, editor, true);
        }
      });
      editor.on('keyup', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeyupAction(editor, caret, evt);
        }
        if (isPageUpDown(evt) && blocked.get()) {
          setNodeChangeBlocker(blocked, editor, false);
          editor.nodeChanged();
        }
      });
    };

    var insertTextAtPosition = function (text, pos) {
      var container = pos.container();
      var offset = pos.offset();
      if (isText$7(container)) {
        container.insertData(offset, text);
        return Optional.some(CaretPosition(container, offset + text.length));
      } else {
        return getElementFromPosition(pos).map(function (elm) {
          var textNode = SugarElement.fromText(text);
          if (pos.isAtEnd()) {
            after$3(elm, textNode);
          } else {
            before$4(elm, textNode);
          }
          return CaretPosition(textNode.dom, text.length);
        });
      }
    };
    var insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    var insertSpaceAtPosition = curry(insertTextAtPosition, ' ');

    var locationToCaretPosition = function (root) {
      return function (location) {
        return location.fold(function (element) {
          return prevPosition(root.dom, CaretPosition.before(element));
        }, function (element) {
          return firstPositionIn(element);
        }, function (element) {
          return lastPositionIn(element);
        }, function (element) {
          return nextPosition(root.dom, CaretPosition.after(element));
        });
      };
    };
    var insertInlineBoundarySpaceOrNbsp = function (root, pos) {
      return function (checkPos) {
        return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
      };
    };
    var setSelection = function (editor) {
      return function (pos) {
        editor.selection.setRng(pos.toRange());
        editor.nodeChanged();
        return true;
      };
    };
    var insertSpaceOrNbspAtSelection = function (editor) {
      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      var root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        var isInlineTarget$1 = curry(isInlineTarget, editor);
        var caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection(editor));
      } else {
        return false;
      }
    };

    var executeKeydownOverride = function (editor, evt) {
      execute([{
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceOrNbspAtSelection, editor)
        }], evt).each(function (_) {
        evt.preventDefault();
      });
    };
    var setup$5 = function (editor) {
      editor.on('keydown', function (evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride(editor, evt);
        }
      });
    };

    var registerKeyboardOverrides = function (editor) {
      var caret = setupSelectedState(editor);
      setup$c(editor);
      setup$b(editor, caret);
      setup$a(editor, caret);
      setup$9(editor);
      setup$5(editor);
      setup$7(editor);
      setup$8(editor, caret);
      setup$6(editor, caret);
      return caret;
    };
    var setup$4 = function (editor) {
      if (!isRtc(editor)) {
        return registerKeyboardOverrides(editor);
      } else {
        return Cell(null);
      }
    };

    var NodeChange = function () {
      function NodeChange(editor) {
        this.lastPath = [];
        this.editor = editor;
        var lastRng;
        var self = this;
        if (!('onselectionchange' in editor.getDoc())) {
          editor.on('NodeChange click mouseup keyup focus', function (e) {
            var nativeRng = editor.selection.getRng();
            var fakeRng = {
              startContainer: nativeRng.startContainer,
              startOffset: nativeRng.startOffset,
              endContainer: nativeRng.endContainer,
              endOffset: nativeRng.endOffset
            };
            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {
              editor.fire('SelectionChange');
            }
            lastRng = fakeRng;
          });
        }
        editor.on('contextmenu', function () {
          editor.fire('SelectionChange');
        });
        editor.on('SelectionChange', function () {
          var startElm = editor.selection.getStart(true);
          if (!startElm || !Env.range && editor.selection.isCollapsed()) {
            return;
          }
          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
            editor.nodeChanged({ selectionChange: true });
          }
        });
        editor.on('mouseup', function (e) {
          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
            if (editor.selection.getNode().nodeName === 'IMG') {
              Delay.setEditorTimeout(editor, function () {
                editor.nodeChanged();
              });
            } else {
              editor.nodeChanged();
            }
          }
        });
      }
      NodeChange.prototype.nodeChanged = function (args) {
        var selection = this.editor.selection;
        var node, parents, root;
        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
          root = this.editor.getBody();
          node = selection.getStart(true) || root;
          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
            node = root;
          }
          parents = [];
          this.editor.dom.getParent(node, function (node) {
            if (node === root) {
              return true;
            }
            parents.push(node);
          });
          args = args || {};
          args.element = node;
          args.parents = parents;
          this.editor.fire('NodeChange', args);
        }
      };
      NodeChange.prototype.isSameElementPath = function (startElm) {
        var i;
        var currentPath = this.editor.$(startElm).parentsUntil(this.editor.getBody()).add(startElm);
        if (currentPath.length === this.lastPath.length) {
          for (i = currentPath.length; i >= 0; i--) {
            if (currentPath[i] !== this.lastPath[i]) {
              break;
            }
          }
          if (i === -1) {
            this.lastPath = currentPath;
            return true;
          }
        }
        this.lastPath = currentPath;
        return false;
      };
      return NodeChange;
    }();

    var preventSummaryToggle = function (editor) {
      editor.on('click', function (e) {
        if (editor.dom.getParent(e.target, 'details')) {
          e.preventDefault();
        }
      });
    };
    var filterDetails = function (editor) {
      editor.parser.addNodeFilter('details', function (elms) {
        each$k(elms, function (details) {
          details.attr('data-mce-open', details.attr('open'));
          details.attr('open', 'open');
        });
      });
      editor.serializer.addNodeFilter('details', function (elms) {
        each$k(elms, function (details) {
          var open = details.attr('data-mce-open');
          details.attr('open', isString$1(open) ? open : null);
          details.attr('data-mce-open', null);
        });
      });
    };
    var setup$3 = function (editor) {
      preventSummaryToggle(editor);
      filterDetails(editor);
    };

    var isTextBlockNode = function (node) {
      return isElement$5(node) && isTextBlock$2(SugarElement.fromDom(node));
    };
    var normalizeSelection = function (editor) {
      var rng = editor.selection.getRng();
      var startPos = CaretPosition.fromRangeStart(rng);
      var endPos = CaretPosition.fromRangeEnd(rng);
      if (CaretPosition.isElementPosition(startPos)) {
        var container = startPos.container();
        if (isTextBlockNode(container)) {
          firstPositionIn(container).each(function (pos) {
            return rng.setStart(pos.container(), pos.offset());
          });
        }
      }
      if (CaretPosition.isElementPosition(endPos)) {
        var container = startPos.container();
        if (isTextBlockNode(container)) {
          lastPositionIn(container).each(function (pos) {
            return rng.setEnd(pos.container(), pos.offset());
          });
        }
      }
      editor.selection.setRng(normalize(rng));
    };
    var setup$2 = function (editor) {
      editor.on('click', function (e) {
        if (e.detail >= 3) {
          normalizeSelection(editor);
        }
      });
    };

    var getAbsolutePosition = function (elm) {
      var clientRect = elm.getBoundingClientRect();
      var doc = elm.ownerDocument;
      var docElem = doc.documentElement;
      var win = doc.defaultView;
      return {
        top: clientRect.top + win.pageYOffset - docElem.clientTop,
        left: clientRect.left + win.pageXOffset - docElem.clientLeft
      };
    };
    var getBodyPosition = function (editor) {
      return editor.inline ? getAbsolutePosition(editor.getBody()) : {
        left: 0,
        top: 0
      };
    };
    var getScrollPosition = function (editor) {
      var body = editor.getBody();
      return editor.inline ? {
        left: body.scrollLeft,
        top: body.scrollTop
      } : {
        left: 0,
        top: 0
      };
    };
    var getBodyScroll = function (editor) {
      var body = editor.getBody(), docElm = editor.getDoc().documentElement;
      var inlineScroll = {
        left: body.scrollLeft,
        top: body.scrollTop
      };
      var iframeScroll = {
        left: body.scrollLeft || docElm.scrollLeft,
        top: body.scrollTop || docElm.scrollTop
      };
      return editor.inline ? inlineScroll : iframeScroll;
    };
    var getMousePosition = function (editor, event) {
      if (event.target.ownerDocument !== editor.getDoc()) {
        var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        var scrollPosition = getBodyScroll(editor);
        return {
          left: event.pageX - iframePosition.left + scrollPosition.left,
          top: event.pageY - iframePosition.top + scrollPosition.top
        };
      }
      return {
        left: event.pageX,
        top: event.pageY
      };
    };
    var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {
      return {
        pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
        pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
      };
    };
    var calc = function (editor, event) {
      return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
    };

    var isContentEditableFalse$1 = isContentEditableFalse$b, isContentEditableTrue$1 = isContentEditableTrue$4;
    var isDraggable = function (rootElm, elm) {
      return isContentEditableFalse$1(elm) && elm !== rootElm;
    };
    var isValidDropTarget = function (editor, targetElement, dragElement) {
      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      }
      return !isContentEditableFalse$1(targetElement);
    };
    var cloneElement = function (elm) {
      var cloneElm = elm.cloneNode(true);
      cloneElm.removeAttribute('data-mce-selected');
      return cloneElm;
    };
    var createGhost = function (editor, elm, width, height) {
      var dom = editor.dom;
      var clonedElm = elm.cloneNode(true);
      dom.setStyles(clonedElm, {
        width: width,
        height: height
      });
      dom.setAttrib(clonedElm, 'data-mce-selected', null);
      var ghostElm = dom.create('div', {
        'class': 'mce-drag-container',
        'data-mce-bogus': 'all',
        'unselectable': 'on',
        'contenteditable': 'false'
      });
      dom.setStyles(ghostElm, {
        position: 'absolute',
        opacity: 0.5,
        overflow: 'hidden',
        border: 0,
        padding: 0,
        margin: 0,
        width: width,
        height: height
      });
      dom.setStyles(clonedElm, {
        margin: 0,
        boxSizing: 'border-box'
      });
      ghostElm.appendChild(clonedElm);
      return ghostElm;
    };
    var appendGhostToBody = function (ghostElm, bodyElm) {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };
    var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {
      var overflowX = 0, overflowY = 0;
      ghostElm.style.left = position.pageX + 'px';
      ghostElm.style.top = position.pageY + 'px';
      if (position.pageX + width > maxX) {
        overflowX = position.pageX + width - maxX;
      }
      if (position.pageY + height > maxY) {
        overflowY = position.pageY + height - maxY;
      }
      ghostElm.style.width = width - overflowX + 'px';
      ghostElm.style.height = height - overflowY + 'px';
    };
    var removeElement = function (elm) {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };
    var isLeftMouseButtonPressed = function (e) {
      return e.button === 0;
    };
    var applyRelPos = function (state, position) {
      return {
        pageX: position.pageX - state.relX,
        pageY: position.pageY + 5
      };
    };
    var start = function (state, editor) {
      return function (e) {
        if (isLeftMouseButtonPressed(e)) {
          var ceElm = find$3(editor.dom.getParents(e.target), or(isContentEditableFalse$1, isContentEditableTrue$1)).getOr(null);
          if (isDraggable(editor.getBody(), ceElm)) {
            var elmPos = editor.dom.getPos(ceElm);
            var bodyElm = editor.getBody();
            var docElm = editor.getDoc().documentElement;
            state.set({
              element: ceElm,
              dragging: false,
              screenX: e.screenX,
              screenY: e.screenY,
              maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
              maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
              relX: e.pageX - elmPos.x,
              relY: e.pageY - elmPos.y,
              width: ceElm.offsetWidth,
              height: ceElm.offsetHeight,
              ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)
            });
          }
        }
      };
    };
    var move = function (state, editor) {
      var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {
        editor._selectionOverrides.hideFakeCaret();
        editor.selection.placeCaretAt(clientX, clientY);
      }, 0);
      editor.on('remove', throttledPlaceCaretAt.stop);
      return function (e) {
        return state.on(function (state) {
          var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
          if (!state.dragging && movement > 10) {
            var args = editor.fire('dragstart', { target: state.element });
            if (args.isDefaultPrevented()) {
              return;
            }
            state.dragging = true;
            editor.focus();
          }
          if (state.dragging) {
            var targetPos = applyRelPos(state, calc(editor, e));
            appendGhostToBody(state.ghost, editor.getBody());
            moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
            throttledPlaceCaretAt(e.clientX, e.clientY);
          }
        });
      };
    };
    var getRawTarget = function (selection) {
      var rng = selection.getSel().getRangeAt(0);
      var startContainer = rng.startContainer;
      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
    };
    var drop = function (state, editor) {
      return function (e) {
        state.on(function (state) {
          if (state.dragging) {
            if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
              var targetClone_1 = cloneElement(state.element);
              var args = editor.fire('drop', {
                clientX: e.clientX,
                clientY: e.clientY
              });
              if (!args.isDefaultPrevented()) {
                editor.undoManager.transact(function () {
                  removeElement(state.element);
                  editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
                  editor._selectionOverrides.hideFakeCaret();
                });
              }
            }
            editor.fire('dragend');
          }
        });
        removeDragState(state);
      };
    };
    var stop = function (state, editor) {
      return function () {
        state.on(function (state) {
          if (state.dragging) {
            editor.fire('dragend');
          }
        });
        removeDragState(state);
      };
    };
    var removeDragState = function (state) {
      state.on(function (state) {
        removeElement(state.ghost);
      });
      state.clear();
    };
    var bindFakeDragEvents = function (editor) {
      var state = value();
      var pageDom = DOMUtils.DOM;
      var rootDocument = document;
      var dragStartHandler = start(state, editor);
      var dragHandler = move(state, editor);
      var dropHandler = drop(state, editor);
      var dragEndHandler = stop(state, editor);
      editor.on('mousedown', dragStartHandler);
      editor.on('mousemove', dragHandler);
      editor.on('mouseup', dropHandler);
      pageDom.bind(rootDocument, 'mousemove', dragHandler);
      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
      editor.on('remove', function () {
        pageDom.unbind(rootDocument, 'mousemove', dragHandler);
        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
      });
      editor.on('keydown', function (e) {
        if (e.keyCode === VK.ESC) {
          dragEndHandler();
        }
      });
    };
    var blockIeDrop = function (editor) {
      editor.on('drop', function (e) {
        var realTarget = typeof e.clientX !== 'undefined' ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
        if (isContentEditableFalse$1(realTarget) || editor.dom.getContentEditableParent(realTarget) === 'false') {
          e.preventDefault();
        }
      });
    };
    var blockUnsupportedFileDrop = function (editor) {
      var preventFileDrop = function (e) {
        if (!e.isDefaultPrevented()) {
          var dataTransfer = e.dataTransfer;
          if (dataTransfer && (contains$3(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {
            e.preventDefault();
            if (e.type === 'drop') {
              displayError(editor, 'Dropped file type is not supported');
            }
          }
        }
      };
      var preventFileDropIfUIElement = function (e) {
        if (isUIElement(editor, e.target)) {
          preventFileDrop(e);
        }
      };
      var setup = function () {
        var pageDom = DOMUtils.DOM;
        var dom = editor.dom;
        var doc = document;
        var editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
        var eventNames = [
          'drop',
          'dragover'
        ];
        each$k(eventNames, function (name) {
          pageDom.bind(doc, name, preventFileDropIfUIElement);
          dom.bind(editorRoot, name, preventFileDrop);
        });
        editor.on('remove', function () {
          each$k(eventNames, function (name) {
            pageDom.unbind(doc, name, preventFileDropIfUIElement);
            dom.unbind(editorRoot, name, preventFileDrop);
          });
        });
      };
      editor.on('init', function () {
        Delay.setEditorTimeout(editor, setup, 0);
      });
    };
    var init$2 = function (editor) {
      bindFakeDragEvents(editor);
      blockIeDrop(editor);
      if (shouldBlockUnsupportedDrop(editor)) {
        blockUnsupportedFileDrop(editor);
      }
    };

    var setup$1 = function (editor) {
      var renderFocusCaret = first(function () {
        if (!editor.removed && editor.getBody().contains(document.activeElement)) {
          var rng = editor.selection.getRng();
          if (rng.collapsed) {
            var caretRange = renderRangeCaret(editor, rng, false);
            editor.selection.setRng(caretRange);
          }
        }
      }, 0);
      editor.on('focus', function () {
        renderFocusCaret.throttle();
      });
      editor.on('blur', function () {
        renderFocusCaret.cancel();
      });
    };

    var setup = function (editor) {
      editor.on('init', function () {
        editor.on('focusin', function (e) {
          var target = e.target;
          if (isMedia$2(target)) {
            var ceRoot = getContentEditableRoot$1(editor.getBody(), target);
            var node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
            if (editor.selection.getNode() !== node) {
              selectNode(editor, node).each(function (rng) {
                return editor.selection.setRng(rng);
              });
            }
          }
        });
      });
    };

    var isContentEditableTrue = isContentEditableTrue$4;
    var isContentEditableFalse = isContentEditableFalse$b;
    var getContentEditableRoot = function (editor, node) {
      return getContentEditableRoot$1(editor.getBody(), node);
    };
    var SelectionOverrides = function (editor) {
      var selection = editor.selection, dom = editor.dom;
      var isBlock = dom.isBlock;
      var rootNode = editor.getBody();
      var fakeCaret = FakeCaret(editor, rootNode, isBlock, function () {
        return hasFocus(editor);
      });
      var realSelectionId = 'sel-' + dom.uniqueId();
      var elementSelectionAttr = 'data-mce-selected';
      var selectedElement;
      var isFakeSelectionElement = function (node) {
        return dom.hasClass(node, 'mce-offscreen-selection');
      };
      var isFakeSelectionTargetElement = function (node) {
        return node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode);
      };
      var isNearFakeSelectionElement = function (pos) {
        return isBeforeContentEditableFalse(pos) || isAfterContentEditableFalse(pos) || isBeforeMedia(pos) || isAfterMedia(pos);
      };
      var getRealSelectionElement = function () {
        var container = dom.get(realSelectionId);
        return container ? container.getElementsByTagName('*')[0] : container;
      };
      var setRange = function (range) {
        if (range) {
          selection.setRng(range);
        }
      };
      var getRange = selection.getRng;
      var showCaret = function (direction, node, before, scrollIntoView) {
        if (scrollIntoView === void 0) {
          scrollIntoView = true;
        }
        var e = editor.fire('ShowCaret', {
          target: node,
          direction: direction,
          before: before
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        if (scrollIntoView) {
          selection.scrollIntoView(node, direction === -1);
        }
        return fakeCaret.show(before, node);
      };
      var showBlockCaretContainer = function (blockCaretContainer) {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
          showCaretContainerBlock(blockCaretContainer);
          setRange(getRange());
          selection.scrollIntoView(blockCaretContainer);
        }
      };
      var registerEvents = function () {
        editor.on('mouseup', function (e) {
          var range = getRange();
          if (range.collapsed && isXYInContentArea(editor, e.clientX, e.clientY)) {
            renderCaretAtRange(editor, range, false).each(setRange);
          }
        });
        editor.on('click', function (e) {
          var contentEditableRoot = getContentEditableRoot(editor, e.target);
          if (contentEditableRoot) {
            if (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              editor.focus();
            }
            if (isContentEditableTrue(contentEditableRoot)) {
              if (dom.isChildOf(contentEditableRoot, selection.getNode())) {
                removeElementSelection();
              }
            }
          }
        });
        editor.on('blur NewBlock', removeElementSelection);
        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);
        var hasNormalCaretPosition = function (elm) {
          var start = elm.firstChild;
          if (isNullable(start)) {
            return false;
          }
          var startPos = CaretPosition.before(start);
          if (isBr$5(startPos.getNode()) && elm.childNodes.length === 1) {
            return !isNearFakeSelectionElement(startPos);
          } else {
            var caretWalker = CaretWalker(elm);
            var newPos = caretWalker.next(startPos);
            return newPos && !isNearFakeSelectionElement(newPos);
          }
        };
        var isInSameBlock = function (node1, node2) {
          var block1 = dom.getParent(node1, isBlock);
          var block2 = dom.getParent(node2, isBlock);
          return block1 === block2;
        };
        var hasBetterMouseTarget = function (targetNode, caretNode) {
          var targetBlock = dom.getParent(targetNode, isBlock);
          var caretBlock = dom.getParent(caretNode, isBlock);
          if (isNullable(targetBlock)) {
            return false;
          }
          if (targetNode !== caretBlock && dom.isChildOf(targetBlock, caretBlock) && isContentEditableFalse(getContentEditableRoot(editor, targetBlock)) === false) {
            return true;
          }
          return !dom.isChildOf(caretBlock, targetBlock) && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
        };
        editor.on('tap', function (e) {
          var targetElm = e.target;
          var contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        }, true);
        editor.on('mousedown', function (e) {
          var targetElm = e.target;
          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {
            return;
          }
          if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {
            return;
          }
          var contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (contentEditableRoot) {
            if (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              selectNode(editor, contentEditableRoot).each(setElementSelection);
            } else {
              removeElementSelection();
              if (!(isContentEditableTrue(contentEditableRoot) && e.shiftKey) && !isXYWithinRange(e.clientX, e.clientY, selection.getRng())) {
                hideFakeCaret();
                selection.placeCaretAt(e.clientX, e.clientY);
              }
            }
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          } else if (isFakeCaretTarget(targetElm) === false) {
            removeElementSelection();
            hideFakeCaret();
            var fakeCaretInfo = closestFakeCaret(rootNode, e.clientX, e.clientY);
            if (fakeCaretInfo) {
              if (!hasBetterMouseTarget(targetElm, fakeCaretInfo.node)) {
                e.preventDefault();
                var range = showCaret(1, fakeCaretInfo.node, fakeCaretInfo.before, false);
                setRange(range);
                editor.getBody().focus();
              }
            }
          }
        });
        editor.on('keypress', function (e) {
          if (VK.modifierPressed(e)) {
            return;
          }
          if (isContentEditableFalse(selection.getNode())) {
            e.preventDefault();
          }
        });
        editor.on('GetSelectionRange', function (e) {
          var rng = e.range;
          if (selectedElement) {
            if (!selectedElement.parentNode) {
              selectedElement = null;
              return;
            }
            rng = rng.cloneRange();
            rng.selectNode(selectedElement);
            e.range = rng;
          }
        });
        editor.on('SetSelectionRange', function (e) {
          e.range = normalizeShortEndedElementSelection(e.range);
          var rng = setElementSelection(e.range, e.forward);
          if (rng) {
            e.range = rng;
          }
        });
        var isPasteBin = function (node) {
          return node.id === 'mcepastebin';
        };
        editor.on('AfterSetSelectionRange', function (e) {
          var rng = e.range;
          var parentNode = rng.startContainer.parentNode;
          if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {
            hideFakeCaret();
          }
          if (!isFakeSelectionElement(parentNode)) {
            removeElementSelection();
          }
        });
        editor.on('copy', function (e) {
          var clipboardData = e.clipboardData;
          if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
            var realSelectionElement = getRealSelectionElement();
            if (realSelectionElement) {
              e.preventDefault();
              clipboardData.clearData();
              clipboardData.setData('text/html', realSelectionElement.outerHTML);
              clipboardData.setData('text/plain', realSelectionElement.outerText || realSelectionElement.innerText);
            }
          }
        });
        init$2(editor);
        setup$1(editor);
        setup(editor);
      };
      var isWithinCaretContainer = function (node) {
        return isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
      };
      var isRangeInCaretContainer = function (rng) {
        return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      };
      var normalizeShortEndedElementSelection = function (rng) {
        var shortEndedElements = editor.schema.getShortEndedElements();
        var newRng = dom.createRng();
        var startContainer = rng.startContainer;
        var startOffset = rng.startOffset;
        var endContainer = rng.endContainer;
        var endOffset = rng.endOffset;
        if (has$2(shortEndedElements, startContainer.nodeName.toLowerCase())) {
          if (startOffset === 0) {
            newRng.setStartBefore(startContainer);
          } else {
            newRng.setStartAfter(startContainer);
          }
        } else {
          newRng.setStart(startContainer, startOffset);
        }
        if (has$2(shortEndedElements, endContainer.nodeName.toLowerCase())) {
          if (endOffset === 0) {
            newRng.setEndBefore(endContainer);
          } else {
            newRng.setEndAfter(endContainer);
          }
        } else {
          newRng.setEnd(endContainer, endOffset);
        }
        return newRng;
      };
      var setupOffscreenSelection = function (node, targetClone, origTargetClone) {
        var $ = editor.$;
        var $realSelectionContainer = descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).fold(function () {
          return $([]);
        }, function (elm) {
          return $([elm.dom]);
        });
        if ($realSelectionContainer.length === 0) {
          $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr('id', realSelectionId);
          $realSelectionContainer.appendTo(editor.getBody());
        }
        var newRange = dom.createRng();
        if (targetClone === origTargetClone && Env.ie) {
          $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xA0</p>').append(targetClone);
          newRange.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
          newRange.setEndAfter(targetClone);
        } else {
          $realSelectionContainer.empty().append(nbsp).append(targetClone).append(nbsp);
          newRange.setStart($realSelectionContainer[0].firstChild, 1);
          newRange.setEnd($realSelectionContainer[0].lastChild, 0);
        }
        $realSelectionContainer.css({ top: dom.getPos(node, editor.getBody()).y });
        $realSelectionContainer[0].focus();
        var sel = selection.getSel();
        sel.removeAllRanges();
        sel.addRange(newRange);
        return newRange;
      };
      var selectElement = function (elm) {
        var targetClone = elm.cloneNode(true);
        var e = editor.fire('ObjectSelected', {
          target: elm,
          targetClone: targetClone
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        var range = setupOffscreenSelection(elm, e.targetClone, targetClone);
        var nodeElm = SugarElement.fromDom(elm);
        each$k(descendants(SugarElement.fromDom(editor.getBody()), '*[data-mce-selected]'), function (elm) {
          if (!eq(nodeElm, elm)) {
            remove$6(elm, elementSelectionAttr);
          }
        });
        if (!dom.getAttrib(elm, elementSelectionAttr)) {
          elm.setAttribute(elementSelectionAttr, '1');
        }
        selectedElement = elm;
        hideFakeCaret();
        return range;
      };
      var setElementSelection = function (range, forward) {
        if (!range) {
          return null;
        }
        if (range.collapsed) {
          if (!isRangeInCaretContainer(range)) {
            var dir = forward ? 1 : -1;
            var caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
            var beforeNode = caretPosition.getNode(!forward);
            if (isFakeCaretTarget(beforeNode)) {
              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
            }
            var afterNode = caretPosition.getNode(forward);
            if (isFakeCaretTarget(afterNode)) {
              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
            }
          }
          return null;
        }
        var startContainer = range.startContainer;
        var startOffset = range.startOffset;
        var endOffset = range.endOffset;
        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }
        if (startContainer.nodeType !== 1) {
          return null;
        }
        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
          var node = startContainer.childNodes[startOffset];
          if (isFakeSelectionTargetElement(node)) {
            return selectElement(node);
          }
        }
        return null;
      };
      var removeElementSelection = function () {
        if (selectedElement) {
          selectedElement.removeAttribute(elementSelectionAttr);
        }
        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$7);
        selectedElement = null;
      };
      var destroy = function () {
        fakeCaret.destroy();
        selectedElement = null;
      };
      var hideFakeCaret = function () {
        fakeCaret.hide();
      };
      if (Env.ceFalse && !isRtc(editor)) {
        registerEvents();
      }
      return {
        showCaret: showCaret,
        showBlockCaretContainer: showBlockCaretContainer,
        hideFakeCaret: hideFakeCaret,
        destroy: destroy
      };
    };

    var Quirks = function (editor) {
      var each = Tools.each;
      var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;
      var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
      var mceInternalUrlPrefix = 'data:text/mce-internal,';
      var mceInternalDataType = isIE ? 'Text' : 'URL';
      var setEditorCommandState = function (cmd, state) {
        try {
          editor.getDoc().execCommand(cmd, false, state);
        } catch (ex) {
        }
      };
      var isDefaultPrevented = function (e) {
        return e.isDefaultPrevented();
      };
      var setMceInternalContent = function (e) {
        var selectionHtml, internalContent;
        if (e.dataTransfer) {
          if (editor.selection.isCollapsed() && e.target.tagName === 'IMG') {
            selection.select(e.target);
          }
          selectionHtml = editor.selection.getContent();
          if (selectionHtml.length > 0) {
            internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);
            e.dataTransfer.setData(mceInternalDataType, internalContent);
          }
        }
      };
      var getMceInternalContent = function (e) {
        var internalContent;
        if (e.dataTransfer) {
          internalContent = e.dataTransfer.getData(mceInternalDataType);
          if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
            internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');
            return {
              id: unescape(internalContent[0]),
              html: unescape(internalContent[1])
            };
          }
        }
        return null;
      };
      var insertClipboardContents = function (content, internal) {
        if (editor.queryCommandSupported('mceInsertClipboardContent')) {
          editor.execCommand('mceInsertClipboardContent', false, {
            content: content,
            internal: internal
          });
        } else {
          editor.execCommand('mceInsertContent', false, content);
        }
      };
      var emptyEditorWhenDeleting = function () {
        var serializeRng = function (rng) {
          var body = dom.create('body');
          var contents = rng.cloneContents();
          body.appendChild(contents);
          return selection.serializer.serialize(body, { format: 'html' });
        };
        var allContentsSelected = function (rng) {
          var selection = serializeRng(rng);
          var allRng = dom.createRng();
          allRng.selectNode(editor.getBody());
          var allSelection = serializeRng(allRng);
          return selection === allSelection;
        };
        editor.on('keydown', function (e) {
          var keyCode = e.keyCode;
          var isCollapsed, body;
          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {
            isCollapsed = editor.selection.isCollapsed();
            body = editor.getBody();
            if (isCollapsed && !dom.isEmpty(body)) {
              return;
            }
            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
              return;
            }
            e.preventDefault();
            editor.setContent('');
            if (body.firstChild && dom.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
            editor.nodeChanged();
          }
        });
      };
      var selectAll = function () {
        editor.shortcuts.add('meta+a', null, 'SelectAll');
      };
      var documentElementEditingFocus = function () {
        if (!editor.inline) {
          dom.bind(editor.getDoc(), 'mousedown mouseup', function (e) {
            var rng;
            if (e.target === editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();
              if (e.type === 'mousedown') {
                if (isCaretContainer$2(rng.startContainer)) {
                  return;
                }
                selection.placeCaretAt(e.clientX, e.clientY);
              } else {
                selection.setRng(rng);
              }
            }
          });
        }
      };
      var removeHrOnBackspace = function () {
        editor.on('keydown', function (e) {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (!editor.getBody().getElementsByTagName('hr').length) {
              return;
            }
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              var node = selection.getNode();
              var previousSibling = node.previousSibling;
              if (node.nodeName === 'HR') {
                dom.remove(node);
                e.preventDefault();
                return;
              }
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
                dom.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      };
      var focusBody = function () {
        if (!Range.prototype.getClientRects) {
          editor.on('mousedown', function (e) {
            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
              var body_1 = editor.getBody();
              body_1.blur();
              Delay.setEditorTimeout(editor, function () {
                body_1.focus();
              });
            }
          });
        }
      };
      var selectControlElements = function () {
        editor.on('click', function (e) {
          var target = e.target;
          if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }
          if (target.nodeName === 'A' && dom.hasClass(target, 'mce-item-anchor')) {
            e.preventDefault();
            selection.select(target);
          }
        });
      };
      var removeStylesWhenDeletingAcrossBlockElements = function () {
        var getAttributeApplyFunction = function () {
          var template = dom.getAttribs(selection.getStart().cloneNode(false));
          return function () {
            var target = selection.getStart();
            if (target !== editor.getBody()) {
              dom.setAttrib(target, 'style', null);
              each(template, function (attr) {
                target.setAttributeNode(attr.cloneNode(true));
              });
            }
          };
        };
        var isSelectionAcrossElements = function () {
          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
        };
        editor.on('keypress', function (e) {
          var applyAttributes;
          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();
            editor.getDoc().execCommand('delete', false, null);
            applyAttributes();
            e.preventDefault();
            return false;
          }
        });
        dom.bind(editor.getDoc(), 'cut', function (e) {
          var applyAttributes;
          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();
            Delay.setEditorTimeout(editor, function () {
              applyAttributes();
            });
          }
        });
      };
      var disableBackspaceIntoATable = function () {
        editor.on('keydown', function (e) {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              var previousSibling = selection.getNode().previousSibling;
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
                e.preventDefault();
                return false;
              }
            }
          }
        });
      };
      var removeBlockQuoteOnBackSpace = function () {
        editor.on('keydown', function (e) {
          var rng, parent;
          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
            return;
          }
          rng = selection.getRng();
          var container = rng.startContainer;
          var offset = rng.startOffset;
          var root = dom.getRoot();
          parent = container;
          if (!rng.collapsed || offset !== 0) {
            return;
          }
          while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
            parent = parent.parentNode;
          }
          if (parent.tagName === 'BLOCKQUOTE') {
            editor.formatter.toggle('blockquote', null, parent);
            rng = dom.createRng();
            rng.setStart(container, 0);
            rng.setEnd(container, 0);
            selection.setRng(rng);
          }
        });
      };
      var setGeckoEditingOptions = function () {
        var setOpts = function () {
          setEditorCommandState('StyleWithCSS', false);
          setEditorCommandState('enableInlineTableEditing', false);
          if (!getObjectResizing(editor)) {
            setEditorCommandState('enableObjectResizing', false);
          }
        };
        if (!isReadOnly$1(editor)) {
          editor.on('BeforeExecCommand mousedown', setOpts);
        }
      };
      var addBrAfterLastLinks = function () {
        var fixLinks = function () {
          each(dom.select('a'), function (node) {
            var parentNode = node.parentNode;
            var root = dom.getRoot();
            if (parentNode.lastChild === node) {
              while (parentNode && !dom.isBlock(parentNode)) {
                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                  return;
                }
                parentNode = parentNode.parentNode;
              }
              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
            }
          });
        };
        editor.on('SetContent ExecCommand', function (e) {
          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
            fixLinks();
          }
        });
      };
      var setDefaultBlockType = function () {
        if (getForcedRootBlock(editor)) {
          editor.on('init', function () {
            setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));
          });
        }
      };
      var normalizeSelection = function () {
        editor.on('keyup focusin mouseup', function (e) {
          if (!VK.modifierPressed(e)) {
            selection.normalize();
          }
        }, true);
      };
      var showBrokenImageIcon = function () {
        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');
      };
      var restoreFocusOnKeyDown = function () {
        if (!editor.inline) {
          editor.on('keydown', function () {
            if (document.activeElement === document.body) {
              editor.getWin().focus();
            }
          });
        }
      };
      var bodyHeight = function () {
        if (!editor.inline) {
          editor.contentStyles.push('body {min-height: 150px}');
          editor.on('click', function (e) {
            var rng;
            if (e.target.nodeName === 'HTML') {
              if (Env.ie > 11) {
                editor.getBody().focus();
                return;
              }
              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      };
      var blockCmdArrowNavigation = function () {
        if (Env.mac) {
          editor.on('keydown', function (e) {
            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
              e.preventDefault();
              var selection_1 = editor.selection.getSel();
              selection_1.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
            }
          });
        }
      };
      var disableAutoUrlDetect = function () {
        setEditorCommandState('AutoUrlDetect', false);
      };
      var tapLinksAndImages = function () {
        editor.on('click', function (e) {
          var elm = e.target;
          do {
            if (elm.tagName === 'A') {
              e.preventDefault();
              return;
            }
          } while (elm = elm.parentNode);
        });
        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
      };
      var blockFormSubmitInsideEditor = function () {
        editor.on('init', function () {
          editor.dom.bind(editor.getBody(), 'submit', function (e) {
            e.preventDefault();
          });
        });
      };
      var removeAppleInterchangeBrs = function () {
        parser.addNodeFilter('br', function (nodes) {
          var i = nodes.length;
          while (i--) {
            if (nodes[i].attr('class') === 'Apple-interchange-newline') {
              nodes[i].remove();
            }
          }
        });
      };
      var ieInternalDragAndDrop = function () {
        editor.on('dragstart', function (e) {
          setMceInternalContent(e);
        });
        editor.on('drop', function (e) {
          if (!isDefaultPrevented(e)) {
            var internalContent = getMceInternalContent(e);
            if (internalContent && internalContent.id !== editor.id) {
              e.preventDefault();
              var rng = fromPoint(e.x, e.y, editor.getDoc());
              selection.setRng(rng);
              insertClipboardContents(internalContent.html, true);
            }
          }
        });
      };
      var refreshContentEditable = noop;
      var isHidden = function () {
        if (!isGecko || editor.removed) {
          return false;
        }
        var sel = editor.selection.getSel();
        return !sel || !sel.rangeCount || sel.rangeCount === 0;
      };
      var setupRtc = function () {
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          blockFormSubmitInsideEditor();
          selectAll();
          if (Env.iOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          }
        }
        if (isGecko) {
          focusBody();
          setGeckoEditingOptions();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
        }
      };
      var setup = function () {
        removeBlockQuoteOnBackSpace();
        emptyEditorWhenDeleting();
        if (!Env.windowsPhone) {
          normalizeSelection();
        }
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          setDefaultBlockType();
          blockFormSubmitInsideEditor();
          disableBackspaceIntoATable();
          removeAppleInterchangeBrs();
          if (Env.iOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          } else {
            selectAll();
          }
        }
        if (Env.ie >= 11) {
          bodyHeight();
          disableBackspaceIntoATable();
        }
        if (Env.ie) {
          selectAll();
          disableAutoUrlDetect();
          ieInternalDragAndDrop();
        }
        if (isGecko) {
          removeHrOnBackspace();
          focusBody();
          removeStylesWhenDeletingAcrossBlockElements();
          setGeckoEditingOptions();
          addBrAfterLastLinks();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
          disableBackspaceIntoATable();
        }
      };
      if (isRtc(editor)) {
        setupRtc();
      } else {
        setup();
      }
      return {
        refreshContentEditable: refreshContentEditable,
        isHidden: isHidden
      };
    };

    var DOM$6 = DOMUtils.DOM;
    var appendStyle = function (editor, text) {
      var body = SugarElement.fromDom(editor.getBody());
      var container = getStyleContainer(getRootNode(body));
      var style = SugarElement.fromTag('style');
      set$1(style, 'type', 'text/css');
      append$1(style, SugarElement.fromText(text));
      append$1(container, style);
      editor.on('remove', function () {
        remove$7(style);
      });
    };
    var getRootName = function (editor) {
      return editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
    };
    var removeUndefined = function (obj) {
      return filter$3(obj, function (v) {
        return isUndefined(v) === false;
      });
    };
    var mkParserSettings = function (editor) {
      var settings = editor.settings;
      var blobCache = editor.editorUpload.blobCache;
      return removeUndefined({
        allow_conditional_comments: settings.allow_conditional_comments,
        allow_html_data_urls: settings.allow_html_data_urls,
        allow_svg_data_urls: settings.allow_svg_data_urls,
        allow_html_in_named_anchor: settings.allow_html_in_named_anchor,
        allow_script_urls: settings.allow_script_urls,
        allow_unsafe_link_target: settings.allow_unsafe_link_target,
        convert_fonts_to_spans: settings.convert_fonts_to_spans,
        fix_list_elements: settings.fix_list_elements,
        font_size_legacy_values: settings.font_size_legacy_values,
        forced_root_block: settings.forced_root_block,
        forced_root_block_attrs: settings.forced_root_block_attrs,
        padd_empty_with_br: settings.padd_empty_with_br,
        preserve_cdata: settings.preserve_cdata,
        remove_trailing_brs: settings.remove_trailing_brs,
        inline_styles: settings.inline_styles,
        root_name: getRootName(editor),
        validate: true,
        blob_cache: blobCache,
        document: editor.getDoc(),
        images_dataimg_filter: settings.images_dataimg_filter
      });
    };
    var mkSerializerSettings = function (editor) {
      var settings = editor.settings;
      return __assign(__assign({}, mkParserSettings(editor)), removeUndefined({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope,
        element_format: settings.element_format,
        entities: settings.entities,
        entity_encoding: settings.entity_encoding,
        indent: settings.indent,
        indent_after: settings.indent_after,
        indent_before: settings.indent_before,
        block_elements: settings.block_elements,
        boolean_attributes: settings.boolean_attributes,
        custom_elements: settings.custom_elements,
        extended_valid_elements: settings.extended_valid_elements,
        invalid_elements: settings.invalid_elements,
        invalid_styles: settings.invalid_styles,
        move_caret_before_on_enter_elements: settings.move_caret_before_on_enter_elements,
        non_empty_elements: settings.non_empty_elements,
        schema: settings.schema,
        self_closing_elements: settings.self_closing_elements,
        short_ended_elements: settings.short_ended_elements,
        special: settings.special,
        text_block_elements: settings.text_block_elements,
        text_inline_elements: settings.text_inline_elements,
        valid_children: settings.valid_children,
        valid_classes: settings.valid_classes,
        valid_elements: settings.valid_elements,
        valid_styles: settings.valid_styles,
        verify_html: settings.verify_html,
        whitespace_elements: settings.whitespace_elements
      }));
    };
    var createParser = function (editor) {
      var parser = DomParser(mkParserSettings(editor), editor.schema);
      parser.addAttributeFilter('src,href,style,tabindex', function (nodes, name) {
        var i = nodes.length, node, value;
        var dom = editor.dom;
        var internalName = 'data-mce-' + name;
        while (i--) {
          node = nodes[i];
          value = node.attr(name);
          if (value && !node.attr(internalName)) {
            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
              continue;
            }
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
              if (!value.length) {
                value = null;
              }
              node.attr(internalName, value);
              node.attr(name, value);
            } else if (name === 'tabindex') {
              node.attr(internalName, value);
              node.attr(name, null);
            } else {
              node.attr(internalName, editor.convertURL(value, name, node.name));
            }
          }
        }
      });
      parser.addNodeFilter('script', function (nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          var type = node.attr('type') || 'no/type';
          if (type.indexOf('mce-') !== 0) {
            node.attr('type', 'mce-' + type);
          }
        }
      });
      if (editor.settings.preserve_cdata) {
        parser.addNodeFilter('#cdata', function (nodes) {
          var i = nodes.length;
          while (i--) {
            var node = nodes[i];
            node.type = 8;
            node.name = '#comment';
            node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';
          }
        });
      }
      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (nodes) {
        var i = nodes.length;
        var nonEmptyElements = editor.schema.getNonEmptyElements();
        while (i--) {
          var node = nodes[i];
          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
            node.append(new AstNode('br', 1)).shortEnded = true;
          }
        }
      });
      return parser;
    };
    var autoFocus = function (editor) {
      if (editor.settings.auto_focus) {
        Delay.setEditorTimeout(editor, function () {
          var focusEditor;
          if (editor.settings.auto_focus === true) {
            focusEditor = editor;
          } else {
            focusEditor = editor.editorManager.get(editor.settings.auto_focus);
          }
          if (!focusEditor.destroyed) {
            focusEditor.focus();
          }
        }, 100);
      }
    };
    var moveSelectionToFirstCaretPosition = function (editor) {
      var root = editor.dom.getRoot();
      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
        firstPositionIn(root).each(function (pos) {
          var node = pos.getNode();
          var caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;
          if (Env.browser.isIE()) {
            storeNative(editor, caretPos.toRange());
          } else {
            editor.selection.setRng(caretPos.toRange());
          }
        });
      }
    };
    var initEditor = function (editor) {
      editor.bindPendingEventDelegates();
      editor.initialized = true;
      fireInit(editor);
      editor.focus(true);
      moveSelectionToFirstCaretPosition(editor);
      editor.nodeChanged({ initial: true });
      editor.execCallback('init_instance_callback', editor);
      autoFocus(editor);
    };
    var getStyleSheetLoader$1 = function (editor) {
      return editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    };
    var makeStylesheetLoadingPromises = function (editor, css, framedFonts) {
      var promises = [new promiseObj(function (resolve, reject) {
          return getStyleSheetLoader$1(editor).loadAll(css, resolve, reject);
        })];
      if (editor.inline) {
        return promises;
      } else {
        return promises.concat([new promiseObj(function (resolve, reject) {
            return editor.ui.styleSheetLoader.loadAll(framedFonts, resolve, reject);
          })]);
      }
    };
    var loadContentCss = function (editor) {
      var styleSheetLoader = getStyleSheetLoader$1(editor);
      var fontCss = getFontCss(editor);
      var css = editor.contentCSS;
      var removeCss = function () {
        styleSheetLoader.unloadAll(css);
        if (!editor.inline) {
          editor.ui.styleSheetLoader.unloadAll(fontCss);
        }
      };
      var loaded = function () {
        if (editor.removed) {
          removeCss();
        } else {
          editor.on('remove', removeCss);
        }
      };
      if (editor.contentStyles.length > 0) {
        var contentCssText_1 = '';
        Tools.each(editor.contentStyles, function (style) {
          contentCssText_1 += style + '\r\n';
        });
        editor.dom.addStyle(contentCssText_1);
      }
      var allStylesheets = promiseObj.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
      if (editor.settings.content_style) {
        appendStyle(editor, editor.settings.content_style);
      }
      return allStylesheets;
    };
    var preInit = function (editor) {
      var settings = editor.settings, doc = editor.getDoc(), body = editor.getBody();
      firePreInit(editor);
      if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
        doc.body.spellcheck = false;
        DOM$6.setAttrib(body, 'spellcheck', 'false');
      }
      editor.quirks = Quirks(editor);
      firePostRender(editor);
      var directionality = getDirectionality(editor);
      if (directionality !== undefined) {
        body.dir = directionality;
      }
      if (settings.protect) {
        editor.on('BeforeSetContent', function (e) {
          Tools.each(settings.protect, function (pattern) {
            e.content = e.content.replace(pattern, function (str) {
              return '<!--mce:protected ' + escape(str) + '-->';
            });
          });
        });
      }
      editor.on('SetContent', function () {
        editor.addVisual(editor.getBody());
      });
      editor.on('compositionstart compositionend', function (e) {
        editor.composing = e.type === 'compositionstart';
      });
    };
    var loadInitialContent = function (editor) {
      if (!isRtc(editor)) {
        editor.load({
          initial: true,
          format: 'html'
        });
      }
      editor.startContent = editor.getContent({ format: 'raw' });
    };
    var initEditorWithInitialContent = function (editor) {
      if (editor.removed !== true) {
        loadInitialContent(editor);
        initEditor(editor);
      }
    };
    var initContentBody = function (editor, skipWrite) {
      var settings = editor.settings;
      var targetElm = editor.getElement();
      var doc = editor.getDoc();
      if (!settings.inline) {
        editor.getElement().style.visibility = editor.orgVisibility;
      }
      if (!skipWrite && !editor.inline) {
        doc.open();
        doc.write(editor.iframeHTML);
        doc.close();
      }
      if (editor.inline) {
        DOM$6.addClass(targetElm, 'mce-content-body');
        editor.contentDocument = doc = document;
        editor.contentWindow = window;
        editor.bodyElement = targetElm;
        editor.contentAreaContainer = targetElm;
      }
      var body = editor.getBody();
      body.disabled = true;
      editor.readonly = !!settings.readonly;
      if (!editor.readonly) {
        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {
          body.style.position = 'relative';
        }
        body.contentEditable = editor.getParam('content_editable_state', true);
      }
      body.disabled = false;
      editor.editorUpload = EditorUpload(editor);
      editor.schema = Schema(settings);
      editor.dom = DOMUtils(doc, {
        keep_values: true,
        url_converter: editor.convertURL,
        url_converter_scope: editor,
        hex_colors: settings.force_hex_style_colors,
        update_styles: true,
        root_element: editor.inline ? editor.getBody() : null,
        collect: function () {
          return editor.inline;
        },
        schema: editor.schema,
        contentCssCors: shouldUseContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor),
        onSetAttrib: function (e) {
          editor.fire('SetAttrib', e);
        }
      });
      editor.parser = createParser(editor);
      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.annotator = Annotator(editor);
      editor.formatter = Formatter(editor);
      editor.undoManager = UndoManager(editor);
      editor._nodeChangeDispatcher = new NodeChange(editor);
      editor._selectionOverrides = SelectionOverrides(editor);
      setup$e(editor);
      setup$3(editor);
      if (!isRtc(editor)) {
        setup$2(editor);
      }
      var caret = setup$4(editor);
      setup$f(editor, caret);
      setup$d(editor);
      setup$g(editor);
      var setupRtcThunk = setup$i(editor);
      preInit(editor);
      setupRtcThunk.fold(function () {
        loadContentCss(editor).then(function () {
          return initEditorWithInitialContent(editor);
        });
      }, function (setupRtc) {
        editor.setProgressState(true);
        loadContentCss(editor).then(function () {
          setupRtc().then(function (_rtcMode) {
            editor.setProgressState(false);
            initEditorWithInitialContent(editor);
          }, function (err) {
            editor.notificationManager.open({
              type: 'error',
              text: String(err)
            });
            initEditorWithInitialContent(editor);
          });
        });
      });
    };

    var DOM$5 = DOMUtils.DOM;
    var relaxDomain = function (editor, ifr) {
      if (document.domain !== window.location.hostname && Env.browser.isIE()) {
        var bodyUuid = uuid('mce');
        editor[bodyUuid] = function () {
          initContentBody(editor);
        };
        var domainRelaxUrl = 'javascript:(function(){' + 'document.open();document.domain="' + document.domain + '";' + 'var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);' + 'document.close();ed.' + bodyUuid + '(true);})()';
        DOM$5.setAttrib(ifr, 'src', domainRelaxUrl);
        return true;
      }
      return false;
    };
    var createIframeElement = function (id, title, height, customAttrs) {
      var iframe = SugarElement.fromTag('iframe');
      setAll$1(iframe, customAttrs);
      setAll$1(iframe, {
        id: id + '_ifr',
        frameBorder: '0',
        allowTransparency: 'true',
        title: title
      });
      add$1(iframe, 'tox-edit-area__iframe');
      return iframe;
    };
    var getIframeHtml = function (editor) {
      var iframeHTML = getDocType(editor) + '<html><head>';
      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
      }
      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      var bodyId = getBodyId(editor);
      var bodyClass = getBodyClass(editor);
      var translatedAriaText = editor.translate(getIframeAriaText(editor));
      if (getContentSecurityPolicy(editor)) {
        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
      }
      iframeHTML += '</head>' + ('<body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '" aria-label="' + translatedAriaText + '">') + '<br>' + '</body></html>';
      return iframeHTML;
    };
    var createIframe = function (editor, o) {
      var iframeTitle = editor.translate('Rich Text Area');
      var ifr = createIframeElement(editor.id, iframeTitle, o.height, getIframeAttrs(editor)).dom;
      ifr.onload = function () {
        ifr.onload = null;
        editor.fire('load');
      };
      var isDomainRelaxed = relaxDomain(editor, ifr);
      editor.contentAreaContainer = o.iframeContainer;
      editor.iframeElement = ifr;
      editor.iframeHTML = getIframeHtml(editor);
      DOM$5.add(o.iframeContainer, ifr);
      return isDomainRelaxed;
    };
    var init$1 = function (editor, boxInfo) {
      var isDomainRelaxed = createIframe(editor, boxInfo);
      if (boxInfo.editorContainer) {
        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
      }
      editor.getElement().style.display = 'none';
      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
      if (!isDomainRelaxed) {
        initContentBody(editor);
      }
    };

    var DOM$4 = DOMUtils.DOM;
    var initPlugin = function (editor, initializedPlugins, plugin) {
      var Plugin = PluginManager.get(plugin);
      var pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, '');
      plugin = Tools.trim(plugin);
      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
        Tools.each(PluginManager.dependencies(plugin), function (dep) {
          initPlugin(editor, initializedPlugins, dep);
        });
        if (editor.plugins[plugin]) {
          return;
        }
        try {
          var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
          editor.plugins[plugin] = pluginInstance;
          if (pluginInstance.init) {
            pluginInstance.init(editor, pluginUrl);
            initializedPlugins.push(plugin);
          }
        } catch (e) {
          pluginInitError(editor, plugin, e);
        }
      }
    };
    var trimLegacyPrefix = function (name) {
      return name.replace(/^\-/, '');
    };
    var initPlugins = function (editor) {
      var initializedPlugins = [];
      Tools.each(getPlugins(editor).split(/[ ,]/), function (name) {
        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
      });
    };
    var initIcons = function (editor) {
      var iconPackName = Tools.trim(getIconPackName(editor));
      var currentIcons = editor.ui.registry.getAll().icons;
      var loadIcons = __assign(__assign({}, IconManager.get('default').icons), IconManager.get(iconPackName).icons);
      each$j(loadIcons, function (svgData, icon) {
        if (!has$2(currentIcons, icon)) {
          editor.ui.registry.addIcon(icon, svgData);
        }
      });
    };
    var initTheme = function (editor) {
      var theme = getTheme(editor);
      if (isString$1(theme)) {
        editor.settings.theme = trimLegacyPrefix(theme);
        var Theme = ThemeManager.get(theme);
        editor.theme = new Theme(editor, ThemeManager.urls[theme]);
        if (editor.theme.init) {
          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ''), editor.$);
        }
      } else {
        editor.theme = {};
      }
    };
    var renderFromLoadedTheme = function (editor) {
      return editor.theme.renderUI();
    };
    var renderFromThemeFunc = function (editor) {
      var elm = editor.getElement();
      var theme = getTheme(editor);
      var info = theme(editor, elm);
      if (info.editorContainer.nodeType) {
        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
      }
      if (info.iframeContainer && info.iframeContainer.nodeType) {
        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
      }
      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
      return info;
    };
    var createThemeFalseResult = function (element) {
      return {
        editorContainer: element,
        iframeContainer: element,
        api: {}
      };
    };
    var renderThemeFalseIframe = function (targetElement) {
      var iframeContainer = DOM$4.create('div');
      DOM$4.insertAfter(iframeContainer, targetElement);
      return createThemeFalseResult(iframeContainer);
    };
    var renderThemeFalse = function (editor) {
      var targetElement = editor.getElement();
      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    var renderThemeUi = function (editor) {
      var elm = editor.getElement();
      editor.orgDisplay = elm.style.display;
      if (isString$1(getTheme(editor))) {
        return renderFromLoadedTheme(editor);
      } else if (isFunction(getTheme(editor))) {
        return renderFromThemeFunc(editor);
      } else {
        return renderThemeFalse(editor);
      }
    };
    var augmentEditorUiApi = function (editor, api) {
      var uiApiFacade = {
        show: Optional.from(api.show).getOr(noop),
        hide: Optional.from(api.hide).getOr(noop),
        disable: Optional.from(api.disable).getOr(noop),
        isDisabled: Optional.from(api.isDisabled).getOr(never),
        enable: function () {
          if (!editor.mode.isReadOnly()) {
            Optional.from(api.enable).map(call);
          }
        }
      };
      editor.ui = __assign(__assign({}, editor.ui), uiApiFacade);
    };
    var init = function (editor) {
      editor.fire('ScriptsLoaded');
      initIcons(editor);
      initTheme(editor);
      initPlugins(editor);
      var renderInfo = renderThemeUi(editor);
      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
      var boxInfo = {
        editorContainer: renderInfo.editorContainer,
        iframeContainer: renderInfo.iframeContainer
      };
      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
      appendContentCssFromSettings(editor);
      if (editor.inline) {
        return initContentBody(editor);
      } else {
        return init$1(editor, boxInfo);
      }
    };

    var DOM$3 = DOMUtils.DOM;
    var hasSkipLoadPrefix = function (name) {
      return name.charAt(0) === '-';
    };
    var loadLanguage = function (scriptLoader, editor) {
      var languageCode = getLanguageCode(editor);
      var languageUrl = getLanguageUrl(editor);
      if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {
        var url_1 = languageUrl !== '' ? languageUrl : editor.editorManager.baseURL + '/langs/' + languageCode + '.js';
        scriptLoader.add(url_1, noop, undefined, function () {
          languageLoadError(editor, url_1, languageCode);
        });
      }
    };
    var loadTheme = function (scriptLoader, editor, suffix, callback) {
      var theme = getTheme(editor);
      if (isString$1(theme)) {
        if (!hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
          var themeUrl = getThemeUrl(editor);
          if (themeUrl) {
            ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
          } else {
            ThemeManager.load(theme, 'themes/' + theme + '/theme' + suffix + '.js');
          }
        }
        scriptLoader.loadQueue(function () {
          ThemeManager.waitFor(theme, callback);
        });
      } else {
        callback();
      }
    };
    var getIconsUrlMetaFromUrl = function (editor) {
      return Optional.from(getIconsUrl(editor)).filter(function (url) {
        return url.length > 0;
      }).map(function (url) {
        return {
          url: url,
          name: Optional.none()
        };
      });
    };
    var getIconsUrlMetaFromName = function (editor, name, suffix) {
      return Optional.from(name).filter(function (name) {
        return name.length > 0 && !IconManager.has(name);
      }).map(function (name) {
        return {
          url: editor.editorManager.baseURL + '/icons/' + name + '/icons' + suffix + '.js',
          name: Optional.some(name)
        };
      });
    };
    var loadIcons = function (scriptLoader, editor, suffix) {
      var defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);
      var customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(function () {
        return getIconsUrlMetaFromName(editor, getIconPackName(editor), '');
      });
      each$k(cat([
        defaultIconsUrl,
        customIconsUrl
      ]), function (urlMeta) {
        scriptLoader.add(urlMeta.url, noop, undefined, function () {
          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
        });
      });
    };
    var loadPlugins = function (editor, suffix) {
      Tools.each(getExternalPlugins$1(editor), function (url, name) {
        PluginManager.load(name, url, noop, undefined, function () {
          pluginLoadError(editor, url, name);
        });
        editor.settings.plugins += ' ' + name;
      });
      Tools.each(getPlugins(editor).split(/[ ,]/), function (plugin) {
        plugin = Tools.trim(plugin);
        if (plugin && !PluginManager.urls[plugin]) {
          if (hasSkipLoadPrefix(plugin)) {
            plugin = plugin.substr(1, plugin.length);
            var dependencies = PluginManager.dependencies(plugin);
            Tools.each(dependencies, function (depPlugin) {
              var defaultSettings = {
                prefix: 'plugins/',
                resource: depPlugin,
                suffix: '/plugin' + suffix + '.js'
              };
              var dep = PluginManager.createUrl(defaultSettings, depPlugin);
              PluginManager.load(dep.resource, dep, noop, undefined, function () {
                pluginLoadError(editor, dep.prefix + dep.resource + dep.suffix, dep.resource);
              });
            });
          } else {
            var url_2 = {
              prefix: 'plugins/',
              resource: plugin,
              suffix: '/plugin' + suffix + '.js'
            };
            PluginManager.load(plugin, url_2, noop, undefined, function () {
              pluginLoadError(editor, url_2.prefix + url_2.resource + url_2.suffix, plugin);
            });
          }
        }
      });
    };
    var loadScripts = function (editor, suffix) {
      var scriptLoader = ScriptLoader.ScriptLoader;
      loadTheme(scriptLoader, editor, suffix, function () {
        loadLanguage(scriptLoader, editor);
        loadIcons(scriptLoader, editor, suffix);
        loadPlugins(editor, suffix);
        scriptLoader.loadQueue(function () {
          if (!editor.removed) {
            init(editor);
          }
        }, editor, function () {
          if (!editor.removed) {
            init(editor);
          }
        });
      });
    };
    var getStyleSheetLoader = function (element, editor) {
      return instance.forElement(element, {
        contentCssCors: hasContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor)
      });
    };
    var render = function (editor) {
      var id = editor.id;
      I18n.setCode(getLanguageCode(editor));
      var readyHandler = function () {
        DOM$3.unbind(window, 'ready', readyHandler);
        editor.render();
      };
      if (!EventUtils.Event.domLoaded) {
        DOM$3.bind(window, 'ready', readyHandler);
        return;
      }
      if (!editor.getElement()) {
        return;
      }
      if (!Env.contentEditable) {
        return;
      }
      var element = SugarElement.fromDom(editor.getElement());
      var snapshot = clone$3(element);
      editor.on('remove', function () {
        eachr(element.dom.attributes, function (attr) {
          return remove$6(element, attr.name);
        });
        setAll$1(element, snapshot);
      });
      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
      if (!isInline(editor)) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = 'hidden';
      } else {
        editor.inline = true;
      }
      var form = editor.getElement().form || DOM$3.getParent(id, 'form');
      if (form) {
        editor.formElement = form;
        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
          DOM$3.insertAfter(DOM$3.create('input', {
            type: 'hidden',
            name: id
          }), id);
          editor.hasHiddenInput = true;
        }
        editor.formEventDelegate = function (e) {
          editor.fire(e.type, e);
        };
        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);
        editor.on('reset', function () {
          editor.resetContent();
        });
        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = function () {
            editor.editorManager.triggerSave();
            editor.setDirty(false);
            return form._mceOldSubmit(form);
          };
        }
      }
      editor.windowManager = WindowManager(editor);
      editor.notificationManager = NotificationManager(editor);
      if (isEncodingXml(editor)) {
        editor.on('GetContent', function (e) {
          if (e.save) {
            e.content = DOM$3.encode(e.content);
          }
        });
      }
      if (shouldAddFormSubmitTrigger(editor)) {
        editor.on('submit', function () {
          if (editor.initialized) {
            editor.save();
          }
        });
      }
      if (shouldAddUnloadTrigger(editor)) {
        editor._beforeUnload = function () {
          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
            editor.save({
              format: 'raw',
              no_events: true,
              set_dirty: false
            });
          }
        };
        editor.editorManager.on('BeforeUnload', editor._beforeUnload);
      }
      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };

    var addVisual = function (editor, elm) {
      return addVisual$1(editor, elm);
    };

    var legacyPropNames = {
      'font-size': 'size',
      'font-family': 'face'
    };
    var getSpecifiedFontProp = function (propName, rootElm, elm) {
      var getProperty = function (elm) {
        return getRaw(elm, propName).orThunk(function () {
          if (name(elm) === 'font') {
            return get$9(legacyPropNames, propName).bind(function (legacyPropName) {
              return getOpt(elm, legacyPropName);
            });
          } else {
            return Optional.none();
          }
        });
      };
      var isRoot = function (elm) {
        return eq(SugarElement.fromDom(rootElm), elm);
      };
      return closest$1(SugarElement.fromDom(elm), function (elm) {
        return getProperty(elm);
      }, isRoot);
    };
    var normalizeFontFamily = function (fontFamily) {
      return fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
    };
    var getComputedFontProp = function (propName, elm) {
      return Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    };
    var getFontProp = function (propName) {
      return function (rootElm, elm) {
        return Optional.from(elm).map(SugarElement.fromDom).filter(isElement$6).bind(function (element) {
          return getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom));
        }).getOr('');
      };
    };
    var getFontSize = getFontProp('font-size');
    var getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));

    var findFirstCaretElement = function (editor) {
      return firstPositionIn(editor.getBody()).map(function (caret) {
        var container = caret.container();
        return isText$7(container) ? container.parentNode : container;
      });
    };
    var getCaretElement = function (editor) {
      return Optional.from(editor.selection.getRng()).bind(function (rng) {
        var root = editor.getBody();
        var atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
        return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
      });
    };
    var bindRange = function (editor, binder) {
      return getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$6).bind(binder);
    };
    var mapRange = function (editor, mapper) {
      return bindRange(editor, compose1(Optional.some, mapper));
    };

    var fromFontSizeNumber = function (editor, value) {
      if (/^[0-9.]+$/.test(value)) {
        var fontSizeNumber = parseInt(value, 10);
        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
          var fontSizes = getFontStyleValues(editor);
          var fontClasses = getFontSizeClasses(editor);
          if (fontClasses) {
            return fontClasses[fontSizeNumber - 1] || value;
          } else {
            return fontSizes[fontSizeNumber - 1] || value;
          }
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    var normalizeFontNames = function (font) {
      var fonts = font.split(/\s*,\s*/);
      return map$3(fonts, function (font) {
        if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, '\''))) {
          return '\'' + font + '\'';
        } else {
          return font;
        }
      }).join(',');
    };
    var fontNameAction = function (editor, value) {
      var font = fromFontSizeNumber(editor, value);
      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
      editor.nodeChanged();
    };
    var fontNameQuery = function (editor) {
      return mapRange(editor, function (elm) {
        return getFontFamily(editor.getBody(), elm.dom);
      }).getOr('');
    };
    var fontSizeAction = function (editor, value) {
      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
      editor.nodeChanged();
    };
    var fontSizeQuery = function (editor) {
      return mapRange(editor, function (elm) {
        return getFontSize(editor.getBody(), elm.dom);
      }).getOr('');
    };

    var lineHeightQuery = function (editor) {
      return mapRange(editor, function (elm) {
        var root = SugarElement.fromDom(editor.getBody());
        var specifiedStyle = closest$1(elm, function (elm) {
          return getRaw(elm, 'line-height');
        }, curry(eq, root));
        var computedStyle = function () {
          var lineHeight = parseFloat(get$5(elm, 'line-height'));
          var fontSize = parseFloat(get$5(elm, 'font-size'));
          return String(lineHeight / fontSize);
        };
        return specifiedStyle.getOrThunk(computedStyle);
      }).getOr('');
    };
    var lineHeightAction = function (editor, lineHeight) {
      editor.formatter.toggle('lineheight', { value: String(lineHeight) });
      editor.nodeChanged();
    };

    var processValue = function (value) {
      if (typeof value !== 'string') {
        var details = Tools.extend({
          paste: value.paste,
          data: { paste: value.paste }
        }, value);
        return {
          content: value.content,
          details: details
        };
      }
      return {
        content: value,
        details: {}
      };
    };
    var insertAtCaret = function (editor, value) {
      var result = processValue(value);
      insertContent(editor, result.content, result.details);
    };

    var each$4 = Tools.each;
    var map = Tools.map, inArray = Tools.inArray;
    var EditorCommands = function () {
      function EditorCommands(editor) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        };
        this.editor = editor;
        this.setupCommands(editor);
      }
      EditorCommands.prototype.execCommand = function (command, ui, value, args) {
        var func, state = false;
        var self = this;
        if (self.editor.removed) {
          return;
        }
        if (command.toLowerCase() !== 'mcefocus') {
          if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
            self.editor.focus();
          } else {
            restore(self.editor);
          }
        }
        args = self.editor.fire('BeforeExecCommand', {
          command: command,
          ui: ui,
          value: value
        });
        if (args.isDefaultPrevented()) {
          return false;
        }
        var customCommand = command.toLowerCase();
        if (func = self.commands.exec[customCommand]) {
          func(customCommand, ui, value);
          self.editor.fire('ExecCommand', {
            command: command,
            ui: ui,
            value: value
          });
          return true;
        }
        each$4(this.editor.plugins, function (p) {
          if (p.execCommand && p.execCommand(command, ui, value)) {
            self.editor.fire('ExecCommand', {
              command: command,
              ui: ui,
              value: value
            });
            state = true;
            return false;
          }
        });
        if (state) {
          return state;
        }
        if (self.editor.theme && self.editor.theme.execCommand && self.editor.theme.execCommand(command, ui, value)) {
          self.editor.fire('ExecCommand', {
            command: command,
            ui: ui,
            value: value
          });
          return true;
        }
        try {
          state = self.editor.getDoc().execCommand(command, ui, value);
        } catch (ex) {
        }
        if (state) {
          self.editor.fire('ExecCommand', {
            command: command,
            ui: ui,
            value: value
          });
          return true;
        }
        return false;
      };
      EditorCommands.prototype.queryCommandState = function (command) {
        var func;
        if (this.editor.quirks.isHidden() || this.editor.removed) {
          return;
        }
        command = command.toLowerCase();
        if (func = this.commands.state[command]) {
          return func(command);
        }
        try {
          return this.editor.getDoc().queryCommandState(command);
        } catch (ex) {
        }
        return false;
      };
      EditorCommands.prototype.queryCommandValue = function (command) {
        var func;
        if (this.editor.quirks.isHidden() || this.editor.removed) {
          return;
        }
        command = command.toLowerCase();
        if (func = this.commands.value[command]) {
          return func(command);
        }
        try {
          return this.editor.getDoc().queryCommandValue(command);
        } catch (ex) {
        }
      };
      EditorCommands.prototype.addCommands = function (commandList, type) {
        if (type === void 0) {
          type = 'exec';
        }
        var self = this;
        each$4(commandList, function (callback, command) {
          each$4(command.toLowerCase().split(','), function (command) {
            self.commands[type][command] = callback;
          });
        });
      };
      EditorCommands.prototype.addCommand = function (command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.exec[command] = function (command, ui, value, args) {
          return callback.call(scope || _this.editor, ui, value, args);
        };
      };
      EditorCommands.prototype.queryCommandSupported = function (command) {
        command = command.toLowerCase();
        if (this.commands.exec[command]) {
          return true;
        }
        try {
          return this.editor.getDoc().queryCommandSupported(command);
        } catch (ex) {
        }
        return false;
      };
      EditorCommands.prototype.addQueryStateHandler = function (command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.state[command] = function () {
          return callback.call(scope || _this.editor);
        };
      };
      EditorCommands.prototype.addQueryValueHandler = function (command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.value[command] = function () {
          return callback.call(scope || _this.editor);
        };
      };
      EditorCommands.prototype.hasCustomCommand = function (command) {
        command = command.toLowerCase();
        return !!this.commands.exec[command];
      };
      EditorCommands.prototype.execNativeCommand = function (command, ui, value) {
        if (ui === undefined) {
          ui = false;
        }
        if (value === undefined) {
          value = null;
        }
        return this.editor.getDoc().execCommand(command, ui, value);
      };
      EditorCommands.prototype.isFormatMatch = function (name) {
        return this.editor.formatter.match(name);
      };
      EditorCommands.prototype.toggleFormat = function (name, value) {
        this.editor.formatter.toggle(name, value);
        this.editor.nodeChanged();
      };
      EditorCommands.prototype.storeSelection = function (type) {
        this.selectionBookmark = this.editor.selection.getBookmark(type);
      };
      EditorCommands.prototype.restoreSelection = function () {
        this.editor.selection.moveToBookmark(this.selectionBookmark);
      };
      EditorCommands.prototype.setupCommands = function (editor) {
        var self = this;
        this.addCommands({
          'mceResetDesignMode,mceBeginUndoLevel': noop,
          'mceEndUndoLevel,mceAddUndoLevel': function () {
            editor.undoManager.add();
          },
          'mceFocus': function (_command, _ui, value) {
            focus(editor, value);
          },
          'Cut,Copy,Paste': function (command) {
            var doc = editor.getDoc();
            var failed;
            try {
              self.execNativeCommand(command);
            } catch (ex) {
              failed = true;
            }
            if (command === 'paste' && !doc.queryCommandEnabled(command)) {
              failed = true;
            }
            if (failed || !doc.queryCommandSupported(command)) {
              var msg = editor.translate('Your browser doesn\'t support direct access to the clipboard. ' + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
              if (Env.mac) {
                msg = msg.replace(/Ctrl\+/g, '\u2318+');
              }
              editor.notificationManager.open({
                text: msg,
                type: 'error'
              });
            }
          },
          'unlink': function () {
            if (editor.selection.isCollapsed()) {
              var elm = editor.dom.getParent(editor.selection.getStart(), 'a');
              if (elm) {
                editor.dom.remove(elm, true);
              }
              return;
            }
            editor.formatter.remove('link');
          },
          'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone': function (command) {
            var align = command.substring(7);
            if (align === 'full') {
              align = 'justify';
            }
            each$4('left,center,right,justify'.split(','), function (name) {
              if (align !== name) {
                editor.formatter.remove('align' + name);
              }
            });
            if (align !== 'none') {
              self.toggleFormat('align' + align);
            }
          },
          'InsertUnorderedList,InsertOrderedList': function (command) {
            var listParent;
            self.execNativeCommand(command);
            var listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');
            if (listElm) {
              listParent = listElm.parentNode;
              if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                self.storeSelection();
                editor.dom.split(listParent, listElm);
                self.restoreSelection();
              }
            }
          },
          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
            self.toggleFormat(command);
          },
          'ForeColor,HiliteColor': function (command, ui, value) {
            self.toggleFormat(command, { value: value });
          },
          'FontName': function (command, ui, value) {
            fontNameAction(editor, value);
          },
          'FontSize': function (command, ui, value) {
            fontSizeAction(editor, value);
          },
          'LineHeight': function (command, ui, value) {
            lineHeightAction(editor, value);
          },
          'Lang': function (command, ui, lang) {
            self.toggleFormat(command, {
              value: lang.code,
              customValue: lang.customCode
            });
          },
          'RemoveFormat': function (command) {
            editor.formatter.remove(command);
          },
          'mceBlockQuote': function () {
            self.toggleFormat('blockquote');
          },
          'FormatBlock': function (command, ui, value) {
            return self.toggleFormat(value || 'p');
          },
          'mceCleanup': function () {
            var bookmark = editor.selection.getBookmark();
            editor.setContent(editor.getContent());
            editor.selection.moveToBookmark(bookmark);
          },
          'mceRemoveNode': function (command, ui, value) {
            var node = value || editor.selection.getNode();
            if (node !== editor.getBody()) {
              self.storeSelection();
              editor.dom.remove(node, true);
              self.restoreSelection();
            }
          },
          'mceSelectNodeDepth': function (command, ui, value) {
            var counter = 0;
            editor.dom.getParent(editor.selection.getNode(), function (node) {
              if (node.nodeType === 1 && counter++ === value) {
                editor.selection.select(node);
                return false;
              }
            }, editor.getBody());
          },
          'mceSelectNode': function (command, ui, value) {
            editor.selection.select(value);
          },
          'mceInsertContent': function (command, ui, value) {
            insertAtCaret(editor, value);
          },
          'mceInsertRawHTML': function (command, ui, value) {
            editor.selection.setContent('tiny_mce_marker');
            var content = editor.getContent();
            editor.setContent(content.replace(/tiny_mce_marker/g, function () {
              return value;
            }));
          },
          'mceInsertNewLine': function (command, ui, value) {
            insert(editor, value);
          },
          'mceToggleFormat': function (command, ui, value) {
            self.toggleFormat(value);
          },
          'mceSetContent': function (command, ui, value) {
            editor.setContent(value);
          },
          'Indent,Outdent': function (command) {
            handle(editor, command);
          },
          'mceRepaint': noop,
          'InsertHorizontalRule': function () {
            editor.execCommand('mceInsertContent', false, '<hr />');
          },
          'mceToggleVisualAid': function () {
            editor.hasVisual = !editor.hasVisual;
            editor.addVisual();
          },
          'mceReplaceContent': function (command, ui, value) {
            editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
          },
          'mceInsertLink': function (command, ui, value) {
            if (typeof value === 'string') {
              value = { href: value };
            }
            var anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
            value.href = value.href.replace(/ /g, '%20');
            if (!anchor || !value.href) {
              editor.formatter.remove('link');
            }
            if (value.href) {
              editor.formatter.apply('link', value, anchor);
            }
          },
          'selectAll': function () {
            var editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$4);
            if (editingHost) {
              var rng = editor.dom.createRng();
              rng.selectNodeContents(editingHost);
              editor.selection.setRng(rng);
            }
          },
          'mceNewDocument': function () {
            editor.setContent('');
          },
          'InsertLineBreak': function (command, ui, value) {
            insert$1(editor, value);
            return true;
          }
        });
        var alignStates = function (name) {
          return function () {
            var selection = editor.selection;
            var nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
            var matches = map(nodes, function (node) {
              return !!editor.formatter.matchNode(node, name);
            });
            return inArray(matches, true) !== -1;
          };
        };
        self.addCommands({
          'JustifyLeft': alignStates('alignleft'),
          'JustifyCenter': alignStates('aligncenter'),
          'JustifyRight': alignStates('alignright'),
          'JustifyFull': alignStates('alignjustify'),
          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
            return self.isFormatMatch(command);
          },
          'mceBlockQuote': function () {
            return self.isFormatMatch('blockquote');
          },
          'Outdent': function () {
            return canOutdent(editor);
          },
          'InsertUnorderedList,InsertOrderedList': function (command) {
            var list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');
            return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');
          }
        }, 'state');
        self.addCommands({
          Undo: function () {
            editor.undoManager.undo();
          },
          Redo: function () {
            editor.undoManager.redo();
          }
        });
        self.addQueryValueHandler('FontName', function () {
          return fontNameQuery(editor);
        }, this);
        self.addQueryValueHandler('FontSize', function () {
          return fontSizeQuery(editor);
        }, this);
        self.addQueryValueHandler('LineHeight', function () {
          return lineHeightQuery(editor);
        }, this);
      };
      return EditorCommands;
    }();

    var internalContentEditableAttr = 'data-mce-contenteditable';
    var toggleClass = function (elm, cls, state) {
      if (has(elm, cls) && state === false) {
        remove$3(elm, cls);
      } else if (state) {
        add$1(elm, cls);
      }
    };
    var setEditorCommandState = function (editor, cmd, state) {
      try {
        editor.getDoc().execCommand(cmd, false, String(state));
      } catch (ex) {
      }
    };
    var setContentEditable = function (elm, state) {
      elm.dom.contentEditable = state ? 'true' : 'false';
    };
    var switchOffContentEditableTrue = function (elm) {
      each$k(descendants(elm, '*[contenteditable="true"]'), function (elm) {
        set$1(elm, internalContentEditableAttr, 'true');
        setContentEditable(elm, false);
      });
    };
    var switchOnContentEditableTrue = function (elm) {
      each$k(descendants(elm, '*[' + internalContentEditableAttr + '="true"]'), function (elm) {
        remove$6(elm, internalContentEditableAttr);
        setContentEditable(elm, true);
      });
    };
    var removeFakeSelection = function (editor) {
      Optional.from(editor.selection.getNode()).each(function (elm) {
        elm.removeAttribute('data-mce-selected');
      });
    };
    var restoreFakeSelection = function (editor) {
      editor.selection.setRng(editor.selection.getRng());
    };
    var toggleReadOnly = function (editor, state) {
      var body = SugarElement.fromDom(editor.getBody());
      toggleClass(body, 'mce-content-readonly', state);
      if (state) {
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
        editor.readonly = true;
        setContentEditable(body, false);
        switchOffContentEditableTrue(body);
      } else {
        editor.readonly = false;
        setContentEditable(body, true);
        switchOnContentEditableTrue(body);
        setEditorCommandState(editor, 'StyleWithCSS', false);
        setEditorCommandState(editor, 'enableInlineTableEditing', false);
        setEditorCommandState(editor, 'enableObjectResizing', false);
        if (hasEditorOrUiFocus(editor)) {
          editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
      }
    };
    var isReadOnly = function (editor) {
      return editor.readonly;
    };
    var registerFilters = function (editor) {
      editor.parser.addAttributeFilter('contenteditable', function (nodes) {
        if (isReadOnly(editor)) {
          each$k(nodes, function (node) {
            node.attr(internalContentEditableAttr, node.attr('contenteditable'));
            node.attr('contenteditable', 'false');
          });
        }
      });
      editor.serializer.addAttributeFilter(internalContentEditableAttr, function (nodes) {
        if (isReadOnly(editor)) {
          each$k(nodes, function (node) {
            node.attr('contenteditable', node.attr(internalContentEditableAttr));
          });
        }
      });
      editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    var registerReadOnlyContentFilters = function (editor) {
      if (editor.serializer) {
        registerFilters(editor);
      } else {
        editor.on('PreInit', function () {
          registerFilters(editor);
        });
      }
    };
    var isClickEvent = function (e) {
      return e.type === 'click';
    };
    var getAnchorHrefOpt = function (editor, elm) {
      var isRoot = function (elm) {
        return eq(elm, SugarElement.fromDom(editor.getBody()));
      };
      return closest$2(elm, 'a', isRoot).bind(function (a) {
        return getOpt(a, 'href');
      });
    };
    var processReadonlyEvents = function (editor, e) {
      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
        var elm = SugarElement.fromDom(e.target);
        getAnchorHrefOpt(editor, elm).each(function (href) {
          e.preventDefault();
          if (/^#/.test(href)) {
            var targetEl = editor.dom.select(href + ',[name="' + removeLeading(href, '#') + '"]');
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');
          }
        });
      }
    };
    var registerReadOnlySelectionBlockers = function (editor) {
      editor.on('ShowCaret', function (e) {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
      editor.on('ObjectSelected', function (e) {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
    };

    var nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
    var EventDispatcher = function () {
      function EventDispatcher(settings) {
        this.bindings = {};
        this.settings = settings || {};
        this.scope = this.settings.scope || this;
        this.toggleEvent = this.settings.toggleEvent || never;
      }
      EventDispatcher.isNative = function (name) {
        return !!nativeEvents[name.toLowerCase()];
      };
      EventDispatcher.prototype.fire = function (name, args) {
        var lcName = name.toLowerCase();
        var event = normalize$3(lcName, args || {}, this.scope);
        if (this.settings.beforeFire) {
          this.settings.beforeFire(event);
        }
        var handlers = this.bindings[lcName];
        if (handlers) {
          for (var i = 0, l = handlers.length; i < l; i++) {
            var callback = handlers[i];
            if (callback.removed) {
              continue;
            }
            if (callback.once) {
              this.off(lcName, callback.func);
            }
            if (event.isImmediatePropagationStopped()) {
              return event;
            }
            if (callback.func.call(this.scope, event) === false) {
              event.preventDefault();
              return event;
            }
          }
        }
        return event;
      };
      EventDispatcher.prototype.on = function (name, callback, prepend, extra) {
        if (callback === false) {
          callback = never;
        }
        if (callback) {
          var wrappedCallback = {
            func: callback,
            removed: false
          };
          if (extra) {
            Tools.extend(wrappedCallback, extra);
          }
          var names = name.toLowerCase().split(' ');
          var i = names.length;
          while (i--) {
            var currentName = names[i];
            var handlers = this.bindings[currentName];
            if (!handlers) {
              handlers = [];
              this.toggleEvent(currentName, true);
            }
            if (prepend) {
              handlers = __spreadArray([wrappedCallback], handlers, true);
            } else {
              handlers = __spreadArray(__spreadArray([], handlers, true), [wrappedCallback], false);
            }
            this.bindings[currentName] = handlers;
          }
        }
        return this;
      };
      EventDispatcher.prototype.off = function (name, callback) {
        var _this = this;
        if (name) {
          var names = name.toLowerCase().split(' ');
          var i = names.length;
          while (i--) {
            var currentName = names[i];
            var handlers = this.bindings[currentName];
            if (!currentName) {
              each$j(this.bindings, function (_value, bindingName) {
                _this.toggleEvent(bindingName, false);
                delete _this.bindings[bindingName];
              });
              return this;
            }
            if (handlers) {
              if (!callback) {
                handlers.length = 0;
              } else {
                var filteredHandlers = partition(handlers, function (handler) {
                  return handler.func === callback;
                });
                handlers = filteredHandlers.fail;
                this.bindings[currentName] = handlers;
                each$k(filteredHandlers.pass, function (handler) {
                  handler.removed = true;
                });
              }
              if (!handlers.length) {
                this.toggleEvent(name, false);
                delete this.bindings[currentName];
              }
            }
          }
        } else {
          each$j(this.bindings, function (_value, name) {
            _this.toggleEvent(name, false);
          });
          this.bindings = {};
        }
        return this;
      };
      EventDispatcher.prototype.once = function (name, callback, prepend) {
        return this.on(name, callback, prepend, { once: true });
      };
      EventDispatcher.prototype.has = function (name) {
        name = name.toLowerCase();
        return !(!this.bindings[name] || this.bindings[name].length === 0);
      };
      return EventDispatcher;
    }();

    var getEventDispatcher = function (obj) {
      if (!obj._eventDispatcher) {
        obj._eventDispatcher = new EventDispatcher({
          scope: obj,
          toggleEvent: function (name, state) {
            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name, state);
            }
          }
        });
      }
      return obj._eventDispatcher;
    };
    var Observable = {
      fire: function (name, args, bubble) {
        var self = this;
        if (self.removed && name !== 'remove' && name !== 'detach') {
          return args;
        }
        var dispatcherArgs = getEventDispatcher(self).fire(name, args);
        if (bubble !== false && self.parent) {
          var parent_1 = self.parent();
          while (parent_1 && !dispatcherArgs.isPropagationStopped()) {
            parent_1.fire(name, dispatcherArgs, false);
            parent_1 = parent_1.parent();
          }
        }
        return dispatcherArgs;
      },
      on: function (name, callback, prepend) {
        return getEventDispatcher(this).on(name, callback, prepend);
      },
      off: function (name, callback) {
        return getEventDispatcher(this).off(name, callback);
      },
      once: function (name, callback) {
        return getEventDispatcher(this).once(name, callback);
      },
      hasEventListeners: function (name) {
        return getEventDispatcher(this).has(name);
      }
    };

    var DOM$2 = DOMUtils.DOM;
    var customEventRootDelegates;
    var getEventTarget = function (editor, eventName) {
      if (eventName === 'selectionchange') {
        return editor.getDoc();
      }
      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
        return editor.getDoc().documentElement;
      }
      var eventRoot = getEventRoot(editor);
      if (eventRoot) {
        if (!editor.eventRoot) {
          editor.eventRoot = DOM$2.select(eventRoot)[0];
        }
        return editor.eventRoot;
      }
      return editor.getBody();
    };
    var isListening = function (editor) {
      return !editor.hidden && !isReadOnly(editor);
    };
    var fireEvent = function (editor, eventName, e) {
      if (isListening(editor)) {
        editor.fire(eventName, e);
      } else if (isReadOnly(editor)) {
        processReadonlyEvents(editor, e);
      }
    };
    var bindEventDelegate = function (editor, eventName) {
      var delegate;
      if (!editor.delegates) {
        editor.delegates = {};
      }
      if (editor.delegates[eventName] || editor.removed) {
        return;
      }
      var eventRootElm = getEventTarget(editor, eventName);
      if (getEventRoot(editor)) {
        if (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on('removeEditor', function () {
            if (!editor.editorManager.activeEditor) {
              if (customEventRootDelegates) {
                each$j(customEventRootDelegates, function (_value, name) {
                  editor.dom.unbind(getEventTarget(editor, name));
                });
                customEventRootDelegates = null;
              }
            }
          });
        }
        if (customEventRootDelegates[eventName]) {
          return;
        }
        delegate = function (e) {
          var target = e.target;
          var editors = editor.editorManager.get();
          var i = editors.length;
          while (i--) {
            var body = editors[i].getBody();
            if (body === target || DOM$2.isChildOf(target, body)) {
              fireEvent(editors[i], eventName, e);
            }
          }
        };
        customEventRootDelegates[eventName] = delegate;
        DOM$2.bind(eventRootElm, eventName, delegate);
      } else {
        delegate = function (e) {
          fireEvent(editor, eventName, e);
        };
        DOM$2.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    };
    var EditorObservable = __assign(__assign({}, Observable), {
      bindPendingEventDelegates: function () {
        var self = this;
        Tools.each(self._pendingNativeEvents, function (name) {
          bindEventDelegate(self, name);
        });
      },
      toggleNativeEvent: function (name, state) {
        var self = this;
        if (name === 'focus' || name === 'blur') {
          return;
        }
        if (self.removed) {
          return;
        }
        if (state) {
          if (self.initialized) {
            bindEventDelegate(self, name);
          } else {
            if (!self._pendingNativeEvents) {
              self._pendingNativeEvents = [name];
            } else {
              self._pendingNativeEvents.push(name);
            }
          }
        } else if (self.initialized) {
          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
          delete self.delegates[name];
        }
      },
      unbindAllNativeEvents: function () {
        var self = this;
        var body = self.getBody();
        var dom = self.dom;
        if (self.delegates) {
          each$j(self.delegates, function (value, name) {
            self.dom.unbind(getEventTarget(self, name), name, value);
          });
          delete self.delegates;
        }
        if (!self.inline && body && dom) {
          body.onload = null;
          dom.unbind(self.getWin());
          dom.unbind(self.getDoc());
        }
        if (dom) {
          dom.unbind(body);
          dom.unbind(self.getContainer());
        }
      }
    });

    var defaultModes = [
      'design',
      'readonly'
    ];
    var switchToMode = function (editor, activeMode, availableModes, mode) {
      var oldMode = availableModes[activeMode.get()];
      var newMode = availableModes[mode];
      try {
        newMode.activate();
      } catch (e) {
        console.error('problem while activating editor mode ' + mode + ':', e);
        return;
      }
      oldMode.deactivate();
      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
        toggleReadOnly(editor, newMode.editorReadOnly);
      }
      activeMode.set(mode);
      fireSwitchMode(editor, mode);
    };
    var setMode = function (editor, availableModes, activeMode, mode) {
      if (mode === activeMode.get()) {
        return;
      } else if (!has$2(availableModes, mode)) {
        throw new Error('Editor mode \'' + mode + '\' is invalid');
      }
      if (editor.initialized) {
        switchToMode(editor, activeMode, availableModes, mode);
      } else {
        editor.on('init', function () {
          return switchToMode(editor, activeMode, availableModes, mode);
        });
      }
    };
    var registerMode = function (availableModes, mode, api) {
      var _a;
      if (contains$3(defaultModes, mode)) {
        throw new Error('Cannot override default mode ' + mode);
      }
      return __assign(__assign({}, availableModes), (_a = {}, _a[mode] = __assign(__assign({}, api), {
        deactivate: function () {
          try {
            api.deactivate();
          } catch (e) {
            console.error('problem while deactivating editor mode ' + mode + ':', e);
          }
        }
      }), _a));
    };

    var create$4 = function (editor) {
      var activeMode = Cell('design');
      var availableModes = Cell({
        design: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: false
        },
        readonly: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: true
        }
      });
      registerReadOnlyContentFilters(editor);
      registerReadOnlySelectionBlockers(editor);
      return {
        isReadOnly: function () {
          return isReadOnly(editor);
        },
        set: function (mode) {
          return setMode(editor, availableModes.get(), activeMode, mode);
        },
        get: function () {
          return activeMode.get();
        },
        register: function (mode, api) {
          availableModes.set(registerMode(availableModes.get(), mode, api));
        }
      };
    };

    var each$3 = Tools.each, explode$1 = Tools.explode;
    var keyCodeLookup = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    };
    var modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
    var parseShortcut = function (pattern) {
      var key;
      var shortcut = {};
      each$3(explode$1(pattern.toLowerCase(), '+'), function (value) {
        if (value in modifierNames) {
          shortcut[value] = true;
        } else {
          if (/^[0-9]{2,}$/.test(value)) {
            shortcut.keyCode = parseInt(value, 10);
          } else {
            shortcut.charCode = value.charCodeAt(0);
            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
          }
        }
      });
      var id = [shortcut.keyCode];
      for (key in modifierNames) {
        if (shortcut[key]) {
          id.push(key);
        } else {
          shortcut[key] = false;
        }
      }
      shortcut.id = id.join(',');
      if (shortcut.access) {
        shortcut.alt = true;
        if (Env.mac) {
          shortcut.ctrl = true;
        } else {
          shortcut.shift = true;
        }
      }
      if (shortcut.meta) {
        if (Env.mac) {
          shortcut.meta = true;
        } else {
          shortcut.ctrl = true;
          shortcut.meta = false;
        }
      }
      return shortcut;
    };
    var Shortcuts = function () {
      function Shortcuts(editor) {
        this.shortcuts = {};
        this.pendingPatterns = [];
        this.editor = editor;
        var self = this;
        editor.on('keyup keypress keydown', function (e) {
          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
            each$3(self.shortcuts, function (shortcut) {
              if (self.matchShortcut(e, shortcut)) {
                self.pendingPatterns = shortcut.subpatterns.slice(0);
                if (e.type === 'keydown') {
                  self.executeShortcutAction(shortcut);
                }
                return true;
              }
            });
            if (self.matchShortcut(e, self.pendingPatterns[0])) {
              if (self.pendingPatterns.length === 1) {
                if (e.type === 'keydown') {
                  self.executeShortcutAction(self.pendingPatterns[0]);
                }
              }
              self.pendingPatterns.shift();
            }
          }
        });
      }
      Shortcuts.prototype.add = function (pattern, desc, cmdFunc, scope) {
        var self = this;
        var func = self.normalizeCommandFunc(cmdFunc);
        each$3(explode$1(Tools.trim(pattern)), function (pattern) {
          var shortcut = self.createShortcut(pattern, desc, func, scope);
          self.shortcuts[shortcut.id] = shortcut;
        });
        return true;
      };
      Shortcuts.prototype.remove = function (pattern) {
        var shortcut = this.createShortcut(pattern);
        if (this.shortcuts[shortcut.id]) {
          delete this.shortcuts[shortcut.id];
          return true;
        }
        return false;
      };
      Shortcuts.prototype.normalizeCommandFunc = function (cmdFunc) {
        var self = this;
        var cmd = cmdFunc;
        if (typeof cmd === 'string') {
          return function () {
            self.editor.execCommand(cmd, false, null);
          };
        } else if (Tools.isArray(cmd)) {
          return function () {
            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        } else {
          return cmd;
        }
      };
      Shortcuts.prototype.createShortcut = function (pattern, desc, cmdFunc, scope) {
        var shortcuts = Tools.map(explode$1(pattern, '>'), parseShortcut);
        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
          func: cmdFunc,
          scope: scope || this.editor
        });
        return Tools.extend(shortcuts[0], {
          desc: this.editor.translate(desc),
          subpatterns: shortcuts.slice(1)
        });
      };
      Shortcuts.prototype.hasModifier = function (e) {
        return e.altKey || e.ctrlKey || e.metaKey;
      };
      Shortcuts.prototype.isFunctionKey = function (e) {
        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
      };
      Shortcuts.prototype.matchShortcut = function (e, shortcut) {
        if (!shortcut) {
          return false;
        }
        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
          return false;
        }
        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
          return false;
        }
        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
          e.preventDefault();
          return true;
        }
        return false;
      };
      Shortcuts.prototype.executeShortcutAction = function (shortcut) {
        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
      };
      return Shortcuts;
    }();

    var create$3 = function () {
      var buttons = {};
      var menuItems = {};
      var popups = {};
      var icons = {};
      var contextMenus = {};
      var contextToolbars = {};
      var sidebars = {};
      var add = function (collection, type) {
        return function (name, spec) {
          return collection[name.toLowerCase()] = __assign(__assign({}, spec), { type: type });
        };
      };
      var addIcon = function (name, svgData) {
        return icons[name.toLowerCase()] = svgData;
      };
      return {
        addButton: add(buttons, 'button'),
        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
        addToggleButton: add(buttons, 'togglebutton'),
        addMenuButton: add(buttons, 'menubutton'),
        addSplitButton: add(buttons, 'splitbutton'),
        addMenuItem: add(menuItems, 'menuitem'),
        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
        addToggleMenuItem: add(menuItems, 'togglemenuitem'),
        addAutocompleter: add(popups, 'autocompleter'),
        addContextMenu: add(contextMenus, 'contextmenu'),
        addContextToolbar: add(contextToolbars, 'contexttoolbar'),
        addContextForm: add(contextToolbars, 'contextform'),
        addSidebar: add(sidebars, 'sidebar'),
        addIcon: addIcon,
        getAll: function () {
          return {
            buttons: buttons,
            menuItems: menuItems,
            icons: icons,
            popups: popups,
            contextMenus: contextMenus,
            contextToolbars: contextToolbars,
            sidebars: sidebars
          };
        }
      };
    };

    var registry = function () {
      var bridge = create$3();
      return {
        addAutocompleter: bridge.addAutocompleter,
        addButton: bridge.addButton,
        addContextForm: bridge.addContextForm,
        addContextMenu: bridge.addContextMenu,
        addContextToolbar: bridge.addContextToolbar,
        addIcon: bridge.addIcon,
        addMenuButton: bridge.addMenuButton,
        addMenuItem: bridge.addMenuItem,
        addNestedMenuItem: bridge.addNestedMenuItem,
        addSidebar: bridge.addSidebar,
        addSplitButton: bridge.addSplitButton,
        addToggleButton: bridge.addToggleButton,
        addGroupToolbarButton: bridge.addGroupToolbarButton,
        addToggleMenuItem: bridge.addToggleMenuItem,
        getAll: bridge.getAll
      };
    };

    var DOM$1 = DOMUtils.DOM;
    var extend$3 = Tools.extend, each$2 = Tools.each;
    var resolve = Tools.resolve;
    var ie = Env.ie;
    var Editor = function () {
      function Editor(id, settings, editorManager) {
        var _this = this;
        this.plugins = {};
        this.contentCSS = [];
        this.contentStyles = [];
        this.loadedCSS = {};
        this.isNotDirty = false;
        this.editorManager = editorManager;
        this.documentBaseUrl = editorManager.documentBaseURL;
        extend$3(this, EditorObservable);
        this.settings = getEditorSettings(this, id, this.documentBaseUrl, editorManager.defaultSettings, settings);
        if (this.settings.suffix) {
          editorManager.suffix = this.settings.suffix;
        }
        this.suffix = editorManager.suffix;
        if (this.settings.base_url) {
          editorManager._setBaseUrl(this.settings.base_url);
        }
        this.baseUri = editorManager.baseURI;
        if (this.settings.referrer_policy) {
          ScriptLoader.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy);
          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy);
        }
        AddOnManager.languageLoad = this.settings.language_load;
        AddOnManager.baseURL = editorManager.baseURL;
        this.id = id;
        this.setDirty(false);
        this.documentBaseURI = new URI(this.settings.document_base_url, { base_uri: this.baseUri });
        this.baseURI = this.baseUri;
        this.inline = !!this.settings.inline;
        this.shortcuts = new Shortcuts(this);
        this.editorCommands = new EditorCommands(this);
        if (this.settings.cache_suffix) {
          Env.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, '');
        }
        this.ui = {
          registry: registry(),
          styleSheetLoader: undefined,
          show: noop,
          hide: noop,
          enable: noop,
          disable: noop,
          isDisabled: never
        };
        var self = this;
        var modeInstance = create$4(self);
        this.mode = modeInstance;
        this.setMode = modeInstance.set;
        editorManager.fire('SetupEditor', { editor: this });
        this.execCallback('setup', this);
        this.$ = DomQuery.overrideDefaults(function () {
          return {
            context: _this.inline ? _this.getBody() : _this.getDoc(),
            element: _this.getBody()
          };
        });
      }
      Editor.prototype.render = function () {
        render(this);
      };
      Editor.prototype.focus = function (skipFocus) {
        this.execCommand('mceFocus', false, skipFocus);
      };
      Editor.prototype.hasFocus = function () {
        return hasFocus(this);
      };
      Editor.prototype.execCallback = function (name) {
        var x = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          x[_i - 1] = arguments[_i];
        }
        var self = this;
        var callback = self.settings[name], scope;
        if (!callback) {
          return;
        }
        if (self.callbackLookup && (scope = self.callbackLookup[name])) {
          callback = scope.func;
          scope = scope.scope;
        }
        if (typeof callback === 'string') {
          scope = callback.replace(/\.\w+$/, '');
          scope = scope ? resolve(scope) : 0;
          callback = resolve(callback);
          self.callbackLookup = self.callbackLookup || {};
          self.callbackLookup[name] = {
            func: callback,
            scope: scope
          };
        }
        return callback.apply(scope || self, x);
      };
      Editor.prototype.translate = function (text) {
        return I18n.translate(text);
      };
      Editor.prototype.getParam = function (name, defaultVal, type) {
        return getParam(this, name, defaultVal, type);
      };
      Editor.prototype.hasPlugin = function (name, loaded) {
        var hasPlugin = contains$3(getPlugins(this).split(/[ ,]/), name);
        if (hasPlugin) {
          return loaded ? PluginManager.get(name) !== undefined : true;
        } else {
          return false;
        }
      };
      Editor.prototype.nodeChanged = function (args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      };
      Editor.prototype.addCommand = function (name, callback, scope) {
        this.editorCommands.addCommand(name, callback, scope);
      };
      Editor.prototype.addQueryStateHandler = function (name, callback, scope) {
        this.editorCommands.addQueryStateHandler(name, callback, scope);
      };
      Editor.prototype.addQueryValueHandler = function (name, callback, scope) {
        this.editorCommands.addQueryValueHandler(name, callback, scope);
      };
      Editor.prototype.addShortcut = function (pattern, desc, cmdFunc, scope) {
        this.shortcuts.add(pattern, desc, cmdFunc, scope);
      };
      Editor.prototype.execCommand = function (cmd, ui, value, args) {
        return this.editorCommands.execCommand(cmd, ui, value, args);
      };
      Editor.prototype.queryCommandState = function (cmd) {
        return this.editorCommands.queryCommandState(cmd);
      };
      Editor.prototype.queryCommandValue = function (cmd) {
        return this.editorCommands.queryCommandValue(cmd);
      };
      Editor.prototype.queryCommandSupported = function (cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      };
      Editor.prototype.show = function () {
        var self = this;
        if (self.hidden) {
          self.hidden = false;
          if (self.inline) {
            self.getBody().contentEditable = 'true';
          } else {
            DOM$1.show(self.getContainer());
            DOM$1.hide(self.id);
          }
          self.load();
          self.fire('show');
        }
      };
      Editor.prototype.hide = function () {
        var self = this, doc = self.getDoc();
        if (!self.hidden) {
          if (ie && doc && !self.inline) {
            doc.execCommand('SelectAll');
          }
          self.save();
          if (self.inline) {
            self.getBody().contentEditable = 'false';
            if (self === self.editorManager.focusedEditor) {
              self.editorManager.focusedEditor = null;
            }
          } else {
            DOM$1.hide(self.getContainer());
            DOM$1.setStyle(self.id, 'display', self.orgDisplay);
          }
          self.hidden = true;
          self.fire('hide');
        }
      };
      Editor.prototype.isHidden = function () {
        return !!this.hidden;
      };
      Editor.prototype.setProgressState = function (state, time) {
        this.fire('ProgressState', {
          state: state,
          time: time
        });
      };
      Editor.prototype.load = function (args) {
        var self = this;
        var elm = self.getElement(), html;
        if (self.removed) {
          return '';
        }
        if (elm) {
          args = args || {};
          args.load = true;
          var value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
          html = self.setContent(value, args);
          args.element = elm;
          if (!args.no_events) {
            self.fire('LoadContent', args);
          }
          args.element = elm = null;
          return html;
        }
      };
      Editor.prototype.save = function (args) {
        var self = this;
        var elm = self.getElement(), html, form;
        if (!elm || !self.initialized || self.removed) {
          return;
        }
        args = args || {};
        args.save = true;
        args.element = elm;
        html = args.content = self.getContent(args);
        if (!args.no_events) {
          self.fire('SaveContent', args);
        }
        if (args.format === 'raw') {
          self.fire('RawSaveContent', args);
        }
        html = args.content;
        if (!isTextareaOrInput(elm)) {
          if (args.is_removing || !self.inline) {
            elm.innerHTML = html;
          }
          if (form = DOM$1.getParent(self.id, 'form')) {
            each$2(form.elements, function (elm) {
              if (elm.name === self.id) {
                elm.value = html;
                return false;
              }
            });
          }
        } else {
          elm.value = html;
        }
        args.element = elm = null;
        if (args.set_dirty !== false) {
          self.setDirty(false);
        }
        return html;
      };
      Editor.prototype.setContent = function (content, args) {
        return setContent(this, content, args);
      };
      Editor.prototype.getContent = function (args) {
        return getContent(this, args);
      };
      Editor.prototype.insertContent = function (content, args) {
        if (args) {
          content = extend$3({ content: content }, args);
        }
        this.execCommand('mceInsertContent', false, content);
      };
      Editor.prototype.resetContent = function (initialContent) {
        if (initialContent === undefined) {
          setContent(this, this.startContent, { format: 'raw' });
        } else {
          setContent(this, initialContent);
        }
        this.undoManager.reset();
        this.setDirty(false);
        this.nodeChanged();
      };
      Editor.prototype.isDirty = function () {
        return !this.isNotDirty;
      };
      Editor.prototype.setDirty = function (state) {
        var oldState = !this.isNotDirty;
        this.isNotDirty = !state;
        if (state && state !== oldState) {
          this.fire('dirty');
        }
      };
      Editor.prototype.getContainer = function () {
        var self = this;
        if (!self.container) {
          self.container = DOM$1.get(self.editorContainer || self.id + '_parent');
        }
        return self.container;
      };
      Editor.prototype.getContentAreaContainer = function () {
        return this.contentAreaContainer;
      };
      Editor.prototype.getElement = function () {
        if (!this.targetElm) {
          this.targetElm = DOM$1.get(this.id);
        }
        return this.targetElm;
      };
      Editor.prototype.getWin = function () {
        var self = this;
        var elm;
        if (!self.contentWindow) {
          elm = self.iframeElement;
          if (elm) {
            self.contentWindow = elm.contentWindow;
          }
        }
        return self.contentWindow;
      };
      Editor.prototype.getDoc = function () {
        var self = this;
        var win;
        if (!self.contentDocument) {
          win = self.getWin();
          if (win) {
            self.contentDocument = win.document;
          }
        }
        return self.contentDocument;
      };
      Editor.prototype.getBody = function () {
        var doc = this.getDoc();
        return this.bodyElement || (doc ? doc.body : null);
      };
      Editor.prototype.convertURL = function (url, name, elm) {
        var self = this, settings = self.settings;
        if (settings.urlconverter_callback) {
          return self.execCallback('urlconverter_callback', url, elm, true, name);
        }
        if (!settings.convert_urls || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {
          return url;
        }
        if (settings.relative_urls) {
          return self.documentBaseURI.toRelative(url);
        }
        url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
        return url;
      };
      Editor.prototype.addVisual = function (elm) {
        addVisual(this, elm);
      };
      Editor.prototype.remove = function () {
        remove(this);
      };
      Editor.prototype.destroy = function (automatic) {
        destroy(this, automatic);
      };
      Editor.prototype.uploadImages = function (callback) {
        return this.editorUpload.uploadImages(callback);
      };
      Editor.prototype._scanForImages = function () {
        return this.editorUpload.scanForImages();
      };
      Editor.prototype.addButton = function () {
        throw new Error('editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead');
      };
      Editor.prototype.addSidebar = function () {
        throw new Error('editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead');
      };
      Editor.prototype.addMenuItem = function () {
        throw new Error('editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead');
      };
      Editor.prototype.addContextToolbar = function () {
        throw new Error('editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead');
      };
      return Editor;
    }();

    var DOM = DOMUtils.DOM;
    var explode = Tools.explode, each$1 = Tools.each, extend$2 = Tools.extend;
    var instanceCounter = 0, boundGlobalEvents = false;
    var beforeUnloadDelegate;
    var legacyEditors = [];
    var editors = [];
    var isValidLegacyKey = function (id) {
      return id !== 'length';
    };
    var globalEventDelegate = function (e) {
      var type = e.type;
      each$1(EditorManager.get(), function (editor) {
        switch (type) {
        case 'scroll':
          editor.fire('ScrollWindow', e);
          break;
        case 'resize':
          editor.fire('ResizeWindow', e);
          break;
        }
      });
    };
    var toggleGlobalEvents = function (state) {
      if (state !== boundGlobalEvents) {
        if (state) {
          DomQuery(window).on('resize scroll', globalEventDelegate);
        } else {
          DomQuery(window).off('resize scroll', globalEventDelegate);
        }
        boundGlobalEvents = state;
      }
    };
    var removeEditorFromList = function (targetEditor) {
      var oldEditors = editors;
      delete legacyEditors[targetEditor.id];
      for (var i = 0; i < legacyEditors.length; i++) {
        if (legacyEditors[i] === targetEditor) {
          legacyEditors.splice(i, 1);
          break;
        }
      }
      editors = filter$4(editors, function (editor) {
        return targetEditor !== editor;
      });
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }
      return oldEditors.length !== editors.length;
    };
    var purgeDestroyedEditor = function (editor) {
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(true);
        editor.removed = true;
        editor = null;
      }
      return editor;
    };
    var isQuirksMode = document.compatMode !== 'CSS1Compat';
    var EditorManager = __assign(__assign({}, Observable), {
      baseURI: null,
      baseURL: null,
      defaultSettings: {},
      documentBaseURL: null,
      suffix: null,
      $: DomQuery,
      majorVersion: '5',
      minorVersion: '10.2',
      releaseDate: '2021-11-17',
      editors: legacyEditors,
      i18n: I18n,
      activeEditor: null,
      focusedEditor: null,
      settings: {},
      setup: function () {
        var self = this;
        var baseURL, documentBaseURL, suffix = '';
        documentBaseURL = URI.getDocumentBaseUrl(document.location);
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(documentBaseURL)) {
            documentBaseURL += '/';
          }
        }
        var preInit = window.tinymce || window.tinyMCEPreInit;
        if (preInit) {
          baseURL = preInit.base || preInit.baseURL;
          suffix = preInit.suffix;
        } else {
          var scripts = document.getElementsByTagName('script');
          for (var i = 0; i < scripts.length; i++) {
            var src = scripts[i].src || '';
            if (src === '') {
              continue;
            }
            var srcScript = src.substring(src.lastIndexOf('/'));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
              if (srcScript.indexOf('.min') !== -1) {
                suffix = '.min';
              }
              baseURL = src.substring(0, src.lastIndexOf('/'));
              break;
            }
          }
          if (!baseURL && document.currentScript) {
            var src = document.currentScript.src;
            if (src.indexOf('.min') !== -1) {
              suffix = '.min';
            }
            baseURL = src.substring(0, src.lastIndexOf('/'));
          }
        }
        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
        self.documentBaseURL = documentBaseURL;
        self.baseURI = new URI(self.baseURL);
        self.suffix = suffix;
        setup$l(self);
      },
      overrideDefaults: function (defaultSettings) {
        var baseUrl = defaultSettings.base_url;
        if (baseUrl) {
          this._setBaseUrl(baseUrl);
        }
        var suffix = defaultSettings.suffix;
        if (defaultSettings.suffix) {
          this.suffix = suffix;
        }
        this.defaultSettings = defaultSettings;
        var pluginBaseUrls = defaultSettings.plugin_base_urls;
        if (pluginBaseUrls !== undefined) {
          each$j(pluginBaseUrls, function (pluginBaseUrl, pluginName) {
            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
          });
        }
      },
      init: function (settings) {
        var self = this;
        var result;
        var invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
        var isInvalidInlineTarget = function (settings, elm) {
          return settings.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
        };
        var createId = function (elm) {
          var id = elm.id;
          if (!id) {
            id = get$9(elm, 'name').filter(function (name) {
              return !DOM.get(name);
            }).getOrThunk(DOM.uniqueId);
            elm.setAttribute('id', id);
          }
          return id;
        };
        var execCallback = function (name) {
          var callback = settings[name];
          if (!callback) {
            return;
          }
          return callback.apply(self, []);
        };
        var hasClass = function (elm, className) {
          return className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);
        };
        var findTargets = function (settings) {
          var targets = [];
          if (Env.browser.isIE() && Env.browser.version.major < 11) {
            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/');
            return [];
          } else if (isQuirksMode) {
            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');
            return [];
          }
          if (settings.types) {
            each$1(settings.types, function (type) {
              targets = targets.concat(DOM.select(type.selector));
            });
            return targets;
          } else if (settings.selector) {
            return DOM.select(settings.selector);
          } else if (settings.target) {
            return [settings.target];
          }
          switch (settings.mode) {
          case 'exact':
            var l = settings.elements || '';
            if (l.length > 0) {
              each$1(explode(l), function (id) {
                var elm = DOM.get(id);
                if (elm) {
                  targets.push(elm);
                } else {
                  each$1(document.forms, function (f) {
                    each$1(f.elements, function (e) {
                      if (e.name === id) {
                        id = 'mce_editor_' + instanceCounter++;
                        DOM.setAttrib(e, 'id', id);
                        targets.push(e);
                      }
                    });
                  });
                }
              });
            }
            break;
          case 'textareas':
          case 'specific_textareas':
            each$1(DOM.select('textarea'), function (elm) {
              if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {
                return;
              }
              if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
                targets.push(elm);
              }
            });
            break;
          }
          return targets;
        };
        var provideResults = function (editors) {
          result = editors;
        };
        var initEditors = function () {
          var initCount = 0;
          var editors = [];
          var targets;
          var createEditor = function (id, settings, targetElm) {
            var editor = new Editor(id, settings, self);
            editors.push(editor);
            editor.on('init', function () {
              if (++initCount === targets.length) {
                provideResults(editors);
              }
            });
            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          };
          DOM.unbind(window, 'ready', initEditors);
          execCallback('onpageload');
          targets = DomQuery.unique(findTargets(settings));
          if (settings.types) {
            each$1(settings.types, function (type) {
              Tools.each(targets, function (elm) {
                if (DOM.is(elm, type.selector)) {
                  createEditor(createId(elm), extend$2({}, settings, type), elm);
                  return false;
                }
                return true;
              });
            });
            return;
          }
          Tools.each(targets, function (elm) {
            purgeDestroyedEditor(self.get(elm.id));
          });
          targets = Tools.grep(targets, function (elm) {
            return !self.get(elm.id);
          });
          if (targets.length === 0) {
            provideResults([]);
          } else {
            each$1(targets, function (elm) {
              if (isInvalidInlineTarget(settings, elm)) {
                initError('Could not initialize inline editor on invalid inline target element', elm);
              } else {
                createEditor(createId(elm), settings, elm);
              }
            });
          }
        };
        self.settings = settings;
        DOM.bind(window, 'ready', initEditors);
        return new promiseObj(function (resolve) {
          if (result) {
            resolve(result);
          } else {
            provideResults = function (editors) {
              resolve(editors);
            };
          }
        });
      },
      get: function (id) {
        if (arguments.length === 0) {
          return editors.slice(0);
        } else if (isString$1(id)) {
          return find$3(editors, function (editor) {
            return editor.id === id;
          }).getOr(null);
        } else if (isNumber(id)) {
          return editors[id] ? editors[id] : null;
        } else {
          return null;
        }
      },
      add: function (editor) {
        var self = this;
        var existingEditor = legacyEditors[editor.id];
        if (existingEditor === editor) {
          return editor;
        }
        if (self.get(editor.id) === null) {
          if (isValidLegacyKey(editor.id)) {
            legacyEditors[editor.id] = editor;
          }
          legacyEditors.push(editor);
          editors.push(editor);
        }
        toggleGlobalEvents(true);
        self.activeEditor = editor;
        self.fire('AddEditor', { editor: editor });
        if (!beforeUnloadDelegate) {
          beforeUnloadDelegate = function (e) {
            var event = self.fire('BeforeUnload');
            if (event.returnValue) {
              e.preventDefault();
              e.returnValue = event.returnValue;
              return event.returnValue;
            }
          };
          window.addEventListener('beforeunload', beforeUnloadDelegate);
        }
        return editor;
      },
      createEditor: function (id, settings) {
        return this.add(new Editor(id, settings, this));
      },
      remove: function (selector) {
        var self = this;
        var i, editor;
        if (!selector) {
          for (i = editors.length - 1; i >= 0; i--) {
            self.remove(editors[i]);
          }
          return;
        }
        if (isString$1(selector)) {
          each$1(DOM.select(selector), function (elm) {
            editor = self.get(elm.id);
            if (editor) {
              self.remove(editor);
            }
          });
          return;
        }
        editor = selector;
        if (isNull(self.get(editor.id))) {
          return null;
        }
        if (removeEditorFromList(editor)) {
          self.fire('RemoveEditor', { editor: editor });
        }
        if (editors.length === 0) {
          window.removeEventListener('beforeunload', beforeUnloadDelegate);
        }
        editor.remove();
        toggleGlobalEvents(editors.length > 0);
        return editor;
      },
      execCommand: function (cmd, ui, value) {
        var self = this, editor = self.get(value);
        switch (cmd) {
        case 'mceAddEditor':
          if (!self.get(value)) {
            new Editor(value, self.settings, self).render();
          }
          return true;
        case 'mceRemoveEditor':
          if (editor) {
            editor.remove();
          }
          return true;
        case 'mceToggleEditor':
          if (!editor) {
            self.execCommand('mceAddEditor', false, value);
            return true;
          }
          if (editor.isHidden()) {
            editor.show();
          } else {
            editor.hide();
          }
          return true;
        }
        if (self.activeEditor) {
          return self.activeEditor.execCommand(cmd, ui, value);
        }
        return false;
      },
      triggerSave: function () {
        each$1(editors, function (editor) {
          editor.save();
        });
      },
      addI18n: function (code, items) {
        I18n.add(code, items);
      },
      translate: function (text) {
        return I18n.translate(text);
      },
      setActive: function (editor) {
        var activeEditor = this.activeEditor;
        if (this.activeEditor !== editor) {
          if (activeEditor) {
            activeEditor.fire('deactivate', { relatedTarget: editor });
          }
          editor.fire('activate', { relatedTarget: activeEditor });
        }
        this.activeEditor = editor;
      },
      _setBaseUrl: function (baseUrl) {
        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
        this.baseURI = new URI(this.baseURL);
      }
    });
    EditorManager.setup();

    var min$1 = Math.min, max$1 = Math.max, round$1 = Math.round;
    var relativePosition = function (rect, targetRect, rel) {
      var x = targetRect.x;
      var y = targetRect.y;
      var w = rect.w;
      var h = rect.h;
      var targetW = targetRect.w;
      var targetH = targetRect.h;
      var relChars = (rel || '').split('');
      if (relChars[0] === 'b') {
        y += targetH;
      }
      if (relChars[1] === 'r') {
        x += targetW;
      }
      if (relChars[0] === 'c') {
        y += round$1(targetH / 2);
      }
      if (relChars[1] === 'c') {
        x += round$1(targetW / 2);
      }
      if (relChars[3] === 'b') {
        y -= h;
      }
      if (relChars[4] === 'r') {
        x -= w;
      }
      if (relChars[3] === 'c') {
        y -= round$1(h / 2);
      }
      if (relChars[4] === 'c') {
        x -= round$1(w / 2);
      }
      return create$2(x, y, w, h);
    };
    var findBestRelativePosition = function (rect, targetRect, constrainRect, rels) {
      var pos, i;
      for (i = 0; i < rels.length; i++) {
        pos = relativePosition(rect, targetRect, rels[i]);
        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }
      return null;
    };
    var inflate = function (rect, w, h) {
      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    var intersect = function (rect, cropRect) {
      var x1 = max$1(rect.x, cropRect.x);
      var y1 = max$1(rect.y, cropRect.y);
      var x2 = min$1(rect.x + rect.w, cropRect.x + cropRect.w);
      var y2 = min$1(rect.y + rect.h, cropRect.y + cropRect.h);
      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    var clamp = function (rect, clampRect, fixedSize) {
      var x1 = rect.x;
      var y1 = rect.y;
      var x2 = rect.x + rect.w;
      var y2 = rect.y + rect.h;
      var cx2 = clampRect.x + clampRect.w;
      var cy2 = clampRect.y + clampRect.h;
      var underflowX1 = max$1(0, clampRect.x - x1);
      var underflowY1 = max$1(0, clampRect.y - y1);
      var overflowX2 = max$1(0, x2 - cx2);
      var overflowY2 = max$1(0, y2 - cy2);
      x1 += underflowX1;
      y1 += underflowY1;
      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }
      x2 -= overflowX2;
      y2 -= overflowY2;
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    var create$2 = function (x, y, w, h) {
      return {
        x: x,
        y: y,
        w: w,
        h: h
      };
    };
    var fromClientRect = function (clientRect) {
      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    var Rect = {
      inflate: inflate,
      relativePosition: relativePosition,
      findBestRelativePosition: findBestRelativePosition,
      intersect: intersect,
      clamp: clamp,
      create: create$2,
      fromClientRect: fromClientRect
    };

    var awaiter = function (resolveCb, rejectCb, timeout) {
      if (timeout === void 0) {
        timeout = 1000;
      }
      var done = false;
      var timer = null;
      var complete = function (completer) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (!done) {
            done = true;
            if (timer !== null) {
              clearTimeout(timer);
              timer = null;
            }
            completer.apply(null, args);
          }
        };
      };
      var resolve = complete(resolveCb);
      var reject = complete(rejectCb);
      var start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!done && timer === null) {
          timer = setTimeout(function () {
            return reject.apply(null, args);
          }, timeout);
        }
      };
      return {
        start: start,
        resolve: resolve,
        reject: reject
      };
    };
    var create$1 = function () {
      var tasks = {};
      var resultFns = {};
      var load = function (id, url) {
        var loadErrMsg = 'Script at URL "' + url + '" failed to load';
        var runErrMsg = 'Script at URL "' + url + '" did not call `tinymce.Resource.add(\'' + id + '\', data)` within 1 second';
        if (tasks[id] !== undefined) {
          return tasks[id];
        } else {
          var task = new promiseObj(function (resolve, reject) {
            var waiter = awaiter(resolve, reject);
            resultFns[id] = waiter.resolve;
            ScriptLoader.ScriptLoader.loadScript(url, function () {
              return waiter.start(runErrMsg);
            }, function () {
              return waiter.reject(loadErrMsg);
            });
          });
          tasks[id] = task;
          return task;
        }
      };
      var add = function (id, data) {
        if (resultFns[id] !== undefined) {
          resultFns[id](data);
          delete resultFns[id];
        }
        tasks[id] = promiseObj.resolve(data);
      };
      return {
        load: load,
        add: add
      };
    };
    var Resource = create$1();

    var each = Tools.each, extend$1 = Tools.extend;
    var extendClass, initializing;
    var Class = function () {
    };
    Class.extend = extendClass = function (props) {
      var self = this;
      var _super = self.prototype;
      var Class = function () {
        var i, mixins, mixin;
        var self = this;
        if (!initializing) {
          if (self.init) {
            self.init.apply(self, arguments);
          }
          mixins = self.Mixins;
          if (mixins) {
            i = mixins.length;
            while (i--) {
              mixin = mixins[i];
              if (mixin.init) {
                mixin.init.apply(self, arguments);
              }
            }
          }
        }
      };
      var dummy = function () {
        return this;
      };
      var createMethod = function (name, fn) {
        return function () {
          var self = this;
          var tmp = self._super;
          self._super = _super[name];
          var ret = fn.apply(self, arguments);
          self._super = tmp;
          return ret;
        };
      };
      initializing = true;
      var prototype = new self();
      initializing = false;
      if (props.Mixins) {
        each(props.Mixins, function (mixin) {
          for (var name_1 in mixin) {
            if (name_1 !== 'init') {
              props[name_1] = mixin[name_1];
            }
          }
        });
        if (_super.Mixins) {
          props.Mixins = _super.Mixins.concat(props.Mixins);
        }
      }
      if (props.Methods) {
        each(props.Methods.split(','), function (name) {
          props[name] = dummy;
        });
      }
      if (props.Properties) {
        each(props.Properties.split(','), function (name) {
          var fieldName = '_' + name;
          props[name] = function (value) {
            var self = this;
            if (value !== undefined) {
              self[fieldName] = value;
              return self;
            }
            return self[fieldName];
          };
        });
      }
      if (props.Statics) {
        each(props.Statics, function (func, name) {
          Class[name] = func;
        });
      }
      if (props.Defaults && _super.Defaults) {
        props.Defaults = extend$1({}, _super.Defaults, props.Defaults);
      }
      each$j(props, function (member, name) {
        if (typeof member === 'function' && _super[name]) {
          prototype[name] = createMethod(name, member);
        } else {
          prototype[name] = member;
        }
      });
      Class.prototype = prototype;
      Class.constructor = Class;
      Class.extend = extendClass;
      return Class;
    };

    var min = Math.min, max = Math.max, round = Math.round;
    var Color = function (value) {
      var self = {};
      var r = 0, g = 0, b = 0;
      var rgb2hsv = function (r, g, b) {
        var h, s, v;
        h = 0;
        s = 0;
        v = 0;
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var minRGB = min(r, min(g, b));
        var maxRGB = max(r, max(g, b));
        if (minRGB === maxRGB) {
          v = minRGB;
          return {
            h: 0,
            s: 0,
            v: v * 100
          };
        }
        var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
        h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
        h = 60 * (h - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;
        return {
          h: round(h),
          s: round(s * 100),
          v: round(v * 100)
        };
      };
      var hsvToRgb = function (hue, saturation, brightness) {
        hue = (parseInt(hue, 10) || 0) % 360;
        saturation = parseInt(saturation, 10) / 100;
        brightness = parseInt(brightness, 10) / 100;
        saturation = max(0, min(saturation, 1));
        brightness = max(0, min(brightness, 1));
        if (saturation === 0) {
          r = g = b = round(255 * brightness);
          return;
        }
        var side = hue / 60;
        var chroma = brightness * saturation;
        var x = chroma * (1 - Math.abs(side % 2 - 1));
        var match = brightness - chroma;
        switch (Math.floor(side)) {
        case 0:
          r = chroma;
          g = x;
          b = 0;
          break;
        case 1:
          r = x;
          g = chroma;
          b = 0;
          break;
        case 2:
          r = 0;
          g = chroma;
          b = x;
          break;
        case 3:
          r = 0;
          g = x;
          b = chroma;
          break;
        case 4:
          r = x;
          g = 0;
          b = chroma;
          break;
        case 5:
          r = chroma;
          g = 0;
          b = x;
          break;
        default:
          r = g = b = 0;
        }
        r = round(255 * (r + match));
        g = round(255 * (g + match));
        b = round(255 * (b + match));
      };
      var toHex = function () {
        var hex = function (val) {
          val = parseInt(val, 10).toString(16);
          return val.length > 1 ? val : '0' + val;
        };
        return '#' + hex(r) + hex(g) + hex(b);
      };
      var toRgb = function () {
        return {
          r: r,
          g: g,
          b: b
        };
      };
      var toHsv = function () {
        return rgb2hsv(r, g, b);
      };
      var parse = function (value) {
        var matches;
        if (typeof value === 'object') {
          if ('r' in value) {
            r = value.r;
            g = value.g;
            b = value.b;
          } else if ('v' in value) {
            hsvToRgb(value.h, value.s, value.v);
          }
        } else {
          if (matches = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value)) {
            r = parseInt(matches[1], 10);
            g = parseInt(matches[2], 10);
            b = parseInt(matches[3], 10);
          } else if (matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value)) {
            r = parseInt(matches[1], 16);
            g = parseInt(matches[2], 16);
            b = parseInt(matches[3], 16);
          } else if (matches = /#([0-F])([0-F])([0-F])/gi.exec(value)) {
            r = parseInt(matches[1] + matches[1], 16);
            g = parseInt(matches[2] + matches[2], 16);
            b = parseInt(matches[3] + matches[3], 16);
          }
        }
        r = r < 0 ? 0 : r > 255 ? 255 : r;
        g = g < 0 ? 0 : g > 255 ? 255 : g;
        b = b < 0 ? 0 : b > 255 ? 255 : b;
        return self;
      };
      if (value) {
        parse(value);
      }
      self.toRgb = toRgb;
      self.toHsv = toHsv;
      self.toHex = toHex;
      self.parse = parse;
      return self;
    };

    var serialize = function (obj) {
      var data = JSON.stringify(obj);
      if (!isString$1(data)) {
        return data;
      }
      return data.replace(/[\u0080-\uFFFF]/g, function (match) {
        var hexCode = match.charCodeAt(0).toString(16);
        return '\\u' + '0000'.substring(hexCode.length) + hexCode;
      });
    };
    var JSONUtils = {
      serialize: serialize,
      parse: function (text) {
        try {
          return JSON.parse(text);
        } catch (ex) {
        }
      }
    };

    var JSONP = {
      callbacks: {},
      count: 0,
      send: function (settings) {
        var self = this, dom = DOMUtils.DOM, count = settings.count !== undefined ? settings.count : self.count;
        var id = 'tinymce_jsonp_' + count;
        self.callbacks[count] = function (json) {
          dom.remove(id);
          delete self.callbacks[count];
          settings.callback(json);
        };
        dom.add(dom.doc.body, 'script', {
          id: id,
          src: settings.url,
          type: 'text/javascript'
        });
        self.count++;
      }
    };

    var XHR = __assign(__assign({}, Observable), {
      send: function (settings) {
        var xhr, count = 0;
        var ready = function () {
          if (!settings.async || xhr.readyState === 4 || count++ > 10000) {
            if (settings.success && count < 10000 && xhr.status === 200) {
              settings.success.call(settings.success_scope, '' + xhr.responseText, xhr, settings);
            } else if (settings.error) {
              settings.error.call(settings.error_scope, count > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, settings);
            }
            xhr = null;
          } else {
            Delay.setTimeout(ready, 10);
          }
        };
        settings.scope = settings.scope || this;
        settings.success_scope = settings.success_scope || settings.scope;
        settings.error_scope = settings.error_scope || settings.scope;
        settings.async = settings.async !== false;
        settings.data = settings.data || '';
        XHR.fire('beforeInitialize', { settings: settings });
        xhr = new XMLHttpRequest();
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType(settings.content_type);
        }
        xhr.open(settings.type || (settings.data ? 'POST' : 'GET'), settings.url, settings.async);
        if (settings.crossDomain) {
          xhr.withCredentials = true;
        }
        if (settings.content_type) {
          xhr.setRequestHeader('Content-Type', settings.content_type);
        }
        if (settings.requestheaders) {
          Tools.each(settings.requestheaders, function (header) {
            xhr.setRequestHeader(header.key, header.value);
          });
        }
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        xhr = XHR.fire('beforeSend', {
          xhr: xhr,
          settings: settings
        }).xhr;
        xhr.send(settings.data);
        if (!settings.async) {
          return ready();
        }
        Delay.setTimeout(ready, 10);
      }
    });

    var extend = Tools.extend;
    var JSONRequest = function () {
      function JSONRequest(settings) {
        this.settings = extend({}, settings);
        this.count = 0;
      }
      JSONRequest.sendRPC = function (o) {
        return new JSONRequest().send(o);
      };
      JSONRequest.prototype.send = function (args) {
        var ecb = args.error, scb = args.success;
        var xhrArgs = extend(this.settings, args);
        xhrArgs.success = function (c, x) {
          c = JSONUtils.parse(c);
          if (typeof c === 'undefined') {
            c = { error: 'JSON Parse error.' };
          }
          if (c.error) {
            ecb.call(xhrArgs.error_scope || xhrArgs.scope, c.error, x);
          } else {
            scb.call(xhrArgs.success_scope || xhrArgs.scope, c.result);
          }
        };
        xhrArgs.error = function (ty, x) {
          if (ecb) {
            ecb.call(xhrArgs.error_scope || xhrArgs.scope, ty, x);
          }
        };
        xhrArgs.data = JSONUtils.serialize({
          id: args.id || 'c' + this.count++,
          method: args.method,
          params: args.params
        });
        xhrArgs.content_type = 'application/json';
        XHR.send(xhrArgs);
      };
      return JSONRequest;
    }();

    var create = function () {
      return function () {
        var data = {};
        var keys = [];
        var storage = {
          getItem: function (key) {
            var item = data[key];
            return item ? item : null;
          },
          setItem: function (key, value) {
            keys.push(key);
            data[key] = String(value);
          },
          key: function (index) {
            return keys[index];
          },
          removeItem: function (key) {
            keys = keys.filter(function (k) {
              return k === key;
            });
            delete data[key];
          },
          clear: function () {
            keys = [];
            data = {};
          },
          length: 0
        };
        Object.defineProperty(storage, 'length', {
          get: function () {
            return keys.length;
          },
          configurable: false,
          enumerable: false
        });
        return storage;
      }();
    };

    var localStorage;
    try {
      var test = '__storage_test__';
      localStorage = window.localStorage;
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
    } catch (e) {
      localStorage = create();
    }
    var LocalStorage = localStorage;

    var publicApi = {
      geom: { Rect: Rect },
      util: {
        Promise: promiseObj,
        Delay: Delay,
        Tools: Tools,
        VK: VK,
        URI: URI,
        Class: Class,
        EventDispatcher: EventDispatcher,
        Observable: Observable,
        I18n: I18n,
        XHR: XHR,
        JSON: JSONUtils,
        JSONRequest: JSONRequest,
        JSONP: JSONP,
        LocalStorage: LocalStorage,
        Color: Color,
        ImageUploader: ImageUploader
      },
      dom: {
        EventUtils: EventUtils,
        Sizzle: Sizzle,
        DomQuery: DomQuery,
        TreeWalker: DomTreeWalker,
        TextSeeker: TextSeeker,
        DOMUtils: DOMUtils,
        ScriptLoader: ScriptLoader,
        RangeUtils: RangeUtils,
        Serializer: DomSerializer,
        StyleSheetLoader: StyleSheetLoader,
        ControlSelection: ControlSelection,
        BookmarkManager: BookmarkManager,
        Selection: EditorSelection,
        Event: EventUtils.Event
      },
      html: {
        Styles: Styles,
        Entities: Entities,
        Node: AstNode,
        Schema: Schema,
        SaxParser: SaxParser,
        DomParser: DomParser,
        Writer: Writer,
        Serializer: HtmlSerializer
      },
      Env: Env,
      AddOnManager: AddOnManager,
      Annotator: Annotator,
      Formatter: Formatter,
      UndoManager: UndoManager,
      EditorCommands: EditorCommands,
      WindowManager: WindowManager,
      NotificationManager: NotificationManager,
      EditorObservable: EditorObservable,
      Shortcuts: Shortcuts,
      Editor: Editor,
      FocusManager: FocusManager,
      EditorManager: EditorManager,
      DOM: DOMUtils.DOM,
      ScriptLoader: ScriptLoader.ScriptLoader,
      PluginManager: PluginManager,
      ThemeManager: ThemeManager,
      IconManager: IconManager,
      Resource: Resource,
      trim: Tools.trim,
      isArray: Tools.isArray,
      is: Tools.is,
      toArray: Tools.toArray,
      makeMap: Tools.makeMap,
      each: Tools.each,
      map: Tools.map,
      grep: Tools.grep,
      inArray: Tools.inArray,
      extend: Tools.extend,
      create: Tools.create,
      walk: Tools.walk,
      createNS: Tools.createNS,
      resolve: Tools.resolve,
      explode: Tools.explode,
      _addCacheSuffix: Tools._addCacheSuffix,
      isOpera: Env.opera,
      isWebKit: Env.webkit,
      isIE: Env.ie,
      isGecko: Env.gecko,
      isMac: Env.mac
    };
    var tinymce = Tools.extend(EditorManager, publicApi);

    var exportToModuleLoaders = function (tinymce) {
      if (true) {
        try {
          module.exports = tinymce;
        } catch (_) {
        }
      }
    };
    var exportToWindowGlobal = function (tinymce) {
      window.tinymce = tinymce;
      window.tinyMCE = tinymce;
    };
    exportToWindowGlobal(tinymce);
    exportToModuleLoaders(tinymce);

}());

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("d8fc")))

/***/ }),

/***/ "c34e":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$2 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');

    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var allowHtmlInNamedAnchor = function (editor) {
      return editor.getParam('allow_html_in_named_anchor', false, 'boolean');
    };

    var namedAnchorSelector = 'a:not([href])';
    var isEmptyString = function (str) {
      return !str;
    };
    var getIdFromAnchor = function (elm) {
      var id = elm.getAttribute('id') || elm.getAttribute('name');
      return id || '';
    };
    var isAnchor = function (elm) {
      return elm && elm.nodeName.toLowerCase() === 'a';
    };
    var isNamedAnchor = function (elm) {
      return isAnchor(elm) && !elm.getAttribute('href') && getIdFromAnchor(elm) !== '';
    };
    var isEmptyNamedAnchor = function (elm) {
      return isNamedAnchor(elm) && !elm.firstChild;
    };

    var removeEmptyNamedAnchorsInSelection = function (editor) {
      var dom = editor.dom;
      global$1(dom).walk(editor.selection.getRng(), function (nodes) {
        global.each(nodes, function (node) {
          if (isEmptyNamedAnchor(node)) {
            dom.remove(node, false);
          }
        });
      });
    };
    var isValidId = function (id) {
      return /^[A-Za-z][A-Za-z0-9\-:._]*$/.test(id);
    };
    var getNamedAnchor = function (editor) {
      return editor.dom.getParent(editor.selection.getStart(), namedAnchorSelector);
    };
    var getId = function (editor) {
      var anchor = getNamedAnchor(editor);
      if (anchor) {
        return getIdFromAnchor(anchor);
      } else {
        return '';
      }
    };
    var createAnchor = function (editor, id) {
      editor.undoManager.transact(function () {
        if (!allowHtmlInNamedAnchor(editor)) {
          editor.selection.collapse(true);
        }
        if (editor.selection.isCollapsed()) {
          editor.insertContent(editor.dom.createHTML('a', { id: id }));
        } else {
          removeEmptyNamedAnchorsInSelection(editor);
          editor.formatter.remove('namedAnchor', null, null, true);
          editor.formatter.apply('namedAnchor', { value: id });
          editor.addVisual();
        }
      });
    };
    var updateAnchor = function (editor, id, anchorElement) {
      anchorElement.removeAttribute('name');
      anchorElement.id = id;
      editor.addVisual();
      editor.undoManager.add();
    };
    var insert = function (editor, id) {
      var anchor = getNamedAnchor(editor);
      if (anchor) {
        updateAnchor(editor, id, anchor);
      } else {
        createAnchor(editor, id);
      }
      editor.focus();
    };

    var insertAnchor = function (editor, newId) {
      if (!isValidId(newId)) {
        editor.windowManager.alert('Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.');
        return false;
      } else {
        insert(editor, newId);
        return true;
      }
    };
    var open = function (editor) {
      var currentId = getId(editor);
      editor.windowManager.open({
        title: 'Anchor',
        size: 'normal',
        body: {
          type: 'panel',
          items: [{
              name: 'id',
              type: 'input',
              label: 'ID',
              placeholder: 'example'
            }]
        },
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: { id: currentId },
        onSubmit: function (api) {
          if (insertAnchor(editor, api.getData().id)) {
            api.close();
          }
        }
      });
    };

    var register$1 = function (editor) {
      editor.addCommand('mceAnchor', function () {
        open(editor);
      });
    };

    var isNamedAnchorNode = function (node) {
      return node && isEmptyString(node.attr('href')) && !isEmptyString(node.attr('id') || node.attr('name'));
    };
    var isEmptyNamedAnchorNode = function (node) {
      return isNamedAnchorNode(node) && !node.firstChild;
    };
    var setContentEditable = function (state) {
      return function (nodes) {
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (isEmptyNamedAnchorNode(node)) {
            node.attr('contenteditable', state);
          }
        }
      };
    };
    var setup = function (editor) {
      editor.on('PreInit', function () {
        editor.parser.addNodeFilter('a', setContentEditable('false'));
        editor.serializer.addNodeFilter('a', setContentEditable(null));
      });
    };

    var registerFormats = function (editor) {
      editor.formatter.register('namedAnchor', {
        inline: 'a',
        selector: namedAnchorSelector,
        remove: 'all',
        split: true,
        deep: true,
        attributes: { id: '%value' },
        onmatch: function (node, _fmt, _itemName) {
          return isNamedAnchor(node);
        }
      });
    };

    var register = function (editor) {
      editor.ui.registry.addToggleButton('anchor', {
        icon: 'bookmark',
        tooltip: 'Anchor',
        onAction: function () {
          return editor.execCommand('mceAnchor');
        },
        onSetup: function (buttonApi) {
          return editor.selection.selectorChangedWithUnbind('a:not([href])', buttonApi.setActive).unbind;
        }
      });
      editor.ui.registry.addMenuItem('anchor', {
        icon: 'bookmark',
        text: 'Anchor...',
        onAction: function () {
          return editor.execCommand('mceAnchor');
        }
      });
    };

    function Plugin () {
      global$2.add('anchor', function (editor) {
        setup(editor);
        register$1(editor);
        register(editor);
        editor.on('PreInit', function () {
          registerFormats(editor);
        });
      });
    }

    Plugin();

}());


/***/ }),

/***/ "cf92":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType$1 = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq$2 = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString = isType$1('string');
    var isObject = isType$1('object');
    var isArray = isType$1('array');
    var isNull = eq$2(null);
    var isBoolean = isSimpleType('boolean');
    var isUndefined = eq$2(undefined);
    var isNullable = function (a) {
      return a === null || a === undefined;
    };
    var isNonNullable = function (a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType('function');
    var isNumber = isSimpleType('number');

    var noop = function () {
    };
    var compose = function (fa, fb) {
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var compose1 = function (fbc, fab) {
      return function (a) {
        return fbc(fab(a));
      };
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    var tripleEquals = function (a, b) {
      return a === b;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var not = function (f) {
      return function (t) {
        return !f(t);
      };
    };
    var die = function (msg) {
      return function () {
        throw new Error(msg);
      };
    };
    var never = constant(false);
    var always = constant(true);

    var none$2 = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none$2,
        each: noop,
        bind: none$2,
        exists: never,
        forall: always,
        filter: function () {
          return none$2();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from$1 = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none$2,
      from: from$1
    };

    var nativeSlice = Array.prototype.slice;
    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var contains$2 = function (xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var range$1 = function (num, f) {
      var r = [];
      for (var i = 0; i < num; i++) {
        r.push(f(i));
      }
      return r;
    };
    var map$1 = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each$2 = function (xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function (xs, f) {
      for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var partition = function (xs, pred) {
      var pass = [];
      var fail = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        var arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass: pass,
        fail: fail
      };
    };
    var filter$2 = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var foldr = function (xs, f, acc) {
      eachr(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var foldl = function (xs, f, acc) {
      each$2(xs, function (x, i) {
        acc = f(acc, x, i);
      });
      return acc;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find$1 = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var findIndex = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    var flatten$1 = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind$2 = function (xs, f) {
      return flatten$1(map$1(xs, f));
    };
    var forall = function (xs, pred) {
      for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    var reverse = function (xs) {
      var r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    var mapToObject = function (xs, f) {
      var r = {};
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    var pure = function (x) {
      return [x];
    };
    var sort$1 = function (xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    var get$d = function (xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function (xs) {
      return get$d(xs, 0);
    };
    var last$2 = function (xs) {
      return get$d(xs, xs.length - 1);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() && !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      var isPhone = isiPhone || isMobile && !isTablet;
      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$2(group(1), group(2));
    };
    var detect$6 = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find(versionRegexes, cleanedAgent);
    };
    var unknown$2 = function () {
      return nu$2(0, 0);
    };
    var nu$2 = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$2,
      detect: detect$6,
      unknown: unknown$2
    };

    var detectBrowser$1 = function (browsers, userAgentData) {
      return findMap(userAgentData.brands, function (uaBrand) {
        var lcBrand = uaBrand.brand.toLowerCase();
        return find$1(browsers, function (browser) {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(function (info) {
          return {
            current: info.name,
            version: Version.nu(parseInt(uaBrand.version, 10), 0)
          };
        });
      });
    };

    var detect$5 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find$1(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$5(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$5(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };

    var removeFromStart = function (str, numChars) {
      return str.substring(numChars);
    };

    var checkRange = function (str, substr, start) {
      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    };
    var removeLeading = function (str, prefix) {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    var contains$1 = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function (str, prefix) {
      return checkRange(str, prefix, 0);
    };
    var endsWith = function (str, suffix) {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    var blank = function (r) {
      return function (s) {
        return s.replace(r, '');
      };
    };
    var trim = blank(/^\s+|\s+$/g);
    var isNotEmpty = function (s) {
      return s.length > 0;
    };
    var isEmpty$1 = function (s) {
      return !isNotEmpty(s);
    };
    var toFloat = function (value) {
      var num = parseFloat(value);
      return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains$1(uastring, target);
      };
    };
    var browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chrome',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
        }
      }
    ];
    var oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: function (uastring) {
          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'OSX',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    var edge = 'Edge';
    var chrome = 'Chrome';
    var ie = 'IE';
    var opera = 'Opera';
    var firefox = 'Firefox';
    var safari = 'Safari';
    var unknown$1 = function () {
      return nu$1({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$1 = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$1,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    var windows = 'Windows';
    var ios = 'iOS';
    var android = 'Android';
    var linux = 'Linux';
    var osx = 'OSX';
    var solaris = 'Solaris';
    var freebsd = 'FreeBSD';
    var chromeos = 'ChromeOS';
    var unknown = function () {
      return nu({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown,
      nu: nu,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    var detect$4 = function (userAgent, userAgentDataOpt, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = userAgentDataOpt.bind(function (userAgentData) {
        return detectBrowser$1(browsers, userAgentData);
      }).orThunk(function () {
        return detectBrowser(browsers, userAgent);
      }).fold(Browser.unknown, Browser.nu);
      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$4 };

    var mediaMatch = function (query) {
      return window.matchMedia(query).matches;
    };
    var platform = cached(function () {
      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);
    });
    var detect$3 = function () {
      return platform();
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) & match) !== 0;
    };
    var documentPositionContainedBy = function (a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
    };

    var COMMENT = 8;
    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;

    var fromHtml$1 = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error('HTML does not have a single root node', html);
        throw new Error('HTML must have a single root node');
      }
      return fromDom$1(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || document;
      var node = doc.createElement(tag);
      return fromDom$1(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || document;
      var node = doc.createTextNode(text);
      return fromDom$1(node);
    };
    var fromDom$1 = function (node) {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    var fromPoint$1 = function (docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);
    };
    var SugarElement = {
      fromHtml: fromHtml$1,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom$1,
      fromPoint: fromPoint$1
    };

    var is$2 = function (element, selector) {
      var dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    };
    var all$1 = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map$1(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    var one = function (selector, scope) {
      var base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    var eq$1 = function (e1, e2) {
      return e1.dom === e2.dom;
    };
    var regularContains = function (e1, e2) {
      var d1 = e1.dom;
      var d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function (e1, e2) {
      return documentPositionContainedBy(e1.dom, e2.dom);
    };
    var contains = function (e1, e2) {
      return detect$3().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };
    var is$1 = is$2;

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each$1 = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map = function (obj, f) {
      return tupleMap(obj, function (x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function (obj, f) {
      var r = {};
      each$1(obj, function (x, i) {
        var tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each$1(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter$1 = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var mapToArray = function (obj, f) {
      var r = [];
      each$1(obj, function (value, name) {
        r.push(f(value, name));
      });
      return r;
    };
    var values = function (obj) {
      return mapToArray(obj, identity);
    };
    var size = function (obj) {
      return keys(obj).length;
    };
    var get$c = function (obj, key) {
      return has$1(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has$1 = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has$1(obj, key) && obj[key] !== undefined && obj[key] !== null;
    };
    var isEmpty = function (r) {
      for (var x in r) {
        if (hasOwnProperty.call(r, x)) {
          return false;
        }
      }
      return true;
    };

    var validSectionList = [
      'tfoot',
      'thead',
      'tbody',
      'colgroup'
    ];
    var isValidSection = function (parentName) {
      return contains$2(validSectionList, parentName);
    };
    var grid = function (rows, columns) {
      return {
        rows: rows,
        columns: columns
      };
    };
    var address = function (row, column) {
      return {
        row: row,
        column: column
      };
    };
    var detail = function (element, rowspan, colspan) {
      return {
        element: element,
        rowspan: rowspan,
        colspan: colspan
      };
    };
    var detailnew = function (element, rowspan, colspan, isNew) {
      return {
        element: element,
        rowspan: rowspan,
        colspan: colspan,
        isNew: isNew
      };
    };
    var extended = function (element, rowspan, colspan, row, column, isLocked) {
      return {
        element: element,
        rowspan: rowspan,
        colspan: colspan,
        row: row,
        column: column,
        isLocked: isLocked
      };
    };
    var rowdetail = function (element, cells, section) {
      return {
        element: element,
        cells: cells,
        section: section
      };
    };
    var rowdetailnew = function (element, cells, section, isNew) {
      return {
        element: element,
        cells: cells,
        section: section,
        isNew: isNew
      };
    };
    var elementnew = function (element, isNew, isLocked) {
      return {
        element: element,
        isNew: isNew,
        isLocked: isLocked
      };
    };
    var rowcells = function (element, cells, section, isNew) {
      return {
        element: element,
        cells: cells,
        section: section,
        isNew: isNew
      };
    };
    var bounds = function (startRow, startCol, finishRow, finishCol) {
      return {
        startRow: startRow,
        startCol: startCol,
        finishRow: finishRow,
        finishCol: finishCol
      };
    };
    var columnext = function (element, colspan, column) {
      return {
        element: element,
        colspan: colspan,
        column: column
      };
    };
    var colgroup = function (element, columns) {
      return {
        element: element,
        columns: columns
      };
    };

    typeof window !== 'undefined' ? window : Function('return this;')();

    var name = function (element) {
      var r = element.dom.nodeName;
      return r.toLowerCase();
    };
    var type$1 = function (element) {
      return element.dom.nodeType;
    };
    var isType = function (t) {
      return function (element) {
        return type$1(element) === t;
      };
    };
    var isComment = function (element) {
      return type$1(element) === COMMENT || name(element) === '#comment';
    };
    var isElement = isType(ELEMENT);
    var isText = isType(TEXT);
    var isDocument = isType(DOCUMENT);
    var isDocumentFragment = isType(DOCUMENT_FRAGMENT);
    var isTag = function (tag) {
      return function (e) {
        return isElement(e) && name(e) === tag;
      };
    };

    var owner = function (element) {
      return SugarElement.fromDom(element.dom.ownerDocument);
    };
    var documentOrOwner = function (dos) {
      return isDocument(dos) ? dos : owner(dos);
    };
    var defaultView = function (element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    };
    var parent = function (element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var parentElement = function (element) {
      return Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    };
    var parents = function (element, isRoot) {
      var stop = isFunction(isRoot) ? isRoot : never;
      var dom = element.dom;
      var ret = [];
      while (dom.parentNode !== null && dom.parentNode !== undefined) {
        var rawParent = dom.parentNode;
        var p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
          break;
        } else {
          dom = rawParent;
        }
      }
      return ret;
    };
    var prevSibling = function (element) {
      return Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    };
    var nextSibling = function (element) {
      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    };
    var children$3 = function (element) {
      return map$1(element.dom.childNodes, SugarElement.fromDom);
    };
    var child$3 = function (element, index) {
      var cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    var firstChild = function (element) {
      return child$3(element, 0);
    };

    var isShadowRoot = function (dos) {
      return isDocumentFragment(dos) && isNonNullable(dos.dom.host);
    };
    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    var isSupported$1 = constant(supported);
    var getRootNode = supported ? function (e) {
      return SugarElement.fromDom(e.dom.getRootNode());
    } : documentOrOwner;
    var getShadowRoot = function (e) {
      var r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    var getShadowHost = function (e) {
      return SugarElement.fromDom(e.dom.host);
    };
    var getOriginalEventTarget = function (event) {
      if (isSupported$1() && isNonNullable(event.target)) {
        var el = SugarElement.fromDom(event.target);
        if (isElement(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    var isOpenShadowHost = function (element) {
      return isNonNullable(element.dom.shadowRoot);
    };

    var inBody = function (element) {
      var dom = isText(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      var doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {
        return doc.body.contains(dom);
      }, compose1(inBody, getShadowHost));
    };
    var body$1 = function () {
      return getBody$1(SugarElement.fromDom(document));
    };
    var getBody$1 = function (doc) {
      var b = doc.dom.body;
      if (b === null || b === undefined) {
        throw new Error('Body is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    var ancestors$4 = function (scope, predicate, isRoot) {
      return filter$2(parents(scope, isRoot), predicate);
    };
    var children$2 = function (scope, predicate) {
      return filter$2(children$3(scope), predicate);
    };
    var descendants$1 = function (scope, predicate) {
      var result = [];
      each$2(children$3(scope), function (x) {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants$1(x, predicate));
      });
      return result;
    };

    var ancestors$3 = function (scope, selector, isRoot) {
      return ancestors$4(scope, function (e) {
        return is$2(e, selector);
      }, isRoot);
    };
    var children$1 = function (scope, selector) {
      return children$2(scope, function (e) {
        return is$2(e, selector);
      });
    };
    var descendants = function (scope, selector) {
      return all$1(selector, scope);
    };

    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
      if (is(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor(scope, a, isRoot);
      }
    }

    var ancestor$2 = function (scope, predicate, isRoot) {
      var element = scope.dom;
      var stop = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$2 = function (scope, predicate, isRoot) {
      var is = function (s, test) {
        return test(s);
      };
      return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);
    };
    var child$2 = function (scope, predicate) {
      var pred = function (node) {
        return predicate(SugarElement.fromDom(node));
      };
      var result = find$1(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    var descendant$1 = function (scope, predicate) {
      var descend = function (node) {
        for (var i = 0; i < node.childNodes.length; i++) {
          var child_1 = SugarElement.fromDom(node.childNodes[i]);
          if (predicate(child_1)) {
            return Optional.some(child_1);
          }
          var res = descend(node.childNodes[i]);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope.dom);
    };

    var ancestor$1 = function (scope, selector, isRoot) {
      return ancestor$2(scope, function (e) {
        return is$2(e, selector);
      }, isRoot);
    };
    var child$1 = function (scope, selector) {
      return child$2(scope, function (e) {
        return is$2(e, selector);
      });
    };
    var descendant = function (scope, selector) {
      return one(selector, scope);
    };
    var closest$1 = function (scope, selector, isRoot) {
      var is = function (element, selector) {
        return is$2(element, selector);
      };
      return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);
    };

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    var set$2 = function (element, key, value) {
      rawSet(element.dom, key, value);
    };
    var setAll$1 = function (element, attrs) {
      var dom = element.dom;
      each$1(attrs, function (v, k) {
        rawSet(dom, k, v);
      });
    };
    var setOptions = function (element, attrs) {
      each$1(attrs, function (v, k) {
        v.fold(function () {
          remove$7(element, k);
        }, function (value) {
          rawSet(element.dom, k, value);
        });
      });
    };
    var get$b = function (element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    var getOpt = function (element, key) {
      return Optional.from(get$b(element, key));
    };
    var remove$7 = function (element, key) {
      element.dom.removeAttribute(key);
    };
    var clone$2 = function (element) {
      return foldl(element.dom.attributes, function (acc, attr) {
        acc[attr.name] = attr.value;
        return acc;
      }, {});
    };

    var is = function (lhs, rhs, comparator) {
      if (comparator === void 0) {
        comparator = tripleEquals;
      }
      return lhs.exists(function (left) {
        return comparator(left, rhs);
      });
    };
    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    var lift2 = function (oa, ob, f) {
      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    };
    var bindFrom = function (a, f) {
      return a !== undefined && a !== null ? f(a) : Optional.none();
    };
    var flatten = function (oot) {
      return oot.bind(identity);
    };
    var someIf = function (b, a) {
      return b ? Optional.some(a) : Optional.none();
    };

    var isSupported = function (dom) {
      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
    };

    var internalSet = function (dom, property, value) {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var internalRemove = function (dom, property) {
      if (isSupported(dom)) {
        dom.style.removeProperty(property);
      }
    };
    var set$1 = function (element, property, value) {
      var dom = element.dom;
      internalSet(dom, property, value);
    };
    var setAll = function (element, css) {
      var dom = element.dom;
      each$1(css, function (v, k) {
        internalSet(dom, k, v);
      });
    };
    var get$a = function (element, property) {
      var dom = element.dom;
      var styles = window.getComputedStyle(dom);
      var r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    var getUnsafeProperty = function (dom, property) {
      return isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    };
    var getRaw$2 = function (element, property) {
      var dom = element.dom;
      var raw = getUnsafeProperty(dom, property);
      return Optional.from(raw).filter(function (r) {
        return r.length > 0;
      });
    };
    var remove$6 = function (element, property) {
      var dom = element.dom;
      internalRemove(dom, property);
      if (is(getOpt(element, 'style').map(trim), '')) {
        remove$7(element, 'style');
      }
    };
    var copy$2 = function (source, target) {
      var sourceDom = source.dom;
      var targetDom = target.dom;
      if (isSupported(sourceDom) && isSupported(targetDom)) {
        targetDom.style.cssText = sourceDom.style.cssText;
      }
    };

    var getAttrValue = function (cell, name, fallback) {
      if (fallback === void 0) {
        fallback = 0;
      }
      return getOpt(cell, name).map(function (value) {
        return parseInt(value, 10);
      }).getOr(fallback);
    };
    var getSpan = function (cell, type) {
      return getAttrValue(cell, type, 1);
    };
    var hasColspan = function (cellOrCol) {
      if (isTag('col')(cellOrCol)) {
        return getAttrValue(cellOrCol, 'span', 1) > 1;
      } else {
        return getSpan(cellOrCol, 'colspan') > 1;
      }
    };
    var hasRowspan = function (cell) {
      return getSpan(cell, 'rowspan') > 1;
    };
    var getCssValue = function (element, property) {
      return parseInt(get$a(element, property), 10);
    };
    var minWidth = constant(10);
    var minHeight = constant(10);

    var firstLayer = function (scope, selector) {
      return filterFirstLayer(scope, selector, always);
    };
    var filterFirstLayer = function (scope, selector, predicate) {
      return bind$2(children$3(scope), function (x) {
        if (is$2(x, selector)) {
          return predicate(x) ? [x] : [];
        } else {
          return filterFirstLayer(x, selector, predicate);
        }
      });
    };

    var lookup = function (tags, element, isRoot) {
      if (isRoot === void 0) {
        isRoot = never;
      }
      if (isRoot(element)) {
        return Optional.none();
      }
      if (contains$2(tags, name(element))) {
        return Optional.some(element);
      }
      var isRootOrUpperTable = function (elm) {
        return is$2(elm, 'table') || isRoot(elm);
      };
      return ancestor$1(element, tags.join(','), isRootOrUpperTable);
    };
    var cell = function (element, isRoot) {
      return lookup([
        'td',
        'th'
      ], element, isRoot);
    };
    var cells$1 = function (ancestor) {
      return firstLayer(ancestor, 'th,td');
    };
    var columns$1 = function (ancestor) {
      if (is$2(ancestor, 'colgroup')) {
        return children$1(ancestor, 'col');
      } else {
        return bind$2(columnGroups(ancestor), function (columnGroup) {
          return children$1(columnGroup, 'col');
        });
      }
    };
    var table = function (element, isRoot) {
      return closest$1(element, 'table', isRoot);
    };
    var rows$1 = function (ancestor) {
      return firstLayer(ancestor, 'tr');
    };
    var columnGroups = function (ancestor) {
      return table(ancestor).fold(constant([]), function (table) {
        return children$1(table, 'colgroup');
      });
    };

    var fromRowsOrColGroups = function (elems, getSection) {
      return map$1(elems, function (row) {
        if (name(row) === 'colgroup') {
          var cells = map$1(columns$1(row), function (column) {
            var colspan = getAttrValue(column, 'span', 1);
            return detail(column, 1, colspan);
          });
          return rowdetail(row, cells, 'colgroup');
        } else {
          var cells = map$1(cells$1(row), function (cell) {
            var rowspan = getAttrValue(cell, 'rowspan', 1);
            var colspan = getAttrValue(cell, 'colspan', 1);
            return detail(cell, rowspan, colspan);
          });
          return rowdetail(row, cells, getSection(row));
        }
      });
    };
    var getParentSection = function (group) {
      return parent(group).map(function (parent) {
        var parentName = name(parent);
        return isValidSection(parentName) ? parentName : 'tbody';
      }).getOr('tbody');
    };
    var fromTable$1 = function (table) {
      var rows = rows$1(table);
      var columnGroups$1 = columnGroups(table);
      var elems = __spreadArray(__spreadArray([], columnGroups$1, true), rows, true);
      return fromRowsOrColGroups(elems, getParentSection);
    };
    var fromPastedRows = function (elems, section) {
      return fromRowsOrColGroups(elems, function () {
        return section;
      });
    };

    var addCells = function (gridRow, index, cells) {
      var existingCells = gridRow.cells;
      var before = existingCells.slice(0, index);
      var after = existingCells.slice(index);
      var newCells = before.concat(cells).concat(after);
      return setCells(gridRow, newCells);
    };
    var addCell = function (gridRow, index, cell) {
      return addCells(gridRow, index, [cell]);
    };
    var mutateCell = function (gridRow, index, cell) {
      var cells = gridRow.cells;
      cells[index] = cell;
    };
    var setCells = function (gridRow, cells) {
      return rowcells(gridRow.element, cells, gridRow.section, gridRow.isNew);
    };
    var mapCells = function (gridRow, f) {
      var cells = gridRow.cells;
      var r = map$1(cells, f);
      return rowcells(gridRow.element, r, gridRow.section, gridRow.isNew);
    };
    var getCell = function (gridRow, index) {
      return gridRow.cells[index];
    };
    var getCellElement = function (gridRow, index) {
      return getCell(gridRow, index).element;
    };
    var cellLength = function (gridRow) {
      return gridRow.cells.length;
    };
    var extractGridDetails = function (grid) {
      var result = partition(grid, function (row) {
        return row.section === 'colgroup';
      });
      return {
        rows: result.fail,
        cols: result.pass
      };
    };
    var clone$1 = function (gridRow, cloneRow, cloneCell) {
      var newCells = map$1(gridRow.cells, cloneCell);
      return rowcells(cloneRow(gridRow.element), newCells, gridRow.section, true);
    };

    var LOCKED_COL_ATTR = 'data-snooker-locked-cols';
    var getLockedColumnsFromTable = function (table) {
      return getOpt(table, LOCKED_COL_ATTR).bind(function (lockedColStr) {
        return Optional.from(lockedColStr.match(/\d+/g));
      }).map(function (lockedCols) {
        return mapToObject(lockedCols, always);
      });
    };
    var getLockedColumnsFromGrid = function (grid) {
      var locked = foldl(extractGridDetails(grid).rows, function (acc, row) {
        each$2(row.cells, function (cell, idx) {
          if (cell.isLocked) {
            acc[idx] = true;
          }
        });
        return acc;
      }, {});
      var lockedArr = mapToArray(locked, function (_val, key) {
        return parseInt(key, 10);
      });
      return sort$1(lockedArr);
    };

    var key = function (row, column) {
      return row + ',' + column;
    };
    var getAt = function (warehouse, row, column) {
      return Optional.from(warehouse.access[key(row, column)]);
    };
    var findItem = function (warehouse, item, comparator) {
      var filtered = filterItems(warehouse, function (detail) {
        return comparator(item, detail.element);
      });
      return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();
    };
    var filterItems = function (warehouse, predicate) {
      var all = bind$2(warehouse.all, function (r) {
        return r.cells;
      });
      return filter$2(all, predicate);
    };
    var generateColumns = function (rowData) {
      var columnsGroup = {};
      var index = 0;
      each$2(rowData.cells, function (column) {
        var colspan = column.colspan;
        range$1(colspan, function (columnIndex) {
          var colIndex = index + columnIndex;
          columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);
        });
        index += colspan;
      });
      return columnsGroup;
    };
    var generate$1 = function (list) {
      var access = {};
      var cells = [];
      var tableOpt = head(list).map(function (rowData) {
        return rowData.element;
      }).bind(table);
      var lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});
      var maxRows = 0;
      var maxColumns = 0;
      var rowCount = 0;
      var _a = partition(list, function (rowData) {
          return rowData.section === 'colgroup';
        }), colgroupRows = _a.pass, rows = _a.fail;
      each$2(rows, function (rowData) {
        var currentRow = [];
        each$2(rowData.cells, function (rowCell) {
          var start = 0;
          while (access[key(rowCount, start)] !== undefined) {
            start++;
          }
          var isLocked = hasNonNullableKey(lockedColumns, start.toString());
          var current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);
          for (var occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {
            for (var occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {
              var rowPosition = rowCount + occupiedRowPosition;
              var columnPosition = start + occupiedColumnPosition;
              var newpos = key(rowPosition, columnPosition);
              access[newpos] = current;
              maxColumns = Math.max(maxColumns, columnPosition + 1);
            }
          }
          currentRow.push(current);
        });
        maxRows++;
        cells.push(rowdetail(rowData.element, currentRow, rowData.section));
        rowCount++;
      });
      var _b = last$2(colgroupRows).map(function (rowData) {
          var columns = generateColumns(rowData);
          var colgroup$1 = colgroup(rowData.element, values(columns));
          return {
            colgroups: [colgroup$1],
            columns: columns
          };
        }).getOrThunk(function () {
          return {
            colgroups: [],
            columns: {}
          };
        }), columns = _b.columns, colgroups = _b.colgroups;
      var grid$1 = grid(maxRows, maxColumns);
      return {
        grid: grid$1,
        access: access,
        all: cells,
        columns: columns,
        colgroups: colgroups
      };
    };
    var fromTable = function (table) {
      var list = fromTable$1(table);
      return generate$1(list);
    };
    var justCells = function (warehouse) {
      return bind$2(warehouse.all, function (w) {
        return w.cells;
      });
    };
    var justColumns = function (warehouse) {
      return values(warehouse.columns);
    };
    var hasColumns = function (warehouse) {
      return keys(warehouse.columns).length > 0;
    };
    var getColumnAt = function (warehouse, columnIndex) {
      return Optional.from(warehouse.columns[columnIndex]);
    };
    var Warehouse = {
      fromTable: fromTable,
      generate: generate$1,
      getAt: getAt,
      findItem: findItem,
      filterItems: filterItems,
      justCells: justCells,
      justColumns: justColumns,
      hasColumns: hasColumns,
      getColumnAt: getColumnAt
    };

    var inSelection = function (bounds, detail) {
      var leftEdge = detail.column;
      var rightEdge = detail.column + detail.colspan - 1;
      var topEdge = detail.row;
      var bottomEdge = detail.row + detail.rowspan - 1;
      return leftEdge <= bounds.finishCol && rightEdge >= bounds.startCol && (topEdge <= bounds.finishRow && bottomEdge >= bounds.startRow);
    };
    var isWithin = function (bounds, detail) {
      return detail.column >= bounds.startCol && detail.column + detail.colspan - 1 <= bounds.finishCol && detail.row >= bounds.startRow && detail.row + detail.rowspan - 1 <= bounds.finishRow;
    };
    var isRectangular = function (warehouse, bounds) {
      var isRect = true;
      var detailIsWithin = curry(isWithin, bounds);
      for (var i = bounds.startRow; i <= bounds.finishRow; i++) {
        for (var j = bounds.startCol; j <= bounds.finishCol; j++) {
          isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
        }
      }
      return isRect ? Optional.some(bounds) : Optional.none();
    };

    var getBounds = function (detailA, detailB) {
      return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));
    };
    var getAnyBox = function (warehouse, startCell, finishCell) {
      var startCoords = Warehouse.findItem(warehouse, startCell, eq$1);
      var finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);
      return startCoords.bind(function (sc) {
        return finishCoords.map(function (fc) {
          return getBounds(sc, fc);
        });
      });
    };
    var getBox$1 = function (warehouse, startCell, finishCell) {
      return getAnyBox(warehouse, startCell, finishCell).bind(function (bounds) {
        return isRectangular(warehouse, bounds);
      });
    };

    var moveBy$1 = function (warehouse, cell, row, column) {
      return Warehouse.findItem(warehouse, cell, eq$1).bind(function (detail) {
        var startRow = row > 0 ? detail.row + detail.rowspan - 1 : detail.row;
        var startCol = column > 0 ? detail.column + detail.colspan - 1 : detail.column;
        var dest = Warehouse.getAt(warehouse, startRow + row, startCol + column);
        return dest.map(function (d) {
          return d.element;
        });
      });
    };
    var intercepts$1 = function (warehouse, start, finish) {
      return getAnyBox(warehouse, start, finish).map(function (bounds) {
        var inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds));
        return map$1(inside, function (detail) {
          return detail.element;
        });
      });
    };
    var parentCell = function (warehouse, innerCell) {
      var isContainedBy = function (c1, c2) {
        return contains(c2, c1);
      };
      return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(function (detail) {
        return detail.element;
      });
    };

    var moveBy = function (cell, deltaRow, deltaColumn) {
      return table(cell).bind(function (table) {
        var warehouse = getWarehouse(table);
        return moveBy$1(warehouse, cell, deltaRow, deltaColumn);
      });
    };
    var intercepts = function (table, first, last) {
      var warehouse = getWarehouse(table);
      return intercepts$1(warehouse, first, last);
    };
    var nestedIntercepts = function (table, first, firstTable, last, lastTable) {
      var warehouse = getWarehouse(table);
      var optStartCell = eq$1(table, firstTable) ? Optional.some(first) : parentCell(warehouse, first);
      var optLastCell = eq$1(table, lastTable) ? Optional.some(last) : parentCell(warehouse, last);
      return optStartCell.bind(function (startCell) {
        return optLastCell.bind(function (lastCell) {
          return intercepts$1(warehouse, startCell, lastCell);
        });
      });
    };
    var getBox = function (table, first, last) {
      var warehouse = getWarehouse(table);
      return getBox$1(warehouse, first, last);
    };
    var getWarehouse = Warehouse.fromTable;

    var before$4 = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var after$5 = function (marker, element) {
      var sibling = nextSibling(marker);
      sibling.fold(function () {
        var parent$1 = parent(marker);
        parent$1.each(function (v) {
          append$1(v, element);
        });
      }, function (v) {
        before$4(v, element);
      });
    };
    var prepend = function (parent, element) {
      var firstChild$1 = firstChild(parent);
      firstChild$1.fold(function () {
        append$1(parent, element);
      }, function (v) {
        parent.dom.insertBefore(element.dom, v.dom);
      });
    };
    var append$1 = function (parent, element) {
      parent.dom.appendChild(element.dom);
    };
    var appendAt = function (parent, element, index) {
      child$3(parent, index).fold(function () {
        append$1(parent, element);
      }, function (v) {
        before$4(v, element);
      });
    };
    var wrap = function (element, wrapper) {
      before$4(element, wrapper);
      append$1(wrapper, element);
    };

    var before$3 = function (marker, elements) {
      each$2(elements, function (x) {
        before$4(marker, x);
      });
    };
    var after$4 = function (marker, elements) {
      each$2(elements, function (x, i) {
        var e = i === 0 ? marker : elements[i - 1];
        after$5(e, x);
      });
    };
    var append = function (parent, elements) {
      each$2(elements, function (x) {
        append$1(parent, x);
      });
    };

    var empty = function (element) {
      element.dom.textContent = '';
      each$2(children$3(element), function (rogue) {
        remove$5(rogue);
      });
    };
    var remove$5 = function (element) {
      var dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    var unwrap = function (wrapper) {
      var children = children$3(wrapper);
      if (children.length > 0) {
        before$3(wrapper, children);
      }
      remove$5(wrapper);
    };

    var NodeValue = function (is, name) {
      var get = function (element) {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      var getOption = function (element) {
        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      };
      var set = function (element, value) {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get: get,
        getOption: getOption,
        set: set
      };
    };

    var api$2 = NodeValue(isText, 'text');
    var get$9 = function (element) {
      return api$2.get(element);
    };
    var getOption = function (element) {
      return api$2.getOption(element);
    };
    var set = function (element, value) {
      return api$2.set(element, value);
    };

    var TagBoundaries = [
      'body',
      'p',
      'div',
      'article',
      'aside',
      'figcaption',
      'figure',
      'footer',
      'header',
      'nav',
      'section',
      'ol',
      'ul',
      'li',
      'table',
      'thead',
      'tbody',
      'tfoot',
      'caption',
      'tr',
      'td',
      'th',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'blockquote',
      'pre',
      'address'
    ];

    function DomUniverse () {
      var clone = function (element) {
        return SugarElement.fromDom(element.dom.cloneNode(false));
      };
      var document = function (element) {
        return documentOrOwner(element).dom;
      };
      var isBoundary = function (element) {
        if (!isElement(element)) {
          return false;
        }
        if (name(element) === 'body') {
          return true;
        }
        return contains$2(TagBoundaries, name(element));
      };
      var isEmptyTag = function (element) {
        if (!isElement(element)) {
          return false;
        }
        return contains$2([
          'br',
          'img',
          'hr',
          'input'
        ], name(element));
      };
      var isNonEditable = function (element) {
        return isElement(element) && get$b(element, 'contenteditable') === 'false';
      };
      var comparePosition = function (element, other) {
        return element.dom.compareDocumentPosition(other.dom);
      };
      var copyAttributesTo = function (source, destination) {
        var as = clone$2(source);
        setAll$1(destination, as);
      };
      var isSpecial = function (element) {
        var tag = name(element);
        return contains$2([
          'script',
          'noscript',
          'iframe',
          'noframes',
          'noembed',
          'title',
          'style',
          'textarea',
          'xmp'
        ], tag);
      };
      var getLanguage = function (element) {
        return isElement(element) ? getOpt(element, 'lang') : Optional.none();
      };
      return {
        up: constant({
          selector: ancestor$1,
          closest: closest$1,
          predicate: ancestor$2,
          all: parents
        }),
        down: constant({
          selector: descendants,
          predicate: descendants$1
        }),
        styles: constant({
          get: get$a,
          getRaw: getRaw$2,
          set: set$1,
          remove: remove$6
        }),
        attrs: constant({
          get: get$b,
          set: set$2,
          remove: remove$7,
          copyTo: copyAttributesTo
        }),
        insert: constant({
          before: before$4,
          after: after$5,
          afterAll: after$4,
          append: append$1,
          appendAll: append,
          prepend: prepend,
          wrap: wrap
        }),
        remove: constant({
          unwrap: unwrap,
          remove: remove$5
        }),
        create: constant({
          nu: SugarElement.fromTag,
          clone: clone,
          text: SugarElement.fromText
        }),
        query: constant({
          comparePosition: comparePosition,
          prevSibling: prevSibling,
          nextSibling: nextSibling
        }),
        property: constant({
          children: children$3,
          name: name,
          parent: parent,
          document: document,
          isText: isText,
          isComment: isComment,
          isElement: isElement,
          isSpecial: isSpecial,
          getLanguage: getLanguage,
          getText: get$9,
          setText: set,
          isBoundary: isBoundary,
          isEmptyTag: isEmptyTag,
          isNonEditable: isNonEditable
        }),
        eq: eq$1,
        is: is$1
      };
    }

    var all = function (universe, look, elements, f) {
      var head = elements[0];
      var tail = elements.slice(1);
      return f(universe, look, head, tail);
    };
    var oneAll = function (universe, look, elements) {
      return elements.length > 0 ? all(universe, look, elements, unsafeOne) : Optional.none();
    };
    var unsafeOne = function (universe, look, head, tail) {
      var start = look(universe, head);
      return foldr(tail, function (b, a) {
        var current = look(universe, a);
        return commonElement(universe, b, current);
      }, start);
    };
    var commonElement = function (universe, start, end) {
      return start.bind(function (s) {
        return end.filter(curry(universe.eq, s));
      });
    };

    var eq = function (universe, item) {
      return curry(universe.eq, item);
    };
    var ancestors$2 = function (universe, start, end, isRoot) {
      if (isRoot === void 0) {
        isRoot = never;
      }
      var ps1 = [start].concat(universe.up().all(start));
      var ps2 = [end].concat(universe.up().all(end));
      var prune = function (path) {
        var index = findIndex(path, isRoot);
        return index.fold(function () {
          return path;
        }, function (ind) {
          return path.slice(0, ind + 1);
        });
      };
      var pruned1 = prune(ps1);
      var pruned2 = prune(ps2);
      var shared = find$1(pruned1, function (x) {
        return exists(pruned2, eq(universe, x));
      });
      return {
        firstpath: pruned1,
        secondpath: pruned2,
        shared: shared
      };
    };

    var sharedOne$1 = oneAll;
    var ancestors$1 = ancestors$2;

    var universe$3 = DomUniverse();
    var sharedOne = function (look, elements) {
      return sharedOne$1(universe$3, function (_universe, element) {
        return look(element);
      }, elements);
    };
    var ancestors = function (start, finish, isRoot) {
      return ancestors$1(universe$3, start, finish, isRoot);
    };

    var lookupTable = function (container) {
      return ancestor$1(container, 'table');
    };
    var identify = function (start, finish, isRoot) {
      var getIsRoot = function (rootTable) {
        return function (element) {
          return isRoot !== undefined && isRoot(element) || eq$1(element, rootTable);
        };
      };
      if (eq$1(start, finish)) {
        return Optional.some({
          boxes: Optional.some([start]),
          start: start,
          finish: finish
        });
      } else {
        return lookupTable(start).bind(function (startTable) {
          return lookupTable(finish).bind(function (finishTable) {
            if (eq$1(startTable, finishTable)) {
              return Optional.some({
                boxes: intercepts(startTable, start, finish),
                start: start,
                finish: finish
              });
            } else if (contains(startTable, finishTable)) {
              var ancestorCells = ancestors$3(finish, 'td,th', getIsRoot(startTable));
              var finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
              return Optional.some({
                boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),
                start: start,
                finish: finishCell
              });
            } else if (contains(finishTable, startTable)) {
              var ancestorCells = ancestors$3(start, 'td,th', getIsRoot(finishTable));
              var startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;
              return Optional.some({
                boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),
                start: start,
                finish: startCell
              });
            } else {
              return ancestors(start, finish).shared.bind(function (lca) {
                return closest$1(lca, 'table', isRoot).bind(function (lcaTable) {
                  var finishAncestorCells = ancestors$3(finish, 'td,th', getIsRoot(lcaTable));
                  var finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
                  var startAncestorCells = ancestors$3(start, 'td,th', getIsRoot(lcaTable));
                  var startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;
                  return Optional.some({
                    boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),
                    start: startCell,
                    finish: finishCell
                  });
                });
              });
            }
          });
        });
      }
    };
    var retrieve$1 = function (container, selector) {
      var sels = descendants(container, selector);
      return sels.length > 0 ? Optional.some(sels) : Optional.none();
    };
    var getLast = function (boxes, lastSelectedSelector) {
      return find$1(boxes, function (box) {
        return is$2(box, lastSelectedSelector);
      });
    };
    var getEdges = function (container, firstSelectedSelector, lastSelectedSelector) {
      return descendant(container, firstSelectedSelector).bind(function (first) {
        return descendant(container, lastSelectedSelector).bind(function (last) {
          return sharedOne(lookupTable, [
            first,
            last
          ]).map(function (table) {
            return {
              first: first,
              last: last,
              table: table
            };
          });
        });
      });
    };
    var expandTo = function (finish, firstSelectedSelector) {
      return ancestor$1(finish, 'table').bind(function (table) {
        return descendant(table, firstSelectedSelector).bind(function (start) {
          return identify(start, finish).bind(function (identified) {
            return identified.boxes.map(function (boxes) {
              return {
                boxes: boxes,
                start: identified.start,
                finish: identified.finish
              };
            });
          });
        });
      });
    };
    var shiftSelection = function (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) {
      return getLast(boxes, lastSelectedSelector).bind(function (last) {
        return moveBy(last, deltaRow, deltaColumn).bind(function (finish) {
          return expandTo(finish, firstSelectedSelector);
        });
      });
    };

    var retrieve = function (container, selector) {
      return retrieve$1(container, selector);
    };
    var retrieveBox = function (container, firstSelectedSelector, lastSelectedSelector) {
      return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind(function (edges) {
        var isRoot = function (ancestor) {
          return eq$1(container, ancestor);
        };
        var sectionSelector = 'thead,tfoot,tbody,table';
        var firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);
        var lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);
        return firstAncestor.bind(function (fA) {
          return lastAncestor.bind(function (lA) {
            return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();
          });
        });
      });
    };

    var generate = function (cases) {
      if (!isArray(cases)) {
        throw new Error('cases must be an array');
      }
      if (cases.length === 0) {
        throw new Error('there must be at least one case');
      }
      var constructors = [];
      var adt = {};
      each$2(cases, function (acase, count) {
        var keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error('one and only one name per case');
        }
        var key = keys$1[0];
        var value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error('duplicate key detected:' + key);
        } else if (key === 'cata') {
          throw new Error('cannot have a case named cata (sorry)');
        } else if (!isArray(value)) {
          throw new Error('case arguments must be an array');
        }
        constructors.push(key);
        adt[key] = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var argLength = args.length;
          if (argLength !== value.length) {
            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
          }
          var match = function (branches) {
            var branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
            }
            var allReqd = forall(constructors, function (reqKey) {
              return contains$2(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: function () {
              var foldArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                foldArgs[_i] = arguments[_i];
              }
              if (foldArgs.length !== cases.length) {
                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
              }
              var target = foldArgs[count];
              return target.apply(null, args);
            },
            match: match,
            log: function (label) {
              console.log(label, {
                constructors: constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    var Adt = { generate: generate };

    var type = Adt.generate([
      { none: [] },
      { multiple: ['elements'] },
      { single: ['element'] }
    ]);
    var cata$2 = function (subject, onNone, onMultiple, onSingle) {
      return subject.fold(onNone, onMultiple, onSingle);
    };
    var none$1 = type.none;
    var multiple = type.multiple;
    var single = type.single;

    var Selections = function (lazyRoot, getStart, selectedSelector) {
      var get = function () {
        return retrieve(lazyRoot(), selectedSelector).fold(function () {
          return getStart().fold(none$1, single);
        }, function (cells) {
          return multiple(cells);
        });
      };
      return { get: get };
    };

    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var clone = function (original, isDeep) {
      return SugarElement.fromDom(original.dom.cloneNode(isDeep));
    };
    var shallow = function (original) {
      return clone(original, false);
    };
    var deep = function (original) {
      return clone(original, true);
    };
    var shallowAs = function (original, tag) {
      var nu = SugarElement.fromTag(tag);
      var attributes = clone$2(original);
      setAll$1(nu, attributes);
      return nu;
    };
    var copy$1 = function (original, tag) {
      var nu = shallowAs(original, tag);
      var cloneChildren = children$3(deep(original));
      append(nu, cloneChildren);
      return nu;
    };
    var mutate$1 = function (original, tag) {
      var nu = shallowAs(original, tag);
      before$4(original, nu);
      var children = children$3(original);
      append(nu, children);
      remove$5(original);
      return nu;
    };

    var Dimension = function (name, getOffset) {
      var set = function (element, h) {
        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
        }
        var dom = element.dom;
        if (isSupported(dom)) {
          dom.style[name] = h + 'px';
        }
      };
      var get = function (element) {
        var r = getOffset(element);
        if (r <= 0 || r === null) {
          var css = get$a(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      var getOuter = get;
      var aggregate = function (element, properties) {
        return foldl(properties, function (acc, property) {
          var val = get$a(element, property);
          var value = val === undefined ? 0 : parseInt(val, 10);
          return isNaN(value) ? acc : acc + value;
        }, 0);
      };
      var max = function (element, value, properties) {
        var cumulativeInclusions = aggregate(element, properties);
        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set,
        get: get,
        getOuter: getOuter,
        aggregate: aggregate,
        max: max
      };
    };

    var needManualCalc = function () {
      var browser = detect$3().browser;
      return browser.isIE() || browser.isEdge();
    };
    var toNumber = function (px, fallback) {
      return toFloat(px).getOr(fallback);
    };
    var getProp = function (element, name, fallback) {
      return toNumber(get$a(element, name), fallback);
    };
    var getBoxSizing = function (element) {
      return get$a(element, 'box-sizing');
    };
    var calcContentBoxSize = function (element, size, upper, lower) {
      var paddingUpper = getProp(element, 'padding-' + upper, 0);
      var paddingLower = getProp(element, 'padding-' + lower, 0);
      var borderUpper = getProp(element, 'border-' + upper + '-width', 0);
      var borderLower = getProp(element, 'border-' + lower + '-width', 0);
      return size - paddingUpper - paddingLower - borderUpper - borderLower;
    };
    var getCalculatedHeight = function (element, boxSizing) {
      var dom = element.dom;
      var height = dom.getBoundingClientRect().height || dom.offsetHeight;
      return boxSizing === 'border-box' ? height : calcContentBoxSize(element, height, 'top', 'bottom');
    };
    var getCalculatedWidth = function (element, boxSizing) {
      var dom = element.dom;
      var width = dom.getBoundingClientRect().width || dom.offsetWidth;
      return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');
    };
    var getHeight$1 = function (element) {
      return needManualCalc() ? getCalculatedHeight(element, getBoxSizing(element)) : getProp(element, 'height', element.dom.offsetHeight);
    };
    var getWidth = function (element) {
      return needManualCalc() ? getCalculatedWidth(element, getBoxSizing(element)) : getProp(element, 'width', element.dom.offsetWidth);
    };
    var getInnerWidth = function (element) {
      return getCalculatedWidth(element, 'content-box');
    };

    var api$1 = Dimension('width', function (element) {
      return element.dom.offsetWidth;
    });
    var get$8 = function (element) {
      return api$1.get(element);
    };
    var getOuter$2 = function (element) {
      return api$1.getOuter(element);
    };
    var getInner = getInnerWidth;
    var getRuntime$1 = getWidth;

    var columns = function (warehouse, isValidCell) {
      if (isValidCell === void 0) {
        isValidCell = always;
      }
      var grid = warehouse.grid;
      var cols = range$1(grid.columns, identity);
      var rowsArr = range$1(grid.rows, identity);
      return map$1(cols, function (col) {
        var getBlock = function () {
          return bind$2(rowsArr, function (r) {
            return Warehouse.getAt(warehouse, r, col).filter(function (detail) {
              return detail.column === col;
            }).toArray();
          });
        };
        var isValid = function (detail) {
          return detail.colspan === 1 && isValidCell(detail.element);
        };
        var getFallback = function () {
          return Warehouse.getAt(warehouse, 0, col);
        };
        return decide(getBlock, isValid, getFallback);
      });
    };
    var decide = function (getBlock, isValid, getFallback) {
      var inBlock = getBlock();
      var validInBlock = find$1(inBlock, isValid);
      var detailOption = validInBlock.orThunk(function () {
        return Optional.from(inBlock[0]).orThunk(getFallback);
      });
      return detailOption.map(function (detail) {
        return detail.element;
      });
    };
    var rows = function (warehouse) {
      var grid = warehouse.grid;
      var rowsArr = range$1(grid.rows, identity);
      var cols = range$1(grid.columns, identity);
      return map$1(rowsArr, function (row) {
        var getBlock = function () {
          return bind$2(cols, function (c) {
            return Warehouse.getAt(warehouse, row, c).filter(function (detail) {
              return detail.row === row;
            }).fold(constant([]), function (detail) {
              return [detail];
            });
          });
        };
        var isSingle = function (detail) {
          return detail.rowspan === 1;
        };
        var getFallback = function () {
          return Warehouse.getAt(warehouse, row, 0);
        };
        return decide(getBlock, isSingle, getFallback);
      });
    };

    var deduce = function (xs, index) {
      if (index < 0 || index >= xs.length - 1) {
        return Optional.none();
      }
      var current = xs[index].fold(function () {
        var rest = reverse(xs.slice(0, index));
        return findMap(rest, function (a, i) {
          return a.map(function (aa) {
            return {
              value: aa,
              delta: i + 1
            };
          });
        });
      }, function (c) {
        return Optional.some({
          value: c,
          delta: 0
        });
      });
      var next = xs[index + 1].fold(function () {
        var rest = xs.slice(index + 1);
        return findMap(rest, function (a, i) {
          return a.map(function (aa) {
            return {
              value: aa,
              delta: i + 1
            };
          });
        });
      }, function (n) {
        return Optional.some({
          value: n,
          delta: 1
        });
      });
      return current.bind(function (c) {
        return next.map(function (n) {
          var extras = n.delta + c.delta;
          return Math.abs(n.value - c.value) / extras;
        });
      });
    };

    var onDirection = function (isLtr, isRtl) {
      return function (element) {
        return getDirection(element) === 'rtl' ? isRtl : isLtr;
      };
    };
    var getDirection = function (element) {
      return get$a(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';
    };

    var api = Dimension('height', function (element) {
      var dom = element.dom;
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    var get$7 = function (element) {
      return api.get(element);
    };
    var getOuter$1 = function (element) {
      return api.getOuter(element);
    };
    var getRuntime = getHeight$1;

    var r = function (left, top) {
      var translate = function (x, y) {
        return r(left + x, top + y);
      };
      return {
        left: left,
        top: top,
        translate: translate
      };
    };
    var SugarPosition = r;

    var boxPosition = function (dom) {
      var box = dom.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    var firstDefinedOrZero = function (a, b) {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    var absolute = function (element) {
      var doc = element.dom.ownerDocument;
      var body = doc.body;
      var win = doc.defaultView;
      var html = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    var viewport = function (element) {
      var dom = element.dom;
      var doc = dom.ownerDocument;
      var body = doc.body;
      if (body === dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom);
    };

    var rowInfo = function (row, y) {
      return {
        row: row,
        y: y
      };
    };
    var colInfo = function (col, x) {
      return {
        col: col,
        x: x
      };
    };
    var rtlEdge = function (cell) {
      var pos = absolute(cell);
      return pos.left + getOuter$2(cell);
    };
    var ltrEdge = function (cell) {
      return absolute(cell).left;
    };
    var getLeftEdge = function (index, cell) {
      return colInfo(index, ltrEdge(cell));
    };
    var getRightEdge = function (index, cell) {
      return colInfo(index, rtlEdge(cell));
    };
    var getTop$1 = function (cell) {
      return absolute(cell).top;
    };
    var getTopEdge = function (index, cell) {
      return rowInfo(index, getTop$1(cell));
    };
    var getBottomEdge = function (index, cell) {
      return rowInfo(index, getTop$1(cell) + getOuter$1(cell));
    };
    var findPositions = function (getInnerEdge, getOuterEdge, array) {
      if (array.length === 0) {
        return [];
      }
      var lines = map$1(array.slice(1), function (cellOption, index) {
        return cellOption.map(function (cell) {
          return getInnerEdge(index, cell);
        });
      });
      var lastLine = array[array.length - 1].map(function (cell) {
        return getOuterEdge(array.length - 1, cell);
      });
      return lines.concat([lastLine]);
    };
    var negate = function (step) {
      return -step;
    };
    var height = {
      delta: identity,
      positions: function (optElements) {
        return findPositions(getTopEdge, getBottomEdge, optElements);
      },
      edge: getTop$1
    };
    var ltr$1 = {
      delta: identity,
      edge: ltrEdge,
      positions: function (optElements) {
        return findPositions(getLeftEdge, getRightEdge, optElements);
      }
    };
    var rtl$1 = {
      delta: negate,
      edge: rtlEdge,
      positions: function (optElements) {
        return findPositions(getRightEdge, getLeftEdge, optElements);
      }
    };
    var detect$2 = onDirection(ltr$1, rtl$1);
    var width = {
      delta: function (amount, table) {
        return detect$2(table).delta(amount, table);
      },
      positions: function (cols, table) {
        return detect$2(table).positions(cols, table);
      },
      edge: function (cell) {
        return detect$2(cell).edge(cell);
      }
    };

    var units = {
      unsupportedLength: [
        'em',
        'ex',
        'cap',
        'ch',
        'ic',
        'rem',
        'lh',
        'rlh',
        'vw',
        'vh',
        'vi',
        'vb',
        'vmin',
        'vmax',
        'cm',
        'mm',
        'Q',
        'in',
        'pc',
        'pt',
        'px'
      ],
      fixed: [
        'px',
        'pt'
      ],
      relative: ['%'],
      empty: ['']
    };
    var pattern = function () {
      var decimalDigits = '[0-9]+';
      var signedInteger = '[+-]?' + decimalDigits;
      var exponentPart = '[eE]' + signedInteger;
      var dot = '\\.';
      var opt = function (input) {
        return '(?:' + input + ')?';
      };
      var unsignedDecimalLiteral = [
        'Infinity',
        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
        dot + decimalDigits + opt(exponentPart),
        decimalDigits + opt(exponentPart)
      ].join('|');
      var float = '[+-]?(?:' + unsignedDecimalLiteral + ')';
      return new RegExp('^(' + float + ')(.*)$');
    }();
    var isUnit = function (unit, accepted) {
      return exists(accepted, function (acc) {
        return exists(units[acc], function (check) {
          return unit === check;
        });
      });
    };
    var parse = function (input, accepted) {
      var match = Optional.from(pattern.exec(input));
      return match.bind(function (array) {
        var value = Number(array[1]);
        var unitRaw = array[2];
        if (isUnit(unitRaw, accepted)) {
          return Optional.some({
            value: value,
            unit: unitRaw
          });
        } else {
          return Optional.none();
        }
      });
    };

    var rPercentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
    var rPixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
    var isCol$2 = isTag('col');
    var getPercentSize = function (elm, outerGetter, innerGetter) {
      var relativeParent = parentElement(elm).getOrThunk(function () {
        return getBody$1(owner(elm));
      });
      return outerGetter(elm) / innerGetter(relativeParent) * 100;
    };
    var setPixelWidth = function (cell, amount) {
      set$1(cell, 'width', amount + 'px');
    };
    var setPercentageWidth = function (cell, amount) {
      set$1(cell, 'width', amount + '%');
    };
    var setHeight = function (cell, amount) {
      set$1(cell, 'height', amount + 'px');
    };
    var getHeightValue = function (cell) {
      return getRuntime(cell) + 'px';
    };
    var convert = function (cell, number, getter, setter) {
      var newSize = table(cell).map(function (table) {
        var total = getter(table);
        return Math.floor(number / 100 * total);
      }).getOr(number);
      setter(cell, newSize);
      return newSize;
    };
    var normalizePixelSize = function (value, cell, getter, setter) {
      var number = parseFloat(value);
      return endsWith(value, '%') && name(cell) !== 'table' ? convert(cell, number, getter, setter) : number;
    };
    var getTotalHeight = function (cell) {
      var value = getHeightValue(cell);
      if (!value) {
        return get$7(cell);
      }
      return normalizePixelSize(value, cell, get$7, setHeight);
    };
    var get$6 = function (cell, type, f) {
      var v = f(cell);
      var span = getSpan(cell, type);
      return v / span;
    };
    var getRaw$1 = function (element, prop) {
      return getRaw$2(element, prop).orThunk(function () {
        return getOpt(element, prop).map(function (val) {
          return val + 'px';
        });
      });
    };
    var getRawWidth$1 = function (element) {
      return getRaw$1(element, 'width');
    };
    var getRawHeight = function (element) {
      return getRaw$1(element, 'height');
    };
    var getPercentageWidth = function (cell) {
      return getPercentSize(cell, get$8, getInner);
    };
    var getPixelWidth$1 = function (cell) {
      return isCol$2(cell) ? get$8(cell) : getRuntime$1(cell);
    };
    var getHeight = function (cell) {
      return get$6(cell, 'rowspan', getTotalHeight);
    };
    var getGenericWidth = function (cell) {
      var width = getRawWidth$1(cell);
      return width.bind(function (w) {
        return parse(w, [
          'fixed',
          'relative',
          'empty'
        ]);
      });
    };
    var setGenericWidth = function (cell, amount, unit) {
      set$1(cell, 'width', amount + unit);
    };
    var getPixelTableWidth = function (table) {
      return get$8(table) + 'px';
    };
    var getPercentTableWidth = function (table) {
      return getPercentSize(table, get$8, getInner) + '%';
    };
    var isPercentSizing$1 = function (table) {
      return getRawWidth$1(table).exists(function (size) {
        return rPercentageBasedSizeRegex.test(size);
      });
    };
    var isPixelSizing$1 = function (table) {
      return getRawWidth$1(table).exists(function (size) {
        return rPixelBasedSizeRegex.test(size);
      });
    };
    var isNoneSizing$1 = function (table) {
      return getRawWidth$1(table).isNone();
    };
    var percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);

    var isCol$1 = isTag('col');
    var getRawW = function (cell) {
      return getRawWidth$1(cell).getOrThunk(function () {
        return getPixelWidth$1(cell) + 'px';
      });
    };
    var getRawH = function (cell) {
      return getRawHeight(cell).getOrThunk(function () {
        return getHeight(cell) + 'px';
      });
    };
    var justCols = function (warehouse) {
      return map$1(Warehouse.justColumns(warehouse), function (column) {
        return Optional.from(column.element);
      });
    };
    var isValidColumn = function (cell) {
      var browser = detect$3().browser;
      var supportsColWidths = browser.isChrome() || browser.isFirefox();
      return isCol$1(cell) ? supportsColWidths : true;
    };
    var getDimension = function (cellOpt, index, backups, filter, getter, fallback) {
      return cellOpt.filter(filter).fold(function () {
        return fallback(deduce(backups, index));
      }, function (cell) {
        return getter(cell);
      });
    };
    var getWidthFrom = function (warehouse, table, getWidth, fallback) {
      var columnCells = columns(warehouse);
      var columns$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;
      var backups = [Optional.some(width.edge(table))].concat(map$1(width.positions(columnCells, table), function (pos) {
        return pos.map(function (p) {
          return p.x;
        });
      }));
      var colFilter = not(hasColspan);
      return map$1(columns$1, function (cellOption, c) {
        return getDimension(cellOption, c, backups, colFilter, function (column) {
          if (isValidColumn(column)) {
            return getWidth(column);
          } else {
            var cell = bindFrom(columnCells[c], identity);
            return getDimension(cell, c, backups, colFilter, function (cell) {
              return fallback(Optional.some(get$8(cell)));
            }, fallback);
          }
        }, fallback);
      });
    };
    var getDeduced = function (deduced) {
      return deduced.map(function (d) {
        return d + 'px';
      }).getOr('');
    };
    var getRawWidths = function (warehouse, table) {
      return getWidthFrom(warehouse, table, getRawW, getDeduced);
    };
    var getPercentageWidths = function (warehouse, table, tableSize) {
      return getWidthFrom(warehouse, table, getPercentageWidth, function (deduced) {
        return deduced.fold(function () {
          return tableSize.minCellWidth();
        }, function (cellWidth) {
          return cellWidth / tableSize.pixelWidth() * 100;
        });
      });
    };
    var getPixelWidths = function (warehouse, table, tableSize) {
      return getWidthFrom(warehouse, table, getPixelWidth$1, function (deduced) {
        return deduced.getOrThunk(tableSize.minCellWidth);
      });
    };
    var getHeightFrom = function (warehouse, table, direction, getHeight, fallback) {
      var rows$1 = rows(warehouse);
      var backups = [Optional.some(direction.edge(table))].concat(map$1(direction.positions(rows$1, table), function (pos) {
        return pos.map(function (p) {
          return p.y;
        });
      }));
      return map$1(rows$1, function (cellOption, c) {
        return getDimension(cellOption, c, backups, not(hasRowspan), getHeight, fallback);
      });
    };
    var getPixelHeights = function (warehouse, table, direction) {
      return getHeightFrom(warehouse, table, direction, getHeight, function (deduced) {
        return deduced.getOrThunk(minHeight);
      });
    };
    var getRawHeights = function (warehouse, table, direction) {
      return getHeightFrom(warehouse, table, direction, getRawH, getDeduced);
    };

    var widthLookup = function (table, getter) {
      return function () {
        if (inBody(table)) {
          return getter(table);
        } else {
          return parseFloat(getRaw$2(table, 'width').getOr('0'));
        }
      };
    };
    var noneSize = function (table) {
      var getWidth = widthLookup(table, get$8);
      var zero = constant(0);
      var getWidths = function (warehouse, tableSize) {
        return getPixelWidths(warehouse, table, tableSize);
      };
      return {
        width: getWidth,
        pixelWidth: getWidth,
        getWidths: getWidths,
        getCellDelta: zero,
        singleColumnWidth: constant([0]),
        minCellWidth: zero,
        setElementWidth: noop,
        adjustTableWidth: noop,
        isRelative: true,
        label: 'none'
      };
    };
    var percentageSize = function (table) {
      var getFloatWidth = widthLookup(table, function (elem) {
        return parseFloat(getPercentTableWidth(elem));
      });
      var getWidth = widthLookup(table, get$8);
      var getCellDelta = function (delta) {
        return delta / getWidth() * 100;
      };
      var singleColumnWidth = function (w, _delta) {
        return [100 - w];
      };
      var minCellWidth = function () {
        return minWidth() / getWidth() * 100;
      };
      var adjustTableWidth = function (delta) {
        var currentWidth = getFloatWidth();
        var change = delta / 100 * currentWidth;
        var newWidth = currentWidth + change;
        setPercentageWidth(table, newWidth);
      };
      var getWidths = function (warehouse, tableSize) {
        return getPercentageWidths(warehouse, table, tableSize);
      };
      return {
        width: getFloatWidth,
        pixelWidth: getWidth,
        getWidths: getWidths,
        getCellDelta: getCellDelta,
        singleColumnWidth: singleColumnWidth,
        minCellWidth: minCellWidth,
        setElementWidth: setPercentageWidth,
        adjustTableWidth: adjustTableWidth,
        isRelative: true,
        label: 'percent'
      };
    };
    var pixelSize = function (table) {
      var getWidth = widthLookup(table, get$8);
      var getCellDelta = identity;
      var singleColumnWidth = function (w, delta) {
        var newNext = Math.max(minWidth(), w + delta);
        return [newNext - w];
      };
      var adjustTableWidth = function (delta) {
        var newWidth = getWidth() + delta;
        setPixelWidth(table, newWidth);
      };
      var getWidths = function (warehouse, tableSize) {
        return getPixelWidths(warehouse, table, tableSize);
      };
      return {
        width: getWidth,
        pixelWidth: getWidth,
        getWidths: getWidths,
        getCellDelta: getCellDelta,
        singleColumnWidth: singleColumnWidth,
        minCellWidth: minWidth,
        setElementWidth: setPixelWidth,
        adjustTableWidth: adjustTableWidth,
        isRelative: false,
        label: 'pixel'
      };
    };
    var chooseSize = function (element, width) {
      var percentMatch = percentageBasedSizeRegex().exec(width);
      if (percentMatch !== null) {
        return percentageSize(element);
      } else {
        return pixelSize(element);
      }
    };
    var getTableSize = function (table) {
      var width = getRawWidth$1(table);
      return width.fold(function () {
        return noneSize(table);
      }, function (w) {
        return chooseSize(table, w);
      });
    };
    var TableSize = {
      getTableSize: getTableSize,
      pixelSize: pixelSize,
      percentageSize: percentageSize,
      noneSize: noneSize
    };

    var statsStruct = function (minRow, minCol, maxRow, maxCol, allCells, selectedCells) {
      return {
        minRow: minRow,
        minCol: minCol,
        maxRow: maxRow,
        maxCol: maxCol,
        allCells: allCells,
        selectedCells: selectedCells
      };
    };
    var findSelectedStats = function (house, isSelected) {
      var totalColumns = house.grid.columns;
      var totalRows = house.grid.rows;
      var minRow = totalRows;
      var minCol = totalColumns;
      var maxRow = 0;
      var maxCol = 0;
      var allCells = [];
      var selectedCells = [];
      each$1(house.access, function (detail) {
        allCells.push(detail);
        if (isSelected(detail)) {
          selectedCells.push(detail);
          var startRow = detail.row;
          var endRow = startRow + detail.rowspan - 1;
          var startCol = detail.column;
          var endCol = startCol + detail.colspan - 1;
          if (startRow < minRow) {
            minRow = startRow;
          } else if (endRow > maxRow) {
            maxRow = endRow;
          }
          if (startCol < minCol) {
            minCol = startCol;
          } else if (endCol > maxCol) {
            maxCol = endCol;
          }
        }
      });
      return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);
    };
    var makeCell = function (list, seenSelected, rowIndex) {
      var row = list[rowIndex].element;
      var td = SugarElement.fromTag('td');
      append$1(td, SugarElement.fromTag('br'));
      var f = seenSelected ? append$1 : prepend;
      f(row, td);
    };
    var fillInGaps = function (list, house, stats, isSelected) {
      var totalColumns = house.grid.columns;
      var totalRows = house.grid.rows;
      for (var i = 0; i < totalRows; i++) {
        var seenSelected = false;
        for (var j = 0; j < totalColumns; j++) {
          if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {
            var needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();
            if (needCell) {
              makeCell(list, seenSelected, i);
            } else {
              seenSelected = true;
            }
          }
        }
      }
    };
    var clean = function (replica, stats, house, widthDelta) {
      each$1(house.columns, function (col) {
        if (col.column < stats.minCol || col.column > stats.maxCol) {
          remove$5(col.element);
        }
      });
      var emptyRows = filter$2(firstLayer(replica, 'tr'), function (row) {
        return row.dom.childElementCount === 0;
      });
      each$2(emptyRows, remove$5);
      if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) {
        each$2(firstLayer(replica, 'th,td'), function (cell) {
          remove$7(cell, 'rowspan');
          remove$7(cell, 'colspan');
        });
      }
      remove$7(replica, LOCKED_COL_ATTR);
      remove$7(replica, 'data-snooker-col-series');
      var tableSize = TableSize.getTableSize(replica);
      tableSize.adjustTableWidth(widthDelta);
    };
    var getTableWidthDelta = function (table, warehouse, tableSize, stats) {
      if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) {
        return 0;
      }
      var colWidths = getPixelWidths(warehouse, table, tableSize);
      var allColsWidth = foldl(colWidths, function (acc, width) {
        return acc + width;
      }, 0);
      var selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), function (acc, width) {
        return acc + width;
      }, 0);
      var newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();
      var delta = newWidth - tableSize.pixelWidth();
      return tableSize.getCellDelta(delta);
    };
    var extract$1 = function (table, selectedSelector) {
      var isSelected = function (detail) {
        return is$2(detail.element, selectedSelector);
      };
      var replica = deep(table);
      var list = fromTable$1(replica);
      var tableSize = TableSize.getTableSize(table);
      var replicaHouse = Warehouse.generate(list);
      var replicaStats = findSelectedStats(replicaHouse, isSelected);
      var selector = 'th:not(' + selectedSelector + ')' + ',td:not(' + selectedSelector + ')';
      var unselectedCells = filterFirstLayer(replica, 'th,td', function (cell) {
        return is$2(cell, selector);
      });
      each$2(unselectedCells, remove$5);
      fillInGaps(list, replicaHouse, replicaStats, isSelected);
      var house = Warehouse.fromTable(table);
      var widthDelta = getTableWidthDelta(table, house, tableSize, replicaStats);
      clean(replica, replicaStats, replicaHouse, widthDelta);
      return replica;
    };

    var nbsp = '\xA0';

    var getEnd = function (element) {
      return name(element) === 'img' ? 1 : getOption(element).fold(function () {
        return children$3(element).length;
      }, function (v) {
        return v.length;
      });
    };
    var isTextNodeWithCursorPosition = function (el) {
      return getOption(el).filter(function (text) {
        return text.trim().length !== 0 || text.indexOf(nbsp) > -1;
      }).isSome();
    };
    var elementsWithCursorPosition = [
      'img',
      'br'
    ];
    var isCursorPosition = function (elem) {
      var hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem));
    };

    var first = function (element) {
      return descendant$1(element, isCursorPosition);
    };
    var last$1 = function (element) {
      return descendantRtl(element, isCursorPosition);
    };
    var descendantRtl = function (scope, predicate) {
      var descend = function (element) {
        var children = children$3(element);
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          if (predicate(child)) {
            return Optional.some(child);
          }
          var res = descend(child);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope);
    };

    var transferableAttributes = {
      scope: [
        'row',
        'col'
      ]
    };
    var createCell = function (doc) {
      return function () {
        var td = SugarElement.fromTag('td', doc.dom);
        append$1(td, SugarElement.fromTag('br', doc.dom));
        return td;
      };
    };
    var createCol = function (doc) {
      return function () {
        return SugarElement.fromTag('col', doc.dom);
      };
    };
    var createColgroup = function (doc) {
      return function () {
        return SugarElement.fromTag('colgroup', doc.dom);
      };
    };
    var createRow$1 = function (doc) {
      return function () {
        return SugarElement.fromTag('tr', doc.dom);
      };
    };
    var replace$1 = function (cell, tag, attrs) {
      var replica = copy$1(cell, tag);
      each$1(attrs, function (v, k) {
        if (v === null) {
          remove$7(replica, k);
        } else {
          set$2(replica, k, v);
        }
      });
      return replica;
    };
    var pasteReplace = function (cell) {
      return cell;
    };
    var cloneFormats = function (oldCell, newCell, formats) {
      var first$1 = first(oldCell);
      return first$1.map(function (firstText) {
        var formatSelector = formats.join(',');
        var parents = ancestors$3(firstText, formatSelector, function (element) {
          return eq$1(element, oldCell);
        });
        return foldr(parents, function (last, parent) {
          var clonedFormat = shallow(parent);
          remove$7(clonedFormat, 'contenteditable');
          append$1(last, clonedFormat);
          return clonedFormat;
        }, newCell);
      }).getOr(newCell);
    };
    var cloneAppropriateAttributes = function (original, clone) {
      each$1(transferableAttributes, function (validAttributes, attributeName) {
        return getOpt(original, attributeName).filter(function (attribute) {
          return contains$2(validAttributes, attribute);
        }).each(function (attribute) {
          return set$2(clone, attributeName, attribute);
        });
      });
    };
    var cellOperations = function (mutate, doc, formatsToClone) {
      var cloneCss = function (prev, clone) {
        copy$2(prev.element, clone);
        remove$6(clone, 'height');
        if (prev.colspan !== 1) {
          remove$6(clone, 'width');
        }
      };
      var newCell = function (prev) {
        var td = SugarElement.fromTag(name(prev.element), doc.dom);
        var formats = formatsToClone.getOr([
          'strong',
          'em',
          'b',
          'i',
          'span',
          'font',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'p',
          'div'
        ]);
        var lastNode = formats.length > 0 ? cloneFormats(prev.element, td, formats) : td;
        append$1(lastNode, SugarElement.fromTag('br'));
        cloneCss(prev, td);
        cloneAppropriateAttributes(prev.element, td);
        mutate(prev.element, td);
        return td;
      };
      var newCol = function (prev) {
        var col = SugarElement.fromTag(name(prev.element), doc.dom);
        cloneCss(prev, col);
        mutate(prev.element, col);
        return col;
      };
      return {
        col: newCol,
        colgroup: createColgroup(doc),
        row: createRow$1(doc),
        cell: newCell,
        replace: replace$1,
        colGap: createCol(doc),
        gap: createCell(doc)
      };
    };
    var paste$1 = function (doc) {
      return {
        col: createCol(doc),
        colgroup: createColgroup(doc),
        row: createRow$1(doc),
        cell: createCell(doc),
        replace: pasteReplace,
        colGap: createCol(doc),
        gap: createCell(doc)
      };
    };

    var fromHtml = function (html, scope) {
      var doc = scope || document;
      var div = doc.createElement('div');
      div.innerHTML = html;
      return children$3(SugarElement.fromDom(div));
    };
    var fromDom = function (nodes) {
      return map$1(nodes, SugarElement.fromDom);
    };

    var getNodeName = function (elm) {
      return elm.nodeName.toLowerCase();
    };
    var getBody = function (editor) {
      return SugarElement.fromDom(editor.getBody());
    };
    var getPixelWidth = function (elm) {
      return elm.getBoundingClientRect().width;
    };
    var getPixelHeight = function (elm) {
      return elm.getBoundingClientRect().height;
    };
    var getIsRoot = function (editor) {
      return function (element) {
        return eq$1(element, getBody(editor));
      };
    };
    var removePxSuffix = function (size) {
      return size ? size.replace(/px$/, '') : '';
    };
    var addPxSuffix = function (size) {
      return /^\d+(\.\d+)?$/.test(size) ? size + 'px' : size;
    };
    var removeDataStyle = function (table) {
      remove$7(table, 'data-mce-style');
      var removeStyleAttribute = function (element) {
        return remove$7(element, 'data-mce-style');
      };
      each$2(cells$1(table), removeStyleAttribute);
      each$2(columns$1(table), removeStyleAttribute);
      each$2(rows$1(table), removeStyleAttribute);
    };
    var getRawWidth = function (editor, elm) {
      var raw = editor.dom.getStyle(elm, 'width') || editor.dom.getAttrib(elm, 'width');
      return Optional.from(raw).filter(isNotEmpty);
    };
    var isPercentage$1 = function (value) {
      return /^(\d+(\.\d+)?)%$/.test(value);
    };
    var isPixel = function (value) {
      return /^(\d+(\.\d+)?)px$/.test(value);
    };
    var getSelectionStart = function (editor) {
      return SugarElement.fromDom(editor.selection.getStart());
    };
    var getSelectionEnd = function (editor) {
      return SugarElement.fromDom(editor.selection.getEnd());
    };

    var selection = function (selections) {
      return cata$2(selections.get(), constant([]), identity, pure);
    };
    var unmergable = function (selections) {
      var hasSpan = function (elem, type) {
        return getOpt(elem, type).exists(function (span) {
          return parseInt(span, 10) > 1;
        });
      };
      var hasRowOrColSpan = function (elem) {
        return hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan');
      };
      var candidates = selection(selections);
      return candidates.length > 0 && forall(candidates, hasRowOrColSpan) ? Optional.some(candidates) : Optional.none();
    };
    var mergable = function (table, selections, ephemera) {
      return cata$2(selections.get(), Optional.none, function (cells) {
        if (cells.length <= 1) {
          return Optional.none();
        } else {
          return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector).map(function (bounds) {
            return {
              bounds: bounds,
              cells: cells
            };
          });
        }
      }, Optional.none);
    };

    var strSelected = 'data-mce-selected';
    var strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';
    var strAttributeSelector = '[' + strSelected + ']';
    var strFirstSelected = 'data-mce-first-selected';
    var strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';
    var strLastSelected = 'data-mce-last-selected';
    var strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';
    var attributeSelector = strAttributeSelector;
    var ephemera = {
      selected: strSelected,
      selectedSelector: strSelectedSelector,
      firstSelected: strFirstSelected,
      firstSelectedSelector: strFirstSelectedSelector,
      lastSelected: strLastSelected,
      lastSelectedSelector: strLastSelectedSelector
    };

    var noMenu = function (cell) {
      return {
        element: cell,
        mergable: Optional.none(),
        unmergable: Optional.none(),
        selection: [cell]
      };
    };
    var forMenu = function (selections, table, cell) {
      return {
        element: cell,
        mergable: mergable(table, selections, ephemera),
        unmergable: unmergable(selections),
        selection: selection(selections)
      };
    };
    var paste = function (element, clipboard, generators) {
      return {
        element: element,
        clipboard: clipboard,
        generators: generators
      };
    };
    var pasteRows = function (selections, cell, clipboard, generators) {
      return {
        selection: selection(selections),
        clipboard: clipboard,
        generators: generators
      };
    };

    var getSelectionCellFallback = function (element) {
      return table(element).bind(function (table) {
        return retrieve(table, ephemera.firstSelectedSelector);
      }).fold(constant(element), function (cells) {
        return cells[0];
      });
    };
    var getSelectionFromSelector = function (selector) {
      return function (initCell, isRoot) {
        var cellName = name(initCell);
        var cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;
        return closest$1(cell, selector, isRoot);
      };
    };
    var getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');
    var getSelectionCell = getSelectionFromSelector('th,td');
    var getCellsFromSelection = function (selections) {
      return selection(selections);
    };
    var getRowsFromSelection = function (selected, selector) {
      var cellOpt = getSelectionCell(selected);
      var rowsOpt = cellOpt.bind(function (cell) {
        return table(cell);
      }).map(function (table) {
        return rows$1(table);
      });
      return lift2(cellOpt, rowsOpt, function (cell, rows) {
        return filter$2(rows, function (row) {
          return exists(fromDom(row.dom.cells), function (rowCell) {
            return get$b(rowCell, selector) === '1' || eq$1(rowCell, cell);
          });
        });
      }).getOr([]);
    };

    var extractSelected = function (cells) {
      return table(cells[0]).map(function (table) {
        var replica = extract$1(table, attributeSelector);
        removeDataStyle(replica);
        return [replica];
      });
    };
    var serializeElements = function (editor, elements) {
      return map$1(elements, function (elm) {
        return editor.selection.serializer.serialize(elm.dom, {});
      }).join('');
    };
    var getTextContent = function (elements) {
      return map$1(elements, function (element) {
        return element.dom.innerText;
      }).join('');
    };
    var registerEvents = function (editor, selections, actions) {
      editor.on('BeforeGetContent', function (e) {
        var multiCellContext = function (cells) {
          e.preventDefault();
          extractSelected(cells).each(function (elements) {
            e.content = e.format === 'text' ? getTextContent(elements) : serializeElements(editor, elements);
          });
        };
        if (e.selection === true) {
          cata$2(selections.get(), noop, multiCellContext, noop);
        }
      });
      editor.on('BeforeSetContent', function (e) {
        if (e.selection === true && e.paste === true) {
          var selectedCells = getCellsFromSelection(selections);
          head(selectedCells).each(function (cell) {
            table(cell).each(function (table) {
              var elements = filter$2(fromHtml(e.content), function (content) {
                return name(content) !== 'meta';
              });
              var isTable = isTag('table');
              if (elements.length === 1 && isTable(elements[0])) {
                e.preventDefault();
                var doc = SugarElement.fromDom(editor.getDoc());
                var generators = paste$1(doc);
                var targets = paste(cell, elements[0], generators);
                actions.pasteCells(table, targets).each(function () {
                  editor.focus();
                });
              }
            });
          });
        }
      });
    };

    var adt$7 = Adt.generate([
      { none: [] },
      { only: ['index'] },
      {
        left: [
          'index',
          'next'
        ]
      },
      {
        middle: [
          'prev',
          'index',
          'next'
        ]
      },
      {
        right: [
          'prev',
          'index'
        ]
      }
    ]);
    var ColumnContext = __assign({}, adt$7);

    var neighbours = function (input, index) {
      if (input.length === 0) {
        return ColumnContext.none();
      }
      if (input.length === 1) {
        return ColumnContext.only(0);
      }
      if (index === 0) {
        return ColumnContext.left(0, 1);
      }
      if (index === input.length - 1) {
        return ColumnContext.right(index - 1, index);
      }
      if (index > 0 && index < input.length - 1) {
        return ColumnContext.middle(index - 1, index, index + 1);
      }
      return ColumnContext.none();
    };
    var determine = function (input, column, step, tableSize, resize) {
      var result = input.slice(0);
      var context = neighbours(input, column);
      var onNone = constant(map$1(result, constant(0)));
      var onOnly = function (index) {
        return tableSize.singleColumnWidth(result[index], step);
      };
      var onLeft = function (index, next) {
        return resize.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
      };
      var onMiddle = function (prev, index, next) {
        return resize.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
      };
      var onRight = function (prev, index) {
        return resize.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);
      };
      return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
    };

    var total = function (start, end, measures) {
      var r = 0;
      for (var i = start; i < end; i++) {
        r += measures[i] !== undefined ? measures[i] : 0;
      }
      return r;
    };
    var recalculateWidthForCells = function (warehouse, widths) {
      var all = Warehouse.justCells(warehouse);
      return map$1(all, function (cell) {
        var width = total(cell.column, cell.column + cell.colspan, widths);
        return {
          element: cell.element,
          width: width,
          colspan: cell.colspan
        };
      });
    };
    var recalculateWidthForColumns = function (warehouse, widths) {
      var groups = Warehouse.justColumns(warehouse);
      return map$1(groups, function (column, index) {
        return {
          element: column.element,
          width: widths[index],
          colspan: column.colspan
        };
      });
    };
    var recalculateHeightForCells = function (warehouse, heights) {
      var all = Warehouse.justCells(warehouse);
      return map$1(all, function (cell) {
        var height = total(cell.row, cell.row + cell.rowspan, heights);
        return {
          element: cell.element,
          height: height,
          rowspan: cell.rowspan
        };
      });
    };
    var matchRowHeight = function (warehouse, heights) {
      return map$1(warehouse.all, function (row, i) {
        return {
          element: row.element,
          height: heights[i]
        };
      });
    };

    var sumUp = function (newSize) {
      return foldr(newSize, function (b, a) {
        return b + a;
      }, 0);
    };
    var recalculate = function (warehouse, widths) {
      if (Warehouse.hasColumns(warehouse)) {
        return recalculateWidthForColumns(warehouse, widths);
      } else {
        return recalculateWidthForCells(warehouse, widths);
      }
    };
    var recalculateAndApply = function (warehouse, widths, tableSize) {
      var newSizes = recalculate(warehouse, widths);
      each$2(newSizes, function (cell) {
        tableSize.setElementWidth(cell.element, cell.width);
      });
    };
    var adjustWidth = function (table, delta, index, resizing, tableSize) {
      var warehouse = Warehouse.fromTable(table);
      var step = tableSize.getCellDelta(delta);
      var widths = tableSize.getWidths(warehouse, tableSize);
      var isLastColumn = index === warehouse.grid.columns - 1;
      var clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);
      var deltas = determine(widths, index, clampedStep, tableSize, resizing);
      var newWidths = map$1(deltas, function (dx, i) {
        return dx + widths[i];
      });
      recalculateAndApply(warehouse, newWidths, tableSize);
      resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);
    };
    var adjustHeight = function (table, delta, index, direction) {
      var warehouse = Warehouse.fromTable(table);
      var heights = getPixelHeights(warehouse, table, direction);
      var newHeights = map$1(heights, function (dy, i) {
        return index === i ? Math.max(delta + dy, minHeight()) : dy;
      });
      var newCellSizes = recalculateHeightForCells(warehouse, newHeights);
      var newRowSizes = matchRowHeight(warehouse, newHeights);
      each$2(newRowSizes, function (row) {
        setHeight(row.element, row.height);
      });
      each$2(newCellSizes, function (cell) {
        setHeight(cell.element, cell.height);
      });
      var total = sumUp(newHeights);
      setHeight(table, total);
    };
    var adjustAndRedistributeWidths$1 = function (_table, list, details, tableSize, resizeBehaviour) {
      var warehouse = Warehouse.generate(list);
      var sizes = tableSize.getWidths(warehouse, tableSize);
      var tablePixelWidth = tableSize.pixelWidth();
      var _a = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative), newSizes = _a.newSizes, delta = _a.delta;
      recalculateAndApply(warehouse, newSizes, tableSize);
      tableSize.adjustTableWidth(delta);
    };
    var adjustWidthTo = function (_table, list, _info, tableSize) {
      var warehouse = Warehouse.generate(list);
      var widths = tableSize.getWidths(warehouse, tableSize);
      recalculateAndApply(warehouse, widths, tableSize);
    };

    var zero = function (array) {
      return map$1(array, constant(0));
    };
    var surround = function (sizes, startIndex, endIndex, results, f) {
      return f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));
    };
    var clampDeltaHelper = function (predicate) {
      return function (sizes, index, delta, minCellSize) {
        if (!predicate(delta)) {
          return delta;
        } else {
          var newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));
          var diff = Math.abs(newSize - sizes[index]);
          return delta >= 0 ? diff : -diff;
        }
      };
    };
    var clampNegativeDelta = clampDeltaHelper(function (delta) {
      return delta < 0;
    });
    var clampDelta = clampDeltaHelper(always);
    var resizeTable = function () {
      var calcFixedDeltas = function (sizes, index, next, delta, minCellSize) {
        var clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
        return surround(sizes, index, next + 1, [
          clampedDelta,
          0
        ], zero);
      };
      var calcRelativeDeltas = function (sizes, index, delta, minCellSize) {
        var ratio = (100 + delta) / 100;
        var newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);
        return map$1(sizes, function (size, idx) {
          var newSize = idx === index ? newThis : size / ratio;
          return newSize - size;
        });
      };
      var calcLeftEdgeDeltas = function (sizes, index, next, delta, minCellSize, isRelative) {
        if (isRelative) {
          return calcRelativeDeltas(sizes, index, delta, minCellSize);
        } else {
          return calcFixedDeltas(sizes, index, next, delta, minCellSize);
        }
      };
      var calcMiddleDeltas = function (sizes, _prev, index, next, delta, minCellSize, isRelative) {
        return calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);
      };
      var resizeTable = function (resizer, delta) {
        return resizer(delta);
      };
      var calcRightEdgeDeltas = function (sizes, _prev, index, delta, minCellSize, isRelative) {
        if (isRelative) {
          return calcRelativeDeltas(sizes, index, delta, minCellSize);
        } else {
          var clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
          return zero(sizes.slice(0, index)).concat([clampedDelta]);
        }
      };
      var calcRedestributedWidths = function (sizes, totalWidth, pixelDelta, isRelative) {
        if (isRelative) {
          var tableWidth = totalWidth + pixelDelta;
          var ratio_1 = tableWidth / totalWidth;
          var newSizes = map$1(sizes, function (size) {
            return size / ratio_1;
          });
          return {
            delta: ratio_1 * 100 - 100,
            newSizes: newSizes
          };
        } else {
          return {
            delta: pixelDelta,
            newSizes: sizes
          };
        }
      };
      return {
        resizeTable: resizeTable,
        clampTableDelta: clampNegativeDelta,
        calcLeftEdgeDeltas: calcLeftEdgeDeltas,
        calcMiddleDeltas: calcMiddleDeltas,
        calcRightEdgeDeltas: calcRightEdgeDeltas,
        calcRedestributedWidths: calcRedestributedWidths
      };
    };
    var preserveTable = function () {
      var calcLeftEdgeDeltas = function (sizes, index, next, delta, minCellSize) {
        var idx = delta >= 0 ? next : index;
        var clampedDelta = clampDelta(sizes, idx, delta, minCellSize);
        return surround(sizes, index, next + 1, [
          clampedDelta,
          -clampedDelta
        ], zero);
      };
      var calcMiddleDeltas = function (sizes, _prev, index, next, delta, minCellSize) {
        return calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);
      };
      var resizeTable = function (resizer, delta, isLastColumn) {
        if (isLastColumn) {
          resizer(delta);
        }
      };
      var calcRightEdgeDeltas = function (sizes, _prev, _index, delta, _minCellSize, isRelative) {
        if (isRelative) {
          return zero(sizes);
        } else {
          var diff = delta / sizes.length;
          return map$1(sizes, constant(diff));
        }
      };
      var clampTableDelta = function (sizes, index, delta, minCellSize, isLastColumn) {
        if (isLastColumn) {
          if (delta >= 0) {
            return delta;
          } else {
            var maxDelta = foldl(sizes, function (a, b) {
              return a + b - minCellSize;
            }, 0);
            return Math.max(-maxDelta, delta);
          }
        } else {
          return clampNegativeDelta(sizes, index, delta, minCellSize);
        }
      };
      var calcRedestributedWidths = function (sizes, _totalWidth, _pixelDelta, _isRelative) {
        return {
          delta: 0,
          newSizes: sizes
        };
      };
      return {
        resizeTable: resizeTable,
        clampTableDelta: clampTableDelta,
        calcLeftEdgeDeltas: calcLeftEdgeDeltas,
        calcMiddleDeltas: calcMiddleDeltas,
        calcRightEdgeDeltas: calcRightEdgeDeltas,
        calcRedestributedWidths: calcRedestributedWidths
      };
    };

    var only = function (element, isResizable) {
      var parent = Optional.from(element.dom.documentElement).map(SugarElement.fromDom).getOr(element);
      return {
        parent: constant(parent),
        view: constant(element),
        origin: constant(SugarPosition(0, 0)),
        isResizable: isResizable
      };
    };
    var detached = function (editable, chrome, isResizable) {
      var origin = function () {
        return absolute(chrome);
      };
      return {
        parent: constant(chrome),
        view: constant(editable),
        origin: origin,
        isResizable: isResizable
      };
    };
    var body = function (editable, chrome, isResizable) {
      return {
        parent: constant(chrome),
        view: constant(editable),
        origin: constant(SugarPosition(0, 0)),
        isResizable: isResizable
      };
    };
    var ResizeWire = {
      only: only,
      detached: detached,
      body: body
    };

    var adt$6 = Adt.generate([
      { invalid: ['raw'] },
      { pixels: ['value'] },
      { percent: ['value'] }
    ]);
    var validateFor = function (suffix, type, value) {
      var rawAmount = value.substring(0, value.length - suffix.length);
      var amount = parseFloat(rawAmount);
      return rawAmount === amount.toString() ? type(amount) : adt$6.invalid(value);
    };
    var from = function (value) {
      if (endsWith(value, '%')) {
        return validateFor('%', adt$6.percent, value);
      }
      if (endsWith(value, 'px')) {
        return validateFor('px', adt$6.pixels, value);
      }
      return adt$6.invalid(value);
    };
    var Size = __assign(__assign({}, adt$6), { from: from });

    var redistributeToPercent = function (widths, totalWidth) {
      return map$1(widths, function (w) {
        var colType = Size.from(w);
        return colType.fold(function () {
          return w;
        }, function (px) {
          var ratio = px / totalWidth * 100;
          return ratio + '%';
        }, function (pc) {
          return pc + '%';
        });
      });
    };
    var redistributeToPx = function (widths, totalWidth, newTotalWidth) {
      var scale = newTotalWidth / totalWidth;
      return map$1(widths, function (w) {
        var colType = Size.from(w);
        return colType.fold(function () {
          return w;
        }, function (px) {
          return px * scale + 'px';
        }, function (pc) {
          return pc / 100 * newTotalWidth + 'px';
        });
      });
    };
    var redistributeEmpty = function (newWidthType, columns) {
      var f = newWidthType.fold(function () {
        return constant('');
      }, function (pixels) {
        var num = pixels / columns;
        return constant(num + 'px');
      }, function () {
        var num = 100 / columns;
        return constant(num + '%');
      });
      return range$1(columns, f);
    };
    var redistributeValues = function (newWidthType, widths, totalWidth) {
      return newWidthType.fold(function () {
        return widths;
      }, function (px) {
        return redistributeToPx(widths, totalWidth, px);
      }, function (_pc) {
        return redistributeToPercent(widths, totalWidth);
      });
    };
    var redistribute$1 = function (widths, totalWidth, newWidth) {
      var newType = Size.from(newWidth);
      var floats = forall(widths, function (s) {
        return s === '0px';
      }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);
      return normalize(floats);
    };
    var sum = function (values, fallback) {
      if (values.length === 0) {
        return fallback;
      }
      return foldr(values, function (rest, v) {
        return Size.from(v).fold(constant(0), identity, identity) + rest;
      }, 0);
    };
    var roundDown = function (num, unit) {
      var floored = Math.floor(num);
      return {
        value: floored + unit,
        remainder: num - floored
      };
    };
    var add$3 = function (value, amount) {
      return Size.from(value).fold(constant(value), function (px) {
        return px + amount + 'px';
      }, function (pc) {
        return pc + amount + '%';
      });
    };
    var normalize = function (values) {
      if (values.length === 0) {
        return values;
      }
      var scan = foldr(values, function (rest, value) {
        var info = Size.from(value).fold(function () {
          return {
            value: value,
            remainder: 0
          };
        }, function (num) {
          return roundDown(num, 'px');
        }, function (num) {
          return {
            value: num + '%',
            remainder: 0
          };
        });
        return {
          output: [info.value].concat(rest.output),
          remainder: rest.remainder + info.remainder
        };
      }, {
        output: [],
        remainder: 0
      });
      var r = scan.output;
      return r.slice(0, r.length - 1).concat([add$3(r[r.length - 1], Math.round(scan.remainder))]);
    };
    var validate = Size.from;

    var redistributeToW = function (newWidths, cells, unit) {
      each$2(cells, function (cell) {
        var widths = newWidths.slice(cell.column, cell.colspan + cell.column);
        var w = sum(widths, minWidth());
        set$1(cell.element, 'width', w + unit);
      });
    };
    var redistributeToColumns = function (newWidths, columns, unit) {
      each$2(columns, function (column, index) {
        var width = sum([newWidths[index]], minWidth());
        set$1(column.element, 'width', width + unit);
      });
    };
    var redistributeToH = function (newHeights, rows, cells, unit) {
      each$2(cells, function (cell) {
        var heights = newHeights.slice(cell.row, cell.rowspan + cell.row);
        var h = sum(heights, minHeight());
        set$1(cell.element, 'height', h + unit);
      });
      each$2(rows, function (row, i) {
        set$1(row.element, 'height', newHeights[i]);
      });
    };
    var getUnit = function (newSize) {
      return validate(newSize).fold(constant('px'), constant('px'), constant('%'));
    };
    var redistribute = function (table, optWidth, optHeight) {
      var warehouse = Warehouse.fromTable(table);
      var rows = warehouse.all;
      var cells = Warehouse.justCells(warehouse);
      var columns = Warehouse.justColumns(warehouse);
      optWidth.each(function (newWidth) {
        var widthUnit = getUnit(newWidth);
        var totalWidth = get$8(table);
        var oldWidths = getRawWidths(warehouse, table);
        var nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);
        if (Warehouse.hasColumns(warehouse)) {
          redistributeToColumns(nuWidths, columns, widthUnit);
        } else {
          redistributeToW(nuWidths, cells, widthUnit);
        }
        set$1(table, 'width', newWidth);
      });
      optHeight.each(function (newHeight) {
        var hUnit = getUnit(newHeight);
        var totalHeight = get$7(table);
        var oldHeights = getRawHeights(warehouse, table, height);
        var nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);
        redistributeToH(nuHeights, rows, cells, hUnit);
        set$1(table, 'height', newHeight);
      });
    };
    var isPercentSizing = isPercentSizing$1;
    var isPixelSizing = isPixelSizing$1;
    var isNoneSizing = isNoneSizing$1;

    var getGridSize = function (table) {
      var warehouse = Warehouse.fromTable(table);
      return warehouse.grid;
    };

    var Event = function (fields) {
      var handlers = [];
      var bind = function (handler) {
        if (handler === undefined) {
          throw new Error('Event bind error: undefined handler');
        }
        handlers.push(handler);
      };
      var unbind = function (handler) {
        handlers = filter$2(handlers, function (h) {
          return h !== handler;
        });
      };
      var trigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var event = {};
        each$2(fields, function (name, i) {
          event[name] = args[i];
        });
        each$2(handlers, function (handler) {
          handler(event);
        });
      };
      return {
        bind: bind,
        unbind: unbind,
        trigger: trigger
      };
    };

    var create$4 = function (typeDefs) {
      var registry = map(typeDefs, function (event) {
        return {
          bind: event.bind,
          unbind: event.unbind
        };
      });
      var trigger = map(typeDefs, function (event) {
        return event.trigger;
      });
      return {
        registry: registry,
        trigger: trigger
      };
    };

    var last = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        cancel();
        timer = setTimeout(function () {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var sort = function (arr) {
      return arr.slice(0).sort();
    };
    var reqMessage = function (required, keys) {
      throw new Error('All required keys (' + sort(required).join(', ') + ') were not specified. Specified keys were: ' + sort(keys).join(', ') + '.');
    };
    var unsuppMessage = function (unsupported) {
      throw new Error('Unsupported keys for object: ' + sort(unsupported).join(', '));
    };
    var validateStrArr = function (label, array) {
      if (!isArray(array)) {
        throw new Error('The ' + label + ' fields must be an array. Was: ' + array + '.');
      }
      each$2(array, function (a) {
        if (!isString(a)) {
          throw new Error('The value ' + a + ' in the ' + label + ' fields was not a string.');
        }
      });
    };
    var invalidTypeMessage = function (incorrect, type) {
      throw new Error('All values need to be of type: ' + type + '. Keys (' + sort(incorrect).join(', ') + ') were not.');
    };
    var checkDupes = function (everything) {
      var sorted = sort(everything);
      var dupe = find$1(sorted, function (s, i) {
        return i < sorted.length - 1 && s === sorted[i + 1];
      });
      dupe.each(function (d) {
        throw new Error('The field: ' + d + ' occurs more than once in the combined fields: [' + sorted.join(', ') + '].');
      });
    };

    var base = function (handleUnsupported, required) {
      return baseWith(handleUnsupported, required, {
        validate: isFunction,
        label: 'function'
      });
    };
    var baseWith = function (handleUnsupported, required, pred) {
      if (required.length === 0) {
        throw new Error('You must specify at least one required field.');
      }
      validateStrArr('required', required);
      checkDupes(required);
      return function (obj) {
        var keys$1 = keys(obj);
        var allReqd = forall(required, function (req) {
          return contains$2(keys$1, req);
        });
        if (!allReqd) {
          reqMessage(required, keys$1);
        }
        handleUnsupported(required, keys$1);
        var invalidKeys = filter$2(required, function (key) {
          return !pred.validate(obj[key], key);
        });
        if (invalidKeys.length > 0) {
          invalidTypeMessage(invalidKeys, pred.label);
        }
        return obj;
      };
    };
    var handleExact = function (required, keys) {
      var unsupported = filter$2(keys, function (key) {
        return !contains$2(required, key);
      });
      if (unsupported.length > 0) {
        unsuppMessage(unsupported);
      }
    };
    var exactly = function (required) {
      return base(handleExact, required);
    };

    var DragMode = exactly([
      'compare',
      'extract',
      'mutate',
      'sink'
    ]);
    var DragSink = exactly([
      'element',
      'start',
      'stop',
      'destroy'
    ]);
    var DragApi = exactly([
      'forceDrop',
      'drop',
      'move',
      'delayDrop'
    ]);

    var InDrag = function () {
      var previous = Optional.none();
      var reset = function () {
        previous = Optional.none();
      };
      var update = function (mode, nu) {
        var result = previous.map(function (old) {
          return mode.compare(old, nu);
        });
        previous = Optional.some(nu);
        return result;
      };
      var onEvent = function (event, mode) {
        var dataOption = mode.extract(event);
        dataOption.each(function (data) {
          var offset = update(mode, data);
          offset.each(function (d) {
            events.trigger.move(d);
          });
        });
      };
      var events = create$4({ move: Event(['info']) });
      return {
        onEvent: onEvent,
        reset: reset,
        events: events.registry
      };
    };

    var NoDrag = function () {
      var events = create$4({ move: Event(['info']) });
      return {
        onEvent: noop,
        reset: noop,
        events: events.registry
      };
    };

    var Movement = function () {
      var noDragState = NoDrag();
      var inDragState = InDrag();
      var dragState = noDragState;
      var on = function () {
        dragState.reset();
        dragState = inDragState;
      };
      var off = function () {
        dragState.reset();
        dragState = noDragState;
      };
      var onEvent = function (event, mode) {
        dragState.onEvent(event, mode);
      };
      var isOn = function () {
        return dragState === inDragState;
      };
      return {
        on: on,
        off: off,
        isOn: isOn,
        onEvent: onEvent,
        events: inDragState.events
      };
    };

    var setup = function (mutation, mode, settings) {
      var active = false;
      var events = create$4({
        start: Event([]),
        stop: Event([])
      });
      var movement = Movement();
      var drop = function () {
        sink.stop();
        if (movement.isOn()) {
          movement.off();
          events.trigger.stop();
        }
      };
      var throttledDrop = last(drop, 200);
      var go = function (parent) {
        sink.start(parent);
        movement.on();
        events.trigger.start();
      };
      var mousemove = function (event) {
        throttledDrop.cancel();
        movement.onEvent(event, mode);
      };
      movement.events.move.bind(function (event) {
        mode.mutate(mutation, event.info);
      });
      var on = function () {
        active = true;
      };
      var off = function () {
        active = false;
      };
      var runIfActive = function (f) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (active) {
            f.apply(null, args);
          }
        };
      };
      var sink = mode.sink(DragApi({
        forceDrop: drop,
        drop: runIfActive(drop),
        move: runIfActive(mousemove),
        delayDrop: runIfActive(throttledDrop.throttle)
      }), settings);
      var destroy = function () {
        sink.destroy();
      };
      return {
        element: sink.element,
        go: go,
        on: on,
        off: off,
        destroy: destroy,
        events: events.registry
      };
    };

    var mkEvent = function (target, x, y, stop, prevent, kill, raw) {
      return {
        target: target,
        x: x,
        y: y,
        stop: stop,
        prevent: prevent,
        kill: kill,
        raw: raw
      };
    };
    var fromRawEvent$1 = function (rawEvent) {
      var target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      var stop = function () {
        return rawEvent.stopPropagation();
      };
      var prevent = function () {
        return rawEvent.preventDefault();
      };
      var kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    var handle$2 = function (filter, handler) {
      return function (rawEvent) {
        if (filter(rawEvent)) {
          handler(fromRawEvent$1(rawEvent));
        }
      };
    };
    var binder = function (element, event, filter, handler, useCapture) {
      var wrapped = handle$2(filter, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    var bind$1 = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, false);
    };
    var unbind = function (element, event, handler, useCapture) {
      element.dom.removeEventListener(event, handler, useCapture);
    };

    var filter = always;
    var bind = function (element, event, handler) {
      return bind$1(element, event, filter, handler);
    };
    var fromRawEvent = fromRawEvent$1;

    var read = function (element, attr) {
      var value = get$b(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    var add$2 = function (element, attr, id) {
      var old = read(element, attr);
      var nu = old.concat([id]);
      set$2(element, attr, nu.join(' '));
      return true;
    };
    var remove$4 = function (element, attr, id) {
      var nu = filter$2(read(element, attr), function (v) {
        return v !== id;
      });
      if (nu.length > 0) {
        set$2(element, attr, nu.join(' '));
      } else {
        remove$7(element, attr);
      }
      return false;
    };

    var supports = function (element) {
      return element.dom.classList !== undefined;
    };
    var get$5 = function (element) {
      return read(element, 'class');
    };
    var add$1 = function (element, clazz) {
      return add$2(element, 'class', clazz);
    };
    var remove$3 = function (element, clazz) {
      return remove$4(element, 'class', clazz);
    };

    var add = function (element, clazz) {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$1(element, clazz);
      }
    };
    var cleanClass = function (element) {
      var classList = supports(element) ? element.dom.classList : get$5(element);
      if (classList.length === 0) {
        remove$7(element, 'class');
      }
    };
    var remove$2 = function (element, clazz) {
      if (supports(element)) {
        var classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$3(element, clazz);
      }
      cleanClass(element);
    };
    var has = function (element, clazz) {
      return supports(element) && element.dom.classList.contains(clazz);
    };

    var css = function (namespace) {
      var dashNamespace = namespace.replace(/\./g, '-');
      var resolve = function (str) {
        return dashNamespace + '-' + str;
      };
      return { resolve: resolve };
    };

    var styles$1 = css('ephox-dragster');
    var resolve$1 = styles$1.resolve;

    var Blocker = function (options) {
      var settings = __assign({ layerClass: resolve$1('blocker') }, options);
      var div = SugarElement.fromTag('div');
      set$2(div, 'role', 'presentation');
      setAll(div, {
        position: 'fixed',
        left: '0px',
        top: '0px',
        width: '100%',
        height: '100%'
      });
      add(div, resolve$1('blocker'));
      add(div, settings.layerClass);
      var element = constant(div);
      var destroy = function () {
        remove$5(div);
      };
      return {
        element: element,
        destroy: destroy
      };
    };

    var compare = function (old, nu) {
      return SugarPosition(nu.left - old.left, nu.top - old.top);
    };
    var extract = function (event) {
      return Optional.some(SugarPosition(event.x, event.y));
    };
    var mutate = function (mutation, info) {
      mutation.mutate(info.left, info.top);
    };
    var sink = function (dragApi, settings) {
      var blocker = Blocker(settings);
      var mdown = bind(blocker.element(), 'mousedown', dragApi.forceDrop);
      var mup = bind(blocker.element(), 'mouseup', dragApi.drop);
      var mmove = bind(blocker.element(), 'mousemove', dragApi.move);
      var mout = bind(blocker.element(), 'mouseout', dragApi.delayDrop);
      var destroy = function () {
        blocker.destroy();
        mup.unbind();
        mmove.unbind();
        mout.unbind();
        mdown.unbind();
      };
      var start = function (parent) {
        append$1(parent, blocker.element());
      };
      var stop = function () {
        remove$5(blocker.element());
      };
      return DragSink({
        element: blocker.element,
        start: start,
        stop: stop,
        destroy: destroy
      });
    };
    var MouseDrag = DragMode({
      compare: compare,
      extract: extract,
      sink: sink,
      mutate: mutate
    });

    var transform$1 = function (mutation, settings) {
      if (settings === void 0) {
        settings = {};
      }
      var mode = settings.mode !== undefined ? settings.mode : MouseDrag;
      return setup(mutation, mode, settings);
    };

    var closest = function (target) {
      return closest$1(target, '[contenteditable]');
    };
    var isEditable$1 = function (element, assumeEditable) {
      if (assumeEditable === void 0) {
        assumeEditable = false;
      }
      if (!detect$3().browser.isIE() && inBody(element)) {
        return element.dom.isContentEditable;
      } else {
        return closest(element).fold(constant(assumeEditable), function (editable) {
          return getRaw(editable) === 'true';
        });
      }
    };
    var getRaw = function (element) {
      return element.dom.contentEditable;
    };

    var styles = css('ephox-snooker');
    var resolve = styles.resolve;

    var Mutation = function () {
      var events = create$4({
        drag: Event([
          'xDelta',
          'yDelta'
        ])
      });
      var mutate = function (x, y) {
        events.trigger.drag(x, y);
      };
      return {
        mutate: mutate,
        events: events.registry
      };
    };

    var BarMutation = function () {
      var events = create$4({
        drag: Event([
          'xDelta',
          'yDelta',
          'target'
        ])
      });
      var target = Optional.none();
      var delegate = Mutation();
      delegate.events.drag.bind(function (event) {
        target.each(function (t) {
          events.trigger.drag(event.xDelta, event.yDelta, t);
        });
      });
      var assign = function (t) {
        target = Optional.some(t);
      };
      var get = function () {
        return target;
      };
      return {
        assign: assign,
        get: get,
        mutate: delegate.mutate,
        events: events.registry
      };
    };

    var col = function (column, x, y, w, h) {
      var bar = SugarElement.fromTag('div');
      setAll(bar, {
        position: 'absolute',
        left: x - w / 2 + 'px',
        top: y + 'px',
        height: h + 'px',
        width: w + 'px'
      });
      setAll$1(bar, {
        'data-column': column,
        'role': 'presentation'
      });
      return bar;
    };
    var row = function (r, x, y, w, h) {
      var bar = SugarElement.fromTag('div');
      setAll(bar, {
        position: 'absolute',
        left: x + 'px',
        top: y - h / 2 + 'px',
        height: h + 'px',
        width: w + 'px'
      });
      setAll$1(bar, {
        'data-row': r,
        'role': 'presentation'
      });
      return bar;
    };

    var resizeBar = resolve('resizer-bar');
    var resizeRowBar = resolve('resizer-rows');
    var resizeColBar = resolve('resizer-cols');
    var BAR_THICKNESS = 7;
    var resizableRows = function (warehouse, isResizable) {
      return bind$2(warehouse.all, function (row, i) {
        return isResizable(row.element) ? [i] : [];
      });
    };
    var resizableColumns = function (warehouse, isResizable) {
      var resizableCols = [];
      range$1(warehouse.grid.columns, function (index) {
        var colElmOpt = Warehouse.getColumnAt(warehouse, index).map(function (col) {
          return col.element;
        });
        if (colElmOpt.forall(isResizable)) {
          resizableCols.push(index);
        }
      });
      return filter$2(resizableCols, function (colIndex) {
        var columnCells = Warehouse.filterItems(warehouse, function (cell) {
          return cell.column === colIndex;
        });
        return forall(columnCells, function (cell) {
          return isResizable(cell.element);
        });
      });
    };
    var destroy = function (wire) {
      var previous = descendants(wire.parent(), '.' + resizeBar);
      each$2(previous, remove$5);
    };
    var drawBar = function (wire, positions, create) {
      var origin = wire.origin();
      each$2(positions, function (cpOption) {
        cpOption.each(function (cp) {
          var bar = create(origin, cp);
          add(bar, resizeBar);
          append$1(wire.parent(), bar);
        });
      });
    };
    var refreshCol = function (wire, colPositions, position, tableHeight) {
      drawBar(wire, colPositions, function (origin, cp) {
        var colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);
        add(colBar, resizeColBar);
        return colBar;
      });
    };
    var refreshRow = function (wire, rowPositions, position, tableWidth) {
      drawBar(wire, rowPositions, function (origin, cp) {
        var rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);
        add(rowBar, resizeRowBar);
        return rowBar;
      });
    };
    var refreshGrid = function (warhouse, wire, table, rows, cols) {
      var position = absolute(table);
      var isResizable = wire.isResizable;
      var rowPositions = rows.length > 0 ? height.positions(rows, table) : [];
      var resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable) : [];
      var resizableRowPositions = filter$2(rowPositions, function (_pos, i) {
        return exists(resizableRowBars, function (barIndex) {
          return i === barIndex;
        });
      });
      refreshRow(wire, resizableRowPositions, position, getOuter$2(table));
      var colPositions = cols.length > 0 ? width.positions(cols, table) : [];
      var resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable) : [];
      var resizableColPositions = filter$2(colPositions, function (_pos, i) {
        return exists(resizableColBars, function (barIndex) {
          return i === barIndex;
        });
      });
      refreshCol(wire, resizableColPositions, position, getOuter$1(table));
    };
    var refresh = function (wire, table) {
      destroy(wire);
      if (wire.isResizable(table)) {
        var warehouse = Warehouse.fromTable(table);
        var rows$1 = rows(warehouse);
        var cols = columns(warehouse);
        refreshGrid(warehouse, wire, table, rows$1, cols);
      }
    };
    var each = function (wire, f) {
      var bars = descendants(wire.parent(), '.' + resizeBar);
      each$2(bars, f);
    };
    var hide = function (wire) {
      each(wire, function (bar) {
        set$1(bar, 'display', 'none');
      });
    };
    var show = function (wire) {
      each(wire, function (bar) {
        set$1(bar, 'display', 'block');
      });
    };
    var isRowBar = function (element) {
      return has(element, resizeRowBar);
    };
    var isColBar = function (element) {
      return has(element, resizeColBar);
    };

    var resizeBarDragging = resolve('resizer-bar-dragging');
    var BarManager = function (wire) {
      var mutation = BarMutation();
      var resizing = transform$1(mutation, {});
      var hoverTable = Optional.none();
      var getResizer = function (element, type) {
        return Optional.from(get$b(element, type));
      };
      mutation.events.drag.bind(function (event) {
        getResizer(event.target, 'data-row').each(function (_dataRow) {
          var currentRow = getCssValue(event.target, 'top');
          set$1(event.target, 'top', currentRow + event.yDelta + 'px');
        });
        getResizer(event.target, 'data-column').each(function (_dataCol) {
          var currentCol = getCssValue(event.target, 'left');
          set$1(event.target, 'left', currentCol + event.xDelta + 'px');
        });
      });
      var getDelta = function (target, dir) {
        var newX = getCssValue(target, dir);
        var oldX = getAttrValue(target, 'data-initial-' + dir, 0);
        return newX - oldX;
      };
      resizing.events.stop.bind(function () {
        mutation.get().each(function (target) {
          hoverTable.each(function (table) {
            getResizer(target, 'data-row').each(function (row) {
              var delta = getDelta(target, 'top');
              remove$7(target, 'data-initial-top');
              events.trigger.adjustHeight(table, delta, parseInt(row, 10));
            });
            getResizer(target, 'data-column').each(function (column) {
              var delta = getDelta(target, 'left');
              remove$7(target, 'data-initial-left');
              events.trigger.adjustWidth(table, delta, parseInt(column, 10));
            });
            refresh(wire, table);
          });
        });
      });
      var handler = function (target, dir) {
        events.trigger.startAdjust();
        mutation.assign(target);
        set$2(target, 'data-initial-' + dir, getCssValue(target, dir));
        add(target, resizeBarDragging);
        set$1(target, 'opacity', '0.2');
        resizing.go(wire.parent());
      };
      var mousedown = bind(wire.parent(), 'mousedown', function (event) {
        if (isRowBar(event.target)) {
          handler(event.target, 'top');
        }
        if (isColBar(event.target)) {
          handler(event.target, 'left');
        }
      });
      var isRoot = function (e) {
        return eq$1(e, wire.view());
      };
      var findClosestEditableTable = function (target) {
        return closest$1(target, 'table', isRoot).filter(isEditable$1);
      };
      var mouseover = bind(wire.view(), 'mouseover', function (event) {
        findClosestEditableTable(event.target).fold(function () {
          if (inBody(event.target)) {
            destroy(wire);
          }
        }, function (table) {
          hoverTable = Optional.some(table);
          refresh(wire, table);
        });
      });
      var destroy$1 = function () {
        mousedown.unbind();
        mouseover.unbind();
        resizing.destroy();
        destroy(wire);
      };
      var refresh$1 = function (tbl) {
        refresh(wire, tbl);
      };
      var events = create$4({
        adjustHeight: Event([
          'table',
          'delta',
          'row'
        ]),
        adjustWidth: Event([
          'table',
          'delta',
          'column'
        ]),
        startAdjust: Event([])
      });
      return {
        destroy: destroy$1,
        refresh: refresh$1,
        on: resizing.on,
        off: resizing.off,
        hideBars: curry(hide, wire),
        showBars: curry(show, wire),
        events: events.registry
      };
    };

    var create$3 = function (wire, resizing, lazySizing) {
      var hdirection = height;
      var vdirection = width;
      var manager = BarManager(wire);
      var events = create$4({
        beforeResize: Event([
          'table',
          'type'
        ]),
        afterResize: Event([
          'table',
          'type'
        ]),
        startDrag: Event([])
      });
      manager.events.adjustHeight.bind(function (event) {
        var table = event.table;
        events.trigger.beforeResize(table, 'row');
        var delta = hdirection.delta(event.delta, table);
        adjustHeight(table, delta, event.row, hdirection);
        events.trigger.afterResize(table, 'row');
      });
      manager.events.startAdjust.bind(function (_event) {
        events.trigger.startDrag();
      });
      manager.events.adjustWidth.bind(function (event) {
        var table = event.table;
        events.trigger.beforeResize(table, 'col');
        var delta = vdirection.delta(event.delta, table);
        var tableSize = lazySizing(table);
        adjustWidth(table, delta, event.column, resizing, tableSize);
        events.trigger.afterResize(table, 'col');
      });
      return {
        on: manager.on,
        off: manager.off,
        hideBars: manager.hideBars,
        showBars: manager.showBars,
        destroy: manager.destroy,
        events: events.registry
      };
    };
    var TableResize = { create: create$3 };

    var fireNewRow = function (editor, row) {
      return editor.fire('newrow', { node: row });
    };
    var fireNewCell = function (editor, cell) {
      return editor.fire('newcell', { node: cell });
    };
    var fireObjectResizeStart = function (editor, target, width, height, origin) {
      editor.fire('ObjectResizeStart', {
        target: target,
        width: width,
        height: height,
        origin: origin
      });
    };
    var fireObjectResized = function (editor, target, width, height, origin) {
      editor.fire('ObjectResized', {
        target: target,
        width: width,
        height: height,
        origin: origin
      });
    };
    var fireTableSelectionChange = function (editor, cells, start, finish, otherCells) {
      editor.fire('TableSelectionChange', {
        cells: cells,
        start: start,
        finish: finish,
        otherCells: otherCells
      });
    };
    var fireTableSelectionClear = function (editor) {
      editor.fire('TableSelectionClear');
    };
    var fireTableModified = function (editor, table, data) {
      editor.fire('TableModified', __assign(__assign({}, data), { table: table }));
    };
    var styleModified = {
      structure: false,
      style: true
    };
    var structureModified = {
      structure: true,
      style: false
    };
    var styleAndStructureModified = {
      structure: true,
      style: true
    };

    var defaultTableToolbar = 'tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol';
    var defaultStyles = {
      'border-collapse': 'collapse',
      'width': '100%'
    };
    var defaultCellBorderWidths = range$1(5, function (i) {
      var size = i + 1 + 'px';
      return {
        title: size,
        value: size
      };
    });
    var defaultCellBorderStyles = map$1([
      'Solid',
      'Dotted',
      'Dashed',
      'Double',
      'Groove',
      'Ridge',
      'Inset',
      'Outset',
      'None',
      'Hidden'
    ], function (type) {
      return {
        title: type,
        value: type.toLowerCase()
      };
    });
    var determineDefaultStyles = function (editor) {
      var _a;
      if (isPixelsForced(editor)) {
        var dom = editor.dom;
        var parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();
        var contentWidth = getInner(SugarElement.fromDom(parentBlock));
        return __assign(__assign({}, defaultStyles), { width: contentWidth + 'px' });
      } else if (isResponsiveForced(editor)) {
        return filter$1(defaultStyles, function (_value, key) {
          return key !== 'width';
        });
      } else {
        return defaultStyles;
      }
    };
    var defaultAttributes = { border: '1' };
    var defaultColumnResizingBehaviour = 'preservetable';
    var getTableSizingMode = function (editor) {
      return editor.getParam('table_sizing_mode', 'auto');
    };
    var getTableResponseWidth = function (editor) {
      return editor.getParam('table_responsive_width');
    };
    var getTableBorderWidths = function (editor) {
      return editor.getParam('table_border_widths', defaultCellBorderWidths, 'array');
    };
    var getTableBorderStyles = function (editor) {
      return editor.getParam('table_border_styles', defaultCellBorderStyles, 'array');
    };
    var getDefaultAttributes = function (editor) {
      return editor.getParam('table_default_attributes', defaultAttributes, 'object');
    };
    var getDefaultStyles = function (editor) {
      return editor.getParam('table_default_styles', determineDefaultStyles(editor), 'object');
    };
    var hasTableResizeBars = function (editor) {
      return editor.getParam('table_resize_bars', true, 'boolean');
    };
    var hasTabNavigation = function (editor) {
      return editor.getParam('table_tab_navigation', true, 'boolean');
    };
    var hasAdvancedCellTab = function (editor) {
      return editor.getParam('table_cell_advtab', true, 'boolean');
    };
    var hasAdvancedRowTab = function (editor) {
      return editor.getParam('table_row_advtab', true, 'boolean');
    };
    var hasAdvancedTableTab = function (editor) {
      return editor.getParam('table_advtab', true, 'boolean');
    };
    var hasAppearanceOptions = function (editor) {
      return editor.getParam('table_appearance_options', true, 'boolean');
    };
    var hasTableGrid = function (editor) {
      return editor.getParam('table_grid', true, 'boolean');
    };
    var shouldStyleWithCss = function (editor) {
      return editor.getParam('table_style_by_css', false, 'boolean');
    };
    var getCellClassList = function (editor) {
      return editor.getParam('table_cell_class_list', [], 'array');
    };
    var getRowClassList = function (editor) {
      return editor.getParam('table_row_class_list', [], 'array');
    };
    var getTableClassList = function (editor) {
      return editor.getParam('table_class_list', [], 'array');
    };
    var isPercentagesForced = function (editor) {
      return getTableSizingMode(editor) === 'relative' || getTableResponseWidth(editor) === true;
    };
    var isPixelsForced = function (editor) {
      return getTableSizingMode(editor) === 'fixed' || getTableResponseWidth(editor) === false;
    };
    var isResponsiveForced = function (editor) {
      return getTableSizingMode(editor) === 'responsive';
    };
    var getToolbar = function (editor) {
      return editor.getParam('table_toolbar', defaultTableToolbar);
    };
    var useColumnGroup = function (editor) {
      return editor.getParam('table_use_colgroups', false, 'boolean');
    };
    var getTableHeaderType = function (editor) {
      var defaultValue = 'section';
      var value = editor.getParam('table_header_type', defaultValue, 'string');
      var validValues = [
        'section',
        'cells',
        'sectionCells',
        'auto'
      ];
      if (!contains$2(validValues, value)) {
        return defaultValue;
      } else {
        return value;
      }
    };
    var getColumnResizingBehaviour = function (editor) {
      var validModes = [
        'preservetable',
        'resizetable'
      ];
      var givenMode = editor.getParam('table_column_resizing', defaultColumnResizingBehaviour, 'string');
      return find$1(validModes, function (mode) {
        return mode === givenMode;
      }).getOr(defaultColumnResizingBehaviour);
    };
    var isPreserveTableColumnResizing = function (editor) {
      return getColumnResizingBehaviour(editor) === 'preservetable';
    };
    var isResizeTableColumnResizing = function (editor) {
      return getColumnResizingBehaviour(editor) === 'resizetable';
    };
    var getCloneElements = function (editor) {
      var cloneElements = editor.getParam('table_clone_elements');
      if (isString(cloneElements)) {
        return Optional.some(cloneElements.split(/[ ,]/));
      } else if (Array.isArray(cloneElements)) {
        return Optional.some(cloneElements);
      } else {
        return Optional.none();
      }
    };
    var hasObjectResizing = function (editor) {
      var objectResizing = editor.getParam('object_resizing', true);
      return isString(objectResizing) ? objectResizing === 'table' : objectResizing;
    };
    var getTableBackgroundColorMap = function (editor) {
      return editor.getParam('table_background_color_map', [], 'array');
    };
    var getTableBorderColorMap = function (editor) {
      return editor.getParam('table_border_color_map', [], 'array');
    };

    var get$4 = function (editor, table) {
      if (isPercentagesForced(editor)) {
        return TableSize.percentageSize(table);
      } else if (isPixelsForced(editor)) {
        return TableSize.pixelSize(table);
      } else {
        return TableSize.getTableSize(table);
      }
    };

    var cleanupLegacyAttributes = function (element) {
      remove$7(element, 'width');
    };
    var convertToPercentSize = function (table) {
      var newWidth = getPercentTableWidth(table);
      redistribute(table, Optional.some(newWidth), Optional.none());
      cleanupLegacyAttributes(table);
    };
    var convertToPixelSize = function (table) {
      var newWidth = getPixelTableWidth(table);
      redistribute(table, Optional.some(newWidth), Optional.none());
      cleanupLegacyAttributes(table);
    };
    var convertToNoneSize = function (table) {
      remove$6(table, 'width');
      var columns = columns$1(table);
      var rowElements = columns.length > 0 ? columns : cells$1(table);
      each$2(rowElements, function (cell) {
        remove$6(cell, 'width');
        cleanupLegacyAttributes(cell);
      });
      cleanupLegacyAttributes(table);
    };

    var enforcePercentage = convertToPercentSize;
    var enforcePixels = convertToPixelSize;
    var enforceNone = convertToNoneSize;
    var syncPixels = function (table) {
      var warehouse = Warehouse.fromTable(table);
      if (!Warehouse.hasColumns(warehouse)) {
        each$2(cells$1(table), function (cell) {
          var computedWidth = get$a(cell, 'width');
          set$1(cell, 'width', computedWidth);
          remove$7(cell, 'width');
        });
      }
    };

    var createContainer = function () {
      var container = SugarElement.fromTag('div');
      setAll(container, {
        position: 'static',
        height: '0',
        width: '0',
        padding: '0',
        margin: '0',
        border: '0'
      });
      append$1(body$1(), container);
      return container;
    };
    var get$3 = function (editor, isResizable) {
      return editor.inline ? ResizeWire.body(getBody(editor), createContainer(), isResizable) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable);
    };
    var remove$1 = function (editor, wire) {
      if (editor.inline) {
        remove$5(wire.parent());
      }
    };

    var barResizerPrefix = 'bar-';
    var isResizable = function (elm) {
      return get$b(elm, 'data-mce-resize') !== 'false';
    };
    var getResizeHandler = function (editor) {
      var selectionRng = Optional.none();
      var resize = Optional.none();
      var wire = Optional.none();
      var startW;
      var startRawW;
      var isTable = function (elm) {
        return elm.nodeName === 'TABLE';
      };
      var lazyResize = function () {
        return resize;
      };
      var lazyWire = function () {
        return wire.getOr(ResizeWire.only(SugarElement.fromDom(editor.getBody()), isResizable));
      };
      var lazySizing = function (table) {
        return get$4(editor, table);
      };
      var lazyResizingBehaviour = function () {
        return isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();
      };
      var getNumColumns = function (table) {
        return getGridSize(table).columns;
      };
      var afterCornerResize = function (table, origin, width) {
        var isRightEdgeResize = endsWith(origin, 'e');
        if (startRawW === '') {
          enforcePercentage(table);
        }
        if (width !== startW && startRawW !== '') {
          set$1(table, 'width', startRawW);
          var resizing = lazyResizingBehaviour();
          var tableSize = lazySizing(table);
          var col = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table) - 1 : 0;
          adjustWidth(table, width - startW, col, resizing, tableSize);
        } else if (isPercentage$1(startRawW)) {
          var percentW = parseFloat(startRawW.replace('%', ''));
          var targetPercentW = width * percentW / startW;
          set$1(table, 'width', targetPercentW + '%');
        }
        if (isPixel(startRawW)) {
          syncPixels(table);
        }
      };
      var destroy = function () {
        resize.each(function (sz) {
          sz.destroy();
        });
        wire.each(function (w) {
          remove$1(editor, w);
        });
      };
      editor.on('init', function () {
        var rawWire = get$3(editor, isResizable);
        wire = Optional.some(rawWire);
        if (hasObjectResizing(editor) && hasTableResizeBars(editor)) {
          var resizing = lazyResizingBehaviour();
          var sz = TableResize.create(rawWire, resizing, lazySizing);
          sz.on();
          sz.events.startDrag.bind(function (_event) {
            selectionRng = Optional.some(editor.selection.getRng());
          });
          sz.events.beforeResize.bind(function (event) {
            var rawTable = event.table.dom;
            fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
          });
          sz.events.afterResize.bind(function (event) {
            var table = event.table;
            var rawTable = table.dom;
            removeDataStyle(table);
            selectionRng.each(function (rng) {
              editor.selection.setRng(rng);
              editor.focus();
            });
            fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
            editor.undoManager.add();
          });
          resize = Optional.some(sz);
        }
      });
      editor.on('ObjectResizeStart', function (e) {
        var targetElm = e.target;
        if (isTable(targetElm)) {
          var table = SugarElement.fromDom(targetElm);
          each$2(editor.dom.select('.mce-clonedresizable'), function (clone) {
            editor.dom.addClass(clone, 'mce-' + getColumnResizingBehaviour(editor) + '-columns');
          });
          if (!isPixelSizing(table) && isPixelsForced(editor)) {
            enforcePixels(table);
          } else if (!isPercentSizing(table) && isPercentagesForced(editor)) {
            enforcePercentage(table);
          }
          if (isNoneSizing(table) && startsWith(e.origin, barResizerPrefix)) {
            enforcePercentage(table);
          }
          startW = e.width;
          startRawW = isResponsiveForced(editor) ? '' : getRawWidth(editor, targetElm).getOr('');
        }
      });
      editor.on('ObjectResized', function (e) {
        var targetElm = e.target;
        if (isTable(targetElm)) {
          var table = SugarElement.fromDom(targetElm);
          var origin_1 = e.origin;
          if (startsWith(origin_1, 'corner-')) {
            afterCornerResize(table, origin_1, e.width);
          }
          removeDataStyle(table);
          fireTableModified(editor, table.dom, styleModified);
        }
      });
      editor.on('SwitchMode', function () {
        lazyResize().each(function (resize) {
          if (editor.mode.isReadOnly()) {
            resize.hideBars();
          } else {
            resize.showBars();
          }
        });
      });
      return {
        lazyResize: lazyResize,
        lazyWire: lazyWire,
        destroy: destroy
      };
    };

    var point = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };

    var scan$1 = function (universe, element, direction) {
      if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) {
        return direction(element).bind(function (elem) {
          return scan$1(universe, elem, direction).orThunk(function () {
            return Optional.some(elem);
          });
        });
      } else {
        return Optional.none();
      }
    };
    var toEnd = function (universe, element) {
      if (universe.property().isText(element)) {
        return universe.property().getText(element).length;
      }
      var children = universe.property().children(element);
      return children.length;
    };
    var freefallRtl$2 = function (universe, element) {
      var candidate = scan$1(universe, element, universe.query().prevSibling).getOr(element);
      if (universe.property().isText(candidate)) {
        return point(candidate, toEnd(universe, candidate));
      }
      var children = universe.property().children(candidate);
      return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));
    };

    var freefallRtl$1 = freefallRtl$2;

    var universe$2 = DomUniverse();
    var freefallRtl = function (element) {
      return freefallRtl$1(universe$2, element);
    };

    var halve = function (main, other) {
      var colspan = getSpan(main, 'colspan');
      if (colspan === 1) {
        var width = getGenericWidth(main);
        width.each(function (w) {
          var newWidth = w.value / 2;
          setGenericWidth(main, newWidth, w.unit);
          setGenericWidth(other, newWidth, w.unit);
        });
      }
    };

    var isHeaderCell = isTag('th');
    var isHeaderCells = function (cells) {
      return forall(cells, function (cell) {
        return isHeaderCell(cell.element);
      });
    };
    var getRowHeaderType = function (isHeaderRow, isHeaderCells) {
      if (isHeaderRow && isHeaderCells) {
        return 'sectionCells';
      } else if (isHeaderRow) {
        return 'section';
      } else {
        return 'cells';
      }
    };
    var getRowType$1 = function (row) {
      var isHeaderRow = row.section === 'thead';
      var isHeaderCells = is(findCommonCellType(row.cells), 'th');
      if (isHeaderRow || isHeaderCells) {
        return {
          type: 'header',
          subType: getRowHeaderType(isHeaderRow, isHeaderCells)
        };
      } else if (row.section === 'tfoot') {
        return { type: 'footer' };
      } else {
        return { type: 'body' };
      }
    };
    var findCommonCellType = function (cells) {
      var headerCells = filter$2(cells, function (cell) {
        return isHeaderCell(cell.element);
      });
      if (headerCells.length === 0) {
        return Optional.some('td');
      } else if (headerCells.length === cells.length) {
        return Optional.some('th');
      } else {
        return Optional.none();
      }
    };
    var findCommonRowType = function (rows) {
      var rowTypes = map$1(rows, function (row) {
        return getRowType$1(row).type;
      });
      var hasHeader = contains$2(rowTypes, 'header');
      var hasFooter = contains$2(rowTypes, 'footer');
      if (!hasHeader && !hasFooter) {
        return Optional.some('body');
      } else {
        var hasBody = contains$2(rowTypes, 'body');
        if (hasHeader && !hasBody && !hasFooter) {
          return Optional.some('header');
        } else if (!hasHeader && !hasBody && hasFooter) {
          return Optional.some('footer');
        } else {
          return Optional.none();
        }
      }
    };
    var findTableRowHeaderType = function (warehouse) {
      return findMap(warehouse.all, function (row) {
        var rowType = getRowType$1(row);
        return rowType.type === 'header' ? Optional.from(rowType.subType) : Optional.none();
      });
    };

    var transformCell = function (cell, comparator, substitution) {
      return elementnew(substitution(cell.element, comparator), true, cell.isLocked);
    };
    var transformRow = function (row, section) {
      return row.section !== section ? rowcells(row.element, row.cells, section, row.isNew) : row;
    };
    var section = function () {
      return {
        transformRow: transformRow,
        transformCell: function (cell, comparator, substitution) {
          var newCell = substitution(cell.element, comparator);
          var fixedCell = name(newCell) !== 'td' ? mutate$1(newCell, 'td') : newCell;
          return elementnew(fixedCell, cell.isNew, cell.isLocked);
        }
      };
    };
    var sectionCells = function () {
      return {
        transformRow: transformRow,
        transformCell: transformCell
      };
    };
    var cells = function () {
      return {
        transformRow: function (row, section) {
          var newSection = section === 'thead' ? 'tbody' : section;
          return transformRow(row, newSection);
        },
        transformCell: transformCell
      };
    };
    var fallback = function () {
      return {
        transformRow: identity,
        transformCell: transformCell
      };
    };
    var getTableSectionType = function (table, fallback) {
      var warehouse = Warehouse.fromTable(table);
      var type = findTableRowHeaderType(warehouse).getOr(fallback);
      switch (type) {
      case 'section':
        return section();
      case 'sectionCells':
        return sectionCells();
      case 'cells':
        return cells();
      }
    };
    var TableSection = {
      getTableSectionType: getTableSectionType,
      section: section,
      sectionCells: sectionCells,
      cells: cells,
      fallback: fallback
    };

    var setIfNot = function (element, property, value, ignore) {
      if (value === ignore) {
        remove$7(element, property);
      } else {
        set$2(element, property, value);
      }
    };
    var insert$1 = function (table, selector, element) {
      last$2(children$1(table, selector)).fold(function () {
        return prepend(table, element);
      }, function (child) {
        return after$5(child, element);
      });
    };
    var generateSection = function (table, sectionName) {
      var section = child$1(table, sectionName).getOrThunk(function () {
        var newSection = SugarElement.fromTag(sectionName, owner(table).dom);
        if (sectionName === 'thead') {
          insert$1(table, 'caption,colgroup', newSection);
        } else if (sectionName === 'colgroup') {
          insert$1(table, 'caption', newSection);
        } else {
          append$1(table, newSection);
        }
        return newSection;
      });
      empty(section);
      return section;
    };
    var render$1 = function (table, grid) {
      var newRows = [];
      var newCells = [];
      var syncRows = function (gridSection) {
        return map$1(gridSection, function (row) {
          if (row.isNew) {
            newRows.push(row.element);
          }
          var tr = row.element;
          empty(tr);
          each$2(row.cells, function (cell) {
            if (cell.isNew) {
              newCells.push(cell.element);
            }
            setIfNot(cell.element, 'colspan', cell.colspan, 1);
            setIfNot(cell.element, 'rowspan', cell.rowspan, 1);
            append$1(tr, cell.element);
          });
          return tr;
        });
      };
      var syncColGroup = function (gridSection) {
        return bind$2(gridSection, function (colGroup) {
          return map$1(colGroup.cells, function (col) {
            setIfNot(col.element, 'span', col.colspan, 1);
            return col.element;
          });
        });
      };
      var renderSection = function (gridSection, sectionName) {
        var section = generateSection(table, sectionName);
        var sync = sectionName === 'colgroup' ? syncColGroup : syncRows;
        var sectionElems = sync(gridSection);
        append(section, sectionElems);
      };
      var removeSection = function (sectionName) {
        child$1(table, sectionName).each(remove$5);
      };
      var renderOrRemoveSection = function (gridSection, sectionName) {
        if (gridSection.length > 0) {
          renderSection(gridSection, sectionName);
        } else {
          removeSection(sectionName);
        }
      };
      var headSection = [];
      var bodySection = [];
      var footSection = [];
      var columnGroupsSection = [];
      each$2(grid, function (row) {
        switch (row.section) {
        case 'thead':
          headSection.push(row);
          break;
        case 'tbody':
          bodySection.push(row);
          break;
        case 'tfoot':
          footSection.push(row);
          break;
        case 'colgroup':
          columnGroupsSection.push(row);
          break;
        }
      });
      renderOrRemoveSection(columnGroupsSection, 'colgroup');
      renderOrRemoveSection(headSection, 'thead');
      renderOrRemoveSection(bodySection, 'tbody');
      renderOrRemoveSection(footSection, 'tfoot');
      return {
        newRows: newRows,
        newCells: newCells
      };
    };
    var copy = function (grid) {
      return map$1(grid, function (row) {
        var tr = shallow(row.element);
        each$2(row.cells, function (cell) {
          var clonedCell = deep(cell.element);
          setIfNot(clonedCell, 'colspan', cell.colspan, 1);
          setIfNot(clonedCell, 'rowspan', cell.rowspan, 1);
          append$1(tr, clonedCell);
        });
        return tr;
      });
    };

    var getColumn = function (grid, index) {
      return map$1(grid, function (row) {
        return getCell(row, index);
      });
    };
    var getRow = function (grid, index) {
      return grid[index];
    };
    var findDiff = function (xs, comp) {
      if (xs.length === 0) {
        return 0;
      }
      var first = xs[0];
      var index = findIndex(xs, function (x) {
        return !comp(first.element, x.element);
      });
      return index.getOr(xs.length);
    };
    var subgrid = function (grid, row, column, comparator) {
      var gridRow = getRow(grid, row);
      var isColRow = gridRow.section === 'colgroup';
      var colspan = findDiff(gridRow.cells.slice(column), comparator);
      var rowspan = isColRow ? 1 : findDiff(getColumn(grid.slice(row), column), comparator);
      return {
        colspan: colspan,
        rowspan: rowspan
      };
    };

    var toDetails = function (grid, comparator) {
      var seen = map$1(grid, function (row) {
        return map$1(row.cells, never);
      });
      var updateSeen = function (rowIndex, columnIndex, rowspan, colspan) {
        for (var row = rowIndex; row < rowIndex + rowspan; row++) {
          for (var column = columnIndex; column < columnIndex + colspan; column++) {
            seen[row][column] = true;
          }
        }
      };
      return map$1(grid, function (row, rowIndex) {
        var details = bind$2(row.cells, function (cell, columnIndex) {
          if (seen[rowIndex][columnIndex] === false) {
            var result = subgrid(grid, rowIndex, columnIndex, comparator);
            updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);
            return [detailnew(cell.element, result.rowspan, result.colspan, cell.isNew)];
          } else {
            return [];
          }
        });
        return rowdetailnew(row.element, details, row.section, row.isNew);
      });
    };
    var toGrid = function (warehouse, generators, isNew) {
      var grid = [];
      each$2(warehouse.colgroups, function (colgroup) {
        var colgroupCols = [];
        for (var columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
          var element = Warehouse.getColumnAt(warehouse, columnIndex).map(function (column) {
            return elementnew(column.element, isNew, false);
          }).getOrThunk(function () {
            return elementnew(generators.colGap(), true, false);
          });
          colgroupCols.push(element);
        }
        grid.push(rowcells(colgroup.element, colgroupCols, 'colgroup', isNew));
      });
      for (var rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {
        var rowCells = [];
        for (var columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
          var element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map(function (item) {
            return elementnew(item.element, isNew, item.isLocked);
          }).getOrThunk(function () {
            return elementnew(generators.gap(), true, false);
          });
          rowCells.push(element);
        }
        var rowDetail = warehouse.all[rowIndex];
        var row = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);
        grid.push(row);
      }
      return grid;
    };

    var fromWarehouse = function (warehouse, generators) {
      return toGrid(warehouse, generators, false);
    };
    var toDetailList = function (grid) {
      return toDetails(grid, eq$1);
    };
    var findInWarehouse = function (warehouse, element) {
      return findMap(warehouse.all, function (r) {
        return find$1(r.cells, function (e) {
          return eq$1(element, e.element);
        });
      });
    };
    var extractCells = function (warehouse, target, predicate) {
      var details = map$1(target.selection, function (cell$1) {
        return cell(cell$1).bind(function (lc) {
          return findInWarehouse(warehouse, lc);
        }).filter(predicate);
      });
      var cells = cat(details);
      return someIf(cells.length > 0, cells);
    };
    var run = function (operation, extract, adjustment, postAction, genWrappers) {
      return function (wire, table, target, generators, behaviours) {
        var warehouse = Warehouse.fromTable(table);
        var tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);
        var output = extract(warehouse, target).map(function (info) {
          var model = fromWarehouse(warehouse, generators);
          var result = operation(model, info, eq$1, genWrappers(generators), tableSection);
          var lockedColumns = getLockedColumnsFromGrid(result.grid);
          var grid = toDetailList(result.grid);
          return {
            info: info,
            grid: grid,
            cursor: result.cursor,
            lockedColumns: lockedColumns
          };
        });
        return output.bind(function (out) {
          var newElements = render$1(table, out.grid);
          var tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(function () {
            return TableSize.getTableSize(table);
          });
          var resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);
          adjustment(table, out.grid, out.info, {
            sizing: tableSizing,
            resize: resizing,
            section: tableSection
          });
          postAction(table);
          refresh(wire, table);
          remove$7(table, LOCKED_COL_ATTR);
          if (out.lockedColumns.length > 0) {
            set$2(table, LOCKED_COL_ATTR, out.lockedColumns.join(','));
          }
          return Optional.some({
            cursor: out.cursor,
            newRows: newElements.newRows,
            newCells: newElements.newCells
          });
        });
      };
    };
    var onPaste = function (warehouse, target) {
      return cell(target.element).bind(function (cell) {
        return findInWarehouse(warehouse, cell).map(function (details) {
          var value = __assign(__assign({}, details), {
            generators: target.generators,
            clipboard: target.clipboard
          });
          return value;
        });
      });
    };
    var onPasteByEditor = function (warehouse, target) {
      return extractCells(warehouse, target, always).map(function (cells) {
        return {
          cells: cells,
          generators: target.generators,
          clipboard: target.clipboard
        };
      });
    };
    var onMergable = function (_warehouse, target) {
      return target.mergable;
    };
    var onUnmergable = function (_warehouse, target) {
      return target.unmergable;
    };
    var onCells = function (warehouse, target) {
      return extractCells(warehouse, target, always);
    };
    var onUnlockedCells = function (warehouse, target) {
      return extractCells(warehouse, target, function (detail) {
        return !detail.isLocked;
      });
    };
    var isUnlockedTableCell = function (warehouse, cell) {
      return findInWarehouse(warehouse, cell).exists(function (detail) {
        return !detail.isLocked;
      });
    };
    var allUnlocked = function (warehouse, cells) {
      return forall(cells, function (cell) {
        return isUnlockedTableCell(warehouse, cell);
      });
    };
    var onUnlockedMergable = function (warehouse, target) {
      return onMergable(warehouse, target).filter(function (mergeable) {
        return allUnlocked(warehouse, mergeable.cells);
      });
    };
    var onUnlockedUnmergable = function (warehouse, target) {
      return onUnmergable(warehouse, target).filter(function (cells) {
        return allUnlocked(warehouse, cells);
      });
    };

    var merge$2 = function (grid, bounds, comparator, substitution) {
      var rows = extractGridDetails(grid).rows;
      if (rows.length === 0) {
        return grid;
      }
      for (var i = bounds.startRow; i <= bounds.finishRow; i++) {
        for (var j = bounds.startCol; j <= bounds.finishCol; j++) {
          var row = rows[i];
          var isLocked = getCell(row, j).isLocked;
          mutateCell(row, j, elementnew(substitution(), false, isLocked));
        }
      }
      return grid;
    };
    var unmerge = function (grid, target, comparator, substitution) {
      var rows = extractGridDetails(grid).rows;
      var first = true;
      for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < cellLength(rows[0]); j++) {
          var row = rows[i];
          var currentCell = getCell(row, j);
          var currentCellElm = currentCell.element;
          var isToReplace = comparator(currentCellElm, target);
          if (isToReplace === true && first === false) {
            mutateCell(row, j, elementnew(substitution(), true, currentCell.isLocked));
          } else if (isToReplace === true) {
            first = false;
          }
        }
      }
      return grid;
    };
    var uniqueCells = function (row, comparator) {
      return foldl(row, function (rest, cell) {
        return exists(rest, function (currentCell) {
          return comparator(currentCell.element, cell.element);
        }) ? rest : rest.concat([cell]);
      }, []);
    };
    var splitCols = function (grid, index, comparator, substitution) {
      if (index > 0 && index < grid[0].cells.length) {
        each$2(grid, function (row) {
          var prevCell = row.cells[index - 1];
          var current = row.cells[index];
          var isToReplace = comparator(current.element, prevCell.element);
          if (isToReplace) {
            mutateCell(row, index, elementnew(substitution(), true, current.isLocked));
          }
        });
      }
      return grid;
    };
    var splitRows = function (grid, index, comparator, substitution) {
      var rows = extractGridDetails(grid).rows;
      if (index > 0 && index < rows.length) {
        var rowPrevCells = rows[index - 1].cells;
        var cells = uniqueCells(rowPrevCells, comparator);
        each$2(cells, function (cell) {
          var replacement = Optional.none();
          for (var i = index; i < rows.length; i++) {
            var _loop_1 = function (j) {
              var row = rows[i];
              var current = getCell(row, j);
              var isToReplace = comparator(current.element, cell.element);
              if (isToReplace) {
                if (replacement.isNone()) {
                  replacement = Optional.some(substitution());
                }
                replacement.each(function (sub) {
                  mutateCell(row, j, elementnew(sub, true, current.isLocked));
                });
              }
            };
            for (var j = 0; j < cellLength(rows[0]); j++) {
              _loop_1(j);
            }
          }
        });
      }
      return grid;
    };

    var value$1 = function (o) {
      var or = function (_opt) {
        return value$1(o);
      };
      var orThunk = function (_f) {
        return value$1(o);
      };
      var map = function (f) {
        return value$1(f(o));
      };
      var mapError = function (_f) {
        return value$1(o);
      };
      var each = function (f) {
        f(o);
      };
      var bind = function (f) {
        return f(o);
      };
      var fold = function (_, onValue) {
        return onValue(o);
      };
      var exists = function (f) {
        return f(o);
      };
      var forall = function (f) {
        return f(o);
      };
      var toOptional = function () {
        return Optional.some(o);
      };
      return {
        isValue: always,
        isError: never,
        getOr: constant(o),
        getOrThunk: constant(o),
        getOrDie: constant(o),
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: each,
        bind: bind,
        exists: exists,
        forall: forall,
        toOptional: toOptional
      };
    };
    var error = function (message) {
      var getOrThunk = function (f) {
        return f();
      };
      var getOrDie = function () {
        return die(String(message))();
      };
      var or = identity;
      var orThunk = function (f) {
        return f();
      };
      var map = function (_f) {
        return error(message);
      };
      var mapError = function (f) {
        return error(f(message));
      };
      var bind = function (_f) {
        return error(message);
      };
      var fold = function (onError, _) {
        return onError(message);
      };
      return {
        isValue: never,
        isError: always,
        getOr: identity,
        getOrThunk: getOrThunk,
        getOrDie: getOrDie,
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: noop,
        bind: bind,
        exists: never,
        forall: always,
        toOptional: Optional.none
      };
    };
    var fromOption = function (opt, err) {
      return opt.fold(function () {
        return error(err);
      }, value$1);
    };
    var Result = {
      value: value$1,
      error: error,
      fromOption: fromOption
    };

    var measure = function (startAddress, gridA, gridB) {
      if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) {
        return Result.error('invalid start address out of table bounds, row: ' + startAddress.row + ', column: ' + startAddress.column);
      }
      var rowRemainder = gridA.slice(startAddress.row);
      var colRemainder = rowRemainder[0].cells.slice(startAddress.column);
      var colRequired = cellLength(gridB[0]);
      var rowRequired = gridB.length;
      return Result.value({
        rowDelta: rowRemainder.length - rowRequired,
        colDelta: colRemainder.length - colRequired
      });
    };
    var measureWidth = function (gridA, gridB) {
      var colLengthA = cellLength(gridA[0]);
      var colLengthB = cellLength(gridB[0]);
      return {
        rowDelta: 0,
        colDelta: colLengthA - colLengthB
      };
    };
    var measureHeight = function (gridA, gridB) {
      var rowLengthA = gridA.length;
      var rowLengthB = gridB.length;
      return {
        rowDelta: rowLengthA - rowLengthB,
        colDelta: 0
      };
    };
    var generateElements = function (amount, row, generators, isLocked) {
      var generator = row.section === 'colgroup' ? generators.col : generators.cell;
      return range$1(amount, function (idx) {
        return elementnew(generator(), true, isLocked(idx));
      });
    };
    var rowFill = function (grid, amount, generators, lockedColumns) {
      var exampleRow = grid[grid.length - 1];
      return grid.concat(range$1(amount, function () {
        var generator = exampleRow.section === 'colgroup' ? generators.colgroup : generators.row;
        var row = clone$1(exampleRow, generator, identity);
        var elements = generateElements(row.cells.length, row, generators, function (idx) {
          return has$1(lockedColumns, idx.toString());
        });
        return setCells(row, elements);
      }));
    };
    var colFill = function (grid, amount, generators, startIndex) {
      return map$1(grid, function (row) {
        var newChildren = generateElements(amount, row, generators, never);
        return addCells(row, startIndex, newChildren);
      });
    };
    var lockedColFill = function (grid, generators, lockedColumns) {
      return map$1(grid, function (row) {
        return foldl(lockedColumns, function (acc, colNum) {
          var newChild = generateElements(1, row, generators, always)[0];
          return addCell(acc, colNum, newChild);
        }, row);
      });
    };
    var tailor = function (gridA, delta, generators) {
      var fillCols = delta.colDelta < 0 ? colFill : identity;
      var fillRows = delta.rowDelta < 0 ? rowFill : identity;
      var lockedColumns = getLockedColumnsFromGrid(gridA);
      var gridWidth = cellLength(gridA[0]);
      var isLastColLocked = exists(lockedColumns, function (locked) {
        return locked === gridWidth - 1;
      });
      var modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);
      var newLockedColumns = getLockedColumnsFromGrid(modifiedCols);
      return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));
    };

    var isSpanning = function (grid, row, col, comparator) {
      var candidate = getCell(grid[row], col);
      var matching = curry(comparator, candidate.element);
      var currentRow = grid[row];
      return grid.length > 1 && cellLength(currentRow) > 1 && (col > 0 && matching(getCellElement(currentRow, col - 1)) || col < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col + 1)) || row > 0 && matching(getCellElement(grid[row - 1], col)) || row < grid.length - 1 && matching(getCellElement(grid[row + 1], col)));
    };
    var mergeTables = function (startAddress, gridA, gridB, generator, comparator, lockedColumns) {
      var startRow = startAddress.row;
      var startCol = startAddress.column;
      var mergeHeight = gridB.length;
      var mergeWidth = cellLength(gridB[0]);
      var endRow = startRow + mergeHeight;
      var endCol = startCol + mergeWidth + lockedColumns.length;
      var lockedColumnObj = mapToObject(lockedColumns, always);
      for (var r = startRow; r < endRow; r++) {
        var skippedCol = 0;
        for (var c = startCol; c < endCol; c++) {
          if (lockedColumnObj[c]) {
            skippedCol++;
            continue;
          }
          if (isSpanning(gridA, r, c, comparator)) {
            unmerge(gridA, getCellElement(gridA[r], c), comparator, generator.cell);
          }
          var gridBColIndex = c - startCol - skippedCol;
          var newCell = getCell(gridB[r - startRow], gridBColIndex);
          var newCellElm = newCell.element;
          var replacement = generator.replace(newCellElm);
          mutateCell(gridA[r], c, elementnew(replacement, true, newCell.isLocked));
        }
      }
      return gridA;
    };
    var getValidStartAddress = function (currentStartAddress, grid, lockedColumns) {
      var gridColLength = cellLength(grid[0]);
      var adjustedRowAddress = extractGridDetails(grid).cols.length + currentStartAddress.row;
      var possibleColAddresses = range$1(gridColLength - currentStartAddress.column, function (num) {
        return num + currentStartAddress.column;
      });
      var validColAddress = find$1(possibleColAddresses, function (num) {
        return forall(lockedColumns, function (col) {
          return col !== num;
        });
      }).getOr(gridColLength - 1);
      return {
        row: adjustedRowAddress,
        column: validColAddress
      };
    };
    var getLockedColumnsWithinBounds = function (startAddress, grid, lockedColumns) {
      return filter$2(lockedColumns, function (colNum) {
        return colNum >= startAddress.column && colNum <= cellLength(grid[0]) + startAddress.column;
      });
    };
    var merge$1 = function (startAddress, gridA, gridB, generator, comparator) {
      var lockedColumns = getLockedColumnsFromGrid(gridA);
      var validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);
      var gridBRows = extractGridDetails(gridB).rows;
      var lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);
      var result = measure(validStartAddress, gridA, gridBRows);
      return result.map(function (diff) {
        var delta = __assign(__assign({}, diff), { colDelta: diff.colDelta - lockedColumnsWithinBounds.length });
        var fittedGrid = tailor(gridA, delta, generator);
        var newLockedColumns = getLockedColumnsFromGrid(fittedGrid);
        var newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);
        return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);
      });
    };
    var insertCols = function (index, gridA, gridB, generator, comparator) {
      splitCols(gridA, index, comparator, generator.cell);
      var delta = measureHeight(gridB, gridA);
      var fittedNewGrid = tailor(gridB, delta, generator);
      var secondDelta = measureHeight(gridA, fittedNewGrid);
      var fittedOldGrid = tailor(gridA, secondDelta, generator);
      return map$1(fittedOldGrid, function (gridRow, i) {
        return addCells(gridRow, index, fittedNewGrid[i].cells);
      });
    };
    var insertRows = function (index, gridA, gridB, generator, comparator) {
      splitRows(gridA, index, comparator, generator.cell);
      var locked = getLockedColumnsFromGrid(gridA);
      var diff = measureWidth(gridA, gridB);
      var delta = __assign(__assign({}, diff), { colDelta: diff.colDelta - locked.length });
      var fittedOldGrid = tailor(gridA, delta, generator);
      var _a = extractGridDetails(fittedOldGrid), oldCols = _a.cols, oldRows = _a.rows;
      var newLocked = getLockedColumnsFromGrid(fittedOldGrid);
      var secondDiff = measureWidth(gridB, gridA);
      var secondDelta = __assign(__assign({}, secondDiff), { colDelta: secondDiff.colDelta + newLocked.length });
      var fittedGridB = lockedColFill(gridB, generator, newLocked);
      var fittedNewGrid = tailor(fittedGridB, secondDelta, generator);
      return oldCols.concat(oldRows.slice(0, index)).concat(fittedNewGrid).concat(oldRows.slice(index, oldRows.length));
    };

    var cloneRow = function (row, cloneCell, comparator, substitution) {
      return clone$1(row, function (elem) {
        return substitution(elem, comparator);
      }, cloneCell);
    };
    var insertRowAt = function (grid, index, example, comparator, substitution) {
      var _a = extractGridDetails(grid), rows = _a.rows, cols = _a.cols;
      var before = rows.slice(0, index);
      var after = rows.slice(index);
      var newRow = cloneRow(rows[example], function (ex, c) {
        var withinSpan = index > 0 && index < rows.length && comparator(getCellElement(rows[index - 1], c), getCellElement(rows[index], c));
        var ret = withinSpan ? getCell(rows[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);
        return ret;
      }, comparator, substitution);
      return cols.concat(before).concat([newRow]).concat(after);
    };
    var getElementFor = function (row, column, section, withinSpan, example, comparator, substitution) {
      if (section === 'colgroup' || !withinSpan) {
        var cell = getCell(row, example);
        return elementnew(substitution(cell.element, comparator), true, false);
      } else {
        return getCell(row, column);
      }
    };
    var insertColumnAt = function (grid, index, example, comparator, substitution) {
      return map$1(grid, function (row) {
        var withinSpan = index > 0 && index < cellLength(row) && comparator(getCellElement(row, index - 1), getCellElement(row, index));
        var sub = getElementFor(row, index, row.section, withinSpan, example, comparator, substitution);
        return addCell(row, index, sub);
      });
    };
    var deleteColumnsAt = function (grid, columns) {
      return bind$2(grid, function (row) {
        var existingCells = row.cells;
        var cells = foldr(columns, function (acc, column) {
          return column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc;
        }, existingCells);
        return cells.length > 0 ? [rowcells(row.element, cells, row.section, row.isNew)] : [];
      });
    };
    var deleteRowsAt = function (grid, start, finish) {
      var _a = extractGridDetails(grid), rows = _a.rows, cols = _a.cols;
      return cols.concat(rows.slice(0, start)).concat(rows.slice(finish + 1));
    };

    var notInStartRow = function (grid, rowIndex, colIndex, comparator) {
      return getCellElement(grid[rowIndex], colIndex) !== undefined && (rowIndex > 0 && comparator(getCellElement(grid[rowIndex - 1], colIndex), getCellElement(grid[rowIndex], colIndex)));
    };
    var notInStartColumn = function (row, index, comparator) {
      return index > 0 && comparator(getCellElement(row, index - 1), getCellElement(row, index));
    };
    var isDuplicatedCell = function (grid, rowIndex, colIndex, comparator) {
      return notInStartRow(grid, rowIndex, colIndex, comparator) || notInStartColumn(grid[rowIndex], colIndex, comparator);
    };
    var rowReplacerPredicate = function (targetRow, columnHeaders) {
      var entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells(targetRow.cells);
      return entireTableIsHeader ? always : function (cell, _rowIndex, colIndex) {
        var type = name(cell.element);
        return !(type === 'th' && columnHeaders[colIndex]);
      };
    };
    var columnReplacePredicate = function (targetColumn, rowHeaders) {
      var entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells(targetColumn);
      return entireTableIsHeader ? always : function (cell, rowIndex, _colIndex) {
        var type = name(cell.element);
        return !(type === 'th' && rowHeaders[rowIndex]);
      };
    };
    var determineScope = function (applyScope, element, newScope, isInHeader) {
      var hasSpan = function (scope) {
        return scope === 'row' ? hasRowspan(element) : hasColspan(element);
      };
      var getScope = function (scope) {
        return hasSpan(scope) ? scope + 'group' : scope;
      };
      if (applyScope) {
        return isHeaderCell(element) ? getScope(newScope) : null;
      } else if (isInHeader && isHeaderCell(element)) {
        var oppositeScope = newScope === 'row' ? 'col' : 'row';
        return getScope(oppositeScope);
      } else {
        return null;
      }
    };
    var rowScopeGenerator = function (applyScope, columnHeaders) {
      return function (cell, rowIndex, columnIndex) {
        return Optional.some(determineScope(applyScope, cell.element, 'col', columnHeaders[columnIndex]));
      };
    };
    var columnScopeGenerator = function (applyScope, rowHeaders) {
      return function (cell, rowIndex) {
        return Optional.some(determineScope(applyScope, cell.element, 'row', rowHeaders[rowIndex]));
      };
    };
    var replace = function (cell, comparator, substitute) {
      return elementnew(substitute(cell.element, comparator), true, cell.isLocked);
    };
    var replaceIn = function (grid, targets, comparator, substitute, replacer, genScope, shouldReplace) {
      var isTarget = function (cell) {
        return exists(targets, function (target) {
          return comparator(cell.element, target.element);
        });
      };
      return map$1(grid, function (row, rowIndex) {
        return mapCells(row, function (cell, colIndex) {
          if (isTarget(cell)) {
            var newCell_1 = shouldReplace(cell, rowIndex, colIndex) ? replacer(cell, comparator, substitute) : cell;
            genScope(newCell_1, rowIndex, colIndex).each(function (scope) {
              setOptions(newCell_1.element, { scope: Optional.from(scope) });
            });
            return newCell_1;
          } else {
            return cell;
          }
        });
      });
    };
    var getColumnCells = function (rows, columnIndex, comparator) {
      return bind$2(rows, function (row, i) {
        return isDuplicatedCell(rows, i, columnIndex, comparator) ? [] : [getCell(row, columnIndex)];
      });
    };
    var getRowCells = function (rows, rowIndex, comparator) {
      var targetRow = rows[rowIndex];
      return bind$2(targetRow.cells, function (item, i) {
        return isDuplicatedCell(rows, rowIndex, i, comparator) ? [] : [item];
      });
    };
    var replaceColumns = function (grid, indexes, applyScope, comparator, substitution) {
      var rows = extractGridDetails(grid).rows;
      var targets = bind$2(indexes, function (index) {
        return getColumnCells(rows, index, comparator);
      });
      var rowHeaders = map$1(grid, function (row) {
        return isHeaderCells(row.cells);
      });
      var shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);
      var scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);
      return replaceIn(grid, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);
    };
    var replaceRows = function (grid, indexes, section, applyScope, comparator, substitution, tableSection) {
      var _a = extractGridDetails(grid), cols = _a.cols, rows = _a.rows;
      var targetRow = rows[indexes[0]];
      var targets = bind$2(indexes, function (index) {
        return getRowCells(rows, index, comparator);
      });
      var columnHeaders = map$1(targetRow.cells, function (_cell, index) {
        return isHeaderCells(getColumnCells(rows, index, comparator));
      });
      var newRows = __spreadArray([], rows, true);
      each$2(indexes, function (index) {
        newRows[index] = tableSection.transformRow(rows[index], section);
      });
      var newGrid = cols.concat(newRows);
      var shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);
      var scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);
      return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);
    };
    var replaceCells = function (grid, details, comparator, substitution) {
      var rows = extractGridDetails(grid).rows;
      var targetCells = map$1(details, function (detail) {
        return getCell(rows[detail.row], detail.column);
      });
      return replaceIn(grid, targetCells, comparator, substitution, replace, Optional.none, always);
    };

    var uniqueColumns = function (details) {
      var uniqueCheck = function (rest, detail) {
        var columnExists = exists(rest, function (currentDetail) {
          return currentDetail.column === detail.column;
        });
        return columnExists ? rest : rest.concat([detail]);
      };
      return foldl(details, uniqueCheck, []).sort(function (detailA, detailB) {
        return detailA.column - detailB.column;
      });
    };

    var isCol = isTag('col');
    var isColgroup = isTag('colgroup');
    var isRow$1 = function (element) {
      return name(element) === 'tr' || isColgroup(element);
    };
    var elementToData = function (element) {
      var colspan = getAttrValue(element, 'colspan', 1);
      var rowspan = getAttrValue(element, 'rowspan', 1);
      return {
        element: element,
        colspan: colspan,
        rowspan: rowspan
      };
    };
    var modification = function (generators, toData) {
      if (toData === void 0) {
        toData = elementToData;
      }
      var nuCell = function (data) {
        return isCol(data.element) ? generators.col(data) : generators.cell(data);
      };
      var nuRow = function (data) {
        return isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);
      };
      var add = function (element) {
        if (isRow$1(element)) {
          return nuRow({ element: element });
        } else {
          var replacement = nuCell(toData(element));
          recent = Optional.some({
            item: element,
            replacement: replacement
          });
          return replacement;
        }
      };
      var recent = Optional.none();
      var getOrInit = function (element, comparator) {
        return recent.fold(function () {
          return add(element);
        }, function (p) {
          return comparator(element, p.item) ? p.replacement : add(element);
        });
      };
      return { getOrInit: getOrInit };
    };
    var transform = function (tag) {
      return function (generators) {
        var list = [];
        var find = function (element, comparator) {
          return find$1(list, function (x) {
            return comparator(x.item, element);
          });
        };
        var makeNew = function (element) {
          var attrs = tag === 'td' ? { scope: null } : {};
          var cell = generators.replace(element, tag, attrs);
          list.push({
            item: element,
            sub: cell
          });
          return cell;
        };
        var replaceOrInit = function (element, comparator) {
          if (isRow$1(element) || isCol(element)) {
            return element;
          } else {
            return find(element, comparator).fold(function () {
              return makeNew(element);
            }, function (p) {
              return comparator(element, p.item) ? p.sub : makeNew(element);
            });
          }
        };
        return { replaceOrInit: replaceOrInit };
      };
    };
    var getScopeAttribute = function (cell) {
      return getOpt(cell, 'scope').map(function (attribute) {
        return attribute.substr(0, 3);
      });
    };
    var merging = function (generators) {
      var unmerge = function (cell) {
        var scope = getScopeAttribute(cell);
        scope.each(function (attribute) {
          return set$2(cell, 'scope', attribute);
        });
        return function () {
          var raw = generators.cell({
            element: cell,
            colspan: 1,
            rowspan: 1
          });
          remove$6(raw, 'width');
          remove$6(cell, 'width');
          scope.each(function (attribute) {
            return set$2(raw, 'scope', attribute);
          });
          return raw;
        };
      };
      var merge = function (cells) {
        var getScopeProperty = function () {
          var stringAttributes = cat(map$1(cells, getScopeAttribute));
          if (stringAttributes.length === 0) {
            return Optional.none();
          } else {
            var baseScope_1 = stringAttributes[0];
            var scopes_1 = [
              'row',
              'col'
            ];
            var isMixed = exists(stringAttributes, function (attribute) {
              return attribute !== baseScope_1 && contains$2(scopes_1, attribute);
            });
            return isMixed ? Optional.none() : Optional.from(baseScope_1);
          }
        };
        remove$6(cells[0], 'width');
        getScopeProperty().fold(function () {
          return remove$7(cells[0], 'scope');
        }, function (attribute) {
          return set$2(cells[0], 'scope', attribute + 'group');
        });
        return constant(cells[0]);
      };
      return {
        unmerge: unmerge,
        merge: merge
      };
    };
    var Generators = {
      modification: modification,
      transform: transform,
      merging: merging
    };

    var blockList = [
      'body',
      'p',
      'div',
      'article',
      'aside',
      'figcaption',
      'figure',
      'footer',
      'header',
      'nav',
      'section',
      'ol',
      'ul',
      'table',
      'thead',
      'tfoot',
      'tbody',
      'caption',
      'tr',
      'td',
      'th',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'blockquote',
      'pre',
      'address'
    ];
    var isList$1 = function (universe, item) {
      var tagName = universe.property().name(item);
      return contains$2([
        'ol',
        'ul'
      ], tagName);
    };
    var isBlock$1 = function (universe, item) {
      var tagName = universe.property().name(item);
      return contains$2(blockList, tagName);
    };
    var isEmptyTag$1 = function (universe, item) {
      return contains$2([
        'br',
        'img',
        'hr',
        'input'
      ], universe.property().name(item));
    };

    var universe$1 = DomUniverse();
    var isBlock = function (element) {
      return isBlock$1(universe$1, element);
    };
    var isList = function (element) {
      return isList$1(universe$1, element);
    };
    var isEmptyTag = function (element) {
      return isEmptyTag$1(universe$1, element);
    };

    var merge = function (cells) {
      var isBr = function (el) {
        return name(el) === 'br';
      };
      var advancedBr = function (children) {
        return forall(children, function (c) {
          return isBr(c) || isText(c) && get$9(c).trim().length === 0;
        });
      };
      var isListItem = function (el) {
        return name(el) === 'li' || ancestor$2(el, isList).isSome();
      };
      var siblingIsBlock = function (el) {
        return nextSibling(el).map(function (rightSibling) {
          if (isBlock(rightSibling)) {
            return true;
          }
          if (isEmptyTag(rightSibling)) {
            return name(rightSibling) === 'img' ? false : true;
          }
          return false;
        }).getOr(false);
      };
      var markCell = function (cell) {
        return last$1(cell).bind(function (rightEdge) {
          var rightSiblingIsBlock = siblingIsBlock(rightEdge);
          return parent(rightEdge).map(function (parent) {
            return rightSiblingIsBlock === true || isListItem(parent) || isBr(rightEdge) || isBlock(parent) && !eq$1(cell, parent) ? [] : [SugarElement.fromTag('br')];
          });
        }).getOr([]);
      };
      var markContent = function () {
        var content = bind$2(cells, function (cell) {
          var children = children$3(cell);
          return advancedBr(children) ? [] : children.concat(markCell(cell));
        });
        return content.length === 0 ? [SugarElement.fromTag('br')] : content;
      };
      var contents = markContent();
      empty(cells[0]);
      append(cells[0], contents);
    };

    var isEditable = function (elem) {
      return isEditable$1(elem, true);
    };
    var prune = function (table) {
      var cells = cells$1(table);
      if (cells.length === 0) {
        remove$5(table);
      }
    };
    var outcome = function (grid, cursor) {
      return {
        grid: grid,
        cursor: cursor
      };
    };
    var findEditableCursorPosition = function (rows) {
      return findMap(rows, function (row) {
        return findMap(row.cells, function (cell) {
          var elem = cell.element;
          return someIf(isEditable(elem), elem);
        });
      });
    };
    var elementFromGrid = function (grid, row, column) {
      var _a, _b;
      var rows = extractGridDetails(grid).rows;
      return Optional.from((_b = (_a = rows[row]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(function () {
        return findEditableCursorPosition(rows);
      });
    };
    var bundle = function (grid, row, column) {
      var cursorElement = elementFromGrid(grid, row, column);
      return outcome(grid, cursorElement);
    };
    var uniqueRows = function (details) {
      var rowCompilation = function (rest, detail) {
        var rowExists = exists(rest, function (currentDetail) {
          return currentDetail.row === detail.row;
        });
        return rowExists ? rest : rest.concat([detail]);
      };
      return foldl(details, rowCompilation, []).sort(function (detailA, detailB) {
        return detailA.row - detailB.row;
      });
    };
    var opInsertRowsBefore = function (grid, details, comparator, genWrappers) {
      var targetIndex = details[0].row;
      var rows = uniqueRows(details);
      var newGrid = foldr(rows, function (acc, row) {
        var newG = insertRowAt(acc.grid, targetIndex, row.row + acc.delta, comparator, genWrappers.getOrInit);
        return {
          grid: newG,
          delta: acc.delta + 1
        };
      }, {
        grid: grid,
        delta: 0
      }).grid;
      return bundle(newGrid, targetIndex, details[0].column);
    };
    var opInsertRowsAfter = function (grid, details, comparator, genWrappers) {
      var rows = uniqueRows(details);
      var target = rows[rows.length - 1];
      var targetIndex = target.row + target.rowspan;
      var newGrid = foldr(rows, function (newG, row) {
        return insertRowAt(newG, targetIndex, row.row, comparator, genWrappers.getOrInit);
      }, grid);
      return bundle(newGrid, targetIndex, details[0].column);
    };
    var opInsertColumnsBefore = function (grid, extractDetail, comparator, genWrappers) {
      var details = extractDetail.details;
      var columns = uniqueColumns(details);
      var targetIndex = columns[0].column;
      var newGrid = foldr(columns, function (acc, col) {
        var newG = insertColumnAt(acc.grid, targetIndex, col.column + acc.delta, comparator, genWrappers.getOrInit);
        return {
          grid: newG,
          delta: acc.delta + 1
        };
      }, {
        grid: grid,
        delta: 0
      }).grid;
      return bundle(newGrid, details[0].row, targetIndex);
    };
    var opInsertColumnsAfter = function (grid, extractDetail, comparator, genWrappers) {
      var details = extractDetail.details;
      var target = details[details.length - 1];
      var targetIndex = target.column + target.colspan;
      var columns = uniqueColumns(details);
      var newGrid = foldr(columns, function (newG, col) {
        return insertColumnAt(newG, targetIndex, col.column, comparator, genWrappers.getOrInit);
      }, grid);
      return bundle(newGrid, details[0].row, targetIndex);
    };
    var opMakeColumnsHeader = function (initialGrid, details, comparator, genWrappers) {
      var columns = uniqueColumns(details);
      var columnIndexes = map$1(columns, function (detail) {
        return detail.column;
      });
      var newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);
      return bundle(newGrid, details[0].row, details[0].column);
    };
    var opMakeCellsHeader = function (initialGrid, details, comparator, genWrappers) {
      var newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
      return bundle(newGrid, details[0].row, details[0].column);
    };
    var opUnmakeColumnsHeader = function (initialGrid, details, comparator, genWrappers) {
      var columns = uniqueColumns(details);
      var columnIndexes = map$1(columns, function (detail) {
        return detail.column;
      });
      var newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);
      return bundle(newGrid, details[0].row, details[0].column);
    };
    var opUnmakeCellsHeader = function (initialGrid, details, comparator, genWrappers) {
      var newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
      return bundle(newGrid, details[0].row, details[0].column);
    };
    var makeRowsSection = function (section, applyScope) {
      return function (initialGrid, details, comparator, genWrappers, tableSection) {
        var rows = uniqueRows(details);
        var rowIndexes = map$1(rows, function (detail) {
          return detail.row;
        });
        var newGrid = replaceRows(initialGrid, rowIndexes, section, applyScope, comparator, genWrappers.replaceOrInit, tableSection);
        return bundle(newGrid, details[0].row, details[0].column);
      };
    };
    var opMakeRowsHeader = makeRowsSection('thead', true);
    var opMakeRowsBody = makeRowsSection('tbody', false);
    var opMakeRowsFooter = makeRowsSection('tfoot', false);
    var opEraseColumns = function (grid, extractDetail, _comparator, _genWrappers) {
      var columns = uniqueColumns(extractDetail.details);
      var newGrid = deleteColumnsAt(grid, map$1(columns, function (column) {
        return column.column;
      }));
      var maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;
      return bundle(newGrid, columns[0].row, Math.min(columns[0].column, maxColIndex));
    };
    var opEraseRows = function (grid, details, _comparator, _genWrappers) {
      var rows = uniqueRows(details);
      var newGrid = deleteRowsAt(grid, rows[0].row, rows[rows.length - 1].row);
      var maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;
      return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);
    };
    var opMergeCells = function (grid, mergable, comparator, genWrappers) {
      var cells = mergable.cells;
      merge(cells);
      var newGrid = merge$2(grid, mergable.bounds, comparator, genWrappers.merge(cells));
      return outcome(newGrid, Optional.from(cells[0]));
    };
    var opUnmergeCells = function (grid, unmergable, comparator, genWrappers) {
      var unmerge$1 = function (b, cell) {
        return unmerge(b, cell, comparator, genWrappers.unmerge(cell));
      };
      var newGrid = foldr(unmergable, unmerge$1, grid);
      return outcome(newGrid, Optional.from(unmergable[0]));
    };
    var opPasteCells = function (grid, pasteDetails, comparator, _genWrappers) {
      var gridify = function (table, generators) {
        var wh = Warehouse.fromTable(table);
        return toGrid(wh, generators, true);
      };
      var gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);
      var startAddress = address(pasteDetails.row, pasteDetails.column);
      var mergedGrid = merge$1(startAddress, grid, gridB, pasteDetails.generators, comparator);
      return mergedGrid.fold(function () {
        return outcome(grid, Optional.some(pasteDetails.element));
      }, function (newGrid) {
        return bundle(newGrid, pasteDetails.row, pasteDetails.column);
      });
    };
    var gridifyRows = function (rows, generators, context) {
      var pasteDetails = fromPastedRows(rows, context.section);
      var wh = Warehouse.generate(pasteDetails);
      return toGrid(wh, generators, true);
    };
    var opPasteColsBefore = function (grid, pasteDetails, comparator, _genWrappers) {
      var rows = extractGridDetails(grid).rows;
      var index = pasteDetails.cells[0].column;
      var context = rows[pasteDetails.cells[0].row];
      var gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
      var mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);
      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    var opPasteColsAfter = function (grid, pasteDetails, comparator, _genWrappers) {
      var rows = extractGridDetails(grid).rows;
      var index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;
      var context = rows[pasteDetails.cells[0].row];
      var gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
      var mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);
      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    var opPasteRowsBefore = function (grid, pasteDetails, comparator, _genWrappers) {
      var rows = extractGridDetails(grid).rows;
      var index = pasteDetails.cells[0].row;
      var context = rows[index];
      var gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
      var mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);
      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    var opPasteRowsAfter = function (grid, pasteDetails, comparator, _genWrappers) {
      var rows = extractGridDetails(grid).rows;
      var index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;
      var context = rows[pasteDetails.cells[0].row];
      var gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
      var mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);
      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
    };
    var opGetColumnsType = function (table, target) {
      var house = Warehouse.fromTable(table);
      var details = onCells(house, target);
      return details.bind(function (selectedCells) {
        var lastSelectedCell = selectedCells[selectedCells.length - 1];
        var minColRange = selectedCells[0].column;
        var maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
        var selectedColumnCells = flatten$1(map$1(house.all, function (row) {
          return filter$2(row.cells, function (cell) {
            return cell.column >= minColRange && cell.column < maxColRange;
          });
        }));
        return findCommonCellType(selectedColumnCells);
      }).getOr('');
    };
    var opGetCellsType = function (table, target) {
      var house = Warehouse.fromTable(table);
      var details = onCells(house, target);
      return details.bind(findCommonCellType).getOr('');
    };
    var opGetRowsType = function (table, target) {
      var house = Warehouse.fromTable(table);
      var details = onCells(house, target);
      return details.bind(function (selectedCells) {
        var lastSelectedCell = selectedCells[selectedCells.length - 1];
        var minRowRange = selectedCells[0].row;
        var maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;
        var selectedRows = house.all.slice(minRowRange, maxRowRange);
        return findCommonRowType(selectedRows);
      }).getOr('');
    };
    var resize = function (table, list, details, behaviours) {
      return adjustWidthTo(table, list, details, behaviours.sizing);
    };
    var adjustAndRedistributeWidths = function (table, list, details, behaviours) {
      return adjustAndRedistributeWidths$1(table, list, details, behaviours.sizing, behaviours.resize);
    };
    var firstColumnIsLocked = function (_warehouse, details) {
      return exists(details, function (detail) {
        return detail.column === 0 && detail.isLocked;
      });
    };
    var lastColumnIsLocked = function (warehouse, details) {
      return exists(details, function (detail) {
        return detail.column + detail.colspan >= warehouse.grid.columns && detail.isLocked;
      });
    };
    var getColumnsWidth = function (warehouse, details) {
      var columns$1 = columns(warehouse);
      var uniqueCols = uniqueColumns(details);
      return foldl(uniqueCols, function (acc, detail) {
        var column = columns$1[detail.column];
        var colWidth = column.map(getOuter$2).getOr(0);
        return acc + colWidth;
      }, 0);
    };
    var insertColumnsExtractor = function (before) {
      return function (warehouse, target) {
        return onCells(warehouse, target).filter(function (details) {
          var checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;
          return !checkLocked(warehouse, details);
        }).map(function (details) {
          return {
            details: details,
            pixelDelta: getColumnsWidth(warehouse, details)
          };
        });
      };
    };
    var eraseColumnsExtractor = function (warehouse, target) {
      return onUnlockedCells(warehouse, target).map(function (details) {
        return {
          details: details,
          pixelDelta: -getColumnsWidth(warehouse, details)
        };
      });
    };
    var pasteColumnsExtractor = function (before) {
      return function (warehouse, target) {
        return onPasteByEditor(warehouse, target).filter(function (details) {
          var checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;
          return !checkLocked(warehouse, details.cells);
        });
      };
    };
    var headerCellGenerator = Generators.transform('th');
    var bodyCellGenerator = Generators.transform('td');
    var insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);
    var insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);
    var insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);
    var insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);
    var eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);
    var eraseRows = run(opEraseRows, onCells, noop, prune, Generators.modification);
    var makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    var unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
    var makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    var makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);
    var makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);
    var makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);
    var unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);
    var mergeCells = run(opMergeCells, onUnlockedMergable, resize, noop, Generators.merging);
    var unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize, noop, Generators.merging);
    var pasteCells = run(opPasteCells, onPaste, resize, noop, Generators.modification);
    var pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);
    var pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);
    var pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);
    var pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);
    var getColumnsType = opGetColumnsType;
    var getCellsType = opGetCellsType;
    var getRowsType = opGetRowsType;

    var TableActions = function (editor, cellSelection, lazyWire) {
      var isTableBody = function (editor) {
        return name(getBody(editor)) === 'table';
      };
      var lastRowGuard = function (table) {
        return isTableBody(editor) === false || getGridSize(table).rows > 1;
      };
      var lastColumnGuard = function (table) {
        return isTableBody(editor) === false || getGridSize(table).columns > 1;
      };
      var cloneFormats = getCloneElements(editor);
      var colMutationOp = isResizeTableColumnResizing(editor) ? noop : halve;
      var getTableSectionType = function (table) {
        switch (getTableHeaderType(editor)) {
        case 'section':
          return TableSection.section();
        case 'sectionCells':
          return TableSection.sectionCells();
        case 'cells':
          return TableSection.cells();
        default:
          return TableSection.getTableSectionType(table, 'section');
        }
      };
      var setSelectionFromAction = function (table, result) {
        return result.cursor.fold(function () {
          var cells = cells$1(table);
          return head(cells).filter(inBody).map(function (firstCell) {
            cellSelection.clear(table);
            var rng = editor.dom.createRng();
            rng.selectNode(firstCell.dom);
            editor.selection.setRng(rng);
            set$2(firstCell, 'data-mce-selected', '1');
            return rng;
          });
        }, function (cell) {
          var des = freefallRtl(cell);
          var rng = editor.dom.createRng();
          rng.setStart(des.element.dom, des.offset);
          rng.setEnd(des.element.dom, des.offset);
          editor.selection.setRng(rng);
          cellSelection.clear(table);
          return Optional.some(rng);
        });
      };
      var execute = function (operation, guard, mutate, lazyWire, effect) {
        return function (table, target, noEvents) {
          if (noEvents === void 0) {
            noEvents = false;
          }
          removeDataStyle(table);
          var wire = lazyWire();
          var doc = SugarElement.fromDom(editor.getDoc());
          var generators = cellOperations(mutate, doc, cloneFormats);
          var behaviours = {
            sizing: get$4(editor, table),
            resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),
            section: getTableSectionType(table)
          };
          return guard(table) ? operation(wire, table, target, generators, behaviours).bind(function (result) {
            each$2(result.newRows, function (row) {
              fireNewRow(editor, row.dom);
            });
            each$2(result.newCells, function (cell) {
              fireNewCell(editor, cell.dom);
            });
            var range = setSelectionFromAction(table, result);
            if (inBody(table)) {
              removeDataStyle(table);
              if (!noEvents) {
                fireTableModified(editor, table.dom, effect);
              }
            }
            return range.map(function (rng) {
              return {
                rng: rng,
                effect: effect
              };
            });
          }) : Optional.none();
        };
      };
      var deleteRow = execute(eraseRows, lastRowGuard, noop, lazyWire, structureModified);
      var deleteColumn = execute(eraseColumns, lastColumnGuard, noop, lazyWire, structureModified);
      var insertRowsBefore$1 = execute(insertRowsBefore, always, noop, lazyWire, structureModified);
      var insertRowsAfter$1 = execute(insertRowsAfter, always, noop, lazyWire, structureModified);
      var insertColumnsBefore$1 = execute(insertColumnsBefore, always, colMutationOp, lazyWire, structureModified);
      var insertColumnsAfter$1 = execute(insertColumnsAfter, always, colMutationOp, lazyWire, structureModified);
      var mergeCells$1 = execute(mergeCells, always, noop, lazyWire, structureModified);
      var unmergeCells$1 = execute(unmergeCells, always, noop, lazyWire, structureModified);
      var pasteColsBefore$1 = execute(pasteColsBefore, always, noop, lazyWire, structureModified);
      var pasteColsAfter$1 = execute(pasteColsAfter, always, noop, lazyWire, structureModified);
      var pasteRowsBefore$1 = execute(pasteRowsBefore, always, noop, lazyWire, structureModified);
      var pasteRowsAfter$1 = execute(pasteRowsAfter, always, noop, lazyWire, structureModified);
      var pasteCells$1 = execute(pasteCells, always, noop, lazyWire, styleAndStructureModified);
      var makeCellsHeader$1 = execute(makeCellsHeader, always, noop, lazyWire, structureModified);
      var unmakeCellsHeader$1 = execute(unmakeCellsHeader, always, noop, lazyWire, structureModified);
      var makeColumnsHeader$1 = execute(makeColumnsHeader, always, noop, lazyWire, structureModified);
      var unmakeColumnsHeader$1 = execute(unmakeColumnsHeader, always, noop, lazyWire, structureModified);
      var makeRowsHeader$1 = execute(makeRowsHeader, always, noop, lazyWire, structureModified);
      var makeRowsBody$1 = execute(makeRowsBody, always, noop, lazyWire, structureModified);
      var makeRowsFooter$1 = execute(makeRowsFooter, always, noop, lazyWire, structureModified);
      var getTableCellType = getCellsType;
      var getTableColType = getColumnsType;
      var getTableRowType = getRowsType;
      return {
        deleteRow: deleteRow,
        deleteColumn: deleteColumn,
        insertRowsBefore: insertRowsBefore$1,
        insertRowsAfter: insertRowsAfter$1,
        insertColumnsBefore: insertColumnsBefore$1,
        insertColumnsAfter: insertColumnsAfter$1,
        mergeCells: mergeCells$1,
        unmergeCells: unmergeCells$1,
        pasteColsBefore: pasteColsBefore$1,
        pasteColsAfter: pasteColsAfter$1,
        pasteRowsBefore: pasteRowsBefore$1,
        pasteRowsAfter: pasteRowsAfter$1,
        pasteCells: pasteCells$1,
        makeCellsHeader: makeCellsHeader$1,
        unmakeCellsHeader: unmakeCellsHeader$1,
        makeColumnsHeader: makeColumnsHeader$1,
        unmakeColumnsHeader: unmakeColumnsHeader$1,
        makeRowsHeader: makeRowsHeader$1,
        makeRowsBody: makeRowsBody$1,
        makeRowsFooter: makeRowsFooter$1,
        getTableRowType: getTableRowType,
        getTableCellType: getTableCellType,
        getTableColType: getTableColType
      };
    };

    var DefaultRenderOptions = {
      styles: {
        'border-collapse': 'collapse',
        'width': '100%'
      },
      attributes: { border: '1' },
      colGroups: false
    };
    var tableHeaderCell = function () {
      return SugarElement.fromTag('th');
    };
    var tableCell = function () {
      return SugarElement.fromTag('td');
    };
    var tableColumn = function () {
      return SugarElement.fromTag('col');
    };
    var createRow = function (columns, rowHeaders, columnHeaders, rowIndex) {
      var tr = SugarElement.fromTag('tr');
      for (var j = 0; j < columns; j++) {
        var td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
        if (j < columnHeaders) {
          set$2(td, 'scope', 'row');
        }
        if (rowIndex < rowHeaders) {
          set$2(td, 'scope', 'col');
        }
        append$1(td, SugarElement.fromTag('br'));
        append$1(tr, td);
      }
      return tr;
    };
    var createGroupRow = function (columns) {
      var columnGroup = SugarElement.fromTag('colgroup');
      range$1(columns, function () {
        return append$1(columnGroup, tableColumn());
      });
      return columnGroup;
    };
    var createRows = function (rows, columns, rowHeaders, columnHeaders) {
      return range$1(rows, function (r) {
        return createRow(columns, rowHeaders, columnHeaders, r);
      });
    };
    var render = function (rows, columns, rowHeaders, columnHeaders, headerType, renderOpts) {
      if (renderOpts === void 0) {
        renderOpts = DefaultRenderOptions;
      }
      var table = SugarElement.fromTag('table');
      var rowHeadersGoInThead = headerType !== 'cells';
      setAll(table, renderOpts.styles);
      setAll$1(table, renderOpts.attributes);
      if (renderOpts.colGroups) {
        append$1(table, createGroupRow(columns));
      }
      var actualRowHeaders = Math.min(rows, rowHeaders);
      if (rowHeadersGoInThead && rowHeaders > 0) {
        var thead = SugarElement.fromTag('thead');
        append$1(table, thead);
        var theadRowHeaders = headerType === 'sectionCells' ? actualRowHeaders : 0;
        var theadRows = createRows(rowHeaders, columns, theadRowHeaders, columnHeaders);
        append(thead, theadRows);
      }
      var tbody = SugarElement.fromTag('tbody');
      append$1(table, tbody);
      var numRows = rowHeadersGoInThead ? rows - actualRowHeaders : rows;
      var numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;
      var tbodyRows = createRows(numRows, columns, numRowHeaders, columnHeaders);
      append(tbody, tbodyRows);
      return table;
    };

    var get$2 = function (element) {
      return element.dom.innerHTML;
    };
    var getOuter = function (element) {
      var container = SugarElement.fromTag('div');
      var clone = SugarElement.fromDom(element.dom.cloneNode(true));
      append$1(container, clone);
      return get$2(container);
    };

    var placeCaretInCell = function (editor, cell) {
      editor.selection.select(cell.dom, true);
      editor.selection.collapse(true);
    };
    var selectFirstCellInTable = function (editor, tableElm) {
      descendant(tableElm, 'td,th').each(curry(placeCaretInCell, editor));
    };
    var fireEvents = function (editor, table) {
      each$2(descendants(table, 'tr'), function (row) {
        fireNewRow(editor, row.dom);
        each$2(descendants(row, 'th,td'), function (cell) {
          fireNewCell(editor, cell.dom);
        });
      });
    };
    var isPercentage = function (width) {
      return isString(width) && width.indexOf('%') !== -1;
    };
    var insert = function (editor, columns, rows, colHeaders, rowHeaders) {
      var defaultStyles = getDefaultStyles(editor);
      var options = {
        styles: defaultStyles,
        attributes: getDefaultAttributes(editor),
        colGroups: useColumnGroup(editor)
      };
      editor.undoManager.ignore(function () {
        var table = render(rows, columns, rowHeaders, colHeaders, getTableHeaderType(editor), options);
        set$2(table, 'data-mce-id', '__mce');
        var html = getOuter(table);
        editor.insertContent(html);
        editor.addVisual();
      });
      return descendant(getBody(editor), 'table[data-mce-id="__mce"]').map(function (table) {
        if (isPixelsForced(editor)) {
          enforcePixels(table);
        } else if (isResponsiveForced(editor)) {
          enforceNone(table);
        } else if (isPercentagesForced(editor) || isPercentage(defaultStyles.width)) {
          enforcePercentage(table);
        }
        removeDataStyle(table);
        remove$7(table, 'data-mce-id');
        fireEvents(editor, table);
        selectFirstCellInTable(editor, table);
        return table.dom;
      }).getOr(null);
    };
    var insertTableWithDataValidation = function (editor, rows, columns, options, errorMsg) {
      if (options === void 0) {
        options = {};
      }
      var checkInput = function (val) {
        return isNumber(val) && val > 0;
      };
      if (checkInput(rows) && checkInput(columns)) {
        var headerRows = options.headerRows || 0;
        var headerColumns = options.headerColumns || 0;
        return insert(editor, columns, rows, headerColumns, headerRows);
      } else {
        console.error(errorMsg);
        return null;
      }
    };

    var getClipboardElements = function (getClipboard) {
      return function () {
        return getClipboard().fold(function () {
          return [];
        }, function (elems) {
          return map$1(elems, function (e) {
            return e.dom;
          });
        });
      };
    };
    var setClipboardElements = function (setClipboard) {
      return function (elems) {
        var elmsOpt = elems.length > 0 ? Optional.some(fromDom(elems)) : Optional.none();
        setClipboard(elmsOpt);
      };
    };
    var insertTable = function (editor) {
      return function (columns, rows, options) {
        if (options === void 0) {
          options = {};
        }
        var table = insertTableWithDataValidation(editor, rows, columns, options, 'Invalid values for insertTable - rows and columns values are required to insert a table.');
        editor.undoManager.add();
        return table;
      };
    };
    var getApi = function (editor, clipboard, resizeHandler, selectionTargets) {
      return {
        insertTable: insertTable(editor),
        setClipboardRows: setClipboardElements(clipboard.setRows),
        getClipboardRows: getClipboardElements(clipboard.getRows),
        setClipboardCols: setClipboardElements(clipboard.setColumns),
        getClipboardCols: getClipboardElements(clipboard.getColumns),
        resizeHandler: resizeHandler,
        selectionTargets: selectionTargets
      };
    };

    var constrainSpan = function (element, property, value) {
      var currentColspan = getAttrValue(element, property, 1);
      if (value === 1 || currentColspan <= 1) {
        remove$7(element, property);
      } else {
        set$2(element, property, Math.min(value, currentColspan));
      }
    };
    var generateColGroup = function (house, minColRange, maxColRange) {
      if (Warehouse.hasColumns(house)) {
        var colsToCopy = filter$2(Warehouse.justColumns(house), function (col) {
          return col.column >= minColRange && col.column < maxColRange;
        });
        var copiedCols = map$1(colsToCopy, function (c) {
          var clonedCol = deep(c.element);
          constrainSpan(clonedCol, 'span', maxColRange - minColRange);
          return clonedCol;
        });
        var fakeColgroup = SugarElement.fromTag('colgroup');
        append(fakeColgroup, copiedCols);
        return [fakeColgroup];
      } else {
        return [];
      }
    };
    var generateRows = function (house, minColRange, maxColRange) {
      return map$1(house.all, function (row) {
        var cellsToCopy = filter$2(row.cells, function (cell) {
          return cell.column >= minColRange && cell.column < maxColRange;
        });
        var copiedCells = map$1(cellsToCopy, function (cell) {
          var clonedCell = deep(cell.element);
          constrainSpan(clonedCell, 'colspan', maxColRange - minColRange);
          return clonedCell;
        });
        var fakeTR = SugarElement.fromTag('tr');
        append(fakeTR, copiedCells);
        return fakeTR;
      });
    };
    var copyCols = function (table, target) {
      var house = Warehouse.fromTable(table);
      var details = onUnlockedCells(house, target);
      return details.map(function (selectedCells) {
        var lastSelectedCell = selectedCells[selectedCells.length - 1];
        var minColRange = selectedCells[0].column;
        var maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
        var fakeColGroups = generateColGroup(house, minColRange, maxColRange);
        var fakeRows = generateRows(house, minColRange, maxColRange);
        return __spreadArray(__spreadArray([], fakeColGroups, true), fakeRows, true);
      });
    };

    var copyRows = function (table, target, generators) {
      var warehouse = Warehouse.fromTable(table);
      var details = onCells(warehouse, target);
      return details.bind(function (selectedCells) {
        var grid = toGrid(warehouse, generators, false);
        var rows = extractGridDetails(grid).rows;
        var slicedGrid = rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);
        var filteredGrid = bind$2(slicedGrid, function (row) {
          var newCells = filter$2(row.cells, function (cell) {
            return !cell.isLocked;
          });
          return newCells.length > 0 ? [__assign(__assign({}, row), { cells: newCells })] : [];
        });
        var slicedDetails = toDetailList(filteredGrid);
        return someIf(slicedDetails.length > 0, slicedDetails);
      }).map(function (slicedDetails) {
        return copy(slicedDetails);
      });
    };

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var getTDTHOverallStyle = function (dom, elm, name) {
      var cells = dom.select('td,th', elm);
      var firstChildStyle;
      var checkChildren = function (firstChildStyle, elms) {
        for (var i = 0; i < elms.length; i++) {
          var currentStyle = dom.getStyle(elms[i], name);
          if (typeof firstChildStyle === 'undefined') {
            firstChildStyle = currentStyle;
          }
          if (firstChildStyle !== currentStyle) {
            return '';
          }
        }
        return firstChildStyle;
      };
      return checkChildren(firstChildStyle, cells);
    };
    var applyAlign = function (editor, elm, name) {
      if (name) {
        editor.formatter.apply('align' + name, {}, elm);
      }
    };
    var applyVAlign = function (editor, elm, name) {
      if (name) {
        editor.formatter.apply('valign' + name, {}, elm);
      }
    };
    var unApplyAlign = function (editor, elm) {
      global$2.each('left center right'.split(' '), function (name) {
        editor.formatter.remove('align' + name, {}, elm);
      });
    };
    var unApplyVAlign = function (editor, elm) {
      global$2.each('top middle bottom'.split(' '), function (name) {
        editor.formatter.remove('valign' + name, {}, elm);
      });
    };

    var verticalAlignValues = [
      {
        text: 'None',
        value: ''
      },
      {
        text: 'Top',
        value: 'top'
      },
      {
        text: 'Middle',
        value: 'middle'
      },
      {
        text: 'Bottom',
        value: 'bottom'
      }
    ];

    var hexColour = function (value) {
      return { value: value };
    };
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    var longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var isHexString = function (hex) {
      return shorthandRegex.test(hex) || longformRegex.test(hex);
    };
    var normalizeHex = function (hex) {
      return removeLeading(hex, '#').toUpperCase();
    };
    var fromString$1 = function (hex) {
      return isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
    };
    var toHex = function (component) {
      var hex = component.toString(16);
      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    var fromRgba = function (rgbaColour) {
      var value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
      return hexColour(value);
    };

    var rgbRegex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
    var rgbaRegex = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/;
    var rgbaColour = function (red, green, blue, alpha) {
      return {
        red: red,
        green: green,
        blue: blue,
        alpha: alpha
      };
    };
    var fromStringValues = function (red, green, blue, alpha) {
      var r = parseInt(red, 10);
      var g = parseInt(green, 10);
      var b = parseInt(blue, 10);
      var a = parseFloat(alpha);
      return rgbaColour(r, g, b, a);
    };
    var fromString = function (rgbaString) {
      if (rgbaString === 'transparent') {
        return Optional.some(rgbaColour(0, 0, 0, 0));
      }
      var rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
      }
      var rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Optional.none();
    };

    var anyToHex = function (color) {
      return fromString$1(color).orThunk(function () {
        return fromString(color).map(fromRgba);
      }).getOrThunk(function () {
        var canvas = document.createElement('canvas');
        canvas.height = 1;
        canvas.width = 1;
        var canvasContext = canvas.getContext('2d');
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        canvasContext.fillStyle = '#FFFFFF';
        canvasContext.fillStyle = color;
        canvasContext.fillRect(0, 0, 1, 1);
        var rgba = canvasContext.getImageData(0, 0, 1, 1).data;
        var r = rgba[0];
        var g = rgba[1];
        var b = rgba[2];
        var a = rgba[3];
        return fromRgba(rgbaColour(r, g, b, a));
      });
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var singleton = function (doRevoke) {
      var subject = Cell(Optional.none());
      var revoke = function () {
        return subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Optional.none());
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      var get = function () {
        return subject.get();
      };
      var set = function (s) {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear,
        isSet: isSet,
        get: get,
        set: set
      };
    };
    var unbindable = function () {
      return singleton(function (s) {
        return s.unbind();
      });
    };
    var value = function () {
      var subject = singleton(noop);
      var on = function (f) {
        return subject.get().each(f);
      };
      return __assign(__assign({}, subject), { on: on });
    };

    var onSetupToggle = function (editor, selections, formatName, formatValue) {
      return function (api) {
        var boundCallback = unbindable();
        var isNone = isEmpty$1(formatValue);
        var init = function () {
          var selectedCells = getCellsFromSelection(selections);
          var checkNode = function (cell) {
            return editor.formatter.match(formatName, { value: formatValue }, cell.dom, isNone);
          };
          if (isNone) {
            api.setActive(!exists(selectedCells, checkNode));
            boundCallback.set(editor.formatter.formatChanged(formatName, function (match) {
              return api.setActive(!match);
            }, true));
          } else {
            api.setActive(forall(selectedCells, checkNode));
            boundCallback.set(editor.formatter.formatChanged(formatName, api.setActive, false, { value: formatValue }));
          }
        };
        editor.initialized ? init() : editor.on('init', init);
        return boundCallback.clear;
      };
    };
    var isListGroup = function (item) {
      return hasNonNullableKey(item, 'menu');
    };
    var buildListItems = function (items) {
      return map$1(items, function (item) {
        var text = item.text || item.title;
        if (isListGroup(item)) {
          return {
            text: text,
            items: buildListItems(item.menu)
          };
        } else {
          return {
            text: text,
            value: item.value
          };
        }
      });
    };
    var buildMenuItems = function (editor, selections, items, format, onAction) {
      return map$1(items, function (item) {
        var text = item.text || item.title;
        if (isListGroup(item)) {
          return {
            type: 'nestedmenuitem',
            text: text,
            getSubmenuItems: function () {
              return buildMenuItems(editor, selections, item.menu, format, onAction);
            }
          };
        } else {
          return {
            text: text,
            type: 'togglemenuitem',
            onAction: function () {
              return onAction(item.value);
            },
            onSetup: onSetupToggle(editor, selections, format, item.value)
          };
        }
      });
    };
    var applyTableCellStyle = function (editor, style) {
      return function (value) {
        var _a;
        editor.execCommand('mceTableApplyCellStyle', false, (_a = {}, _a[style] = value, _a));
      };
    };
    var filterNoneItem = function (list) {
      return bind$2(list, function (item) {
        if (isListGroup(item)) {
          return [__assign(__assign({}, item), { menu: filterNoneItem(item.menu) })];
        } else {
          return isNotEmpty(item.value) ? [item] : [];
        }
      });
    };
    var generateMenuItemsCallback = function (editor, selections, items, format, onAction) {
      return function (callback) {
        return callback(buildMenuItems(editor, selections, items, format, onAction));
      };
    };
    var buildColorMenu = function (editor, colorList, style) {
      var colorMap = map$1(colorList, function (entry) {
        return {
          text: entry.title,
          value: '#' + anyToHex(entry.value).value,
          type: 'choiceitem'
        };
      });
      return [{
          type: 'fancymenuitem',
          fancytype: 'colorswatch',
          initData: {
            colors: colorMap.length > 0 ? colorMap : undefined,
            allowCustomColors: false
          },
          onAction: function (data) {
            var _a;
            var value = data.value === 'remove' ? '' : data.value;
            editor.execCommand('mceTableApplyCellStyle', false, (_a = {}, _a[style] = value, _a));
          }
        }];
    };
    var changeRowHeader = function (editor) {
      return function () {
        var currentType = editor.queryCommandValue('mceTableRowType');
        var newType = currentType === 'header' ? 'body' : 'header';
        editor.execCommand('mceTableRowType', false, { type: newType });
      };
    };
    var changeColumnHeader = function (editor) {
      return function () {
        var currentType = editor.queryCommandValue('mceTableColType');
        var newType = currentType === 'th' ? 'td' : 'th';
        editor.execCommand('mceTableColType', false, { type: newType });
      };
    };

    var getClassList$1 = function (editor) {
      var classes = buildListItems(getCellClassList(editor));
      if (classes.length > 0) {
        return Optional.some({
          name: 'class',
          type: 'listbox',
          label: 'Class',
          items: classes
        });
      }
      return Optional.none();
    };
    var children = [
      {
        name: 'width',
        type: 'input',
        label: 'Width'
      },
      {
        name: 'height',
        type: 'input',
        label: 'Height'
      },
      {
        name: 'celltype',
        type: 'listbox',
        label: 'Cell type',
        items: [
          {
            text: 'Cell',
            value: 'td'
          },
          {
            text: 'Header cell',
            value: 'th'
          }
        ]
      },
      {
        name: 'scope',
        type: 'listbox',
        label: 'Scope',
        items: [
          {
            text: 'None',
            value: ''
          },
          {
            text: 'Row',
            value: 'row'
          },
          {
            text: 'Column',
            value: 'col'
          },
          {
            text: 'Row group',
            value: 'rowgroup'
          },
          {
            text: 'Column group',
            value: 'colgroup'
          }
        ]
      },
      {
        name: 'halign',
        type: 'listbox',
        label: 'Horizontal align',
        items: [
          {
            text: 'None',
            value: ''
          },
          {
            text: 'Left',
            value: 'left'
          },
          {
            text: 'Center',
            value: 'center'
          },
          {
            text: 'Right',
            value: 'right'
          }
        ]
      },
      {
        name: 'valign',
        type: 'listbox',
        label: 'Vertical align',
        items: verticalAlignValues
      }
    ];
    var getItems$2 = function (editor) {
      return children.concat(getClassList$1(editor).toArray());
    };

    var getAdvancedTab = function (editor, dialogName) {
      var emptyBorderStyle = [{
          text: 'Select...',
          value: ''
        }];
      var advTabItems = [
        {
          name: 'borderstyle',
          type: 'listbox',
          label: 'Border style',
          items: emptyBorderStyle.concat(buildListItems(getTableBorderStyles(editor)))
        },
        {
          name: 'bordercolor',
          type: 'colorinput',
          label: 'Border color'
        },
        {
          name: 'backgroundcolor',
          type: 'colorinput',
          label: 'Background color'
        }
      ];
      var borderWidth = {
        name: 'borderwidth',
        type: 'input',
        label: 'Border width'
      };
      var items = dialogName === 'cell' ? [borderWidth].concat(advTabItems) : advTabItems;
      return {
        title: 'Advanced',
        name: 'advanced',
        items: items
      };
    };

    var modifiers = function (testTruthy) {
      return function (editor, node) {
        var dom = editor.dom;
        var setAttrib = function (attr, value) {
          if (!testTruthy || value) {
            dom.setAttrib(node, attr, value);
          }
        };
        var setStyle = function (prop, value) {
          if (!testTruthy || value) {
            dom.setStyle(node, prop, value);
          }
        };
        var setFormat = function (formatName, value) {
          if (!testTruthy || value) {
            if (value === '') {
              editor.formatter.remove(formatName, { value: null }, node, true);
            } else {
              editor.formatter.apply(formatName, { value: value }, node);
            }
          }
        };
        return {
          setAttrib: setAttrib,
          setStyle: setStyle,
          setFormat: setFormat
        };
      };
    };
    var DomModifier = {
      normal: modifiers(false),
      ifTruthy: modifiers(true)
    };

    var rgbToHex = function (dom) {
      return function (value) {
        return startsWith(value, 'rgb') ? dom.toHex(value) : value;
      };
    };
    var extractAdvancedStyles = function (dom, elm) {
      var element = SugarElement.fromDom(elm);
      return {
        borderwidth: getRaw$2(element, 'border-width').getOr(''),
        borderstyle: getRaw$2(element, 'border-style').getOr(''),
        bordercolor: getRaw$2(element, 'border-color').map(rgbToHex(dom)).getOr(''),
        backgroundcolor: getRaw$2(element, 'background-color').map(rgbToHex(dom)).getOr('')
      };
    };
    var getSharedValues = function (data) {
      var baseData = data[0];
      var comparisonData = data.slice(1);
      each$2(comparisonData, function (items) {
        each$2(keys(baseData), function (key) {
          each$1(items, function (itemValue, itemKey) {
            var comparisonValue = baseData[key];
            if (comparisonValue !== '' && key === itemKey) {
              if (comparisonValue !== itemValue) {
                baseData[key] = '';
              }
            }
          });
        });
      });
      return baseData;
    };
    var getAlignment = function (formats, formatName, editor, elm) {
      return find$1(formats, function (name) {
        return !isUndefined(editor.formatter.matchNode(elm, formatName + name));
      }).getOr('');
    };
    var getHAlignment = curry(getAlignment, [
      'left',
      'center',
      'right'
    ], 'align');
    var getVAlignment = curry(getAlignment, [
      'top',
      'middle',
      'bottom'
    ], 'valign');
    var extractDataFromSettings = function (editor, hasAdvTableTab) {
      var style = getDefaultStyles(editor);
      var attrs = getDefaultAttributes(editor);
      var extractAdvancedStyleData = function (dom) {
        return {
          borderstyle: get$c(style, 'border-style').getOr(''),
          bordercolor: rgbToHex(dom)(get$c(style, 'border-color').getOr('')),
          backgroundcolor: rgbToHex(dom)(get$c(style, 'background-color').getOr(''))
        };
      };
      var defaultData = {
        height: '',
        width: '100%',
        cellspacing: '',
        cellpadding: '',
        caption: false,
        class: '',
        align: '',
        border: ''
      };
      var getBorder = function () {
        var borderWidth = style['border-width'];
        if (shouldStyleWithCss(editor) && borderWidth) {
          return { border: borderWidth };
        }
        return get$c(attrs, 'border').fold(function () {
          return {};
        }, function (border) {
          return { border: border };
        });
      };
      var advStyle = hasAdvTableTab ? extractAdvancedStyleData(editor.dom) : {};
      var getCellPaddingCellSpacing = function () {
        var spacing = get$c(style, 'border-spacing').or(get$c(attrs, 'cellspacing')).fold(function () {
          return {};
        }, function (cellspacing) {
          return { cellspacing: cellspacing };
        });
        var padding = get$c(style, 'border-padding').or(get$c(attrs, 'cellpadding')).fold(function () {
          return {};
        }, function (cellpadding) {
          return { cellpadding: cellpadding };
        });
        return __assign(__assign({}, spacing), padding);
      };
      var data = __assign(__assign(__assign(__assign(__assign(__assign({}, defaultData), style), attrs), advStyle), getBorder()), getCellPaddingCellSpacing());
      return data;
    };
    var getRowType = function (elm) {
      return table(SugarElement.fromDom(elm)).map(function (table) {
        var target = { selection: fromDom(elm.cells) };
        return getRowsType(table, target);
      }).getOr('');
    };
    var extractDataFromTableElement = function (editor, elm, hasAdvTableTab) {
      var getBorder = function (dom, elm) {
        var optBorderWidth = getRaw$2(SugarElement.fromDom(elm), 'border-width');
        if (shouldStyleWithCss(editor) && optBorderWidth.isSome()) {
          return optBorderWidth.getOr('');
        }
        return dom.getAttrib(elm, 'border') || getTDTHOverallStyle(editor.dom, elm, 'border-width') || getTDTHOverallStyle(editor.dom, elm, 'border');
      };
      var dom = editor.dom;
      var cellspacing = shouldStyleWithCss(editor) ? dom.getStyle(elm, 'border-spacing') || dom.getAttrib(elm, 'cellspacing') : dom.getAttrib(elm, 'cellspacing') || dom.getStyle(elm, 'border-spacing');
      var cellpadding = shouldStyleWithCss(editor) ? getTDTHOverallStyle(dom, elm, 'padding') || dom.getAttrib(elm, 'cellpadding') : dom.getAttrib(elm, 'cellpadding') || getTDTHOverallStyle(dom, elm, 'padding');
      return __assign({
        width: dom.getStyle(elm, 'width') || dom.getAttrib(elm, 'width'),
        height: dom.getStyle(elm, 'height') || dom.getAttrib(elm, 'height'),
        cellspacing: cellspacing,
        cellpadding: cellpadding,
        border: getBorder(dom, elm),
        caption: !!dom.select('caption', elm)[0],
        class: dom.getAttrib(elm, 'class', ''),
        align: getHAlignment(editor, elm)
      }, hasAdvTableTab ? extractAdvancedStyles(dom, elm) : {});
    };
    var extractDataFromRowElement = function (editor, elm, hasAdvancedRowTab) {
      var dom = editor.dom;
      return __assign({
        height: dom.getStyle(elm, 'height') || dom.getAttrib(elm, 'height'),
        class: dom.getAttrib(elm, 'class', ''),
        type: getRowType(elm),
        align: getHAlignment(editor, elm)
      }, hasAdvancedRowTab ? extractAdvancedStyles(dom, elm) : {});
    };
    var extractDataFromCellElement = function (editor, cell, hasAdvancedCellTab, column) {
      var dom = editor.dom;
      var colElm = column.getOr(cell);
      var getStyle = function (element, style) {
        return dom.getStyle(element, style) || dom.getAttrib(element, style);
      };
      return __assign({
        width: getStyle(colElm, 'width'),
        height: getStyle(cell, 'height'),
        scope: dom.getAttrib(cell, 'scope'),
        celltype: getNodeName(cell),
        class: dom.getAttrib(cell, 'class', ''),
        halign: getHAlignment(editor, cell),
        valign: getVAlignment(editor, cell)
      }, hasAdvancedCellTab ? extractAdvancedStyles(dom, cell) : {});
    };

    var getSelectedCells = function (table, cells) {
      var warehouse = Warehouse.fromTable(table);
      var allCells = Warehouse.justCells(warehouse);
      var filtered = filter$2(allCells, function (cellA) {
        return exists(cells, function (cellB) {
          return eq$1(cellA.element, cellB);
        });
      });
      return map$1(filtered, function (cell) {
        return {
          element: cell.element.dom,
          column: Warehouse.getColumnAt(warehouse, cell.column).map(function (col) {
            return col.element.dom;
          })
        };
      });
    };
    var updateSimpleProps$1 = function (modifier, colModifier, data) {
      modifier.setAttrib('scope', data.scope);
      modifier.setAttrib('class', data.class);
      modifier.setStyle('height', addPxSuffix(data.height));
      colModifier.setStyle('width', addPxSuffix(data.width));
    };
    var updateAdvancedProps$1 = function (modifier, data) {
      modifier.setFormat('tablecellbackgroundcolor', data.backgroundcolor);
      modifier.setFormat('tablecellbordercolor', data.bordercolor);
      modifier.setFormat('tablecellborderstyle', data.borderstyle);
      modifier.setFormat('tablecellborderwidth', addPxSuffix(data.borderwidth));
    };
    var applyStyleData$1 = function (editor, cells, data) {
      var isSingleCell = cells.length === 1;
      each$2(cells, function (item) {
        var cellElm = item.element;
        var modifier = isSingleCell ? DomModifier.normal(editor, cellElm) : DomModifier.ifTruthy(editor, cellElm);
        var colModifier = item.column.map(function (col) {
          return isSingleCell ? DomModifier.normal(editor, col) : DomModifier.ifTruthy(editor, col);
        }).getOr(modifier);
        updateSimpleProps$1(modifier, colModifier, data);
        if (hasAdvancedCellTab(editor)) {
          updateAdvancedProps$1(modifier, data);
        }
        if (isSingleCell) {
          unApplyAlign(editor, cellElm);
          unApplyVAlign(editor, cellElm);
        }
        if (data.halign) {
          applyAlign(editor, cellElm, data.halign);
        }
        if (data.valign) {
          applyVAlign(editor, cellElm, data.valign);
        }
      });
    };
    var applyStructureData$1 = function (editor, data) {
      editor.execCommand('mceTableCellType', false, {
        type: data.celltype,
        no_events: true
      });
    };
    var applyCellData = function (editor, cells, oldData, data) {
      var modifiedData = filter$1(data, function (value, key) {
        return oldData[key] !== value;
      });
      if (size(modifiedData) > 0 && cells.length >= 1) {
        table(cells[0]).each(function (table) {
          var selectedCells = getSelectedCells(table, cells);
          var styleModified = size(filter$1(modifiedData, function (_value, key) {
            return key !== 'scope' && key !== 'celltype';
          })) > 0;
          var structureModified = has$1(modifiedData, 'celltype');
          if (styleModified || has$1(modifiedData, 'scope')) {
            applyStyleData$1(editor, selectedCells, data);
          }
          if (structureModified) {
            applyStructureData$1(editor, data);
          }
          fireTableModified(editor, table.dom, {
            structure: structureModified,
            style: styleModified
          });
        });
      }
    };
    var onSubmitCellForm = function (editor, cells, oldData, api) {
      var data = api.getData();
      api.close();
      editor.undoManager.transact(function () {
        applyCellData(editor, cells, oldData, data);
        editor.focus();
      });
    };
    var getData = function (editor, cells) {
      var cellsData = table(cells[0]).map(function (table) {
        return map$1(getSelectedCells(table, cells), function (item) {
          return extractDataFromCellElement(editor, item.element, hasAdvancedCellTab(editor), item.column);
        });
      });
      return getSharedValues(cellsData.getOrDie());
    };
    var open$2 = function (editor, selections) {
      var cells = getCellsFromSelection(selections);
      if (cells.length === 0) {
        return;
      }
      var data = getData(editor, cells);
      var dialogTabPanel = {
        type: 'tabpanel',
        tabs: [
          {
            title: 'General',
            name: 'general',
            items: getItems$2(editor)
          },
          getAdvancedTab(editor, 'cell')
        ]
      };
      var dialogPanel = {
        type: 'panel',
        items: [{
            type: 'grid',
            columns: 2,
            items: getItems$2(editor)
          }]
      };
      editor.windowManager.open({
        title: 'Cell Properties',
        size: 'normal',
        body: hasAdvancedCellTab(editor) ? dialogTabPanel : dialogPanel,
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: data,
        onSubmit: curry(onSubmitCellForm, editor, cells, data)
      });
    };

    var getClassList = function (editor) {
      var classes = buildListItems(getRowClassList(editor));
      if (classes.length > 0) {
        return Optional.some({
          name: 'class',
          type: 'listbox',
          label: 'Class',
          items: classes
        });
      }
      return Optional.none();
    };
    var formChildren = [
      {
        type: 'listbox',
        name: 'type',
        label: 'Row type',
        items: [
          {
            text: 'Header',
            value: 'header'
          },
          {
            text: 'Body',
            value: 'body'
          },
          {
            text: 'Footer',
            value: 'footer'
          }
        ]
      },
      {
        type: 'listbox',
        name: 'align',
        label: 'Alignment',
        items: [
          {
            text: 'None',
            value: ''
          },
          {
            text: 'Left',
            value: 'left'
          },
          {
            text: 'Center',
            value: 'center'
          },
          {
            text: 'Right',
            value: 'right'
          }
        ]
      },
      {
        label: 'Height',
        name: 'height',
        type: 'input'
      }
    ];
    var getItems$1 = function (editor) {
      return formChildren.concat(getClassList(editor).toArray());
    };

    var updateSimpleProps = function (modifier, data) {
      modifier.setAttrib('class', data.class);
      modifier.setStyle('height', addPxSuffix(data.height));
    };
    var updateAdvancedProps = function (modifier, data) {
      modifier.setStyle('background-color', data.backgroundcolor);
      modifier.setStyle('border-color', data.bordercolor);
      modifier.setStyle('border-style', data.borderstyle);
    };
    var applyStyleData = function (editor, rows, data, oldData) {
      var isSingleRow = rows.length === 1;
      each$2(rows, function (rowElm) {
        var modifier = isSingleRow ? DomModifier.normal(editor, rowElm) : DomModifier.ifTruthy(editor, rowElm);
        updateSimpleProps(modifier, data);
        if (hasAdvancedRowTab(editor)) {
          updateAdvancedProps(modifier, data);
        }
        if (data.align !== oldData.align) {
          unApplyAlign(editor, rowElm);
          applyAlign(editor, rowElm, data.align);
        }
      });
    };
    var applyStructureData = function (editor, data) {
      editor.execCommand('mceTableRowType', false, {
        type: data.type,
        no_events: true
      });
    };
    var applyRowData = function (editor, rows, oldData, data) {
      var modifiedData = filter$1(data, function (value, key) {
        return oldData[key] !== value;
      });
      if (size(modifiedData) > 0) {
        var typeModified_1 = has$1(modifiedData, 'type');
        var styleModified_1 = typeModified_1 ? size(modifiedData) > 1 : true;
        if (styleModified_1) {
          applyStyleData(editor, rows, data, oldData);
        }
        if (typeModified_1) {
          applyStructureData(editor, data);
        }
        table(SugarElement.fromDom(rows[0])).each(function (table) {
          return fireTableModified(editor, table.dom, {
            structure: typeModified_1,
            style: styleModified_1
          });
        });
      }
    };
    var onSubmitRowForm = function (editor, rows, oldData, api) {
      var data = api.getData();
      api.close();
      editor.undoManager.transact(function () {
        applyRowData(editor, rows, oldData, data);
        editor.focus();
      });
    };
    var open$1 = function (editor) {
      var rows = getRowsFromSelection(getSelectionStart(editor), ephemera.selected);
      if (rows.length === 0) {
        return;
      }
      var rowsData = map$1(rows, function (rowElm) {
        return extractDataFromRowElement(editor, rowElm.dom, hasAdvancedRowTab(editor));
      });
      var data = getSharedValues(rowsData);
      var dialogTabPanel = {
        type: 'tabpanel',
        tabs: [
          {
            title: 'General',
            name: 'general',
            items: getItems$1(editor)
          },
          getAdvancedTab(editor, 'row')
        ]
      };
      var dialogPanel = {
        type: 'panel',
        items: [{
            type: 'grid',
            columns: 2,
            items: getItems$1(editor)
          }]
      };
      editor.windowManager.open({
        title: 'Row Properties',
        size: 'normal',
        body: hasAdvancedRowTab(editor) ? dialogTabPanel : dialogPanel,
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: data,
        onSubmit: curry(onSubmitRowForm, editor, map$1(rows, function (r) {
          return r.dom;
        }), data)
      });
    };

    var getItems = function (editor, classes, insertNewTable) {
      var rowColCountItems = !insertNewTable ? [] : [
        {
          type: 'input',
          name: 'cols',
          label: 'Cols',
          inputMode: 'numeric'
        },
        {
          type: 'input',
          name: 'rows',
          label: 'Rows',
          inputMode: 'numeric'
        }
      ];
      var alwaysItems = [
        {
          type: 'input',
          name: 'width',
          label: 'Width'
        },
        {
          type: 'input',
          name: 'height',
          label: 'Height'
        }
      ];
      var appearanceItems = hasAppearanceOptions(editor) ? [
        {
          type: 'input',
          name: 'cellspacing',
          label: 'Cell spacing',
          inputMode: 'numeric'
        },
        {
          type: 'input',
          name: 'cellpadding',
          label: 'Cell padding',
          inputMode: 'numeric'
        },
        {
          type: 'input',
          name: 'border',
          label: 'Border width'
        },
        {
          type: 'label',
          label: 'Caption',
          items: [{
              type: 'checkbox',
              name: 'caption',
              label: 'Show caption'
            }]
        }
      ] : [];
      var alignmentItem = [{
          type: 'listbox',
          name: 'align',
          label: 'Alignment',
          items: [
            {
              text: 'None',
              value: ''
            },
            {
              text: 'Left',
              value: 'left'
            },
            {
              text: 'Center',
              value: 'center'
            },
            {
              text: 'Right',
              value: 'right'
            }
          ]
        }];
      var classListItem = classes.length > 0 ? [{
          type: 'listbox',
          name: 'class',
          label: 'Class',
          items: classes
        }] : [];
      return rowColCountItems.concat(alwaysItems).concat(appearanceItems).concat(alignmentItem).concat(classListItem);
    };

    var styleTDTH = function (dom, elm, name, value) {
      if (elm.tagName === 'TD' || elm.tagName === 'TH') {
        if (isString(name)) {
          dom.setStyle(elm, name, value);
        } else {
          dom.setStyle(elm, name);
        }
      } else {
        if (elm.children) {
          for (var i = 0; i < elm.children.length; i++) {
            styleTDTH(dom, elm.children[i], name, value);
          }
        }
      }
    };
    var applyDataToElement = function (editor, tableElm, data) {
      var dom = editor.dom;
      var attrs = {};
      var styles = {};
      attrs.class = data.class;
      styles.height = addPxSuffix(data.height);
      if (dom.getAttrib(tableElm, 'width') && !shouldStyleWithCss(editor)) {
        attrs.width = removePxSuffix(data.width);
      } else {
        styles.width = addPxSuffix(data.width);
      }
      if (shouldStyleWithCss(editor)) {
        styles['border-width'] = addPxSuffix(data.border);
        styles['border-spacing'] = addPxSuffix(data.cellspacing);
      } else {
        attrs.border = data.border;
        attrs.cellpadding = data.cellpadding;
        attrs.cellspacing = data.cellspacing;
      }
      if (shouldStyleWithCss(editor) && tableElm.children) {
        for (var i = 0; i < tableElm.children.length; i++) {
          styleTDTH(dom, tableElm.children[i], {
            'border-width': addPxSuffix(data.border),
            'padding': addPxSuffix(data.cellpadding)
          });
          if (hasAdvancedTableTab(editor)) {
            styleTDTH(dom, tableElm.children[i], { 'border-color': data.bordercolor });
          }
        }
      }
      if (hasAdvancedTableTab(editor)) {
        styles['background-color'] = data.backgroundcolor;
        styles['border-color'] = data.bordercolor;
        styles['border-style'] = data.borderstyle;
      }
      attrs.style = dom.serializeStyle(__assign(__assign({}, getDefaultStyles(editor)), styles));
      dom.setAttribs(tableElm, __assign(__assign({}, getDefaultAttributes(editor)), attrs));
    };
    var onSubmitTableForm = function (editor, tableElm, oldData, api) {
      var dom = editor.dom;
      var data = api.getData();
      var modifiedData = filter$1(data, function (value, key) {
        return oldData[key] !== value;
      });
      api.close();
      if (data.class === '') {
        delete data.class;
      }
      editor.undoManager.transact(function () {
        if (!tableElm) {
          var cols = parseInt(data.cols, 10) || 1;
          var rows = parseInt(data.rows, 10) || 1;
          tableElm = insert(editor, cols, rows, 0, 0);
        }
        if (size(modifiedData) > 0) {
          applyDataToElement(editor, tableElm, data);
          var captionElm = dom.select('caption', tableElm)[0];
          if (captionElm && !data.caption || !captionElm && data.caption) {
            editor.execCommand('mceTableToggleCaption');
          }
          if (data.align === '') {
            unApplyAlign(editor, tableElm);
          } else {
            applyAlign(editor, tableElm, data.align);
          }
        }
        editor.focus();
        editor.addVisual();
        if (size(modifiedData) > 0) {
          var captionModified = has$1(modifiedData, 'caption');
          var styleModified = captionModified ? size(modifiedData) > 1 : true;
          fireTableModified(editor, tableElm, {
            structure: captionModified,
            style: styleModified
          });
        }
      });
    };
    var open = function (editor, insertNewTable) {
      var dom = editor.dom;
      var tableElm;
      var data = extractDataFromSettings(editor, hasAdvancedTableTab(editor));
      if (insertNewTable === false) {
        tableElm = dom.getParent(editor.selection.getStart(), 'table', editor.getBody());
        if (tableElm) {
          data = extractDataFromTableElement(editor, tableElm, hasAdvancedTableTab(editor));
        } else {
          if (hasAdvancedTableTab(editor)) {
            data.borderstyle = '';
            data.bordercolor = '';
            data.backgroundcolor = '';
          }
        }
      } else {
        data.cols = '1';
        data.rows = '1';
        if (hasAdvancedTableTab(editor)) {
          data.borderstyle = '';
          data.bordercolor = '';
          data.backgroundcolor = '';
        }
      }
      var classes = buildListItems(getTableClassList(editor));
      if (classes.length > 0) {
        if (data.class) {
          data.class = data.class.replace(/\s*mce\-item\-table\s*/g, '');
        }
      }
      var generalPanel = {
        type: 'grid',
        columns: 2,
        items: getItems(editor, classes, insertNewTable)
      };
      var nonAdvancedForm = function () {
        return {
          type: 'panel',
          items: [generalPanel]
        };
      };
      var advancedForm = function () {
        return {
          type: 'tabpanel',
          tabs: [
            {
              title: 'General',
              name: 'general',
              items: [generalPanel]
            },
            getAdvancedTab(editor, 'table')
          ]
        };
      };
      var dialogBody = hasAdvancedTableTab(editor) ? advancedForm() : nonAdvancedForm();
      editor.windowManager.open({
        title: 'Table Properties',
        size: 'normal',
        body: dialogBody,
        onSubmit: curry(onSubmitTableForm, editor, tableElm, data),
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: data
      });
    };

    var getSelectionStartCellOrCaption = function (editor) {
      return getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor));
    };
    var getSelectionStartCell = function (editor) {
      return getSelectionCell(getSelectionStart(editor), getIsRoot(editor));
    };
    var registerCommands = function (editor, actions, cellSelection, selections, clipboard) {
      var isRoot = getIsRoot(editor);
      var eraseTable = function () {
        return getSelectionStartCellOrCaption(editor).each(function (cellOrCaption) {
          table(cellOrCaption, isRoot).filter(not(isRoot)).each(function (table) {
            var cursor = SugarElement.fromText('');
            after$5(table, cursor);
            remove$5(table);
            if (editor.dom.isEmpty(editor.getBody())) {
              editor.setContent('');
              editor.selection.setCursorLocation();
            } else {
              var rng = editor.dom.createRng();
              rng.setStart(cursor.dom, 0);
              rng.setEnd(cursor.dom, 0);
              editor.selection.setRng(rng);
              editor.nodeChanged();
            }
          });
        });
      };
      var setSizingMode = function (sizing) {
        return getSelectionStartCellOrCaption(editor).each(function (cellOrCaption) {
          var isForcedSizing = isResponsiveForced(editor) || isPixelsForced(editor) || isPercentagesForced(editor);
          if (!isForcedSizing) {
            table(cellOrCaption, isRoot).each(function (table) {
              if (sizing === 'relative' && !isPercentSizing(table)) {
                enforcePercentage(table);
              } else if (sizing === 'fixed' && !isPixelSizing(table)) {
                enforcePixels(table);
              } else if (sizing === 'responsive' && !isNoneSizing(table)) {
                enforceNone(table);
              }
              removeDataStyle(table);
              fireTableModified(editor, table.dom, structureModified);
            });
          }
        });
      };
      var getTableFromCell = function (cell) {
        return table(cell, isRoot);
      };
      var performActionOnSelection = function (action) {
        return getSelectionStartCell(editor).bind(function (cell) {
          return getTableFromCell(cell).map(function (table) {
            return action(table, cell);
          });
        });
      };
      var toggleTableClass = function (_ui, clazz) {
        performActionOnSelection(function (table) {
          editor.formatter.toggle('tableclass', { value: clazz }, table.dom);
          fireTableModified(editor, table.dom, styleModified);
        });
      };
      var toggleTableCellClass = function (_ui, clazz) {
        performActionOnSelection(function (table) {
          var selectedCells = getCellsFromSelection(selections);
          var allHaveClass = forall(selectedCells, function (cell) {
            return editor.formatter.match('tablecellclass', { value: clazz }, cell.dom);
          });
          var formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;
          each$2(selectedCells, function (cell) {
            return formatterAction('tablecellclass', { value: clazz }, cell.dom);
          });
          fireTableModified(editor, table.dom, styleModified);
        });
      };
      var toggleCaption = function () {
        getSelectionStartCellOrCaption(editor).each(function (cellOrCaption) {
          table(cellOrCaption, isRoot).each(function (table) {
            child$1(table, 'caption').fold(function () {
              var caption = SugarElement.fromTag('caption');
              append$1(caption, SugarElement.fromText('Caption'));
              appendAt(table, caption, 0);
              editor.selection.setCursorLocation(caption.dom, 0);
            }, function (caption) {
              if (isTag('caption')(cellOrCaption)) {
                one('td', table).each(function (td) {
                  return editor.selection.setCursorLocation(td.dom, 0);
                });
              }
              remove$5(caption);
            });
            fireTableModified(editor, table.dom, structureModified);
          });
        });
      };
      var postExecute = function (_data) {
        editor.focus();
      };
      var actOnSelection = function (execute, noEvents) {
        if (noEvents === void 0) {
          noEvents = false;
        }
        return performActionOnSelection(function (table, startCell) {
          var targets = forMenu(selections, table, startCell);
          execute(table, targets, noEvents).each(postExecute);
        });
      };
      var copyRowSelection = function () {
        return performActionOnSelection(function (table, startCell) {
          var targets = forMenu(selections, table, startCell);
          var generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none());
          return copyRows(table, targets, generators);
        });
      };
      var copyColSelection = function () {
        return performActionOnSelection(function (table, startCell) {
          var targets = forMenu(selections, table, startCell);
          return copyCols(table, targets);
        });
      };
      var pasteOnSelection = function (execute, getRows) {
        return getRows().each(function (rows) {
          var clonedRows = map$1(rows, function (row) {
            return deep(row);
          });
          performActionOnSelection(function (table, startCell) {
            var generators = paste$1(SugarElement.fromDom(editor.getDoc()));
            var targets = pasteRows(selections, startCell, clonedRows, generators);
            execute(table, targets).each(postExecute);
          });
        });
      };
      var actOnType = function (getAction) {
        return function (_ui, args) {
          return get$c(args, 'type').each(function (type) {
            actOnSelection(getAction(type), args.no_events);
          });
        };
      };
      each$1({
        mceTableSplitCells: function () {
          return actOnSelection(actions.unmergeCells);
        },
        mceTableMergeCells: function () {
          return actOnSelection(actions.mergeCells);
        },
        mceTableInsertRowBefore: function () {
          return actOnSelection(actions.insertRowsBefore);
        },
        mceTableInsertRowAfter: function () {
          return actOnSelection(actions.insertRowsAfter);
        },
        mceTableInsertColBefore: function () {
          return actOnSelection(actions.insertColumnsBefore);
        },
        mceTableInsertColAfter: function () {
          return actOnSelection(actions.insertColumnsAfter);
        },
        mceTableDeleteCol: function () {
          return actOnSelection(actions.deleteColumn);
        },
        mceTableDeleteRow: function () {
          return actOnSelection(actions.deleteRow);
        },
        mceTableCutCol: function () {
          return copyColSelection().each(function (selection) {
            clipboard.setColumns(selection);
            actOnSelection(actions.deleteColumn);
          });
        },
        mceTableCutRow: function () {
          return copyRowSelection().each(function (selection) {
            clipboard.setRows(selection);
            actOnSelection(actions.deleteRow);
          });
        },
        mceTableCopyCol: function () {
          return copyColSelection().each(function (selection) {
            return clipboard.setColumns(selection);
          });
        },
        mceTableCopyRow: function () {
          return copyRowSelection().each(function (selection) {
            return clipboard.setRows(selection);
          });
        },
        mceTablePasteColBefore: function () {
          return pasteOnSelection(actions.pasteColsBefore, clipboard.getColumns);
        },
        mceTablePasteColAfter: function () {
          return pasteOnSelection(actions.pasteColsAfter, clipboard.getColumns);
        },
        mceTablePasteRowBefore: function () {
          return pasteOnSelection(actions.pasteRowsBefore, clipboard.getRows);
        },
        mceTablePasteRowAfter: function () {
          return pasteOnSelection(actions.pasteRowsAfter, clipboard.getRows);
        },
        mceTableDelete: eraseTable,
        mceTableCellToggleClass: toggleTableCellClass,
        mceTableToggleClass: toggleTableClass,
        mceTableToggleCaption: toggleCaption,
        mceTableSizingMode: function (_ui, sizing) {
          return setSizingMode(sizing);
        },
        mceTableCellType: actOnType(function (type) {
          return type === 'th' ? actions.makeCellsHeader : actions.unmakeCellsHeader;
        }),
        mceTableColType: actOnType(function (type) {
          return type === 'th' ? actions.makeColumnsHeader : actions.unmakeColumnsHeader;
        }),
        mceTableRowType: actOnType(function (type) {
          switch (type) {
          case 'header':
            return actions.makeRowsHeader;
          case 'footer':
            return actions.makeRowsFooter;
          default:
            return actions.makeRowsBody;
          }
        })
      }, function (func, name) {
        return editor.addCommand(name, func);
      });
      each$1({
        mceTableProps: curry(open, editor, false),
        mceTableRowProps: curry(open$1, editor),
        mceTableCellProps: curry(open$2, editor, selections)
      }, function (func, name) {
        return editor.addCommand(name, function () {
          return func();
        });
      });
      editor.addCommand('mceInsertTable', function (_ui, args) {
        if (isObject(args) && keys(args).length > 0) {
          insertTableWithDataValidation(editor, args.rows, args.columns, args.options, 'Invalid values for mceInsertTable - rows and columns values are required to insert a table.');
        } else {
          open(editor, true);
        }
      });
      editor.addCommand('mceTableApplyCellStyle', function (_ui, args) {
        var getFormatName = function (style) {
          return 'tablecell' + style.toLowerCase().replace('-', '');
        };
        if (!isObject(args)) {
          return;
        }
        var cells = getCellsFromSelection(selections);
        if (cells.length === 0) {
          return;
        }
        var validArgs = filter$1(args, function (value, style) {
          return editor.formatter.has(getFormatName(style)) && isString(value);
        });
        if (isEmpty(validArgs)) {
          return;
        }
        each$1(validArgs, function (value, style) {
          each$2(cells, function (cell) {
            DomModifier.normal(editor, cell.dom).setFormat(getFormatName(style), value);
          });
        });
        getTableFromCell(cells[0]).each(function (table) {
          return fireTableModified(editor, table.dom, styleModified);
        });
      });
    };

    var registerQueryCommands = function (editor, actions, selections) {
      var isRoot = getIsRoot(editor);
      var lookupOnSelection = function (action) {
        return getSelectionCell(getSelectionStart(editor)).bind(function (cell) {
          return table(cell, isRoot).map(function (table) {
            var targets = forMenu(selections, table, cell);
            return action(table, targets);
          });
        }).getOr('');
      };
      each$1({
        mceTableRowType: function () {
          return lookupOnSelection(actions.getTableRowType);
        },
        mceTableCellType: function () {
          return lookupOnSelection(actions.getTableCellType);
        },
        mceTableColType: function () {
          return lookupOnSelection(actions.getTableColType);
        }
      }, function (func, name) {
        return editor.addQueryValueHandler(name, func);
      });
    };

    var Clipboard = function () {
      var rows = value();
      var cols = value();
      return {
        getRows: rows.get,
        setRows: function (r) {
          r.fold(rows.clear, rows.set);
          cols.clear();
        },
        clearRows: rows.clear,
        getColumns: cols.get,
        setColumns: function (c) {
          c.fold(cols.clear, cols.set);
          rows.clear();
        },
        clearColumns: cols.clear
      };
    };

    var genericBase = {
      remove_similar: true,
      inherit: false
    };
    var cellBase = __assign({ selector: 'td,th' }, genericBase);
    var cellFormats = {
      tablecellbackgroundcolor: __assign({ styles: { backgroundColor: '%value' } }, cellBase),
      tablecellverticalalign: __assign({ styles: { 'vertical-align': '%value' } }, cellBase),
      tablecellbordercolor: __assign({ styles: { borderColor: '%value' } }, cellBase),
      tablecellclass: __assign({ classes: ['%value'] }, cellBase),
      tableclass: __assign({
        selector: 'table',
        classes: ['%value']
      }, genericBase),
      tablecellborderstyle: __assign({ styles: { borderStyle: '%value' } }, cellBase),
      tablecellborderwidth: __assign({ styles: { borderWidth: '%value' } }, cellBase)
    };
    var registerFormats = function (editor) {
      editor.formatter.register(cellFormats);
    };

    var adt$5 = Adt.generate([
      { none: ['current'] },
      { first: ['current'] },
      {
        middle: [
          'current',
          'target'
        ]
      },
      { last: ['current'] }
    ]);
    var none = function (current) {
      if (current === void 0) {
        current = undefined;
      }
      return adt$5.none(current);
    };
    var CellLocation = __assign(__assign({}, adt$5), { none: none });

    var walk = function (all, current, index, direction, isEligible) {
      if (isEligible === void 0) {
        isEligible = always;
      }
      var forwards = direction === 1;
      if (!forwards && index <= 0) {
        return CellLocation.first(all[0]);
      } else if (forwards && index >= all.length - 1) {
        return CellLocation.last(all[all.length - 1]);
      } else {
        var newIndex = index + direction;
        var elem = all[newIndex];
        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);
      }
    };
    var detect$1 = function (current, isRoot) {
      return table(current, isRoot).bind(function (table) {
        var all = cells$1(table);
        var index = findIndex(all, function (x) {
          return eq$1(current, x);
        });
        return index.map(function (index) {
          return {
            index: index,
            all: all
          };
        });
      });
    };
    var next = function (current, isEligible, isRoot) {
      var detection = detect$1(current, isRoot);
      return detection.fold(function () {
        return CellLocation.none(current);
      }, function (info) {
        return walk(info.all, current, info.index, 1, isEligible);
      });
    };
    var prev = function (current, isEligible, isRoot) {
      var detection = detect$1(current, isRoot);
      return detection.fold(function () {
        return CellLocation.none();
      }, function (info) {
        return walk(info.all, current, info.index, -1, isEligible);
      });
    };

    var create$2 = function (start, soffset, finish, foffset) {
      return {
        start: start,
        soffset: soffset,
        finish: finish,
        foffset: foffset
      };
    };
    var SimRange = { create: create$2 };

    var adt$4 = Adt.generate([
      { before: ['element'] },
      {
        on: [
          'element',
          'offset'
        ]
      },
      { after: ['element'] }
    ]);
    var cata$1 = function (subject, onBefore, onOn, onAfter) {
      return subject.fold(onBefore, onOn, onAfter);
    };
    var getStart$1 = function (situ) {
      return situ.fold(identity, identity, identity);
    };
    var before$2 = adt$4.before;
    var on = adt$4.on;
    var after$3 = adt$4.after;
    var Situ = {
      before: before$2,
      on: on,
      after: after$3,
      cata: cata$1,
      getStart: getStart$1
    };

    var adt$3 = Adt.generate([
      { domRange: ['rng'] },
      {
        relative: [
          'startSitu',
          'finishSitu'
        ]
      },
      {
        exact: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    var exactFromRange = function (simRange) {
      return adt$3.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    };
    var getStart = function (selection) {
      return selection.match({
        domRange: function (rng) {
          return SugarElement.fromDom(rng.startContainer);
        },
        relative: function (startSitu, _finishSitu) {
          return Situ.getStart(startSitu);
        },
        exact: function (start, _soffset, _finish, _foffset) {
          return start;
        }
      });
    };
    var domRange = adt$3.domRange;
    var relative = adt$3.relative;
    var exact = adt$3.exact;
    var getWin = function (selection) {
      var start = getStart(selection);
      return defaultView(start);
    };
    var range = SimRange.create;
    var SimSelection = {
      domRange: domRange,
      relative: relative,
      exact: exact,
      exactFromRange: exactFromRange,
      getWin: getWin,
      range: range
    };

    var selectNode = function (win, element) {
      var rng = win.document.createRange();
      rng.selectNode(element.dom);
      return rng;
    };
    var selectNodeContents = function (win, element) {
      var rng = win.document.createRange();
      selectNodeContentsUsing(rng, element);
      return rng;
    };
    var selectNodeContentsUsing = function (rng, element) {
      return rng.selectNodeContents(element.dom);
    };
    var setStart = function (rng, situ) {
      situ.fold(function (e) {
        rng.setStartBefore(e.dom);
      }, function (e, o) {
        rng.setStart(e.dom, o);
      }, function (e) {
        rng.setStartAfter(e.dom);
      });
    };
    var setFinish = function (rng, situ) {
      situ.fold(function (e) {
        rng.setEndBefore(e.dom);
      }, function (e, o) {
        rng.setEnd(e.dom, o);
      }, function (e) {
        rng.setEndAfter(e.dom);
      });
    };
    var relativeToNative = function (win, startSitu, finishSitu) {
      var range = win.document.createRange();
      setStart(range, startSitu);
      setFinish(range, finishSitu);
      return range;
    };
    var exactToNative = function (win, start, soffset, finish, foffset) {
      var rng = win.document.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };
    var toRect = function (rect) {
      return {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height
      };
    };
    var getFirstRect$1 = function (rng) {
      var rects = rng.getClientRects();
      var rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
    };

    var adt$2 = Adt.generate([
      {
        ltr: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      },
      {
        rtl: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    var fromRange = function (win, type, range) {
      return type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    };
    var getRanges = function (win, selection) {
      return selection.match({
        domRange: function (rng) {
          return {
            ltr: constant(rng),
            rtl: Optional.none
          };
        },
        relative: function (startSitu, finishSitu) {
          return {
            ltr: cached(function () {
              return relativeToNative(win, startSitu, finishSitu);
            }),
            rtl: cached(function () {
              return Optional.some(relativeToNative(win, finishSitu, startSitu));
            })
          };
        },
        exact: function (start, soffset, finish, foffset) {
          return {
            ltr: cached(function () {
              return exactToNative(win, start, soffset, finish, foffset);
            }),
            rtl: cached(function () {
              return Optional.some(exactToNative(win, finish, foffset, start, soffset));
            })
          };
        }
      });
    };
    var doDiagnose = function (win, ranges) {
      var rng = ranges.ltr();
      if (rng.collapsed) {
        var reversed = ranges.rtl().filter(function (rev) {
          return rev.collapsed === false;
        });
        return reversed.map(function (rev) {
          return adt$2.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset);
        }).getOrThunk(function () {
          return fromRange(win, adt$2.ltr, rng);
        });
      } else {
        return fromRange(win, adt$2.ltr, rng);
      }
    };
    var diagnose = function (win, selection) {
      var ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    var asLtrRange = function (win, selection) {
      var diagnosis = diagnose(win, selection);
      return diagnosis.match({
        ltr: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(start.dom, soffset);
          rng.setEnd(finish.dom, foffset);
          return rng;
        },
        rtl: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(finish.dom, foffset);
          rng.setEnd(start.dom, soffset);
          return rng;
        }
      });
    };
    adt$2.ltr;
    adt$2.rtl;

    var searchForPoint = function (rectForOffset, x, y, maxX, length) {
      if (length === 0) {
        return 0;
      } else if (x === maxX) {
        return length - 1;
      }
      var xDelta = maxX;
      for (var i = 1; i < length; i++) {
        var rect = rectForOffset(i);
        var curDeltaX = Math.abs(x - rect.left);
        if (y <= rect.bottom) {
          if (y < rect.top || curDeltaX > xDelta) {
            return i - 1;
          } else {
            xDelta = curDeltaX;
          }
        }
      }
      return 0;
    };
    var inRect = function (rect, x, y) {
      return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    };

    var locateOffset = function (doc, textnode, x, y, rect) {
      var rangeForOffset = function (o) {
        var r = doc.dom.createRange();
        r.setStart(textnode.dom, o);
        r.collapse(true);
        return r;
      };
      var rectForOffset = function (o) {
        var r = rangeForOffset(o);
        return r.getBoundingClientRect();
      };
      var length = get$9(textnode).length;
      var offset = searchForPoint(rectForOffset, x, y, rect.right, length);
      return rangeForOffset(offset);
    };
    var locate$1 = function (doc, node, x, y) {
      var r = doc.dom.createRange();
      r.selectNode(node.dom);
      var rects = r.getClientRects();
      var foundRect = findMap(rects, function (rect) {
        return inRect(rect, x, y) ? Optional.some(rect) : Optional.none();
      });
      return foundRect.map(function (rect) {
        return locateOffset(doc, node, x, y, rect);
      });
    };

    var searchInChildren = function (doc, node, x, y) {
      var r = doc.dom.createRange();
      var nodes = children$3(node);
      return findMap(nodes, function (n) {
        r.selectNode(n.dom);
        return inRect(r.getBoundingClientRect(), x, y) ? locateNode(doc, n, x, y) : Optional.none();
      });
    };
    var locateNode = function (doc, node, x, y) {
      return isText(node) ? locate$1(doc, node, x, y) : searchInChildren(doc, node, x, y);
    };
    var locate = function (doc, node, x, y) {
      var r = doc.dom.createRange();
      r.selectNode(node.dom);
      var rect = r.getBoundingClientRect();
      var boundedX = Math.max(rect.left, Math.min(rect.right, x));
      var boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
      return locateNode(doc, node, boundedX, boundedY);
    };

    var COLLAPSE_TO_LEFT = true;
    var COLLAPSE_TO_RIGHT = false;
    var getCollapseDirection = function (rect, x) {
      return x - rect.left < rect.right - x ? COLLAPSE_TO_LEFT : COLLAPSE_TO_RIGHT;
    };
    var createCollapsedNode = function (doc, target, collapseDirection) {
      var r = doc.dom.createRange();
      r.selectNode(target.dom);
      r.collapse(collapseDirection);
      return r;
    };
    var locateInElement = function (doc, node, x) {
      var cursorRange = doc.dom.createRange();
      cursorRange.selectNode(node.dom);
      var rect = cursorRange.getBoundingClientRect();
      var collapseDirection = getCollapseDirection(rect, x);
      var f = collapseDirection === COLLAPSE_TO_LEFT ? first : last$1;
      return f(node).map(function (target) {
        return createCollapsedNode(doc, target, collapseDirection);
      });
    };
    var locateInEmpty = function (doc, node, x) {
      var rect = node.dom.getBoundingClientRect();
      var collapseDirection = getCollapseDirection(rect, x);
      return Optional.some(createCollapsedNode(doc, node, collapseDirection));
    };
    var search = function (doc, node, x) {
      var f = children$3(node).length === 0 ? locateInEmpty : locateInElement;
      return f(doc, node, x);
    };

    var caretPositionFromPoint = function (doc, x, y) {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(function (pos) {
        if (pos.offsetNode === null) {
          return Optional.none();
        }
        var r = doc.dom.createRange();
        r.setStart(pos.offsetNode, pos.offset);
        r.collapse();
        return Optional.some(r);
      });
    };
    var caretRangeFromPoint = function (doc, x, y) {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
    };
    var searchTextNodes = function (doc, node, x, y) {
      var r = doc.dom.createRange();
      r.selectNode(node.dom);
      var rect = r.getBoundingClientRect();
      var boundedX = Math.max(rect.left, Math.min(rect.right, x));
      var boundedY = Math.max(rect.top, Math.min(rect.bottom, y));
      return locate(doc, node, boundedX, boundedY);
    };
    var searchFromPoint = function (doc, x, y) {
      return SugarElement.fromPoint(doc, x, y).bind(function (elem) {
        var fallback = function () {
          return search(doc, elem, x);
        };
        return children$3(elem).length === 0 ? fallback() : searchTextNodes(doc, elem, x, y).orThunk(fallback);
      });
    };
    var availableSearch = function () {
      if (document.caretPositionFromPoint) {
        return caretPositionFromPoint;
      } else if (document.caretRangeFromPoint) {
        return caretRangeFromPoint;
      } else {
        return searchFromPoint;
      }
    }();
    var fromPoint = function (win, x, y) {
      var doc = SugarElement.fromDom(win.document);
      return availableSearch(doc, x, y).map(function (rng) {
        return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);
      });
    };

    var beforeSpecial = function (element, offset) {
      var name$1 = name(element);
      if ('input' === name$1) {
        return Situ.after(element);
      } else if (!contains$2([
          'br',
          'img'
        ], name$1)) {
        return Situ.on(element, offset);
      } else {
        return offset === 0 ? Situ.before(element) : Situ.after(element);
      }
    };
    var preprocessRelative = function (startSitu, finishSitu) {
      var start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
      var finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
      return SimSelection.relative(start, finish);
    };
    var preprocessExact = function (start, soffset, finish, foffset) {
      var startSitu = beforeSpecial(start, soffset);
      var finishSitu = beforeSpecial(finish, foffset);
      return SimSelection.relative(startSitu, finishSitu);
    };
    var preprocess = function (selection) {
      return selection.match({
        domRange: function (rng) {
          var start = SugarElement.fromDom(rng.startContainer);
          var finish = SugarElement.fromDom(rng.endContainer);
          return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
        },
        relative: preprocessRelative,
        exact: preprocessExact
      });
    };

    var makeRange = function (start, soffset, finish, foffset) {
      var doc = owner(start);
      var rng = doc.dom.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };
    var after$2 = function (start, soffset, finish, foffset) {
      var r = makeRange(start, soffset, finish, foffset);
      var same = eq$1(start, finish) && soffset === foffset;
      return r.collapsed && !same;
    };

    var getNativeSelection = function (win) {
      return Optional.from(win.getSelection());
    };
    var doSetNativeRange = function (win, rng) {
      getNativeSelection(win).each(function (selection) {
        selection.removeAllRanges();
        selection.addRange(rng);
      });
    };
    var doSetRange = function (win, start, soffset, finish, foffset) {
      var rng = exactToNative(win, start, soffset, finish, foffset);
      doSetNativeRange(win, rng);
    };
    var setLegacyRtlRange = function (win, selection, start, soffset, finish, foffset) {
      selection.collapse(start.dom, soffset);
      selection.extend(finish.dom, foffset);
    };
    var setRangeFromRelative = function (win, relative) {
      return diagnose(win, relative).match({
        ltr: function (start, soffset, finish, foffset) {
          doSetRange(win, start, soffset, finish, foffset);
        },
        rtl: function (start, soffset, finish, foffset) {
          getNativeSelection(win).each(function (selection) {
            if (selection.setBaseAndExtent) {
              selection.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);
            } else if (selection.extend) {
              try {
                setLegacyRtlRange(win, selection, start, soffset, finish, foffset);
              } catch (e) {
                doSetRange(win, finish, foffset, start, soffset);
              }
            } else {
              doSetRange(win, finish, foffset, start, soffset);
            }
          });
        }
      });
    };
    var setExact = function (win, start, soffset, finish, foffset) {
      var relative = preprocessExact(start, soffset, finish, foffset);
      setRangeFromRelative(win, relative);
    };
    var setRelative = function (win, startSitu, finishSitu) {
      var relative = preprocessRelative(startSitu, finishSitu);
      setRangeFromRelative(win, relative);
    };
    var toNative = function (selection) {
      var win = SimSelection.getWin(selection).dom;
      var getDomRange = function (start, soffset, finish, foffset) {
        return exactToNative(win, start, soffset, finish, foffset);
      };
      var filtered = preprocess(selection);
      return diagnose(win, filtered).match({
        ltr: getDomRange,
        rtl: getDomRange
      });
    };
    var readRange = function (selection) {
      if (selection.rangeCount > 0) {
        var firstRng = selection.getRangeAt(0);
        var lastRng = selection.getRangeAt(selection.rangeCount - 1);
        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
      } else {
        return Optional.none();
      }
    };
    var doGetExact = function (selection) {
      if (selection.anchorNode === null || selection.focusNode === null) {
        return readRange(selection);
      } else {
        var anchor = SugarElement.fromDom(selection.anchorNode);
        var focus_1 = SugarElement.fromDom(selection.focusNode);
        return after$2(anchor, selection.anchorOffset, focus_1, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus_1, selection.focusOffset)) : readRange(selection);
      }
    };
    var setToElement = function (win, element, selectNodeContents$1) {
      if (selectNodeContents$1 === void 0) {
        selectNodeContents$1 = true;
      }
      var rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode;
      var rng = rngGetter(win, element);
      doSetNativeRange(win, rng);
    };
    var getExact = function (win) {
      return getNativeSelection(win).filter(function (sel) {
        return sel.rangeCount > 0;
      }).bind(doGetExact);
    };
    var get$1 = function (win) {
      return getExact(win).map(function (range) {
        return SimSelection.exact(range.start, range.soffset, range.finish, range.foffset);
      });
    };
    var getFirstRect = function (win, selection) {
      var rng = asLtrRange(win, selection);
      return getFirstRect$1(rng);
    };
    var getAtPoint = function (win, x, y) {
      return fromPoint(win, x, y);
    };
    var clear = function (win) {
      getNativeSelection(win).each(function (selection) {
        return selection.removeAllRanges();
      });
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.VK');

    var forward = function (editor, isRoot, cell) {
      return go$1(editor, isRoot, next(cell, isEditable$1));
    };
    var backward = function (editor, isRoot, cell) {
      return go$1(editor, isRoot, prev(cell, isEditable$1));
    };
    var getCellFirstCursorPosition = function (editor, cell) {
      var selection = SimSelection.exact(cell, 0, cell, 0);
      return toNative(selection);
    };
    var go$1 = function (editor, isRoot, cell) {
      return cell.fold(Optional.none, Optional.none, function (current, next) {
        return first(next).map(function (cell) {
          return getCellFirstCursorPosition(editor, cell);
        });
      }, function (current) {
        editor.execCommand('mceTableInsertRowAfter');
        return forward(editor, isRoot, current);
      });
    };
    var rootElements = [
      'table',
      'li',
      'dl'
    ];
    var handle$1 = function (event, editor, cellSelection) {
      if (event.keyCode === global$1.TAB) {
        var body_1 = getBody(editor);
        var isRoot_1 = function (element) {
          var name$1 = name(element);
          return eq$1(element, body_1) || contains$2(rootElements, name$1);
        };
        var rng = editor.selection.getRng();
        var container = SugarElement.fromDom(event.shiftKey ? rng.startContainer : rng.endContainer);
        cell(container, isRoot_1).each(function (cell) {
          event.preventDefault();
          table(cell, isRoot_1).each(cellSelection.clear);
          editor.selection.collapse(event.shiftKey);
          var navigation = event.shiftKey ? backward : forward;
          var rng = navigation(editor, isRoot_1, cell);
          rng.each(function (range) {
            editor.selection.setRng(range);
          });
        });
      }
    };

    var create$1 = function (selection, kill) {
      return {
        selection: selection,
        kill: kill
      };
    };
    var Response = { create: create$1 };

    var create = function (start, soffset, finish, foffset) {
      return {
        start: Situ.on(start, soffset),
        finish: Situ.on(finish, foffset)
      };
    };
    var Situs = { create: create };

    var convertToRange = function (win, selection) {
      var rng = asLtrRange(win, selection);
      return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);
    };
    var makeSitus = Situs.create;

    var sync = function (container, isRoot, start, soffset, finish, foffset, selectRange) {
      if (!(eq$1(start, finish) && soffset === foffset)) {
        return closest$1(start, 'td,th', isRoot).bind(function (s) {
          return closest$1(finish, 'td,th', isRoot).bind(function (f) {
            return detect(container, isRoot, s, f, selectRange);
          });
        });
      } else {
        return Optional.none();
      }
    };
    var detect = function (container, isRoot, start, finish, selectRange) {
      if (!eq$1(start, finish)) {
        return identify(start, finish, isRoot).bind(function (cellSel) {
          var boxes = cellSel.boxes.getOr([]);
          if (boxes.length > 1) {
            selectRange(container, boxes, cellSel.start, cellSel.finish);
            return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));
          } else {
            return Optional.none();
          }
        });
      } else {
        return Optional.none();
      }
    };
    var update = function (rows, columns, container, selected, annotations) {
      var updateSelection = function (newSels) {
        annotations.clearBeforeUpdate(container);
        annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);
        return newSels.boxes;
      };
      return shiftSelection(selected, rows, columns, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);
    };

    var traverse = function (item, mode) {
      return {
        item: item,
        mode: mode
      };
    };
    var backtrack = function (universe, item, _direction, transition) {
      if (transition === void 0) {
        transition = sidestep;
      }
      return universe.property().parent(item).map(function (p) {
        return traverse(p, transition);
      });
    };
    var sidestep = function (universe, item, direction, transition) {
      if (transition === void 0) {
        transition = advance;
      }
      return direction.sibling(universe, item).map(function (p) {
        return traverse(p, transition);
      });
    };
    var advance = function (universe, item, direction, transition) {
      if (transition === void 0) {
        transition = advance;
      }
      var children = universe.property().children(item);
      var result = direction.first(children);
      return result.map(function (r) {
        return traverse(r, transition);
      });
    };
    var successors = [
      {
        current: backtrack,
        next: sidestep,
        fallback: Optional.none()
      },
      {
        current: sidestep,
        next: advance,
        fallback: Optional.some(backtrack)
      },
      {
        current: advance,
        next: advance,
        fallback: Optional.some(sidestep)
      }
    ];
    var go = function (universe, item, mode, direction, rules) {
      if (rules === void 0) {
        rules = successors;
      }
      var ruleOpt = find$1(rules, function (succ) {
        return succ.current === mode;
      });
      return ruleOpt.bind(function (rule) {
        return rule.current(universe, item, direction, rule.next).orThunk(function () {
          return rule.fallback.bind(function (fb) {
            return go(universe, item, fb, direction);
          });
        });
      });
    };

    var left$1 = function () {
      var sibling = function (universe, item) {
        return universe.query().prevSibling(item);
      };
      var first = function (children) {
        return children.length > 0 ? Optional.some(children[children.length - 1]) : Optional.none();
      };
      return {
        sibling: sibling,
        first: first
      };
    };
    var right$1 = function () {
      var sibling = function (universe, item) {
        return universe.query().nextSibling(item);
      };
      var first = function (children) {
        return children.length > 0 ? Optional.some(children[0]) : Optional.none();
      };
      return {
        sibling: sibling,
        first: first
      };
    };
    var Walkers = {
      left: left$1,
      right: right$1
    };

    var hone = function (universe, item, predicate, mode, direction, isRoot) {
      var next = go(universe, item, mode, direction);
      return next.bind(function (n) {
        if (isRoot(n.item)) {
          return Optional.none();
        } else {
          return predicate(n.item) ? Optional.some(n.item) : hone(universe, n.item, predicate, n.mode, direction, isRoot);
        }
      });
    };
    var left = function (universe, item, predicate, isRoot) {
      return hone(universe, item, predicate, sidestep, Walkers.left(), isRoot);
    };
    var right = function (universe, item, predicate, isRoot) {
      return hone(universe, item, predicate, sidestep, Walkers.right(), isRoot);
    };

    var isLeaf = function (universe) {
      return function (element) {
        return universe.property().children(element).length === 0;
      };
    };
    var before$1 = function (universe, item, isRoot) {
      return seekLeft$1(universe, item, isLeaf(universe), isRoot);
    };
    var after$1 = function (universe, item, isRoot) {
      return seekRight$1(universe, item, isLeaf(universe), isRoot);
    };
    var seekLeft$1 = left;
    var seekRight$1 = right;

    var universe = DomUniverse();
    var before = function (element, isRoot) {
      return before$1(universe, element, isRoot);
    };
    var after = function (element, isRoot) {
      return after$1(universe, element, isRoot);
    };
    var seekLeft = function (element, predicate, isRoot) {
      return seekLeft$1(universe, element, predicate, isRoot);
    };
    var seekRight = function (element, predicate, isRoot) {
      return seekRight$1(universe, element, predicate, isRoot);
    };

    var ancestor = function (scope, predicate, isRoot) {
      return ancestor$2(scope, predicate, isRoot).isSome();
    };

    var adt$1 = Adt.generate([
      { none: ['message'] },
      { success: [] },
      { failedUp: ['cell'] },
      { failedDown: ['cell'] }
    ]);
    var isOverlapping = function (bridge, before, after) {
      var beforeBounds = bridge.getRect(before);
      var afterBounds = bridge.getRect(after);
      return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
    };
    var isRow = function (elem) {
      return closest$1(elem, 'tr');
    };
    var verify = function (bridge, before, beforeOffset, after, afterOffset, failure, isRoot) {
      return closest$1(after, 'td,th', isRoot).bind(function (afterCell) {
        return closest$1(before, 'td,th', isRoot).map(function (beforeCell) {
          if (!eq$1(afterCell, beforeCell)) {
            return sharedOne(isRow, [
              afterCell,
              beforeCell
            ]).fold(function () {
              return isOverlapping(bridge, beforeCell, afterCell) ? adt$1.success() : failure(beforeCell);
            }, function (_sharedRow) {
              return failure(beforeCell);
            });
          } else {
            return eq$1(after, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$1.none('in same cell');
          }
        });
      }).getOr(adt$1.none('default'));
    };
    var cata = function (subject, onNone, onSuccess, onFailedUp, onFailedDown) {
      return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
    };
    var BeforeAfter = __assign(__assign({}, adt$1), {
      verify: verify,
      cata: cata
    });

    var inParent = function (parent, children, element, index) {
      return {
        parent: parent,
        children: children,
        element: element,
        index: index
      };
    };
    var indexInParent = function (element) {
      return parent(element).bind(function (parent) {
        var children = children$3(parent);
        return indexOf(children, element).map(function (index) {
          return inParent(parent, children, element, index);
        });
      });
    };
    var indexOf = function (elements, element) {
      return findIndex(elements, curry(eq$1, element));
    };

    var isBr = function (elem) {
      return name(elem) === 'br';
    };
    var gatherer = function (cand, gather, isRoot) {
      return gather(cand, isRoot).bind(function (target) {
        return isText(target) && get$9(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);
      });
    };
    var handleBr = function (isRoot, element, direction) {
      return direction.traverse(element).orThunk(function () {
        return gatherer(element, direction.gather, isRoot);
      }).map(direction.relative);
    };
    var findBr = function (element, offset) {
      return child$3(element, offset).filter(isBr).orThunk(function () {
        return child$3(element, offset - 1).filter(isBr);
      });
    };
    var handleParent = function (isRoot, element, offset, direction) {
      return findBr(element, offset).bind(function (br) {
        return direction.traverse(br).fold(function () {
          return gatherer(br, direction.gather, isRoot).map(direction.relative);
        }, function (adjacent) {
          return indexInParent(adjacent).map(function (info) {
            return Situ.on(info.parent, info.index);
          });
        });
      });
    };
    var tryBr = function (isRoot, element, offset, direction) {
      var target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);
      return target.map(function (tgt) {
        return {
          start: tgt,
          finish: tgt
        };
      });
    };
    var process = function (analysis) {
      return BeforeAfter.cata(analysis, function (_message) {
        return Optional.none();
      }, function () {
        return Optional.none();
      }, function (cell) {
        return Optional.some(point(cell, 0));
      }, function (cell) {
        return Optional.some(point(cell, getEnd(cell)));
      });
    };

    var moveDown = function (caret, amount) {
      return {
        left: caret.left,
        top: caret.top + amount,
        right: caret.right,
        bottom: caret.bottom + amount
      };
    };
    var moveUp = function (caret, amount) {
      return {
        left: caret.left,
        top: caret.top - amount,
        right: caret.right,
        bottom: caret.bottom - amount
      };
    };
    var translate = function (caret, xDelta, yDelta) {
      return {
        left: caret.left + xDelta,
        top: caret.top + yDelta,
        right: caret.right + xDelta,
        bottom: caret.bottom + yDelta
      };
    };
    var getTop = function (caret) {
      return caret.top;
    };
    var getBottom = function (caret) {
      return caret.bottom;
    };

    var getPartialBox = function (bridge, element, offset) {
      if (offset >= 0 && offset < getEnd(element)) {
        return bridge.getRangedRect(element, offset, element, offset + 1);
      } else if (offset > 0) {
        return bridge.getRangedRect(element, offset - 1, element, offset);
      }
      return Optional.none();
    };
    var toCaret = function (rect) {
      return {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom
      };
    };
    var getElemBox = function (bridge, element) {
      return Optional.some(bridge.getRect(element));
    };
    var getBoxAt = function (bridge, element, offset) {
      if (isElement(element)) {
        return getElemBox(bridge, element).map(toCaret);
      } else if (isText(element)) {
        return getPartialBox(bridge, element, offset).map(toCaret);
      } else {
        return Optional.none();
      }
    };
    var getEntireBox = function (bridge, element) {
      if (isElement(element)) {
        return getElemBox(bridge, element).map(toCaret);
      } else if (isText(element)) {
        return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
      } else {
        return Optional.none();
      }
    };

    var JUMP_SIZE = 5;
    var NUM_RETRIES = 100;
    var adt = Adt.generate([
      { none: [] },
      { retry: ['caret'] }
    ]);
    var isOutside = function (caret, box) {
      return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;
    };
    var inOutsideBlock = function (bridge, element, caret) {
      return closest$2(element, isBlock).fold(never, function (cell) {
        return getEntireBox(bridge, cell).exists(function (box) {
          return isOutside(caret, box);
        });
      });
    };
    var adjustDown = function (bridge, element, guessBox, original, caret) {
      var lowerCaret = moveDown(caret, JUMP_SIZE);
      if (Math.abs(guessBox.bottom - original.bottom) < 1) {
        return adt.retry(lowerCaret);
      } else if (guessBox.top > caret.bottom) {
        return adt.retry(lowerCaret);
      } else if (guessBox.top === caret.bottom) {
        return adt.retry(moveDown(caret, 1));
      } else {
        return inOutsideBlock(bridge, element, caret) ? adt.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt.none();
      }
    };
    var adjustUp = function (bridge, element, guessBox, original, caret) {
      var higherCaret = moveUp(caret, JUMP_SIZE);
      if (Math.abs(guessBox.top - original.top) < 1) {
        return adt.retry(higherCaret);
      } else if (guessBox.bottom < caret.top) {
        return adt.retry(higherCaret);
      } else if (guessBox.bottom === caret.top) {
        return adt.retry(moveUp(caret, 1));
      } else {
        return inOutsideBlock(bridge, element, caret) ? adt.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt.none();
      }
    };
    var upMovement = {
      point: getTop,
      adjuster: adjustUp,
      move: moveUp,
      gather: before
    };
    var downMovement = {
      point: getBottom,
      adjuster: adjustDown,
      move: moveDown,
      gather: after
    };
    var isAtTable = function (bridge, x, y) {
      return bridge.elementFromPoint(x, y).filter(function (elm) {
        return name(elm) === 'table';
      }).isSome();
    };
    var adjustForTable = function (bridge, movement, original, caret, numRetries) {
      return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);
    };
    var adjustTil = function (bridge, movement, original, caret, numRetries) {
      if (numRetries === 0) {
        return Optional.some(caret);
      }
      if (isAtTable(bridge, caret.left, movement.point(caret))) {
        return adjustForTable(bridge, movement, original, caret, numRetries - 1);
      }
      return bridge.situsFromPoint(caret.left, movement.point(caret)).bind(function (guess) {
        return guess.start.fold(Optional.none, function (element) {
          return getEntireBox(bridge, element).bind(function (guessBox) {
            return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, function (newCaret) {
              return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
            });
          }).orThunk(function () {
            return Optional.some(caret);
          });
        }, Optional.none);
      });
    };
    var ieTryDown = function (bridge, caret) {
      return bridge.situsFromPoint(caret.left, caret.bottom + JUMP_SIZE);
    };
    var ieTryUp = function (bridge, caret) {
      return bridge.situsFromPoint(caret.left, caret.top - JUMP_SIZE);
    };
    var checkScroll = function (movement, adjusted, bridge) {
      if (movement.point(adjusted) > bridge.getInnerHeight()) {
        return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());
      } else if (movement.point(adjusted) < 0) {
        return Optional.some(-movement.point(adjusted));
      } else {
        return Optional.none();
      }
    };
    var retry = function (movement, bridge, caret) {
      var moved = movement.move(caret, JUMP_SIZE);
      var adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);
      return checkScroll(movement, adjusted, bridge).fold(function () {
        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));
      }, function (delta) {
        bridge.scrollBy(0, delta);
        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);
      });
    };
    var Retries = {
      tryUp: curry(retry, upMovement),
      tryDown: curry(retry, downMovement),
      ieTryUp: ieTryUp,
      ieTryDown: ieTryDown,
      getJumpSize: constant(JUMP_SIZE)
    };

    var MAX_RETRIES = 20;
    var findSpot = function (bridge, isRoot, direction) {
      return bridge.getSelection().bind(function (sel) {
        return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(function () {
          return Optional.some(point(sel.finish, sel.foffset));
        }, function (brNeighbour) {
          var range = bridge.fromSitus(brNeighbour);
          var analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot);
          return process(analysis);
        });
      });
    };
    var scan = function (bridge, isRoot, element, offset, direction, numRetries) {
      if (numRetries === 0) {
        return Optional.none();
      }
      return tryCursor(bridge, isRoot, element, offset, direction).bind(function (situs) {
        var range = bridge.fromSitus(situs);
        var analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);
        return BeforeAfter.cata(analysis, function () {
          return Optional.none();
        }, function () {
          return Optional.some(situs);
        }, function (cell) {
          if (eq$1(element, cell) && offset === 0) {
            return tryAgain(bridge, element, offset, moveUp, direction);
          } else {
            return scan(bridge, isRoot, cell, 0, direction, numRetries - 1);
          }
        }, function (cell) {
          if (eq$1(element, cell) && offset === getEnd(cell)) {
            return tryAgain(bridge, element, offset, moveDown, direction);
          } else {
            return scan(bridge, isRoot, cell, getEnd(cell), direction, numRetries - 1);
          }
        });
      });
    };
    var tryAgain = function (bridge, element, offset, move, direction) {
      return getBoxAt(bridge, element, offset).bind(function (box) {
        return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
      });
    };
    var tryAt = function (bridge, direction, box) {
      var browser = detect$3().browser;
      if (browser.isChrome() || browser.isSafari() || browser.isFirefox() || browser.isEdge()) {
        return direction.otherRetry(bridge, box);
      } else if (browser.isIE()) {
        return direction.ieRetry(bridge, box);
      } else {
        return Optional.none();
      }
    };
    var tryCursor = function (bridge, isRoot, element, offset, direction) {
      return getBoxAt(bridge, element, offset).bind(function (box) {
        return tryAt(bridge, direction, box);
      });
    };
    var handle = function (bridge, isRoot, direction) {
      return findSpot(bridge, isRoot, direction).bind(function (spot) {
        return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);
      });
    };

    var inSameTable = function (elem, table) {
      return ancestor(elem, function (e) {
        return parent(e).exists(function (p) {
          return eq$1(p, table);
        });
      });
    };
    var simulate = function (bridge, isRoot, direction, initial, anchor) {
      return closest$1(initial, 'td,th', isRoot).bind(function (start) {
        return closest$1(start, 'table', isRoot).bind(function (table) {
          if (!inSameTable(anchor, table)) {
            return Optional.none();
          }
          return handle(bridge, isRoot, direction).bind(function (range) {
            return closest$1(range.finish, 'td,th', isRoot).map(function (finish) {
              return {
                start: start,
                finish: finish,
                range: range
              };
            });
          });
        });
      });
    };
    var navigate = function (bridge, isRoot, direction, initial, anchor, precheck) {
      if (detect$3().browser.isIE()) {
        return Optional.none();
      } else {
        return precheck(initial, isRoot).orThunk(function () {
          return simulate(bridge, isRoot, direction, initial, anchor).map(function (info) {
            var range = info.range;
            return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);
          });
        });
      }
    };
    var firstUpCheck = function (initial, isRoot) {
      return closest$1(initial, 'tr', isRoot).bind(function (startRow) {
        return closest$1(startRow, 'table', isRoot).bind(function (table) {
          var rows = descendants(table, 'tr');
          if (eq$1(startRow, rows[0])) {
            return seekLeft(table, function (element) {
              return last$1(element).isSome();
            }, isRoot).map(function (last) {
              var lastOffset = getEnd(last);
              return Response.create(Optional.some(makeSitus(last, lastOffset, last, lastOffset)), true);
            });
          } else {
            return Optional.none();
          }
        });
      });
    };
    var lastDownCheck = function (initial, isRoot) {
      return closest$1(initial, 'tr', isRoot).bind(function (startRow) {
        return closest$1(startRow, 'table', isRoot).bind(function (table) {
          var rows = descendants(table, 'tr');
          if (eq$1(startRow, rows[rows.length - 1])) {
            return seekRight(table, function (element) {
              return first(element).isSome();
            }, isRoot).map(function (first) {
              return Response.create(Optional.some(makeSitus(first, 0, first, 0)), true);
            });
          } else {
            return Optional.none();
          }
        });
      });
    };
    var select = function (bridge, container, isRoot, direction, initial, anchor, selectRange) {
      return simulate(bridge, isRoot, direction, initial, anchor).bind(function (info) {
        return detect(container, isRoot, info.start, info.finish, selectRange);
      });
    };

    var findCell = function (target, isRoot) {
      return closest$1(target, 'td,th', isRoot);
    };
    var MouseSelection = function (bridge, container, isRoot, annotations) {
      var cursor = value();
      var clearstate = cursor.clear;
      var applySelection = function (event) {
        cursor.on(function (start) {
          annotations.clearBeforeUpdate(container);
          findCell(event.target, isRoot).each(function (finish) {
            identify(start, finish, isRoot).each(function (cellSel) {
              var boxes = cellSel.boxes.getOr([]);
              if (boxes.length === 1) {
                var singleCell = boxes[0];
                var isNonEditableCell = getRaw(singleCell) === 'false';
                var isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);
                if (isNonEditableCell && isCellClosestContentEditable) {
                  annotations.selectRange(container, boxes, singleCell, singleCell);
                  bridge.selectContents(singleCell);
                }
              } else if (boxes.length > 1) {
                annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
                bridge.selectContents(finish);
              }
            });
          });
        });
      };
      var mousedown = function (event) {
        annotations.clear(container);
        findCell(event.target, isRoot).each(cursor.set);
      };
      var mouseover = function (event) {
        applySelection(event);
      };
      var mouseup = function (event) {
        applySelection(event);
        clearstate();
      };
      return {
        clearstate: clearstate,
        mousedown: mousedown,
        mouseover: mouseover,
        mouseup: mouseup
      };
    };

    var down = {
      traverse: nextSibling,
      gather: after,
      relative: Situ.before,
      otherRetry: Retries.tryDown,
      ieRetry: Retries.ieTryDown,
      failure: BeforeAfter.failedDown
    };
    var up = {
      traverse: prevSibling,
      gather: before,
      relative: Situ.before,
      otherRetry: Retries.tryUp,
      ieRetry: Retries.ieTryUp,
      failure: BeforeAfter.failedUp
    };

    var isKey = function (key) {
      return function (keycode) {
        return keycode === key;
      };
    };
    var isUp = isKey(38);
    var isDown = isKey(40);
    var isNavigation = function (keycode) {
      return keycode >= 37 && keycode <= 40;
    };
    var ltr = {
      isBackward: isKey(37),
      isForward: isKey(39)
    };
    var rtl = {
      isBackward: isKey(39),
      isForward: isKey(37)
    };

    var get = function (_DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    var by = function (x, y, _DOC) {
      var doc = _DOC !== undefined ? _DOC.dom : document;
      var win = doc.defaultView;
      if (win) {
        win.scrollBy(x, y);
      }
    };

    var WindowBridge = function (win) {
      var elementFromPoint = function (x, y) {
        return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);
      };
      var getRect = function (element) {
        return element.dom.getBoundingClientRect();
      };
      var getRangedRect = function (start, soffset, finish, foffset) {
        var sel = SimSelection.exact(start, soffset, finish, foffset);
        return getFirstRect(win, sel);
      };
      var getSelection = function () {
        return get$1(win).map(function (exactAdt) {
          return convertToRange(win, exactAdt);
        });
      };
      var fromSitus = function (situs) {
        var relative = SimSelection.relative(situs.start, situs.finish);
        return convertToRange(win, relative);
      };
      var situsFromPoint = function (x, y) {
        return getAtPoint(win, x, y).map(function (exact) {
          return Situs.create(exact.start, exact.soffset, exact.finish, exact.foffset);
        });
      };
      var clearSelection = function () {
        clear(win);
      };
      var collapseSelection = function (toStart) {
        if (toStart === void 0) {
          toStart = false;
        }
        get$1(win).each(function (sel) {
          return sel.fold(function (rng) {
            return rng.collapse(toStart);
          }, function (startSitu, finishSitu) {
            var situ = toStart ? startSitu : finishSitu;
            setRelative(win, situ, situ);
          }, function (start, soffset, finish, foffset) {
            var node = toStart ? start : finish;
            var offset = toStart ? soffset : foffset;
            setExact(win, node, offset, node, offset);
          });
        });
      };
      var selectNode = function (element) {
        setToElement(win, element, false);
      };
      var selectContents = function (element) {
        setToElement(win, element);
      };
      var setSelection = function (sel) {
        setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);
      };
      var setRelativeSelection = function (start, finish) {
        setRelative(win, start, finish);
      };
      var getInnerHeight = function () {
        return win.innerHeight;
      };
      var getScrollY = function () {
        var pos = get(SugarElement.fromDom(win.document));
        return pos.top;
      };
      var scrollBy = function (x, y) {
        by(x, y, SugarElement.fromDom(win.document));
      };
      return {
        elementFromPoint: elementFromPoint,
        getRect: getRect,
        getRangedRect: getRangedRect,
        getSelection: getSelection,
        fromSitus: fromSitus,
        situsFromPoint: situsFromPoint,
        clearSelection: clearSelection,
        collapseSelection: collapseSelection,
        setSelection: setSelection,
        setRelativeSelection: setRelativeSelection,
        selectNode: selectNode,
        selectContents: selectContents,
        getInnerHeight: getInnerHeight,
        getScrollY: getScrollY,
        scrollBy: scrollBy
      };
    };

    var rc = function (rows, cols) {
      return {
        rows: rows,
        cols: cols
      };
    };
    var mouse = function (win, container, isRoot, annotations) {
      var bridge = WindowBridge(win);
      var handlers = MouseSelection(bridge, container, isRoot, annotations);
      return {
        clearstate: handlers.clearstate,
        mousedown: handlers.mousedown,
        mouseover: handlers.mouseover,
        mouseup: handlers.mouseup
      };
    };
    var keyboard = function (win, container, isRoot, annotations) {
      var bridge = WindowBridge(win);
      var clearToNavigate = function () {
        annotations.clear(container);
        return Optional.none();
      };
      var keydown = function (event, start, soffset, finish, foffset, direction) {
        var realEvent = event.raw;
        var keycode = realEvent.which;
        var shiftKey = realEvent.shiftKey === true;
        var handler = retrieve$1(container, annotations.selectedSelector).fold(function () {
          if (isNavigation(keycode) && !shiftKey) {
            annotations.clearBeforeUpdate(container);
          }
          if (isDown(keycode) && shiftKey) {
            return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);
          } else if (isUp(keycode) && shiftKey) {
            return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);
          } else if (isDown(keycode)) {
            return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);
          } else if (isUp(keycode)) {
            return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);
          } else {
            return Optional.none;
          }
        }, function (selected) {
          var update$1 = function (attempts) {
            return function () {
              var navigation = findMap(attempts, function (delta) {
                return update(delta.rows, delta.cols, container, selected, annotations);
              });
              return navigation.fold(function () {
                return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(function (edges) {
                  var relative = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
                  bridge.setRelativeSelection(Situ.on(edges.first, 0), relative(edges.table));
                  annotations.clear(container);
                  return Response.create(Optional.none(), true);
                });
              }, function (_) {
                return Optional.some(Response.create(Optional.none(), true));
              });
            };
          };
          if (isDown(keycode) && shiftKey) {
            return update$1([rc(+1, 0)]);
          } else if (isUp(keycode) && shiftKey) {
            return update$1([rc(-1, 0)]);
          } else if (direction.isBackward(keycode) && shiftKey) {
            return update$1([
              rc(0, -1),
              rc(-1, 0)
            ]);
          } else if (direction.isForward(keycode) && shiftKey) {
            return update$1([
              rc(0, +1),
              rc(+1, 0)
            ]);
          } else if (isNavigation(keycode) && !shiftKey) {
            return clearToNavigate;
          } else {
            return Optional.none;
          }
        });
        return handler();
      };
      var keyup = function (event, start, soffset, finish, foffset) {
        return retrieve$1(container, annotations.selectedSelector).fold(function () {
          var realEvent = event.raw;
          var keycode = realEvent.which;
          var shiftKey = realEvent.shiftKey === true;
          if (!shiftKey) {
            return Optional.none();
          }
          if (isNavigation(keycode)) {
            return sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);
          } else {
            return Optional.none();
          }
        }, Optional.none);
      };
      return {
        keydown: keydown,
        keyup: keyup
      };
    };
    var external = function (win, container, isRoot, annotations) {
      var bridge = WindowBridge(win);
      return function (start, finish) {
        annotations.clearBeforeUpdate(container);
        identify(start, finish, isRoot).each(function (cellSel) {
          var boxes = cellSel.boxes.getOr([]);
          annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
          bridge.selectContents(finish);
          bridge.collapseSelection();
        });
      };
    };

    var remove = function (element, classes) {
      each$2(classes, function (x) {
        remove$2(element, x);
      });
    };

    var addClass = function (clazz) {
      return function (element) {
        add(element, clazz);
      };
    };
    var removeClasses = function (classes) {
      return function (element) {
        remove(element, classes);
      };
    };

    var byClass = function (ephemera) {
      var addSelectionClass = addClass(ephemera.selected);
      var removeSelectionClasses = removeClasses([
        ephemera.selected,
        ephemera.lastSelected,
        ephemera.firstSelected
      ]);
      var clear = function (container) {
        var sels = descendants(container, ephemera.selectedSelector);
        each$2(sels, removeSelectionClasses);
      };
      var selectRange = function (container, cells, start, finish) {
        clear(container);
        each$2(cells, addSelectionClass);
        add(start, ephemera.firstSelected);
        add(finish, ephemera.lastSelected);
      };
      return {
        clearBeforeUpdate: clear,
        clear: clear,
        selectRange: selectRange,
        selectedSelector: ephemera.selectedSelector,
        firstSelectedSelector: ephemera.firstSelectedSelector,
        lastSelectedSelector: ephemera.lastSelectedSelector
      };
    };
    var byAttr = function (ephemera, onSelection, onClear) {
      var removeSelectionAttributes = function (element) {
        remove$7(element, ephemera.selected);
        remove$7(element, ephemera.firstSelected);
        remove$7(element, ephemera.lastSelected);
      };
      var addSelectionAttribute = function (element) {
        set$2(element, ephemera.selected, '1');
      };
      var clear = function (container) {
        clearBeforeUpdate(container);
        onClear();
      };
      var clearBeforeUpdate = function (container) {
        var sels = descendants(container, ephemera.selectedSelector + ',' + ephemera.firstSelectedSelector + ',' + ephemera.lastSelectedSelector);
        each$2(sels, removeSelectionAttributes);
      };
      var selectRange = function (container, cells, start, finish) {
        clear(container);
        each$2(cells, addSelectionAttribute);
        set$2(start, ephemera.firstSelected, '1');
        set$2(finish, ephemera.lastSelected, '1');
        onSelection(cells, start, finish);
      };
      return {
        clearBeforeUpdate: clearBeforeUpdate,
        clear: clear,
        selectRange: selectRange,
        selectedSelector: ephemera.selectedSelector,
        firstSelectedSelector: ephemera.firstSelectedSelector,
        lastSelectedSelector: ephemera.lastSelectedSelector
      };
    };
    var SelectionAnnotation = {
      byClass: byClass,
      byAttr: byAttr
    };

    var getUpOrLeftCells = function (grid, selectedCells) {
      var upGrid = grid.slice(0, selectedCells[selectedCells.length - 1].row + 1);
      var upDetails = toDetailList(upGrid);
      return bind$2(upDetails, function (detail) {
        var slicedCells = detail.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);
        return map$1(slicedCells, function (cell) {
          return cell.element;
        });
      });
    };
    var getDownOrRightCells = function (grid, selectedCells) {
      var downGrid = grid.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid.length);
      var downDetails = toDetailList(downGrid);
      return bind$2(downDetails, function (detail) {
        var slicedCells = detail.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail.cells.length);
        return map$1(slicedCells, function (cell) {
          return cell.element;
        });
      });
    };
    var getOtherCells = function (table, target, generators) {
      var warehouse = Warehouse.fromTable(table);
      var details = onCells(warehouse, target);
      return details.map(function (selectedCells) {
        var grid = toGrid(warehouse, generators, false);
        var upOrLeftCells = getUpOrLeftCells(grid, selectedCells);
        var downOrRightCells = getDownOrRightCells(grid, selectedCells);
        return {
          upOrLeftCells: upOrLeftCells,
          downOrRightCells: downOrRightCells
        };
      });
    };

    var global = tinymce.util.Tools.resolve('tinymce.Env');

    var hasInternalTarget = function (e) {
      return has(SugarElement.fromDom(e.target), 'ephox-snooker-resizer-bar') === false;
    };
    function CellSelection (editor, lazyResize, selectionTargets) {
      var onSelection = function (cells, start, finish) {
        selectionTargets.targets().each(function (targets) {
          var tableOpt = table(start);
          tableOpt.each(function (table) {
            var cloneFormats = getCloneElements(editor);
            var generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats);
            var otherCells = getOtherCells(table, targets, generators);
            fireTableSelectionChange(editor, cells, start, finish, otherCells);
          });
        });
      };
      var onClear = function () {
        return fireTableSelectionClear(editor);
      };
      var annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);
      editor.on('init', function (_e) {
        var win = editor.getWin();
        var body = getBody(editor);
        var isRoot = getIsRoot(editor);
        var syncSelection = function () {
          var sel = editor.selection;
          var start = SugarElement.fromDom(sel.getStart());
          var end = SugarElement.fromDom(sel.getEnd());
          var shared = sharedOne(table, [
            start,
            end
          ]);
          shared.fold(function () {
            return annotations.clear(body);
          }, noop);
        };
        var mouseHandlers = mouse(win, body, isRoot, annotations);
        var keyHandlers = keyboard(win, body, isRoot, annotations);
        var external$1 = external(win, body, isRoot, annotations);
        var hasShiftKey = function (event) {
          return event.raw.shiftKey === true;
        };
        editor.on('TableSelectorChange', function (e) {
          return external$1(e.start, e.finish);
        });
        var handleResponse = function (event, response) {
          if (!hasShiftKey(event)) {
            return;
          }
          if (response.kill) {
            event.kill();
          }
          response.selection.each(function (ns) {
            var relative = SimSelection.relative(ns.start, ns.finish);
            var rng = asLtrRange(win, relative);
            editor.selection.setRng(rng);
          });
        };
        var keyup = function (event) {
          var wrappedEvent = fromRawEvent(event);
          if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {
            var rng = editor.selection.getRng();
            var start = SugarElement.fromDom(rng.startContainer);
            var end = SugarElement.fromDom(rng.endContainer);
            keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(function (response) {
              handleResponse(wrappedEvent, response);
            });
          }
        };
        var keydown = function (event) {
          var wrappedEvent = fromRawEvent(event);
          lazyResize().each(function (resize) {
            return resize.hideBars();
          });
          var rng = editor.selection.getRng();
          var start = SugarElement.fromDom(rng.startContainer);
          var end = SugarElement.fromDom(rng.endContainer);
          var direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));
          keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(function (response) {
            handleResponse(wrappedEvent, response);
          });
          lazyResize().each(function (resize) {
            return resize.showBars();
          });
        };
        var isLeftMouse = function (raw) {
          return raw.button === 0;
        };
        var isLeftButtonPressed = function (raw) {
          if (raw.buttons === undefined) {
            return true;
          }
          if (global.browser.isEdge() && raw.buttons === 0) {
            return true;
          }
          return (raw.buttons & 1) !== 0;
        };
        var dragStart = function (_e) {
          mouseHandlers.clearstate();
        };
        var mouseDown = function (e) {
          if (isLeftMouse(e) && hasInternalTarget(e)) {
            mouseHandlers.mousedown(fromRawEvent(e));
          }
        };
        var mouseOver = function (e) {
          if (isLeftButtonPressed(e) && hasInternalTarget(e)) {
            mouseHandlers.mouseover(fromRawEvent(e));
          }
        };
        var mouseUp = function (e) {
          if (isLeftMouse(e) && hasInternalTarget(e)) {
            mouseHandlers.mouseup(fromRawEvent(e));
          }
        };
        var getDoubleTap = function () {
          var lastTarget = Cell(SugarElement.fromDom(body));
          var lastTimeStamp = Cell(0);
          var touchEnd = function (t) {
            var target = SugarElement.fromDom(t.target);
            if (name(target) === 'td' || name(target) === 'th') {
              var lT = lastTarget.get();
              var lTS = lastTimeStamp.get();
              if (eq$1(lT, target) && t.timeStamp - lTS < 300) {
                t.preventDefault();
                external$1(target, target);
              }
            }
            lastTarget.set(target);
            lastTimeStamp.set(t.timeStamp);
          };
          return { touchEnd: touchEnd };
        };
        var doubleTap = getDoubleTap();
        editor.on('dragstart', dragStart);
        editor.on('mousedown', mouseDown);
        editor.on('mouseover', mouseOver);
        editor.on('mouseup', mouseUp);
        editor.on('touchend', doubleTap.touchEnd);
        editor.on('keyup', keyup);
        editor.on('keydown', keydown);
        editor.on('NodeChange', syncSelection);
      });
      return { clear: annotations.clear };
    }

    var child = function (scope, selector) {
      return child$1(scope, selector).isSome();
    };

    var getSelectionTargets = function (editor, selections) {
      var targets = Cell(Optional.none());
      var changeHandlers = Cell([]);
      var selectionDetails = Optional.none();
      var isCaption = isTag('caption');
      var isDisabledForSelection = function (key) {
        return selectionDetails.forall(function (details) {
          return !details[key];
        });
      };
      var getStart = function () {
        return getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor));
      };
      var getEnd = function () {
        return getSelectionCellOrCaption(getSelectionEnd(editor), getIsRoot(editor));
      };
      var findTargets = function () {
        return getStart().bind(function (startCellOrCaption) {
          return flatten(lift2(table(startCellOrCaption), getEnd().bind(table), function (startTable, endTable) {
            if (eq$1(startTable, endTable)) {
              if (isCaption(startCellOrCaption)) {
                return Optional.some(noMenu(startCellOrCaption));
              } else {
                return Optional.some(forMenu(selections, startTable, startCellOrCaption));
              }
            }
            return Optional.none();
          }));
        });
      };
      var getExtractedDetails = function (targets) {
        var tableOpt = table(targets.element);
        return tableOpt.map(function (table) {
          var warehouse = Warehouse.fromTable(table);
          var selectedCells = onCells(warehouse, targets).getOr([]);
          var locked = foldl(selectedCells, function (acc, cell) {
            if (cell.isLocked) {
              acc.onAny = true;
              if (cell.column === 0) {
                acc.onFirst = true;
              } else if (cell.column + cell.colspan >= warehouse.grid.columns) {
                acc.onLast = true;
              }
            }
            return acc;
          }, {
            onAny: false,
            onFirst: false,
            onLast: false
          });
          return {
            mergeable: onUnlockedMergable(warehouse, targets).isSome(),
            unmergeable: onUnlockedUnmergable(warehouse, targets).isSome(),
            locked: locked
          };
        });
      };
      var resetTargets = function () {
        targets.set(cached(findTargets)());
        selectionDetails = targets.get().bind(getExtractedDetails);
        each$2(changeHandlers.get(), function (handler) {
          return handler();
        });
      };
      var setupHandler = function (handler) {
        handler();
        changeHandlers.set(changeHandlers.get().concat([handler]));
        return function () {
          changeHandlers.set(filter$2(changeHandlers.get(), function (h) {
            return h !== handler;
          }));
        };
      };
      var onSetup = function (api, isDisabled) {
        return setupHandler(function () {
          return targets.get().fold(function () {
            api.setDisabled(true);
          }, function (targets) {
            api.setDisabled(isDisabled(targets));
          });
        });
      };
      var onSetupWithToggle = function (api, isDisabled, isActive) {
        return setupHandler(function () {
          return targets.get().fold(function () {
            api.setDisabled(true);
            api.setActive(false);
          }, function (targets) {
            api.setDisabled(isDisabled(targets));
            api.setActive(isActive(targets));
          });
        });
      };
      var isDisabledFromLocked = function (lockedDisable) {
        return selectionDetails.exists(function (details) {
          return details.locked[lockedDisable];
        });
      };
      var onSetupTable = function (api) {
        return onSetup(api, function (_) {
          return false;
        });
      };
      var onSetupCellOrRow = function (api) {
        return onSetup(api, function (targets) {
          return isCaption(targets.element);
        });
      };
      var onSetupColumn = function (lockedDisable) {
        return function (api) {
          return onSetup(api, function (targets) {
            return isCaption(targets.element) || isDisabledFromLocked(lockedDisable);
          });
        };
      };
      var onSetupPasteable = function (getClipboardData) {
        return function (api) {
          return onSetup(api, function (targets) {
            return isCaption(targets.element) || getClipboardData().isNone();
          });
        };
      };
      var onSetupPasteableColumn = function (getClipboardData, lockedDisable) {
        return function (api) {
          return onSetup(api, function (targets) {
            return isCaption(targets.element) || getClipboardData().isNone() || isDisabledFromLocked(lockedDisable);
          });
        };
      };
      var onSetupMergeable = function (api) {
        return onSetup(api, function (_targets) {
          return isDisabledForSelection('mergeable');
        });
      };
      var onSetupUnmergeable = function (api) {
        return onSetup(api, function (_targets) {
          return isDisabledForSelection('unmergeable');
        });
      };
      var onSetupTableWithCaption = function (api) {
        return onSetupWithToggle(api, never, function (targets) {
          var tableOpt = table(targets.element, getIsRoot(editor));
          return tableOpt.exists(function (table) {
            return child(table, 'caption');
          });
        });
      };
      var onSetupTableHeaders = function (command, headerType) {
        return function (api) {
          return onSetupWithToggle(api, function (targets) {
            return isCaption(targets.element);
          }, function () {
            return editor.queryCommandValue(command) === headerType;
          });
        };
      };
      var onSetupTableRowHeaders = onSetupTableHeaders('mceTableRowType', 'header');
      var onSetupTableColumnHeaders = onSetupTableHeaders('mceTableColType', 'th');
      editor.on('NodeChange ExecCommand TableSelectorChange', resetTargets);
      return {
        onSetupTable: onSetupTable,
        onSetupCellOrRow: onSetupCellOrRow,
        onSetupColumn: onSetupColumn,
        onSetupPasteable: onSetupPasteable,
        onSetupPasteableColumn: onSetupPasteableColumn,
        onSetupMergeable: onSetupMergeable,
        onSetupUnmergeable: onSetupUnmergeable,
        resetTargets: resetTargets,
        onSetupTableWithCaption: onSetupTableWithCaption,
        onSetupTableRowHeaders: onSetupTableRowHeaders,
        onSetupTableColumnHeaders: onSetupTableColumnHeaders,
        targets: targets.get
      };
    };

    var addButtons = function (editor, selections, selectionTargets, clipboard) {
      editor.ui.registry.addMenuButton('table', {
        tooltip: 'Table',
        icon: 'table',
        fetch: function (callback) {
          return callback('inserttable | cell row column | advtablesort | tableprops deletetable');
        }
      });
      var cmd = function (command) {
        return function () {
          return editor.execCommand(command);
        };
      };
      editor.ui.registry.addButton('tableprops', {
        tooltip: 'Table properties',
        onAction: cmd('mceTableProps'),
        icon: 'table',
        onSetup: selectionTargets.onSetupTable
      });
      editor.ui.registry.addButton('tabledelete', {
        tooltip: 'Delete table',
        onAction: cmd('mceTableDelete'),
        icon: 'table-delete-table',
        onSetup: selectionTargets.onSetupTable
      });
      editor.ui.registry.addButton('tablecellprops', {
        tooltip: 'Cell properties',
        onAction: cmd('mceTableCellProps'),
        icon: 'table-cell-properties',
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tablemergecells', {
        tooltip: 'Merge cells',
        onAction: cmd('mceTableMergeCells'),
        icon: 'table-merge-cells',
        onSetup: selectionTargets.onSetupMergeable
      });
      editor.ui.registry.addButton('tablesplitcells', {
        tooltip: 'Split cell',
        onAction: cmd('mceTableSplitCells'),
        icon: 'table-split-cells',
        onSetup: selectionTargets.onSetupUnmergeable
      });
      editor.ui.registry.addButton('tableinsertrowbefore', {
        tooltip: 'Insert row before',
        onAction: cmd('mceTableInsertRowBefore'),
        icon: 'table-insert-row-above',
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tableinsertrowafter', {
        tooltip: 'Insert row after',
        onAction: cmd('mceTableInsertRowAfter'),
        icon: 'table-insert-row-after',
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tabledeleterow', {
        tooltip: 'Delete row',
        onAction: cmd('mceTableDeleteRow'),
        icon: 'table-delete-row',
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tablerowprops', {
        tooltip: 'Row properties',
        onAction: cmd('mceTableRowProps'),
        icon: 'table-row-properties',
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tableinsertcolbefore', {
        tooltip: 'Insert column before',
        onAction: cmd('mceTableInsertColBefore'),
        icon: 'table-insert-column-before',
        onSetup: selectionTargets.onSetupColumn('onFirst')
      });
      editor.ui.registry.addButton('tableinsertcolafter', {
        tooltip: 'Insert column after',
        onAction: cmd('mceTableInsertColAfter'),
        icon: 'table-insert-column-after',
        onSetup: selectionTargets.onSetupColumn('onLast')
      });
      editor.ui.registry.addButton('tabledeletecol', {
        tooltip: 'Delete column',
        onAction: cmd('mceTableDeleteCol'),
        icon: 'table-delete-column',
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addButton('tablecutrow', {
        tooltip: 'Cut row',
        icon: 'cut-row',
        onAction: cmd('mceTableCutRow'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tablecopyrow', {
        tooltip: 'Copy row',
        icon: 'duplicate-row',
        onAction: cmd('mceTableCopyRow'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addButton('tablepasterowbefore', {
        tooltip: 'Paste row before',
        icon: 'paste-row-before',
        onAction: cmd('mceTablePasteRowBefore'),
        onSetup: selectionTargets.onSetupPasteable(clipboard.getRows)
      });
      editor.ui.registry.addButton('tablepasterowafter', {
        tooltip: 'Paste row after',
        icon: 'paste-row-after',
        onAction: cmd('mceTablePasteRowAfter'),
        onSetup: selectionTargets.onSetupPasteable(clipboard.getRows)
      });
      editor.ui.registry.addButton('tablecutcol', {
        tooltip: 'Cut column',
        icon: 'cut-column',
        onAction: cmd('mceTableCutCol'),
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addButton('tablecopycol', {
        tooltip: 'Copy column',
        icon: 'duplicate-column',
        onAction: cmd('mceTableCopyCol'),
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addButton('tablepastecolbefore', {
        tooltip: 'Paste column before',
        icon: 'paste-column-before',
        onAction: cmd('mceTablePasteColBefore'),
        onSetup: selectionTargets.onSetupPasteableColumn(clipboard.getColumns, 'onFirst')
      });
      editor.ui.registry.addButton('tablepastecolafter', {
        tooltip: 'Paste column after',
        icon: 'paste-column-after',
        onAction: cmd('mceTablePasteColAfter'),
        onSetup: selectionTargets.onSetupPasteableColumn(clipboard.getColumns, 'onLast')
      });
      editor.ui.registry.addButton('tableinsertdialog', {
        tooltip: 'Insert table',
        onAction: cmd('mceInsertTable'),
        icon: 'table'
      });
      var tableClassList = filterNoneItem(getTableClassList(editor));
      if (tableClassList.length !== 0) {
        editor.ui.registry.addMenuButton('tableclass', {
          icon: 'table-classes',
          tooltip: 'Table styles',
          fetch: generateMenuItemsCallback(editor, selections, tableClassList, 'tableclass', function (value) {
            return editor.execCommand('mceTableToggleClass', false, value);
          }),
          onSetup: selectionTargets.onSetupTable
        });
      }
      var tableCellClassList = filterNoneItem(getCellClassList(editor));
      if (tableCellClassList.length !== 0) {
        editor.ui.registry.addMenuButton('tablecellclass', {
          icon: 'table-cell-classes',
          tooltip: 'Cell styles',
          fetch: generateMenuItemsCallback(editor, selections, tableCellClassList, 'tablecellclass', function (value) {
            return editor.execCommand('mceTableCellToggleClass', false, value);
          }),
          onSetup: selectionTargets.onSetupCellOrRow
        });
      }
      editor.ui.registry.addMenuButton('tablecellvalign', {
        icon: 'vertical-align',
        tooltip: 'Vertical align',
        fetch: generateMenuItemsCallback(editor, selections, verticalAlignValues, 'tablecellverticalalign', applyTableCellStyle(editor, 'vertical-align')),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuButton('tablecellborderwidth', {
        icon: 'border-width',
        tooltip: 'Border width',
        fetch: generateMenuItemsCallback(editor, selections, getTableBorderWidths(editor), 'tablecellborderwidth', applyTableCellStyle(editor, 'border-width')),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuButton('tablecellborderstyle', {
        icon: 'border-style',
        tooltip: 'Border style',
        fetch: generateMenuItemsCallback(editor, selections, getTableBorderStyles(editor), 'tablecellborderstyle', applyTableCellStyle(editor, 'border-style')),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addToggleButton('tablecaption', {
        tooltip: 'Table caption',
        onAction: cmd('mceTableToggleCaption'),
        icon: 'table-caption',
        onSetup: selectionTargets.onSetupTableWithCaption
      });
      editor.ui.registry.addMenuButton('tablecellbackgroundcolor', {
        icon: 'cell-background-color',
        tooltip: 'Background color',
        fetch: function (callback) {
          return callback(buildColorMenu(editor, getTableBackgroundColorMap(editor), 'background-color'));
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuButton('tablecellbordercolor', {
        icon: 'cell-border-color',
        tooltip: 'Border color',
        fetch: function (callback) {
          return callback(buildColorMenu(editor, getTableBorderColorMap(editor), 'border-color'));
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addToggleButton('tablerowheader', {
        tooltip: 'Row header',
        icon: 'table-top-header',
        onAction: changeRowHeader(editor),
        onSetup: selectionTargets.onSetupTableRowHeaders
      });
      editor.ui.registry.addToggleButton('tablecolheader', {
        tooltip: 'Column header',
        icon: 'table-left-header',
        onAction: changeColumnHeader(editor),
        onSetup: selectionTargets.onSetupTableColumnHeaders
      });
    };
    var addToolbars = function (editor) {
      var isTable = function (table) {
        return editor.dom.is(table, 'table') && editor.getBody().contains(table);
      };
      var toolbar = getToolbar(editor);
      if (toolbar.length > 0) {
        editor.ui.registry.addContextToolbar('table', {
          predicate: isTable,
          items: toolbar,
          scope: 'node',
          position: 'node'
        });
      }
    };

    var addMenuItems = function (editor, selections, selectionTargets, clipboard) {
      var cmd = function (command) {
        return function () {
          return editor.execCommand(command);
        };
      };
      var insertTableAction = function (data) {
        editor.execCommand('mceInsertTable', false, {
          rows: data.numRows,
          columns: data.numColumns
        });
      };
      var tableProperties = {
        text: 'Table properties',
        onSetup: selectionTargets.onSetupTable,
        onAction: cmd('mceTableProps')
      };
      var deleteTable = {
        text: 'Delete table',
        icon: 'table-delete-table',
        onSetup: selectionTargets.onSetupTable,
        onAction: cmd('mceTableDelete')
      };
      editor.ui.registry.addMenuItem('tableinsertrowbefore', {
        text: 'Insert row before',
        icon: 'table-insert-row-above',
        onAction: cmd('mceTableInsertRowBefore'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tableinsertrowafter', {
        text: 'Insert row after',
        icon: 'table-insert-row-after',
        onAction: cmd('mceTableInsertRowAfter'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tabledeleterow', {
        text: 'Delete row',
        icon: 'table-delete-row',
        onAction: cmd('mceTableDeleteRow'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tablerowprops', {
        text: 'Row properties',
        icon: 'table-row-properties',
        onAction: cmd('mceTableRowProps'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tablecutrow', {
        text: 'Cut row',
        icon: 'cut-row',
        onAction: cmd('mceTableCutRow'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tablecopyrow', {
        text: 'Copy row',
        icon: 'duplicate-row',
        onAction: cmd('mceTableCopyRow'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tablepasterowbefore', {
        text: 'Paste row before',
        icon: 'paste-row-before',
        onAction: cmd('mceTablePasteRowBefore'),
        onSetup: selectionTargets.onSetupPasteable(clipboard.getRows)
      });
      editor.ui.registry.addMenuItem('tablepasterowafter', {
        text: 'Paste row after',
        icon: 'paste-row-after',
        onAction: cmd('mceTablePasteRowAfter'),
        onSetup: selectionTargets.onSetupPasteable(clipboard.getRows)
      });
      var row = {
        type: 'nestedmenuitem',
        text: 'Row',
        getSubmenuItems: constant('tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter')
      };
      editor.ui.registry.addMenuItem('tableinsertcolumnbefore', {
        text: 'Insert column before',
        icon: 'table-insert-column-before',
        onAction: cmd('mceTableInsertColBefore'),
        onSetup: selectionTargets.onSetupColumn('onFirst')
      });
      editor.ui.registry.addMenuItem('tableinsertcolumnafter', {
        text: 'Insert column after',
        icon: 'table-insert-column-after',
        onAction: cmd('mceTableInsertColAfter'),
        onSetup: selectionTargets.onSetupColumn('onLast')
      });
      editor.ui.registry.addMenuItem('tabledeletecolumn', {
        text: 'Delete column',
        icon: 'table-delete-column',
        onAction: cmd('mceTableDeleteCol'),
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addMenuItem('tablecutcolumn', {
        text: 'Cut column',
        icon: 'cut-column',
        onAction: cmd('mceTableCutCol'),
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addMenuItem('tablecopycolumn', {
        text: 'Copy column',
        icon: 'duplicate-column',
        onAction: cmd('mceTableCopyCol'),
        onSetup: selectionTargets.onSetupColumn('onAny')
      });
      editor.ui.registry.addMenuItem('tablepastecolumnbefore', {
        text: 'Paste column before',
        icon: 'paste-column-before',
        onAction: cmd('mceTablePasteColBefore'),
        onSetup: selectionTargets.onSetupPasteableColumn(clipboard.getColumns, 'onFirst')
      });
      editor.ui.registry.addMenuItem('tablepastecolumnafter', {
        text: 'Paste column after',
        icon: 'paste-column-after',
        onAction: cmd('mceTablePasteColAfter'),
        onSetup: selectionTargets.onSetupPasteableColumn(clipboard.getColumns, 'onLast')
      });
      var column = {
        type: 'nestedmenuitem',
        text: 'Column',
        getSubmenuItems: constant('tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter')
      };
      editor.ui.registry.addMenuItem('tablecellprops', {
        text: 'Cell properties',
        icon: 'table-cell-properties',
        onAction: cmd('mceTableCellProps'),
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addMenuItem('tablemergecells', {
        text: 'Merge cells',
        icon: 'table-merge-cells',
        onAction: cmd('mceTableMergeCells'),
        onSetup: selectionTargets.onSetupMergeable
      });
      editor.ui.registry.addMenuItem('tablesplitcells', {
        text: 'Split cell',
        icon: 'table-split-cells',
        onAction: cmd('mceTableSplitCells'),
        onSetup: selectionTargets.onSetupUnmergeable
      });
      var cell = {
        type: 'nestedmenuitem',
        text: 'Cell',
        getSubmenuItems: constant('tablecellprops tablemergecells tablesplitcells')
      };
      if (hasTableGrid(editor) === false) {
        editor.ui.registry.addMenuItem('inserttable', {
          text: 'Table',
          icon: 'table',
          onAction: cmd('mceInsertTable')
        });
      } else {
        editor.ui.registry.addNestedMenuItem('inserttable', {
          text: 'Table',
          icon: 'table',
          getSubmenuItems: function () {
            return [{
                type: 'fancymenuitem',
                fancytype: 'inserttable',
                onAction: insertTableAction
              }];
          }
        });
      }
      editor.ui.registry.addMenuItem('inserttabledialog', {
        text: 'Insert table',
        icon: 'table',
        onAction: cmd('mceInsertTable')
      });
      editor.ui.registry.addMenuItem('tableprops', tableProperties);
      editor.ui.registry.addMenuItem('deletetable', deleteTable);
      editor.ui.registry.addNestedMenuItem('row', row);
      editor.ui.registry.addNestedMenuItem('column', column);
      editor.ui.registry.addNestedMenuItem('cell', cell);
      editor.ui.registry.addContextMenu('table', {
        update: function () {
          selectionTargets.resetTargets();
          return selectionTargets.targets().fold(constant(''), function (targets) {
            if (name(targets.element) === 'caption') {
              return 'tableprops deletetable';
            } else {
              return 'cell row column | advtablesort | tableprops deletetable';
            }
          });
        }
      });
      var tableClassList = filterNoneItem(getTableClassList(editor));
      if (tableClassList.length !== 0) {
        editor.ui.registry.addNestedMenuItem('tableclass', {
          icon: 'table-classes',
          text: 'Table styles',
          getSubmenuItems: function () {
            return buildMenuItems(editor, selections, tableClassList, 'tableclass', function (value) {
              return editor.execCommand('mceTableToggleClass', false, value);
            });
          },
          onSetup: selectionTargets.onSetupTable
        });
      }
      var tableCellClassList = filterNoneItem(getCellClassList(editor));
      if (tableCellClassList.length !== 0) {
        editor.ui.registry.addNestedMenuItem('tablecellclass', {
          icon: 'table-cell-classes',
          text: 'Cell styles',
          getSubmenuItems: function () {
            return buildMenuItems(editor, selections, tableCellClassList, 'tablecellclass', function (value) {
              return editor.execCommand('mceTableCellToggleClass', false, value);
            });
          },
          onSetup: selectionTargets.onSetupCellOrRow
        });
      }
      editor.ui.registry.addNestedMenuItem('tablecellvalign', {
        icon: 'vertical-align',
        text: 'Vertical align',
        getSubmenuItems: function () {
          return buildMenuItems(editor, selections, verticalAlignValues, 'tablecellverticalalign', applyTableCellStyle(editor, 'vertical-align'));
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addNestedMenuItem('tablecellborderwidth', {
        icon: 'border-width',
        text: 'Border width',
        getSubmenuItems: function () {
          return buildMenuItems(editor, selections, getTableBorderWidths(editor), 'tablecellborderwidth', applyTableCellStyle(editor, 'border-width'));
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addNestedMenuItem('tablecellborderstyle', {
        icon: 'border-style',
        text: 'Border style',
        getSubmenuItems: function () {
          return buildMenuItems(editor, selections, getTableBorderStyles(editor), 'tablecellborderstyle', applyTableCellStyle(editor, 'border-style'));
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addToggleMenuItem('tablecaption', {
        icon: 'table-caption',
        text: 'Table caption',
        onAction: cmd('mceTableToggleCaption'),
        onSetup: selectionTargets.onSetupTableWithCaption
      });
      editor.ui.registry.addNestedMenuItem('tablecellbackgroundcolor', {
        icon: 'cell-background-color',
        text: 'Background color',
        getSubmenuItems: function () {
          return buildColorMenu(editor, getTableBackgroundColorMap(editor), 'background-color');
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addNestedMenuItem('tablecellbordercolor', {
        icon: 'cell-border-color',
        text: 'Border color',
        getSubmenuItems: function () {
          return buildColorMenu(editor, getTableBorderColorMap(editor), 'border-color');
        },
        onSetup: selectionTargets.onSetupCellOrRow
      });
      editor.ui.registry.addToggleMenuItem('tablerowheader', {
        text: 'Row header',
        icon: 'table-top-header',
        onAction: changeRowHeader(editor),
        onSetup: selectionTargets.onSetupTableRowHeaders
      });
      editor.ui.registry.addToggleMenuItem('tablecolheader', {
        text: 'Column header',
        icon: 'table-left-header',
        onAction: changeColumnHeader(editor),
        onSetup: selectionTargets.onSetupTableColumnHeaders
      });
    };

    var Plugin = function (editor) {
      var selections = Selections(function () {
        return getBody(editor);
      }, function () {
        return getSelectionCell(getSelectionStart(editor), getIsRoot(editor));
      }, ephemera.selectedSelector);
      var selectionTargets = getSelectionTargets(editor, selections);
      var resizeHandler = getResizeHandler(editor);
      var cellSelection = CellSelection(editor, resizeHandler.lazyResize, selectionTargets);
      var actions = TableActions(editor, cellSelection, resizeHandler.lazyWire);
      var clipboard = Clipboard();
      registerCommands(editor, actions, cellSelection, selections, clipboard);
      registerQueryCommands(editor, actions, selections);
      registerEvents(editor, selections, actions);
      addMenuItems(editor, selections, selectionTargets, clipboard);
      addButtons(editor, selections, selectionTargets, clipboard);
      addToolbars(editor);
      editor.on('PreInit', function () {
        editor.serializer.addTempAttr(ephemera.firstSelected);
        editor.serializer.addTempAttr(ephemera.lastSelected);
        registerFormats(editor);
      });
      if (hasTabNavigation(editor)) {
        editor.on('keydown', function (e) {
          handle$1(e, editor, cellSelection);
        });
      }
      editor.on('remove', function () {
        resizeHandler.destroy();
      });
      return getApi(editor, clipboard, resizeHandler, selectionTargets);
    };
    function Plugin$1 () {
      global$3.add('table', Plugin);
    }

    Plugin$1();

}());


/***/ }),

/***/ "d85a":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "help" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/help')
//   ES2015:
//     import 'tinymce/plugins/help'
__webpack_require__("b094");

/***/ }),

/***/ "daed":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "print" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/print')
//   ES2015:
//     import 'tinymce/plugins/print'
__webpack_require__("dfc7c");

/***/ }),

/***/ "dfc7c":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var global = tinymce.util.Tools.resolve('tinymce.Env');

    var register$1 = function (editor) {
      editor.addCommand('mcePrint', function () {
        if (global.browser.isIE()) {
          editor.getDoc().execCommand('print', false, null);
        } else {
          editor.getWin().print();
        }
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mcePrint');
      };
      editor.ui.registry.addButton('print', {
        icon: 'print',
        tooltip: 'Print',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('print', {
        text: 'Print...',
        icon: 'print',
        onAction: onAction
      });
    };

    function Plugin () {
      global$1.add('print', function (editor) {
        register$1(editor);
        register(editor);
        editor.addShortcut('Meta+P', '', 'mcePrint');
      });
    }

    Plugin();

}());


/***/ }),

/***/ "e2b6":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "fullscreen" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/fullscreen')
//   ES2015:
//     import 'tinymce/plugins/fullscreen'
__webpack_require__("83d4");

/***/ }),

/***/ "eac6":
/***/ (function(module, exports) {

// Source: npm package: emojilib, file:emojis.json
window.tinymce.Resource.add("tinymce.plugins.emoticons", {
  grinning: {
    keywords: [ "face", "smile", "happy", "joy", ":D", "grin" ],
    char: "\ud83d\ude00",
    fitzpatrick_scale: false,
    category: "people"
  },
  grimacing: {
    keywords: [ "face", "grimace", "teeth" ],
    char: "\ud83d\ude2c",
    fitzpatrick_scale: false,
    category: "people"
  },
  grin: {
    keywords: [ "face", "happy", "smile", "joy", "kawaii" ],
    char: "\ud83d\ude01",
    fitzpatrick_scale: false,
    category: "people"
  },
  joy: {
    keywords: [ "face", "cry", "tears", "weep", "happy", "happytears", "haha" ],
    char: "\ud83d\ude02",
    fitzpatrick_scale: false,
    category: "people"
  },
  rofl: {
    keywords: [ "face", "rolling", "floor", "laughing", "lol", "haha" ],
    char: "\ud83e\udd23",
    fitzpatrick_scale: false,
    category: "people"
  },
  partying: {
    keywords: [ "face", "celebration", "woohoo" ],
    char: "\ud83e\udd73",
    fitzpatrick_scale: false,
    category: "people"
  },
  smiley: {
    keywords: [ "face", "happy", "joy", "haha", ":D", ":)", "smile", "funny" ],
    char: "\ud83d\ude03",
    fitzpatrick_scale: false,
    category: "people"
  },
  smile: {
    keywords: [ "face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)" ],
    char: "\ud83d\ude04",
    fitzpatrick_scale: false,
    category: "people"
  },
  sweat_smile: {
    keywords: [ "face", "hot", "happy", "laugh", "sweat", "smile", "relief" ],
    char: "\ud83d\ude05",
    fitzpatrick_scale: false,
    category: "people"
  },
  laughing: {
    keywords: [ "happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh" ],
    char: "\ud83d\ude06",
    fitzpatrick_scale: false,
    category: "people"
  },
  innocent: {
    keywords: [ "face", "angel", "heaven", "halo" ],
    char: "\ud83d\ude07",
    fitzpatrick_scale: false,
    category: "people"
  },
  wink: {
    keywords: [ "face", "happy", "mischievous", "secret", ";)", "smile", "eye" ],
    char: "\ud83d\ude09",
    fitzpatrick_scale: false,
    category: "people"
  },
  blush: {
    keywords: [ "face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy" ],
    char: "\ud83d\ude0a",
    fitzpatrick_scale: false,
    category: "people"
  },
  slightly_smiling_face: {
    keywords: [ "face", "smile" ],
    char: "\ud83d\ude42",
    fitzpatrick_scale: false,
    category: "people"
  },
  upside_down_face: {
    keywords: [ "face", "flipped", "silly", "smile" ],
    char: "\ud83d\ude43",
    fitzpatrick_scale: false,
    category: "people"
  },
  relaxed: {
    keywords: [ "face", "blush", "massage", "happiness" ],
    char: "\u263a\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  yum: {
    keywords: [ "happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring" ],
    char: "\ud83d\ude0b",
    fitzpatrick_scale: false,
    category: "people"
  },
  relieved: {
    keywords: [ "face", "relaxed", "phew", "massage", "happiness" ],
    char: "\ud83d\ude0c",
    fitzpatrick_scale: false,
    category: "people"
  },
  heart_eyes: {
    keywords: [ "face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart" ],
    char: "\ud83d\ude0d",
    fitzpatrick_scale: false,
    category: "people"
  },
  smiling_face_with_three_hearts: {
    keywords: [ "face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore" ],
    char: "\ud83e\udd70",
    fitzpatrick_scale: false,
    category: "people"
  },
  kissing_heart: {
    keywords: [ "face", "love", "like", "affection", "valentines", "infatuation", "kiss" ],
    char: "\ud83d\ude18",
    fitzpatrick_scale: false,
    category: "people"
  },
  kissing: {
    keywords: [ "love", "like", "face", "3", "valentines", "infatuation", "kiss" ],
    char: "\ud83d\ude17",
    fitzpatrick_scale: false,
    category: "people"
  },
  kissing_smiling_eyes: {
    keywords: [ "face", "affection", "valentines", "infatuation", "kiss" ],
    char: "\ud83d\ude19",
    fitzpatrick_scale: false,
    category: "people"
  },
  kissing_closed_eyes: {
    keywords: [ "face", "love", "like", "affection", "valentines", "infatuation", "kiss" ],
    char: "\ud83d\ude1a",
    fitzpatrick_scale: false,
    category: "people"
  },
  stuck_out_tongue_winking_eye: {
    keywords: [ "face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue" ],
    char: "\ud83d\ude1c",
    fitzpatrick_scale: false,
    category: "people"
  },
  zany: {
    keywords: [ "face", "goofy", "crazy" ],
    char: "\ud83e\udd2a",
    fitzpatrick_scale: false,
    category: "people"
  },
  raised_eyebrow: {
    keywords: [ "face", "distrust", "scepticism", "disapproval", "disbelief", "surprise" ],
    char: "\ud83e\udd28",
    fitzpatrick_scale: false,
    category: "people"
  },
  monocle: {
    keywords: [ "face", "stuffy", "wealthy" ],
    char: "\ud83e\uddd0",
    fitzpatrick_scale: false,
    category: "people"
  },
  stuck_out_tongue_closed_eyes: {
    keywords: [ "face", "prank", "playful", "mischievous", "smile", "tongue" ],
    char: "\ud83d\ude1d",
    fitzpatrick_scale: false,
    category: "people"
  },
  stuck_out_tongue: {
    keywords: [ "face", "prank", "childish", "playful", "mischievous", "smile", "tongue" ],
    char: "\ud83d\ude1b",
    fitzpatrick_scale: false,
    category: "people"
  },
  money_mouth_face: {
    keywords: [ "face", "rich", "dollar", "money" ],
    char: "\ud83e\udd11",
    fitzpatrick_scale: false,
    category: "people"
  },
  nerd_face: {
    keywords: [ "face", "nerdy", "geek", "dork" ],
    char: "\ud83e\udd13",
    fitzpatrick_scale: false,
    category: "people"
  },
  sunglasses: {
    keywords: [ "face", "cool", "smile", "summer", "beach", "sunglass" ],
    char: "\ud83d\ude0e",
    fitzpatrick_scale: false,
    category: "people"
  },
  star_struck: {
    keywords: [ "face", "smile", "starry", "eyes", "grinning" ],
    char: "\ud83e\udd29",
    fitzpatrick_scale: false,
    category: "people"
  },
  clown_face: {
    keywords: [ "face" ],
    char: "\ud83e\udd21",
    fitzpatrick_scale: false,
    category: "people"
  },
  cowboy_hat_face: {
    keywords: [ "face", "cowgirl", "hat" ],
    char: "\ud83e\udd20",
    fitzpatrick_scale: false,
    category: "people"
  },
  hugs: {
    keywords: [ "face", "smile", "hug" ],
    char: "\ud83e\udd17",
    fitzpatrick_scale: false,
    category: "people"
  },
  smirk: {
    keywords: [ "face", "smile", "mean", "prank", "smug", "sarcasm" ],
    char: "\ud83d\ude0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  no_mouth: {
    keywords: [ "face", "hellokitty" ],
    char: "\ud83d\ude36",
    fitzpatrick_scale: false,
    category: "people"
  },
  neutral_face: {
    keywords: [ "indifference", "meh", ":|", "neutral" ],
    char: "\ud83d\ude10",
    fitzpatrick_scale: false,
    category: "people"
  },
  expressionless: {
    keywords: [ "face", "indifferent", "-_-", "meh", "deadpan" ],
    char: "\ud83d\ude11",
    fitzpatrick_scale: false,
    category: "people"
  },
  unamused: {
    keywords: [ "indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye" ],
    char: "\ud83d\ude12",
    fitzpatrick_scale: false,
    category: "people"
  },
  roll_eyes: {
    keywords: [ "face", "eyeroll", "frustrated" ],
    char: "\ud83d\ude44",
    fitzpatrick_scale: false,
    category: "people"
  },
  thinking: {
    keywords: [ "face", "hmmm", "think", "consider" ],
    char: "\ud83e\udd14",
    fitzpatrick_scale: false,
    category: "people"
  },
  lying_face: {
    keywords: [ "face", "lie", "pinocchio" ],
    char: "\ud83e\udd25",
    fitzpatrick_scale: false,
    category: "people"
  },
  hand_over_mouth: {
    keywords: [ "face", "whoops", "shock", "surprise" ],
    char: "\ud83e\udd2d",
    fitzpatrick_scale: false,
    category: "people"
  },
  shushing: {
    keywords: [ "face", "quiet", "shhh" ],
    char: "\ud83e\udd2b",
    fitzpatrick_scale: false,
    category: "people"
  },
  symbols_over_mouth: {
    keywords: [ "face", "swearing", "cursing", "cussing", "profanity", "expletive" ],
    char: "\ud83e\udd2c",
    fitzpatrick_scale: false,
    category: "people"
  },
  exploding_head: {
    keywords: [ "face", "shocked", "mind", "blown" ],
    char: "\ud83e\udd2f",
    fitzpatrick_scale: false,
    category: "people"
  },
  flushed: {
    keywords: [ "face", "blush", "shy", "flattered" ],
    char: "\ud83d\ude33",
    fitzpatrick_scale: false,
    category: "people"
  },
  disappointed: {
    keywords: [ "face", "sad", "upset", "depressed", ":(" ],
    char: "\ud83d\ude1e",
    fitzpatrick_scale: false,
    category: "people"
  },
  worried: {
    keywords: [ "face", "concern", "nervous", ":(" ],
    char: "\ud83d\ude1f",
    fitzpatrick_scale: false,
    category: "people"
  },
  angry: {
    keywords: [ "mad", "face", "annoyed", "frustrated" ],
    char: "\ud83d\ude20",
    fitzpatrick_scale: false,
    category: "people"
  },
  rage: {
    keywords: [ "angry", "mad", "hate", "despise" ],
    char: "\ud83d\ude21",
    fitzpatrick_scale: false,
    category: "people"
  },
  pensive: {
    keywords: [ "face", "sad", "depressed", "upset" ],
    char: "\ud83d\ude14",
    fitzpatrick_scale: false,
    category: "people"
  },
  confused: {
    keywords: [ "face", "indifference", "huh", "weird", "hmmm", ":/" ],
    char: "\ud83d\ude15",
    fitzpatrick_scale: false,
    category: "people"
  },
  slightly_frowning_face: {
    keywords: [ "face", "frowning", "disappointed", "sad", "upset" ],
    char: "\ud83d\ude41",
    fitzpatrick_scale: false,
    category: "people"
  },
  frowning_face: {
    keywords: [ "face", "sad", "upset", "frown" ],
    char: "\u2639",
    fitzpatrick_scale: false,
    category: "people"
  },
  persevere: {
    keywords: [ "face", "sick", "no", "upset", "oops" ],
    char: "\ud83d\ude23",
    fitzpatrick_scale: false,
    category: "people"
  },
  confounded: {
    keywords: [ "face", "confused", "sick", "unwell", "oops", ":S" ],
    char: "\ud83d\ude16",
    fitzpatrick_scale: false,
    category: "people"
  },
  tired_face: {
    keywords: [ "sick", "whine", "upset", "frustrated" ],
    char: "\ud83d\ude2b",
    fitzpatrick_scale: false,
    category: "people"
  },
  weary: {
    keywords: [ "face", "tired", "sleepy", "sad", "frustrated", "upset" ],
    char: "\ud83d\ude29",
    fitzpatrick_scale: false,
    category: "people"
  },
  pleading: {
    keywords: [ "face", "begging", "mercy" ],
    char: "\ud83e\udd7a",
    fitzpatrick_scale: false,
    category: "people"
  },
  triumph: {
    keywords: [ "face", "gas", "phew", "proud", "pride" ],
    char: "\ud83d\ude24",
    fitzpatrick_scale: false,
    category: "people"
  },
  open_mouth: {
    keywords: [ "face", "surprise", "impressed", "wow", "whoa", ":O" ],
    char: "\ud83d\ude2e",
    fitzpatrick_scale: false,
    category: "people"
  },
  scream: {
    keywords: [ "face", "munch", "scared", "omg" ],
    char: "\ud83d\ude31",
    fitzpatrick_scale: false,
    category: "people"
  },
  fearful: {
    keywords: [ "face", "scared", "terrified", "nervous", "oops", "huh" ],
    char: "\ud83d\ude28",
    fitzpatrick_scale: false,
    category: "people"
  },
  cold_sweat: {
    keywords: [ "face", "nervous", "sweat" ],
    char: "\ud83d\ude30",
    fitzpatrick_scale: false,
    category: "people"
  },
  hushed: {
    keywords: [ "face", "woo", "shh" ],
    char: "\ud83d\ude2f",
    fitzpatrick_scale: false,
    category: "people"
  },
  frowning: {
    keywords: [ "face", "aw", "what" ],
    char: "\ud83d\ude26",
    fitzpatrick_scale: false,
    category: "people"
  },
  anguished: {
    keywords: [ "face", "stunned", "nervous" ],
    char: "\ud83d\ude27",
    fitzpatrick_scale: false,
    category: "people"
  },
  cry: {
    keywords: [ "face", "tears", "sad", "depressed", "upset", ":'(" ],
    char: "\ud83d\ude22",
    fitzpatrick_scale: false,
    category: "people"
  },
  disappointed_relieved: {
    keywords: [ "face", "phew", "sweat", "nervous" ],
    char: "\ud83d\ude25",
    fitzpatrick_scale: false,
    category: "people"
  },
  drooling_face: {
    keywords: [ "face" ],
    char: "\ud83e\udd24",
    fitzpatrick_scale: false,
    category: "people"
  },
  sleepy: {
    keywords: [ "face", "tired", "rest", "nap" ],
    char: "\ud83d\ude2a",
    fitzpatrick_scale: false,
    category: "people"
  },
  sweat: {
    keywords: [ "face", "hot", "sad", "tired", "exercise" ],
    char: "\ud83d\ude13",
    fitzpatrick_scale: false,
    category: "people"
  },
  hot: {
    keywords: [ "face", "feverish", "heat", "red", "sweating" ],
    char: "\ud83e\udd75",
    fitzpatrick_scale: false,
    category: "people"
  },
  cold: {
    keywords: [ "face", "blue", "freezing", "frozen", "frostbite", "icicles" ],
    char: "\ud83e\udd76",
    fitzpatrick_scale: false,
    category: "people"
  },
  sob: {
    keywords: [ "face", "cry", "tears", "sad", "upset", "depressed" ],
    char: "\ud83d\ude2d",
    fitzpatrick_scale: false,
    category: "people"
  },
  dizzy_face: {
    keywords: [ "spent", "unconscious", "xox", "dizzy" ],
    char: "\ud83d\ude35",
    fitzpatrick_scale: false,
    category: "people"
  },
  astonished: {
    keywords: [ "face", "xox", "surprised", "poisoned" ],
    char: "\ud83d\ude32",
    fitzpatrick_scale: false,
    category: "people"
  },
  zipper_mouth_face: {
    keywords: [ "face", "sealed", "zipper", "secret" ],
    char: "\ud83e\udd10",
    fitzpatrick_scale: false,
    category: "people"
  },
  nauseated_face: {
    keywords: [ "face", "vomit", "gross", "green", "sick", "throw up", "ill" ],
    char: "\ud83e\udd22",
    fitzpatrick_scale: false,
    category: "people"
  },
  sneezing_face: {
    keywords: [ "face", "gesundheit", "sneeze", "sick", "allergy" ],
    char: "\ud83e\udd27",
    fitzpatrick_scale: false,
    category: "people"
  },
  vomiting: {
    keywords: [ "face", "sick" ],
    char: "\ud83e\udd2e",
    fitzpatrick_scale: false,
    category: "people"
  },
  mask: {
    keywords: [ "face", "sick", "ill", "disease" ],
    char: "\ud83d\ude37",
    fitzpatrick_scale: false,
    category: "people"
  },
  face_with_thermometer: {
    keywords: [ "sick", "temperature", "thermometer", "cold", "fever" ],
    char: "\ud83e\udd12",
    fitzpatrick_scale: false,
    category: "people"
  },
  face_with_head_bandage: {
    keywords: [ "injured", "clumsy", "bandage", "hurt" ],
    char: "\ud83e\udd15",
    fitzpatrick_scale: false,
    category: "people"
  },
  woozy: {
    keywords: [ "face", "dizzy", "intoxicated", "tipsy", "wavy" ],
    char: "\ud83e\udd74",
    fitzpatrick_scale: false,
    category: "people"
  },
  sleeping: {
    keywords: [ "face", "tired", "sleepy", "night", "zzz" ],
    char: "\ud83d\ude34",
    fitzpatrick_scale: false,
    category: "people"
  },
  zzz: {
    keywords: [ "sleepy", "tired", "dream" ],
    char: "\ud83d\udca4",
    fitzpatrick_scale: false,
    category: "people"
  },
  poop: {
    keywords: [ "hankey", "shitface", "fail", "turd", "shit" ],
    char: "\ud83d\udca9",
    fitzpatrick_scale: false,
    category: "people"
  },
  smiling_imp: {
    keywords: [ "devil", "horns" ],
    char: "\ud83d\ude08",
    fitzpatrick_scale: false,
    category: "people"
  },
  imp: {
    keywords: [ "devil", "angry", "horns" ],
    char: "\ud83d\udc7f",
    fitzpatrick_scale: false,
    category: "people"
  },
  japanese_ogre: {
    keywords: [ "monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre" ],
    char: "\ud83d\udc79",
    fitzpatrick_scale: false,
    category: "people"
  },
  japanese_goblin: {
    keywords: [ "red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin" ],
    char: "\ud83d\udc7a",
    fitzpatrick_scale: false,
    category: "people"
  },
  skull: {
    keywords: [ "dead", "skeleton", "creepy", "death" ],
    char: "\ud83d\udc80",
    fitzpatrick_scale: false,
    category: "people"
  },
  ghost: {
    keywords: [ "halloween", "spooky", "scary" ],
    char: "\ud83d\udc7b",
    fitzpatrick_scale: false,
    category: "people"
  },
  alien: {
    keywords: [ "UFO", "paul", "weird", "outer_space" ],
    char: "\ud83d\udc7d",
    fitzpatrick_scale: false,
    category: "people"
  },
  robot: {
    keywords: [ "computer", "machine", "bot" ],
    char: "\ud83e\udd16",
    fitzpatrick_scale: false,
    category: "people"
  },
  smiley_cat: {
    keywords: [ "animal", "cats", "happy", "smile" ],
    char: "\ud83d\ude3a",
    fitzpatrick_scale: false,
    category: "people"
  },
  smile_cat: {
    keywords: [ "animal", "cats", "smile" ],
    char: "\ud83d\ude38",
    fitzpatrick_scale: false,
    category: "people"
  },
  joy_cat: {
    keywords: [ "animal", "cats", "haha", "happy", "tears" ],
    char: "\ud83d\ude39",
    fitzpatrick_scale: false,
    category: "people"
  },
  heart_eyes_cat: {
    keywords: [ "animal", "love", "like", "affection", "cats", "valentines", "heart" ],
    char: "\ud83d\ude3b",
    fitzpatrick_scale: false,
    category: "people"
  },
  smirk_cat: {
    keywords: [ "animal", "cats", "smirk" ],
    char: "\ud83d\ude3c",
    fitzpatrick_scale: false,
    category: "people"
  },
  kissing_cat: {
    keywords: [ "animal", "cats", "kiss" ],
    char: "\ud83d\ude3d",
    fitzpatrick_scale: false,
    category: "people"
  },
  scream_cat: {
    keywords: [ "animal", "cats", "munch", "scared", "scream" ],
    char: "\ud83d\ude40",
    fitzpatrick_scale: false,
    category: "people"
  },
  crying_cat_face: {
    keywords: [ "animal", "tears", "weep", "sad", "cats", "upset", "cry" ],
    char: "\ud83d\ude3f",
    fitzpatrick_scale: false,
    category: "people"
  },
  pouting_cat: {
    keywords: [ "animal", "cats" ],
    char: "\ud83d\ude3e",
    fitzpatrick_scale: false,
    category: "people"
  },
  palms_up: {
    keywords: [ "hands", "gesture", "cupped", "prayer" ],
    char: "\ud83e\udd32",
    fitzpatrick_scale: true,
    category: "people"
  },
  raised_hands: {
    keywords: [ "gesture", "hooray", "yea", "celebration", "hands" ],
    char: "\ud83d\ude4c",
    fitzpatrick_scale: true,
    category: "people"
  },
  clap: {
    keywords: [ "hands", "praise", "applause", "congrats", "yay" ],
    char: "\ud83d\udc4f",
    fitzpatrick_scale: true,
    category: "people"
  },
  wave: {
    keywords: [ "hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm" ],
    char: "\ud83d\udc4b",
    fitzpatrick_scale: true,
    category: "people"
  },
  call_me_hand: {
    keywords: [ "hands", "gesture" ],
    char: "\ud83e\udd19",
    fitzpatrick_scale: true,
    category: "people"
  },
  "+1": {
    keywords: [ "thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like" ],
    char: "\ud83d\udc4d",
    fitzpatrick_scale: true,
    category: "people"
  },
  "-1": {
    keywords: [ "thumbsdown", "no", "dislike", "hand" ],
    char: "\ud83d\udc4e",
    fitzpatrick_scale: true,
    category: "people"
  },
  facepunch: {
    keywords: [ "angry", "violence", "fist", "hit", "attack", "hand" ],
    char: "\ud83d\udc4a",
    fitzpatrick_scale: true,
    category: "people"
  },
  fist: {
    keywords: [ "fingers", "hand", "grasp" ],
    char: "\u270a",
    fitzpatrick_scale: true,
    category: "people"
  },
  fist_left: {
    keywords: [ "hand", "fistbump" ],
    char: "\ud83e\udd1b",
    fitzpatrick_scale: true,
    category: "people"
  },
  fist_right: {
    keywords: [ "hand", "fistbump" ],
    char: "\ud83e\udd1c",
    fitzpatrick_scale: true,
    category: "people"
  },
  v: {
    keywords: [ "fingers", "ohyeah", "hand", "peace", "victory", "two" ],
    char: "\u270c",
    fitzpatrick_scale: true,
    category: "people"
  },
  ok_hand: {
    keywords: [ "fingers", "limbs", "perfect", "ok", "okay" ],
    char: "\ud83d\udc4c",
    fitzpatrick_scale: true,
    category: "people"
  },
  raised_hand: {
    keywords: [ "fingers", "stop", "highfive", "palm", "ban" ],
    char: "\u270b",
    fitzpatrick_scale: true,
    category: "people"
  },
  raised_back_of_hand: {
    keywords: [ "fingers", "raised", "backhand" ],
    char: "\ud83e\udd1a",
    fitzpatrick_scale: true,
    category: "people"
  },
  open_hands: {
    keywords: [ "fingers", "butterfly", "hands", "open" ],
    char: "\ud83d\udc50",
    fitzpatrick_scale: true,
    category: "people"
  },
  muscle: {
    keywords: [ "arm", "flex", "hand", "summer", "strong", "biceps" ],
    char: "\ud83d\udcaa",
    fitzpatrick_scale: true,
    category: "people"
  },
  pray: {
    keywords: [ "please", "hope", "wish", "namaste", "highfive" ],
    char: "\ud83d\ude4f",
    fitzpatrick_scale: true,
    category: "people"
  },
  foot: {
    keywords: [ "kick", "stomp" ],
    char: "\ud83e\uddb6",
    fitzpatrick_scale: true,
    category: "people"
  },
  leg: {
    keywords: [ "kick", "limb" ],
    char: "\ud83e\uddb5",
    fitzpatrick_scale: true,
    category: "people"
  },
  handshake: {
    keywords: [ "agreement", "shake" ],
    char: "\ud83e\udd1d",
    fitzpatrick_scale: false,
    category: "people"
  },
  point_up: {
    keywords: [ "hand", "fingers", "direction", "up" ],
    char: "\u261d",
    fitzpatrick_scale: true,
    category: "people"
  },
  point_up_2: {
    keywords: [ "fingers", "hand", "direction", "up" ],
    char: "\ud83d\udc46",
    fitzpatrick_scale: true,
    category: "people"
  },
  point_down: {
    keywords: [ "fingers", "hand", "direction", "down" ],
    char: "\ud83d\udc47",
    fitzpatrick_scale: true,
    category: "people"
  },
  point_left: {
    keywords: [ "direction", "fingers", "hand", "left" ],
    char: "\ud83d\udc48",
    fitzpatrick_scale: true,
    category: "people"
  },
  point_right: {
    keywords: [ "fingers", "hand", "direction", "right" ],
    char: "\ud83d\udc49",
    fitzpatrick_scale: true,
    category: "people"
  },
  fu: {
    keywords: [ "hand", "fingers", "rude", "middle", "flipping" ],
    char: "\ud83d\udd95",
    fitzpatrick_scale: true,
    category: "people"
  },
  raised_hand_with_fingers_splayed: {
    keywords: [ "hand", "fingers", "palm" ],
    char: "\ud83d\udd90",
    fitzpatrick_scale: true,
    category: "people"
  },
  love_you: {
    keywords: [ "hand", "fingers", "gesture" ],
    char: "\ud83e\udd1f",
    fitzpatrick_scale: true,
    category: "people"
  },
  metal: {
    keywords: [ "hand", "fingers", "evil_eye", "sign_of_horns", "rock_on" ],
    char: "\ud83e\udd18",
    fitzpatrick_scale: true,
    category: "people"
  },
  crossed_fingers: {
    keywords: [ "good", "lucky" ],
    char: "\ud83e\udd1e",
    fitzpatrick_scale: true,
    category: "people"
  },
  vulcan_salute: {
    keywords: [ "hand", "fingers", "spock", "star trek" ],
    char: "\ud83d\udd96",
    fitzpatrick_scale: true,
    category: "people"
  },
  writing_hand: {
    keywords: [ "lower_left_ballpoint_pen", "stationery", "write", "compose" ],
    char: "\u270d",
    fitzpatrick_scale: true,
    category: "people"
  },
  selfie: {
    keywords: [ "camera", "phone" ],
    char: "\ud83e\udd33",
    fitzpatrick_scale: true,
    category: "people"
  },
  nail_care: {
    keywords: [ "beauty", "manicure", "finger", "fashion", "nail" ],
    char: "\ud83d\udc85",
    fitzpatrick_scale: true,
    category: "people"
  },
  lips: {
    keywords: [ "mouth", "kiss" ],
    char: "\ud83d\udc44",
    fitzpatrick_scale: false,
    category: "people"
  },
  tooth: {
    keywords: [ "teeth", "dentist" ],
    char: "\ud83e\uddb7",
    fitzpatrick_scale: false,
    category: "people"
  },
  tongue: {
    keywords: [ "mouth", "playful" ],
    char: "\ud83d\udc45",
    fitzpatrick_scale: false,
    category: "people"
  },
  ear: {
    keywords: [ "face", "hear", "sound", "listen" ],
    char: "\ud83d\udc42",
    fitzpatrick_scale: true,
    category: "people"
  },
  nose: {
    keywords: [ "smell", "sniff" ],
    char: "\ud83d\udc43",
    fitzpatrick_scale: true,
    category: "people"
  },
  eye: {
    keywords: [ "face", "look", "see", "watch", "stare" ],
    char: "\ud83d\udc41",
    fitzpatrick_scale: false,
    category: "people"
  },
  eyes: {
    keywords: [ "look", "watch", "stalk", "peek", "see" ],
    char: "\ud83d\udc40",
    fitzpatrick_scale: false,
    category: "people"
  },
  brain: {
    keywords: [ "smart", "intelligent" ],
    char: "\ud83e\udde0",
    fitzpatrick_scale: false,
    category: "people"
  },
  bust_in_silhouette: {
    keywords: [ "user", "person", "human" ],
    char: "\ud83d\udc64",
    fitzpatrick_scale: false,
    category: "people"
  },
  busts_in_silhouette: {
    keywords: [ "user", "person", "human", "group", "team" ],
    char: "\ud83d\udc65",
    fitzpatrick_scale: false,
    category: "people"
  },
  speaking_head: {
    keywords: [ "user", "person", "human", "sing", "say", "talk" ],
    char: "\ud83d\udde3",
    fitzpatrick_scale: false,
    category: "people"
  },
  baby: {
    keywords: [ "child", "boy", "girl", "toddler" ],
    char: "\ud83d\udc76",
    fitzpatrick_scale: true,
    category: "people"
  },
  child: {
    keywords: [ "gender-neutral", "young" ],
    char: "\ud83e\uddd2",
    fitzpatrick_scale: true,
    category: "people"
  },
  boy: {
    keywords: [ "man", "male", "guy", "teenager" ],
    char: "\ud83d\udc66",
    fitzpatrick_scale: true,
    category: "people"
  },
  girl: {
    keywords: [ "female", "woman", "teenager" ],
    char: "\ud83d\udc67",
    fitzpatrick_scale: true,
    category: "people"
  },
  adult: {
    keywords: [ "gender-neutral", "person" ],
    char: "\ud83e\uddd1",
    fitzpatrick_scale: true,
    category: "people"
  },
  man: {
    keywords: [ "mustache", "father", "dad", "guy", "classy", "sir", "moustache" ],
    char: "\ud83d\udc68",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman: {
    keywords: [ "female", "girls", "lady" ],
    char: "\ud83d\udc69",
    fitzpatrick_scale: true,
    category: "people"
  },
  blonde_woman: {
    keywords: [ "woman", "female", "girl", "blonde", "person" ],
    char: "\ud83d\udc71\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  blonde_man: {
    keywords: [ "man", "male", "boy", "blonde", "guy", "person" ],
    char: "\ud83d\udc71",
    fitzpatrick_scale: true,
    category: "people"
  },
  bearded_person: {
    keywords: [ "person", "bewhiskered" ],
    char: "\ud83e\uddd4",
    fitzpatrick_scale: true,
    category: "people"
  },
  older_adult: {
    keywords: [ "human", "elder", "senior", "gender-neutral" ],
    char: "\ud83e\uddd3",
    fitzpatrick_scale: true,
    category: "people"
  },
  older_man: {
    keywords: [ "human", "male", "men", "old", "elder", "senior" ],
    char: "\ud83d\udc74",
    fitzpatrick_scale: true,
    category: "people"
  },
  older_woman: {
    keywords: [ "human", "female", "women", "lady", "old", "elder", "senior" ],
    char: "\ud83d\udc75",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_with_gua_pi_mao: {
    keywords: [ "male", "boy", "chinese" ],
    char: "\ud83d\udc72",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_with_headscarf: {
    keywords: [ "female", "hijab", "mantilla", "tichel" ],
    char: "\ud83e\uddd5",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_with_turban: {
    keywords: [ "female", "indian", "hinduism", "arabs", "woman" ],
    char: "\ud83d\udc73\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_with_turban: {
    keywords: [ "male", "indian", "hinduism", "arabs" ],
    char: "\ud83d\udc73",
    fitzpatrick_scale: true,
    category: "people"
  },
  policewoman: {
    keywords: [ "woman", "police", "law", "legal", "enforcement", "arrest", "911", "female" ],
    char: "\ud83d\udc6e\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  policeman: {
    keywords: [ "man", "police", "law", "legal", "enforcement", "arrest", "911" ],
    char: "\ud83d\udc6e",
    fitzpatrick_scale: true,
    category: "people"
  },
  construction_worker_woman: {
    keywords: [ "female", "human", "wip", "build", "construction", "worker", "labor", "woman" ],
    char: "\ud83d\udc77\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  construction_worker_man: {
    keywords: [ "male", "human", "wip", "guy", "build", "construction", "worker", "labor" ],
    char: "\ud83d\udc77",
    fitzpatrick_scale: true,
    category: "people"
  },
  guardswoman: {
    keywords: [ "uk", "gb", "british", "female", "royal", "woman" ],
    char: "\ud83d\udc82\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  guardsman: {
    keywords: [ "uk", "gb", "british", "male", "guy", "royal" ],
    char: "\ud83d\udc82",
    fitzpatrick_scale: true,
    category: "people"
  },
  female_detective: {
    keywords: [ "human", "spy", "detective", "female", "woman" ],
    char: "\ud83d\udd75\ufe0f\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  male_detective: {
    keywords: [ "human", "spy", "detective" ],
    char: "\ud83d\udd75",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_health_worker: {
    keywords: [ "doctor", "nurse", "therapist", "healthcare", "woman", "human" ],
    char: "\ud83d\udc69\u200d\u2695\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_health_worker: {
    keywords: [ "doctor", "nurse", "therapist", "healthcare", "man", "human" ],
    char: "\ud83d\udc68\u200d\u2695\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_farmer: {
    keywords: [ "rancher", "gardener", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udf3e",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_farmer: {
    keywords: [ "rancher", "gardener", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udf3e",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_cook: {
    keywords: [ "chef", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udf73",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_cook: {
    keywords: [ "chef", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udf73",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_student: {
    keywords: [ "graduate", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udf93",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_student: {
    keywords: [ "graduate", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udf93",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_singer: {
    keywords: [ "rockstar", "entertainer", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udfa4",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_singer: {
    keywords: [ "rockstar", "entertainer", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udfa4",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_teacher: {
    keywords: [ "instructor", "professor", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udfeb",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_teacher: {
    keywords: [ "instructor", "professor", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udfeb",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_factory_worker: {
    keywords: [ "assembly", "industrial", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udfed",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_factory_worker: {
    keywords: [ "assembly", "industrial", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udfed",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_technologist: {
    keywords: [ "coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer" ],
    char: "\ud83d\udc69\u200d\ud83d\udcbb",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_technologist: {
    keywords: [ "coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer" ],
    char: "\ud83d\udc68\u200d\ud83d\udcbb",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_office_worker: {
    keywords: [ "business", "manager", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83d\udcbc",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_office_worker: {
    keywords: [ "business", "manager", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83d\udcbc",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_mechanic: {
    keywords: [ "plumber", "woman", "human", "wrench" ],
    char: "\ud83d\udc69\u200d\ud83d\udd27",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_mechanic: {
    keywords: [ "plumber", "man", "human", "wrench" ],
    char: "\ud83d\udc68\u200d\ud83d\udd27",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_scientist: {
    keywords: [ "biologist", "chemist", "engineer", "physicist", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83d\udd2c",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_scientist: {
    keywords: [ "biologist", "chemist", "engineer", "physicist", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83d\udd2c",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_artist: {
    keywords: [ "painter", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83c\udfa8",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_artist: {
    keywords: [ "painter", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83c\udfa8",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_firefighter: {
    keywords: [ "fireman", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83d\ude92",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_firefighter: {
    keywords: [ "fireman", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83d\ude92",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_pilot: {
    keywords: [ "aviator", "plane", "woman", "human" ],
    char: "\ud83d\udc69\u200d\u2708\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_pilot: {
    keywords: [ "aviator", "plane", "man", "human" ],
    char: "\ud83d\udc68\u200d\u2708\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_astronaut: {
    keywords: [ "space", "rocket", "woman", "human" ],
    char: "\ud83d\udc69\u200d\ud83d\ude80",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_astronaut: {
    keywords: [ "space", "rocket", "man", "human" ],
    char: "\ud83d\udc68\u200d\ud83d\ude80",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_judge: {
    keywords: [ "justice", "court", "woman", "human" ],
    char: "\ud83d\udc69\u200d\u2696\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_judge: {
    keywords: [ "justice", "court", "man", "human" ],
    char: "\ud83d\udc68\u200d\u2696\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_superhero: {
    keywords: [ "woman", "female", "good", "heroine", "superpowers" ],
    char: "\ud83e\uddb8\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_superhero: {
    keywords: [ "man", "male", "good", "hero", "superpowers" ],
    char: "\ud83e\uddb8\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_supervillain: {
    keywords: [ "woman", "female", "evil", "bad", "criminal", "heroine", "superpowers" ],
    char: "\ud83e\uddb9\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_supervillain: {
    keywords: [ "man", "male", "evil", "bad", "criminal", "hero", "superpowers" ],
    char: "\ud83e\uddb9\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  mrs_claus: {
    keywords: [ "woman", "female", "xmas", "mother christmas" ],
    char: "\ud83e\udd36",
    fitzpatrick_scale: true,
    category: "people"
  },
  santa: {
    keywords: [ "festival", "man", "male", "xmas", "father christmas" ],
    char: "\ud83c\udf85",
    fitzpatrick_scale: true,
    category: "people"
  },
  sorceress: {
    keywords: [ "woman", "female", "mage", "witch" ],
    char: "\ud83e\uddd9\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  wizard: {
    keywords: [ "man", "male", "mage", "sorcerer" ],
    char: "\ud83e\uddd9\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_elf: {
    keywords: [ "woman", "female" ],
    char: "\ud83e\udddd\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_elf: {
    keywords: [ "man", "male" ],
    char: "\ud83e\udddd\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_vampire: {
    keywords: [ "woman", "female" ],
    char: "\ud83e\udddb\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_vampire: {
    keywords: [ "man", "male", "dracula" ],
    char: "\ud83e\udddb\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_zombie: {
    keywords: [ "woman", "female", "undead", "walking dead" ],
    char: "\ud83e\udddf\u200d\u2640\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  man_zombie: {
    keywords: [ "man", "male", "dracula", "undead", "walking dead" ],
    char: "\ud83e\udddf\u200d\u2642\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  woman_genie: {
    keywords: [ "woman", "female" ],
    char: "\ud83e\uddde\u200d\u2640\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  man_genie: {
    keywords: [ "man", "male" ],
    char: "\ud83e\uddde\u200d\u2642\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  mermaid: {
    keywords: [ "woman", "female", "merwoman", "ariel" ],
    char: "\ud83e\udddc\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  merman: {
    keywords: [ "man", "male", "triton" ],
    char: "\ud83e\udddc\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_fairy: {
    keywords: [ "woman", "female" ],
    char: "\ud83e\uddda\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_fairy: {
    keywords: [ "man", "male" ],
    char: "\ud83e\uddda\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  angel: {
    keywords: [ "heaven", "wings", "halo" ],
    char: "\ud83d\udc7c",
    fitzpatrick_scale: true,
    category: "people"
  },
  pregnant_woman: {
    keywords: [ "baby" ],
    char: "\ud83e\udd30",
    fitzpatrick_scale: true,
    category: "people"
  },
  breastfeeding: {
    keywords: [ "nursing", "baby" ],
    char: "\ud83e\udd31",
    fitzpatrick_scale: true,
    category: "people"
  },
  princess: {
    keywords: [ "girl", "woman", "female", "blond", "crown", "royal", "queen" ],
    char: "\ud83d\udc78",
    fitzpatrick_scale: true,
    category: "people"
  },
  prince: {
    keywords: [ "boy", "man", "male", "crown", "royal", "king" ],
    char: "\ud83e\udd34",
    fitzpatrick_scale: true,
    category: "people"
  },
  bride_with_veil: {
    keywords: [ "couple", "marriage", "wedding", "woman", "bride" ],
    char: "\ud83d\udc70",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_in_tuxedo: {
    keywords: [ "couple", "marriage", "wedding", "groom" ],
    char: "\ud83e\udd35",
    fitzpatrick_scale: true,
    category: "people"
  },
  running_woman: {
    keywords: [ "woman", "walking", "exercise", "race", "running", "female" ],
    char: "\ud83c\udfc3\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  running_man: {
    keywords: [ "man", "walking", "exercise", "race", "running" ],
    char: "\ud83c\udfc3",
    fitzpatrick_scale: true,
    category: "people"
  },
  walking_woman: {
    keywords: [ "human", "feet", "steps", "woman", "female" ],
    char: "\ud83d\udeb6\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  walking_man: {
    keywords: [ "human", "feet", "steps" ],
    char: "\ud83d\udeb6",
    fitzpatrick_scale: true,
    category: "people"
  },
  dancer: {
    keywords: [ "female", "girl", "woman", "fun" ],
    char: "\ud83d\udc83",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_dancing: {
    keywords: [ "male", "boy", "fun", "dancer" ],
    char: "\ud83d\udd7a",
    fitzpatrick_scale: true,
    category: "people"
  },
  dancing_women: {
    keywords: [ "female", "bunny", "women", "girls" ],
    char: "\ud83d\udc6f",
    fitzpatrick_scale: false,
    category: "people"
  },
  dancing_men: {
    keywords: [ "male", "bunny", "men", "boys" ],
    char: "\ud83d\udc6f\u200d\u2642\ufe0f",
    fitzpatrick_scale: false,
    category: "people"
  },
  couple: {
    keywords: [ "pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage" ],
    char: "\ud83d\udc6b",
    fitzpatrick_scale: false,
    category: "people"
  },
  two_men_holding_hands: {
    keywords: [ "pair", "couple", "love", "like", "bromance", "friendship", "people", "human" ],
    char: "\ud83d\udc6c",
    fitzpatrick_scale: false,
    category: "people"
  },
  two_women_holding_hands: {
    keywords: [ "pair", "friendship", "couple", "love", "like", "female", "people", "human" ],
    char: "\ud83d\udc6d",
    fitzpatrick_scale: false,
    category: "people"
  },
  bowing_woman: {
    keywords: [ "woman", "female", "girl" ],
    char: "\ud83d\ude47\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  bowing_man: {
    keywords: [ "man", "male", "boy" ],
    char: "\ud83d\ude47",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_facepalming: {
    keywords: [ "man", "male", "boy", "disbelief" ],
    char: "\ud83e\udd26\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_facepalming: {
    keywords: [ "woman", "female", "girl", "disbelief" ],
    char: "\ud83e\udd26\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_shrugging: {
    keywords: [ "woman", "female", "girl", "confused", "indifferent", "doubt" ],
    char: "\ud83e\udd37",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_shrugging: {
    keywords: [ "man", "male", "boy", "confused", "indifferent", "doubt" ],
    char: "\ud83e\udd37\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  tipping_hand_woman: {
    keywords: [ "female", "girl", "woman", "human", "information" ],
    char: "\ud83d\udc81",
    fitzpatrick_scale: true,
    category: "people"
  },
  tipping_hand_man: {
    keywords: [ "male", "boy", "man", "human", "information" ],
    char: "\ud83d\udc81\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  no_good_woman: {
    keywords: [ "female", "girl", "woman", "nope" ],
    char: "\ud83d\ude45",
    fitzpatrick_scale: true,
    category: "people"
  },
  no_good_man: {
    keywords: [ "male", "boy", "man", "nope" ],
    char: "\ud83d\ude45\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  ok_woman: {
    keywords: [ "women", "girl", "female", "pink", "human", "woman" ],
    char: "\ud83d\ude46",
    fitzpatrick_scale: true,
    category: "people"
  },
  ok_man: {
    keywords: [ "men", "boy", "male", "blue", "human", "man" ],
    char: "\ud83d\ude46\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  raising_hand_woman: {
    keywords: [ "female", "girl", "woman" ],
    char: "\ud83d\ude4b",
    fitzpatrick_scale: true,
    category: "people"
  },
  raising_hand_man: {
    keywords: [ "male", "boy", "man" ],
    char: "\ud83d\ude4b\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  pouting_woman: {
    keywords: [ "female", "girl", "woman" ],
    char: "\ud83d\ude4e",
    fitzpatrick_scale: true,
    category: "people"
  },
  pouting_man: {
    keywords: [ "male", "boy", "man" ],
    char: "\ud83d\ude4e\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  frowning_woman: {
    keywords: [ "female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy" ],
    char: "\ud83d\ude4d",
    fitzpatrick_scale: true,
    category: "people"
  },
  frowning_man: {
    keywords: [ "male", "boy", "man", "sad", "depressed", "discouraged", "unhappy" ],
    char: "\ud83d\ude4d\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  haircut_woman: {
    keywords: [ "female", "girl", "woman" ],
    char: "\ud83d\udc87",
    fitzpatrick_scale: true,
    category: "people"
  },
  haircut_man: {
    keywords: [ "male", "boy", "man" ],
    char: "\ud83d\udc87\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  massage_woman: {
    keywords: [ "female", "girl", "woman", "head" ],
    char: "\ud83d\udc86",
    fitzpatrick_scale: true,
    category: "people"
  },
  massage_man: {
    keywords: [ "male", "boy", "man", "head" ],
    char: "\ud83d\udc86\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  woman_in_steamy_room: {
    keywords: [ "female", "woman", "spa", "steamroom", "sauna" ],
    char: "\ud83e\uddd6\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  man_in_steamy_room: {
    keywords: [ "male", "man", "spa", "steamroom", "sauna" ],
    char: "\ud83e\uddd6\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "people"
  },
  couple_with_heart_woman_man: {
    keywords: [ "pair", "love", "like", "affection", "human", "dating", "valentines", "marriage" ],
    char: "\ud83d\udc91",
    fitzpatrick_scale: false,
    category: "people"
  },
  couple_with_heart_woman_woman: {
    keywords: [ "pair", "love", "like", "affection", "human", "dating", "valentines", "marriage" ],
    char: "\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc69",
    fitzpatrick_scale: false,
    category: "people"
  },
  couple_with_heart_man_man: {
    keywords: [ "pair", "love", "like", "affection", "human", "dating", "valentines", "marriage" ],
    char: "\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68",
    fitzpatrick_scale: false,
    category: "people"
  },
  couplekiss_man_woman: {
    keywords: [ "pair", "valentines", "love", "like", "dating", "marriage" ],
    char: "\ud83d\udc8f",
    fitzpatrick_scale: false,
    category: "people"
  },
  couplekiss_woman_woman: {
    keywords: [ "pair", "valentines", "love", "like", "dating", "marriage" ],
    char: "\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69",
    fitzpatrick_scale: false,
    category: "people"
  },
  couplekiss_man_man: {
    keywords: [ "pair", "valentines", "love", "like", "dating", "marriage" ],
    char: "\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_woman_boy: {
    keywords: [ "home", "parents", "child", "mom", "dad", "father", "mother", "people", "human" ],
    char: "\ud83d\udc6a",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_woman_girl: {
    keywords: [ "home", "parents", "people", "human", "child" ],
    char: "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_woman_girl_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_woman_boy_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_woman_girl_girl: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_woman_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_woman_girl: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_woman_girl_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_woman_boy_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_woman_girl_girl: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_man_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_man_girl: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_man_girl_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_man_boy_boy: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_man_girl_girl: {
    keywords: [ "home", "parents", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_boy: {
    keywords: [ "home", "parent", "people", "human", "child" ],
    char: "\ud83d\udc69\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_girl: {
    keywords: [ "home", "parent", "people", "human", "child" ],
    char: "\ud83d\udc69\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_girl_boy: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_boy_boy: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_woman_girl_girl: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_boy: {
    keywords: [ "home", "parent", "people", "human", "child" ],
    char: "\ud83d\udc68\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_girl: {
    keywords: [ "home", "parent", "people", "human", "child" ],
    char: "\ud83d\udc68\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_girl_boy: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_boy_boy: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66",
    fitzpatrick_scale: false,
    category: "people"
  },
  family_man_girl_girl: {
    keywords: [ "home", "parent", "people", "human", "children" ],
    char: "\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d\udc67",
    fitzpatrick_scale: false,
    category: "people"
  },
  yarn: {
    keywords: [ "ball", "crochet", "knit" ],
    char: "\ud83e\uddf6",
    fitzpatrick_scale: false,
    category: "people"
  },
  thread: {
    keywords: [ "needle", "sewing", "spool", "string" ],
    char: "\ud83e\uddf5",
    fitzpatrick_scale: false,
    category: "people"
  },
  coat: {
    keywords: [ "jacket" ],
    char: "\ud83e\udde5",
    fitzpatrick_scale: false,
    category: "people"
  },
  labcoat: {
    keywords: [ "doctor", "experiment", "scientist", "chemist" ],
    char: "\ud83e\udd7c",
    fitzpatrick_scale: false,
    category: "people"
  },
  womans_clothes: {
    keywords: [ "fashion", "shopping_bags", "female" ],
    char: "\ud83d\udc5a",
    fitzpatrick_scale: false,
    category: "people"
  },
  tshirt: {
    keywords: [ "fashion", "cloth", "casual", "shirt", "tee" ],
    char: "\ud83d\udc55",
    fitzpatrick_scale: false,
    category: "people"
  },
  jeans: {
    keywords: [ "fashion", "shopping" ],
    char: "\ud83d\udc56",
    fitzpatrick_scale: false,
    category: "people"
  },
  necktie: {
    keywords: [ "shirt", "suitup", "formal", "fashion", "cloth", "business" ],
    char: "\ud83d\udc54",
    fitzpatrick_scale: false,
    category: "people"
  },
  dress: {
    keywords: [ "clothes", "fashion", "shopping" ],
    char: "\ud83d\udc57",
    fitzpatrick_scale: false,
    category: "people"
  },
  bikini: {
    keywords: [ "swimming", "female", "woman", "girl", "fashion", "beach", "summer" ],
    char: "\ud83d\udc59",
    fitzpatrick_scale: false,
    category: "people"
  },
  kimono: {
    keywords: [ "dress", "fashion", "women", "female", "japanese" ],
    char: "\ud83d\udc58",
    fitzpatrick_scale: false,
    category: "people"
  },
  lipstick: {
    keywords: [ "female", "girl", "fashion", "woman" ],
    char: "\ud83d\udc84",
    fitzpatrick_scale: false,
    category: "people"
  },
  kiss: {
    keywords: [ "face", "lips", "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc8b",
    fitzpatrick_scale: false,
    category: "people"
  },
  footprints: {
    keywords: [ "feet", "tracking", "walking", "beach" ],
    char: "\ud83d\udc63",
    fitzpatrick_scale: false,
    category: "people"
  },
  flat_shoe: {
    keywords: [ "ballet", "slip-on", "slipper" ],
    char: "\ud83e\udd7f",
    fitzpatrick_scale: false,
    category: "people"
  },
  high_heel: {
    keywords: [ "fashion", "shoes", "female", "pumps", "stiletto" ],
    char: "\ud83d\udc60",
    fitzpatrick_scale: false,
    category: "people"
  },
  sandal: {
    keywords: [ "shoes", "fashion", "flip flops" ],
    char: "\ud83d\udc61",
    fitzpatrick_scale: false,
    category: "people"
  },
  boot: {
    keywords: [ "shoes", "fashion" ],
    char: "\ud83d\udc62",
    fitzpatrick_scale: false,
    category: "people"
  },
  mans_shoe: {
    keywords: [ "fashion", "male" ],
    char: "\ud83d\udc5e",
    fitzpatrick_scale: false,
    category: "people"
  },
  athletic_shoe: {
    keywords: [ "shoes", "sports", "sneakers" ],
    char: "\ud83d\udc5f",
    fitzpatrick_scale: false,
    category: "people"
  },
  hiking_boot: {
    keywords: [ "backpacking", "camping", "hiking" ],
    char: "\ud83e\udd7e",
    fitzpatrick_scale: false,
    category: "people"
  },
  socks: {
    keywords: [ "stockings", "clothes" ],
    char: "\ud83e\udde6",
    fitzpatrick_scale: false,
    category: "people"
  },
  gloves: {
    keywords: [ "hands", "winter", "clothes" ],
    char: "\ud83e\udde4",
    fitzpatrick_scale: false,
    category: "people"
  },
  scarf: {
    keywords: [ "neck", "winter", "clothes" ],
    char: "\ud83e\udde3",
    fitzpatrick_scale: false,
    category: "people"
  },
  womans_hat: {
    keywords: [ "fashion", "accessories", "female", "lady", "spring" ],
    char: "\ud83d\udc52",
    fitzpatrick_scale: false,
    category: "people"
  },
  tophat: {
    keywords: [ "magic", "gentleman", "classy", "circus" ],
    char: "\ud83c\udfa9",
    fitzpatrick_scale: false,
    category: "people"
  },
  billed_hat: {
    keywords: [ "cap", "baseball" ],
    char: "\ud83e\udde2",
    fitzpatrick_scale: false,
    category: "people"
  },
  rescue_worker_helmet: {
    keywords: [ "construction", "build" ],
    char: "\u26d1",
    fitzpatrick_scale: false,
    category: "people"
  },
  mortar_board: {
    keywords: [ "school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education" ],
    char: "\ud83c\udf93",
    fitzpatrick_scale: false,
    category: "people"
  },
  crown: {
    keywords: [ "king", "kod", "leader", "royalty", "lord" ],
    char: "\ud83d\udc51",
    fitzpatrick_scale: false,
    category: "people"
  },
  school_satchel: {
    keywords: [ "student", "education", "bag", "backpack" ],
    char: "\ud83c\udf92",
    fitzpatrick_scale: false,
    category: "people"
  },
  luggage: {
    keywords: [ "packing", "travel" ],
    char: "\ud83e\uddf3",
    fitzpatrick_scale: false,
    category: "people"
  },
  pouch: {
    keywords: [ "bag", "accessories", "shopping" ],
    char: "\ud83d\udc5d",
    fitzpatrick_scale: false,
    category: "people"
  },
  purse: {
    keywords: [ "fashion", "accessories", "money", "sales", "shopping" ],
    char: "\ud83d\udc5b",
    fitzpatrick_scale: false,
    category: "people"
  },
  handbag: {
    keywords: [ "fashion", "accessory", "accessories", "shopping" ],
    char: "\ud83d\udc5c",
    fitzpatrick_scale: false,
    category: "people"
  },
  briefcase: {
    keywords: [ "business", "documents", "work", "law", "legal", "job", "career" ],
    char: "\ud83d\udcbc",
    fitzpatrick_scale: false,
    category: "people"
  },
  eyeglasses: {
    keywords: [ "fashion", "accessories", "eyesight", "nerdy", "dork", "geek" ],
    char: "\ud83d\udc53",
    fitzpatrick_scale: false,
    category: "people"
  },
  dark_sunglasses: {
    keywords: [ "face", "cool", "accessories" ],
    char: "\ud83d\udd76",
    fitzpatrick_scale: false,
    category: "people"
  },
  goggles: {
    keywords: [ "eyes", "protection", "safety" ],
    char: "\ud83e\udd7d",
    fitzpatrick_scale: false,
    category: "people"
  },
  ring: {
    keywords: [ "wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement" ],
    char: "\ud83d\udc8d",
    fitzpatrick_scale: false,
    category: "people"
  },
  closed_umbrella: {
    keywords: [ "weather", "rain", "drizzle" ],
    char: "\ud83c\udf02",
    fitzpatrick_scale: false,
    category: "people"
  },
  dog: {
    keywords: [ "animal", "friend", "nature", "woof", "puppy", "pet", "faithful" ],
    char: "\ud83d\udc36",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cat: {
    keywords: [ "animal", "meow", "nature", "pet", "kitten" ],
    char: "\ud83d\udc31",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  mouse: {
    keywords: [ "animal", "nature", "cheese_wedge", "rodent" ],
    char: "\ud83d\udc2d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hamster: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc39",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rabbit: {
    keywords: [ "animal", "nature", "pet", "spring", "magic", "bunny" ],
    char: "\ud83d\udc30",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  fox_face: {
    keywords: [ "animal", "nature", "face" ],
    char: "\ud83e\udd8a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bear: {
    keywords: [ "animal", "nature", "wild" ],
    char: "\ud83d\udc3b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  panda_face: {
    keywords: [ "animal", "nature", "panda" ],
    char: "\ud83d\udc3c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  koala: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc28",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tiger: {
    keywords: [ "animal", "cat", "danger", "wild", "nature", "roar" ],
    char: "\ud83d\udc2f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  lion: {
    keywords: [ "animal", "nature" ],
    char: "\ud83e\udd81",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cow: {
    keywords: [ "beef", "ox", "animal", "nature", "moo", "milk" ],
    char: "\ud83d\udc2e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  pig: {
    keywords: [ "animal", "oink", "nature" ],
    char: "\ud83d\udc37",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  pig_nose: {
    keywords: [ "animal", "oink" ],
    char: "\ud83d\udc3d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  frog: {
    keywords: [ "animal", "nature", "croak", "toad" ],
    char: "\ud83d\udc38",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  squid: {
    keywords: [ "animal", "nature", "ocean", "sea" ],
    char: "\ud83e\udd91",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  octopus: {
    keywords: [ "animal", "creature", "ocean", "sea", "nature", "beach" ],
    char: "\ud83d\udc19",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  shrimp: {
    keywords: [ "animal", "ocean", "nature", "seafood" ],
    char: "\ud83e\udd90",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  monkey_face: {
    keywords: [ "animal", "nature", "circus" ],
    char: "\ud83d\udc35",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  gorilla: {
    keywords: [ "animal", "nature", "circus" ],
    char: "\ud83e\udd8d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  see_no_evil: {
    keywords: [ "monkey", "animal", "nature", "haha" ],
    char: "\ud83d\ude48",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hear_no_evil: {
    keywords: [ "animal", "monkey", "nature" ],
    char: "\ud83d\ude49",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  speak_no_evil: {
    keywords: [ "monkey", "animal", "nature", "omg" ],
    char: "\ud83d\ude4a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  monkey: {
    keywords: [ "animal", "nature", "banana", "circus" ],
    char: "\ud83d\udc12",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  chicken: {
    keywords: [ "animal", "cluck", "nature", "bird" ],
    char: "\ud83d\udc14",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  penguin: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc27",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bird: {
    keywords: [ "animal", "nature", "fly", "tweet", "spring" ],
    char: "\ud83d\udc26",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  baby_chick: {
    keywords: [ "animal", "chicken", "bird" ],
    char: "\ud83d\udc24",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hatching_chick: {
    keywords: [ "animal", "chicken", "egg", "born", "baby", "bird" ],
    char: "\ud83d\udc23",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hatched_chick: {
    keywords: [ "animal", "chicken", "baby", "bird" ],
    char: "\ud83d\udc25",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  duck: {
    keywords: [ "animal", "nature", "bird", "mallard" ],
    char: "\ud83e\udd86",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  eagle: {
    keywords: [ "animal", "nature", "bird" ],
    char: "\ud83e\udd85",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  owl: {
    keywords: [ "animal", "nature", "bird", "hoot" ],
    char: "\ud83e\udd89",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bat: {
    keywords: [ "animal", "nature", "blind", "vampire" ],
    char: "\ud83e\udd87",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  wolf: {
    keywords: [ "animal", "nature", "wild" ],
    char: "\ud83d\udc3a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  boar: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc17",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  horse: {
    keywords: [ "animal", "brown", "nature" ],
    char: "\ud83d\udc34",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  unicorn: {
    keywords: [ "animal", "nature", "mystical" ],
    char: "\ud83e\udd84",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  honeybee: {
    keywords: [ "animal", "insect", "nature", "bug", "spring", "honey" ],
    char: "\ud83d\udc1d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bug: {
    keywords: [ "animal", "insect", "nature", "worm" ],
    char: "\ud83d\udc1b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  butterfly: {
    keywords: [ "animal", "insect", "nature", "caterpillar" ],
    char: "\ud83e\udd8b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  snail: {
    keywords: [ "slow", "animal", "shell" ],
    char: "\ud83d\udc0c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  beetle: {
    keywords: [ "animal", "insect", "nature", "ladybug" ],
    char: "\ud83d\udc1e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  ant: {
    keywords: [ "animal", "insect", "nature", "bug" ],
    char: "\ud83d\udc1c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  grasshopper: {
    keywords: [ "animal", "cricket", "chirp" ],
    char: "\ud83e\udd97",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  spider: {
    keywords: [ "animal", "arachnid" ],
    char: "\ud83d\udd77",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  scorpion: {
    keywords: [ "animal", "arachnid" ],
    char: "\ud83e\udd82",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  crab: {
    keywords: [ "animal", "crustacean" ],
    char: "\ud83e\udd80",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  snake: {
    keywords: [ "animal", "evil", "nature", "hiss", "python" ],
    char: "\ud83d\udc0d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  lizard: {
    keywords: [ "animal", "nature", "reptile" ],
    char: "\ud83e\udd8e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  "t-rex": {
    keywords: [ "animal", "nature", "dinosaur", "tyrannosaurus", "extinct" ],
    char: "\ud83e\udd96",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sauropod: {
    keywords: [ "animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct" ],
    char: "\ud83e\udd95",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  turtle: {
    keywords: [ "animal", "slow", "nature", "tortoise" ],
    char: "\ud83d\udc22",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tropical_fish: {
    keywords: [ "animal", "swim", "ocean", "beach", "nemo" ],
    char: "\ud83d\udc20",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  fish: {
    keywords: [ "animal", "food", "nature" ],
    char: "\ud83d\udc1f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  blowfish: {
    keywords: [ "animal", "nature", "food", "sea", "ocean" ],
    char: "\ud83d\udc21",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dolphin: {
    keywords: [ "animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach" ],
    char: "\ud83d\udc2c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  shark: {
    keywords: [ "animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach" ],
    char: "\ud83e\udd88",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  whale: {
    keywords: [ "animal", "nature", "sea", "ocean" ],
    char: "\ud83d\udc33",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  whale2: {
    keywords: [ "animal", "nature", "sea", "ocean" ],
    char: "\ud83d\udc0b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  crocodile: {
    keywords: [ "animal", "nature", "reptile", "lizard", "alligator" ],
    char: "\ud83d\udc0a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  leopard: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc06",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  zebra: {
    keywords: [ "animal", "nature", "stripes", "safari" ],
    char: "\ud83e\udd93",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tiger2: {
    keywords: [ "animal", "nature", "roar" ],
    char: "\ud83d\udc05",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  water_buffalo: {
    keywords: [ "animal", "nature", "ox", "cow" ],
    char: "\ud83d\udc03",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  ox: {
    keywords: [ "animal", "cow", "beef" ],
    char: "\ud83d\udc02",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cow2: {
    keywords: [ "beef", "ox", "animal", "nature", "moo", "milk" ],
    char: "\ud83d\udc04",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  deer: {
    keywords: [ "animal", "nature", "horns", "venison" ],
    char: "\ud83e\udd8c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dromedary_camel: {
    keywords: [ "animal", "hot", "desert", "hump" ],
    char: "\ud83d\udc2a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  camel: {
    keywords: [ "animal", "nature", "hot", "desert", "hump" ],
    char: "\ud83d\udc2b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  giraffe: {
    keywords: [ "animal", "nature", "spots", "safari" ],
    char: "\ud83e\udd92",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  elephant: {
    keywords: [ "animal", "nature", "nose", "th", "circus" ],
    char: "\ud83d\udc18",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rhinoceros: {
    keywords: [ "animal", "nature", "horn" ],
    char: "\ud83e\udd8f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  goat: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc10",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  ram: {
    keywords: [ "animal", "sheep", "nature" ],
    char: "\ud83d\udc0f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sheep: {
    keywords: [ "animal", "nature", "wool", "shipit" ],
    char: "\ud83d\udc11",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  racehorse: {
    keywords: [ "animal", "gamble", "luck" ],
    char: "\ud83d\udc0e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  pig2: {
    keywords: [ "animal", "nature" ],
    char: "\ud83d\udc16",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rat: {
    keywords: [ "animal", "mouse", "rodent" ],
    char: "\ud83d\udc00",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  mouse2: {
    keywords: [ "animal", "nature", "rodent" ],
    char: "\ud83d\udc01",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rooster: {
    keywords: [ "animal", "nature", "chicken" ],
    char: "\ud83d\udc13",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  turkey: {
    keywords: [ "animal", "bird" ],
    char: "\ud83e\udd83",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dove: {
    keywords: [ "animal", "bird" ],
    char: "\ud83d\udd4a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dog2: {
    keywords: [ "animal", "nature", "friend", "doge", "pet", "faithful" ],
    char: "\ud83d\udc15",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  poodle: {
    keywords: [ "dog", "animal", "101", "nature", "pet" ],
    char: "\ud83d\udc29",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cat2: {
    keywords: [ "animal", "meow", "pet", "cats" ],
    char: "\ud83d\udc08",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rabbit2: {
    keywords: [ "animal", "nature", "pet", "magic", "spring" ],
    char: "\ud83d\udc07",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  chipmunk: {
    keywords: [ "animal", "nature", "rodent", "squirrel" ],
    char: "\ud83d\udc3f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hedgehog: {
    keywords: [ "animal", "nature", "spiny" ],
    char: "\ud83e\udd94",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  raccoon: {
    keywords: [ "animal", "nature" ],
    char: "\ud83e\udd9d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  llama: {
    keywords: [ "animal", "nature", "alpaca" ],
    char: "\ud83e\udd99",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hippopotamus: {
    keywords: [ "animal", "nature" ],
    char: "\ud83e\udd9b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  kangaroo: {
    keywords: [ "animal", "nature", "australia", "joey", "hop", "marsupial" ],
    char: "\ud83e\udd98",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  badger: {
    keywords: [ "animal", "nature", "honey" ],
    char: "\ud83e\udda1",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  swan: {
    keywords: [ "animal", "nature", "bird" ],
    char: "\ud83e\udda2",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  peacock: {
    keywords: [ "animal", "nature", "peahen", "bird" ],
    char: "\ud83e\udd9a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  parrot: {
    keywords: [ "animal", "nature", "bird", "pirate", "talk" ],
    char: "\ud83e\udd9c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  lobster: {
    keywords: [ "animal", "nature", "bisque", "claws", "seafood" ],
    char: "\ud83e\udd9e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  mosquito: {
    keywords: [ "animal", "nature", "insect", "malaria" ],
    char: "\ud83e\udd9f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  paw_prints: {
    keywords: [ "animal", "tracking", "footprints", "dog", "cat", "pet", "feet" ],
    char: "\ud83d\udc3e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dragon: {
    keywords: [ "animal", "myth", "nature", "chinese", "green" ],
    char: "\ud83d\udc09",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dragon_face: {
    keywords: [ "animal", "myth", "nature", "chinese", "green" ],
    char: "\ud83d\udc32",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cactus: {
    keywords: [ "vegetable", "plant", "nature" ],
    char: "\ud83c\udf35",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  christmas_tree: {
    keywords: [ "festival", "vacation", "december", "xmas", "celebration" ],
    char: "\ud83c\udf84",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  evergreen_tree: {
    keywords: [ "plant", "nature" ],
    char: "\ud83c\udf32",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  deciduous_tree: {
    keywords: [ "plant", "nature" ],
    char: "\ud83c\udf33",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  palm_tree: {
    keywords: [ "plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical" ],
    char: "\ud83c\udf34",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  seedling: {
    keywords: [ "plant", "nature", "grass", "lawn", "spring" ],
    char: "\ud83c\udf31",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  herb: {
    keywords: [ "vegetable", "plant", "medicine", "weed", "grass", "lawn" ],
    char: "\ud83c\udf3f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  shamrock: {
    keywords: [ "vegetable", "plant", "nature", "irish", "clover" ],
    char: "\u2618",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  four_leaf_clover: {
    keywords: [ "vegetable", "plant", "nature", "lucky", "irish" ],
    char: "\ud83c\udf40",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bamboo: {
    keywords: [ "plant", "nature", "vegetable", "panda", "pine_decoration" ],
    char: "\ud83c\udf8d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tanabata_tree: {
    keywords: [ "plant", "nature", "branch", "summer" ],
    char: "\ud83c\udf8b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  leaves: {
    keywords: [ "nature", "plant", "tree", "vegetable", "grass", "lawn", "spring" ],
    char: "\ud83c\udf43",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  fallen_leaf: {
    keywords: [ "nature", "plant", "vegetable", "leaves" ],
    char: "\ud83c\udf42",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  maple_leaf: {
    keywords: [ "nature", "plant", "vegetable", "ca", "fall" ],
    char: "\ud83c\udf41",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  ear_of_rice: {
    keywords: [ "nature", "plant" ],
    char: "\ud83c\udf3e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  hibiscus: {
    keywords: [ "plant", "vegetable", "flowers", "beach" ],
    char: "\ud83c\udf3a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sunflower: {
    keywords: [ "nature", "plant", "fall" ],
    char: "\ud83c\udf3b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  rose: {
    keywords: [ "flowers", "valentines", "love", "spring" ],
    char: "\ud83c\udf39",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  wilted_flower: {
    keywords: [ "plant", "nature", "flower" ],
    char: "\ud83e\udd40",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tulip: {
    keywords: [ "flowers", "plant", "nature", "summer", "spring" ],
    char: "\ud83c\udf37",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  blossom: {
    keywords: [ "nature", "flowers", "yellow" ],
    char: "\ud83c\udf3c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cherry_blossom: {
    keywords: [ "nature", "plant", "spring", "flower" ],
    char: "\ud83c\udf38",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  bouquet: {
    keywords: [ "flowers", "nature", "spring" ],
    char: "\ud83d\udc90",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  mushroom: {
    keywords: [ "plant", "vegetable" ],
    char: "\ud83c\udf44",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  chestnut: {
    keywords: [ "food", "squirrel" ],
    char: "\ud83c\udf30",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  jack_o_lantern: {
    keywords: [ "halloween", "light", "pumpkin", "creepy", "fall" ],
    char: "\ud83c\udf83",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  shell: {
    keywords: [ "nature", "sea", "beach" ],
    char: "\ud83d\udc1a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  spider_web: {
    keywords: [ "animal", "insect", "arachnid", "silk" ],
    char: "\ud83d\udd78",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  earth_americas: {
    keywords: [ "globe", "world", "USA", "international" ],
    char: "\ud83c\udf0e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  earth_africa: {
    keywords: [ "globe", "world", "international" ],
    char: "\ud83c\udf0d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  earth_asia: {
    keywords: [ "globe", "world", "east", "international" ],
    char: "\ud83c\udf0f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  full_moon: {
    keywords: [ "nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf15",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  waning_gibbous_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon" ],
    char: "\ud83c\udf16",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  last_quarter_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf17",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  waning_crescent_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf18",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  new_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf11",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  waxing_crescent_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf12",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  first_quarter_moon: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf13",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  waxing_gibbous_moon: {
    keywords: [ "nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep" ],
    char: "\ud83c\udf14",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  new_moon_with_face: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf1a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  full_moon_with_face: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf1d",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  first_quarter_moon_with_face: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf1b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  last_quarter_moon_with_face: {
    keywords: [ "nature", "twilight", "planet", "space", "night", "evening", "sleep" ],
    char: "\ud83c\udf1c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sun_with_face: {
    keywords: [ "nature", "morning", "sky" ],
    char: "\ud83c\udf1e",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  crescent_moon: {
    keywords: [ "night", "sleep", "sky", "evening", "magic" ],
    char: "\ud83c\udf19",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  star: {
    keywords: [ "night", "yellow" ],
    char: "\u2b50",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  star2: {
    keywords: [ "night", "sparkle", "awesome", "good", "magic" ],
    char: "\ud83c\udf1f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dizzy: {
    keywords: [ "star", "sparkle", "shoot", "magic" ],
    char: "\ud83d\udcab",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sparkles: {
    keywords: [ "stars", "shine", "shiny", "cool", "awesome", "good", "magic" ],
    char: "\u2728",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  comet: {
    keywords: [ "space" ],
    char: "\u2604",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sunny: {
    keywords: [ "weather", "nature", "brightness", "summer", "beach", "spring" ],
    char: "\u2600\ufe0f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sun_behind_small_cloud: {
    keywords: [ "weather" ],
    char: "\ud83c\udf24",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  partly_sunny: {
    keywords: [ "weather", "nature", "cloudy", "morning", "fall", "spring" ],
    char: "\u26c5",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sun_behind_large_cloud: {
    keywords: [ "weather" ],
    char: "\ud83c\udf25",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sun_behind_rain_cloud: {
    keywords: [ "weather" ],
    char: "\ud83c\udf26",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cloud: {
    keywords: [ "weather", "sky" ],
    char: "\u2601\ufe0f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cloud_with_rain: {
    keywords: [ "weather" ],
    char: "\ud83c\udf27",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cloud_with_lightning_and_rain: {
    keywords: [ "weather", "lightning" ],
    char: "\u26c8",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cloud_with_lightning: {
    keywords: [ "weather", "thunder" ],
    char: "\ud83c\udf29",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  zap: {
    keywords: [ "thunder", "weather", "lightning bolt", "fast" ],
    char: "\u26a1",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  fire: {
    keywords: [ "hot", "cook", "flame" ],
    char: "\ud83d\udd25",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  boom: {
    keywords: [ "bomb", "explode", "explosion", "collision", "blown" ],
    char: "\ud83d\udca5",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  snowflake: {
    keywords: [ "winter", "season", "cold", "weather", "christmas", "xmas" ],
    char: "\u2744\ufe0f",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  cloud_with_snow: {
    keywords: [ "weather" ],
    char: "\ud83c\udf28",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  snowman: {
    keywords: [ "winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow" ],
    char: "\u26c4",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  snowman_with_snow: {
    keywords: [ "winter", "season", "cold", "weather", "christmas", "xmas", "frozen" ],
    char: "\u2603",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  wind_face: {
    keywords: [ "gust", "air" ],
    char: "\ud83c\udf2c",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  dash: {
    keywords: [ "wind", "air", "fast", "shoo", "fart", "smoke", "puff" ],
    char: "\ud83d\udca8",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  tornado: {
    keywords: [ "weather", "cyclone", "twister" ],
    char: "\ud83c\udf2a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  fog: {
    keywords: [ "weather" ],
    char: "\ud83c\udf2b",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  open_umbrella: {
    keywords: [ "weather", "spring" ],
    char: "\u2602",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  umbrella: {
    keywords: [ "rainy", "weather", "spring" ],
    char: "\u2614",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  droplet: {
    keywords: [ "water", "drip", "faucet", "spring" ],
    char: "\ud83d\udca7",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sweat_drops: {
    keywords: [ "water", "drip", "oops" ],
    char: "\ud83d\udca6",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  ocean: {
    keywords: [ "sea", "water", "wave", "nature", "tsunami", "disaster" ],
    char: "\ud83c\udf0a",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  green_apple: {
    keywords: [ "fruit", "nature" ],
    char: "\ud83c\udf4f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  apple: {
    keywords: [ "fruit", "mac", "school" ],
    char: "\ud83c\udf4e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pear: {
    keywords: [ "fruit", "nature", "food" ],
    char: "\ud83c\udf50",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  tangerine: {
    keywords: [ "food", "fruit", "nature", "orange" ],
    char: "\ud83c\udf4a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  lemon: {
    keywords: [ "fruit", "nature" ],
    char: "\ud83c\udf4b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  banana: {
    keywords: [ "fruit", "food", "monkey" ],
    char: "\ud83c\udf4c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  watermelon: {
    keywords: [ "fruit", "food", "picnic", "summer" ],
    char: "\ud83c\udf49",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  grapes: {
    keywords: [ "fruit", "food", "wine" ],
    char: "\ud83c\udf47",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  strawberry: {
    keywords: [ "fruit", "food", "nature" ],
    char: "\ud83c\udf53",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  melon: {
    keywords: [ "fruit", "nature", "food" ],
    char: "\ud83c\udf48",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cherries: {
    keywords: [ "food", "fruit" ],
    char: "\ud83c\udf52",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  peach: {
    keywords: [ "fruit", "nature", "food" ],
    char: "\ud83c\udf51",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pineapple: {
    keywords: [ "fruit", "nature", "food" ],
    char: "\ud83c\udf4d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  coconut: {
    keywords: [ "fruit", "nature", "food", "palm" ],
    char: "\ud83e\udd65",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  kiwi_fruit: {
    keywords: [ "fruit", "food" ],
    char: "\ud83e\udd5d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  mango: {
    keywords: [ "fruit", "food", "tropical" ],
    char: "\ud83e\udd6d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  avocado: {
    keywords: [ "fruit", "food" ],
    char: "\ud83e\udd51",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  broccoli: {
    keywords: [ "fruit", "food", "vegetable" ],
    char: "\ud83e\udd66",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  tomato: {
    keywords: [ "fruit", "vegetable", "nature", "food" ],
    char: "\ud83c\udf45",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  eggplant: {
    keywords: [ "vegetable", "nature", "food", "aubergine" ],
    char: "\ud83c\udf46",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cucumber: {
    keywords: [ "fruit", "food", "pickle" ],
    char: "\ud83e\udd52",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  carrot: {
    keywords: [ "vegetable", "food", "orange" ],
    char: "\ud83e\udd55",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  hot_pepper: {
    keywords: [ "food", "spicy", "chilli", "chili" ],
    char: "\ud83c\udf36",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  potato: {
    keywords: [ "food", "tuber", "vegatable", "starch" ],
    char: "\ud83e\udd54",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  corn: {
    keywords: [ "food", "vegetable", "plant" ],
    char: "\ud83c\udf3d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  leafy_greens: {
    keywords: [ "food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce" ],
    char: "\ud83e\udd6c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  sweet_potato: {
    keywords: [ "food", "nature" ],
    char: "\ud83c\udf60",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  peanuts: {
    keywords: [ "food", "nut" ],
    char: "\ud83e\udd5c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  honey_pot: {
    keywords: [ "bees", "sweet", "kitchen" ],
    char: "\ud83c\udf6f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  croissant: {
    keywords: [ "food", "bread", "french" ],
    char: "\ud83e\udd50",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bread: {
    keywords: [ "food", "wheat", "breakfast", "toast" ],
    char: "\ud83c\udf5e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  baguette_bread: {
    keywords: [ "food", "bread", "french" ],
    char: "\ud83e\udd56",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bagel: {
    keywords: [ "food", "bread", "bakery", "schmear" ],
    char: "\ud83e\udd6f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pretzel: {
    keywords: [ "food", "bread", "twisted" ],
    char: "\ud83e\udd68",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cheese: {
    keywords: [ "food", "chadder" ],
    char: "\ud83e\uddc0",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  egg: {
    keywords: [ "food", "chicken", "breakfast" ],
    char: "\ud83e\udd5a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bacon: {
    keywords: [ "food", "breakfast", "pork", "pig", "meat" ],
    char: "\ud83e\udd53",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  steak: {
    keywords: [ "food", "cow", "meat", "cut", "chop", "lambchop", "porkchop" ],
    char: "\ud83e\udd69",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pancakes: {
    keywords: [ "food", "breakfast", "flapjacks", "hotcakes" ],
    char: "\ud83e\udd5e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  poultry_leg: {
    keywords: [ "food", "meat", "drumstick", "bird", "chicken", "turkey" ],
    char: "\ud83c\udf57",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  meat_on_bone: {
    keywords: [ "good", "food", "drumstick" ],
    char: "\ud83c\udf56",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bone: {
    keywords: [ "skeleton" ],
    char: "\ud83e\uddb4",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fried_shrimp: {
    keywords: [ "food", "animal", "appetizer", "summer" ],
    char: "\ud83c\udf64",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fried_egg: {
    keywords: [ "food", "breakfast", "kitchen", "egg" ],
    char: "\ud83c\udf73",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  hamburger: {
    keywords: [ "meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king" ],
    char: "\ud83c\udf54",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fries: {
    keywords: [ "chips", "snack", "fast food" ],
    char: "\ud83c\udf5f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  stuffed_flatbread: {
    keywords: [ "food", "flatbread", "stuffed", "gyro" ],
    char: "\ud83e\udd59",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  hotdog: {
    keywords: [ "food", "frankfurter" ],
    char: "\ud83c\udf2d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pizza: {
    keywords: [ "food", "party" ],
    char: "\ud83c\udf55",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  sandwich: {
    keywords: [ "food", "lunch", "bread" ],
    char: "\ud83e\udd6a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  canned_food: {
    keywords: [ "food", "soup" ],
    char: "\ud83e\udd6b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  spaghetti: {
    keywords: [ "food", "italian", "noodle" ],
    char: "\ud83c\udf5d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  taco: {
    keywords: [ "food", "mexican" ],
    char: "\ud83c\udf2e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  burrito: {
    keywords: [ "food", "mexican" ],
    char: "\ud83c\udf2f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  green_salad: {
    keywords: [ "food", "healthy", "lettuce" ],
    char: "\ud83e\udd57",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  shallow_pan_of_food: {
    keywords: [ "food", "cooking", "casserole", "paella" ],
    char: "\ud83e\udd58",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  ramen: {
    keywords: [ "food", "japanese", "noodle", "chopsticks" ],
    char: "\ud83c\udf5c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  stew: {
    keywords: [ "food", "meat", "soup" ],
    char: "\ud83c\udf72",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fish_cake: {
    keywords: [ "food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen" ],
    char: "\ud83c\udf65",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fortune_cookie: {
    keywords: [ "food", "prophecy" ],
    char: "\ud83e\udd60",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  sushi: {
    keywords: [ "food", "fish", "japanese", "rice" ],
    char: "\ud83c\udf63",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bento: {
    keywords: [ "food", "japanese", "box" ],
    char: "\ud83c\udf71",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  curry: {
    keywords: [ "food", "spicy", "hot", "indian" ],
    char: "\ud83c\udf5b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  rice_ball: {
    keywords: [ "food", "japanese" ],
    char: "\ud83c\udf59",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  rice: {
    keywords: [ "food", "china", "asian" ],
    char: "\ud83c\udf5a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  rice_cracker: {
    keywords: [ "food", "japanese" ],
    char: "\ud83c\udf58",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  oden: {
    keywords: [ "food", "japanese" ],
    char: "\ud83c\udf62",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  dango: {
    keywords: [ "food", "dessert", "sweet", "japanese", "barbecue", "meat" ],
    char: "\ud83c\udf61",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  shaved_ice: {
    keywords: [ "hot", "dessert", "summer" ],
    char: "\ud83c\udf67",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  ice_cream: {
    keywords: [ "food", "hot", "dessert" ],
    char: "\ud83c\udf68",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  icecream: {
    keywords: [ "food", "hot", "dessert", "summer" ],
    char: "\ud83c\udf66",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  pie: {
    keywords: [ "food", "dessert", "pastry" ],
    char: "\ud83e\udd67",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cake: {
    keywords: [ "food", "dessert" ],
    char: "\ud83c\udf70",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cupcake: {
    keywords: [ "food", "dessert", "bakery", "sweet" ],
    char: "\ud83e\uddc1",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  moon_cake: {
    keywords: [ "food", "autumn" ],
    char: "\ud83e\udd6e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  birthday: {
    keywords: [ "food", "dessert", "cake" ],
    char: "\ud83c\udf82",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  custard: {
    keywords: [ "dessert", "food" ],
    char: "\ud83c\udf6e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  candy: {
    keywords: [ "snack", "dessert", "sweet", "lolly" ],
    char: "\ud83c\udf6c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  lollipop: {
    keywords: [ "food", "snack", "candy", "sweet" ],
    char: "\ud83c\udf6d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  chocolate_bar: {
    keywords: [ "food", "snack", "dessert", "sweet" ],
    char: "\ud83c\udf6b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  popcorn: {
    keywords: [ "food", "movie theater", "films", "snack" ],
    char: "\ud83c\udf7f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  dumpling: {
    keywords: [ "food", "empanada", "pierogi", "potsticker" ],
    char: "\ud83e\udd5f",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  doughnut: {
    keywords: [ "food", "dessert", "snack", "sweet", "donut" ],
    char: "\ud83c\udf69",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cookie: {
    keywords: [ "food", "snack", "oreo", "chocolate", "sweet", "dessert" ],
    char: "\ud83c\udf6a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  milk_glass: {
    keywords: [ "beverage", "drink", "cow" ],
    char: "\ud83e\udd5b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  beer: {
    keywords: [ "relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze" ],
    char: "\ud83c\udf7a",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  beers: {
    keywords: [ "relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze" ],
    char: "\ud83c\udf7b",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  clinking_glasses: {
    keywords: [ "beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast" ],
    char: "\ud83e\udd42",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  wine_glass: {
    keywords: [ "drink", "beverage", "drunk", "alcohol", "booze" ],
    char: "\ud83c\udf77",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  tumbler_glass: {
    keywords: [ "drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot" ],
    char: "\ud83e\udd43",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cocktail: {
    keywords: [ "drink", "drunk", "alcohol", "beverage", "booze", "mojito" ],
    char: "\ud83c\udf78",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  tropical_drink: {
    keywords: [ "beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito" ],
    char: "\ud83c\udf79",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  champagne: {
    keywords: [ "drink", "wine", "bottle", "celebration" ],
    char: "\ud83c\udf7e",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  sake: {
    keywords: [ "wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze" ],
    char: "\ud83c\udf76",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  tea: {
    keywords: [ "drink", "bowl", "breakfast", "green", "british" ],
    char: "\ud83c\udf75",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  cup_with_straw: {
    keywords: [ "drink", "soda" ],
    char: "\ud83e\udd64",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  coffee: {
    keywords: [ "beverage", "caffeine", "latte", "espresso" ],
    char: "\u2615",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  baby_bottle: {
    keywords: [ "food", "container", "milk" ],
    char: "\ud83c\udf7c",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  salt: {
    keywords: [ "condiment", "shaker" ],
    char: "\ud83e\uddc2",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  spoon: {
    keywords: [ "cutlery", "kitchen", "tableware" ],
    char: "\ud83e\udd44",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  fork_and_knife: {
    keywords: [ "cutlery", "kitchen" ],
    char: "\ud83c\udf74",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  plate_with_cutlery: {
    keywords: [ "food", "eat", "meal", "lunch", "dinner", "restaurant" ],
    char: "\ud83c\udf7d",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  bowl_with_spoon: {
    keywords: [ "food", "breakfast", "cereal", "oatmeal", "porridge" ],
    char: "\ud83e\udd63",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  takeout_box: {
    keywords: [ "food", "leftovers" ],
    char: "\ud83e\udd61",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  chopsticks: {
    keywords: [ "food" ],
    char: "\ud83e\udd62",
    fitzpatrick_scale: false,
    category: "food_and_drink"
  },
  soccer: {
    keywords: [ "sports", "football" ],
    char: "\u26bd",
    fitzpatrick_scale: false,
    category: "activity"
  },
  basketball: {
    keywords: [ "sports", "balls", "NBA" ],
    char: "\ud83c\udfc0",
    fitzpatrick_scale: false,
    category: "activity"
  },
  football: {
    keywords: [ "sports", "balls", "NFL" ],
    char: "\ud83c\udfc8",
    fitzpatrick_scale: false,
    category: "activity"
  },
  baseball: {
    keywords: [ "sports", "balls" ],
    char: "\u26be",
    fitzpatrick_scale: false,
    category: "activity"
  },
  softball: {
    keywords: [ "sports", "balls" ],
    char: "\ud83e\udd4e",
    fitzpatrick_scale: false,
    category: "activity"
  },
  tennis: {
    keywords: [ "sports", "balls", "green" ],
    char: "\ud83c\udfbe",
    fitzpatrick_scale: false,
    category: "activity"
  },
  volleyball: {
    keywords: [ "sports", "balls" ],
    char: "\ud83c\udfd0",
    fitzpatrick_scale: false,
    category: "activity"
  },
  rugby_football: {
    keywords: [ "sports", "team" ],
    char: "\ud83c\udfc9",
    fitzpatrick_scale: false,
    category: "activity"
  },
  flying_disc: {
    keywords: [ "sports", "frisbee", "ultimate" ],
    char: "\ud83e\udd4f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "8ball": {
    keywords: [ "pool", "hobby", "game", "luck", "magic" ],
    char: "\ud83c\udfb1",
    fitzpatrick_scale: false,
    category: "activity"
  },
  golf: {
    keywords: [ "sports", "business", "flag", "hole", "summer" ],
    char: "\u26f3",
    fitzpatrick_scale: false,
    category: "activity"
  },
  golfing_woman: {
    keywords: [ "sports", "business", "woman", "female" ],
    char: "\ud83c\udfcc\ufe0f\u200d\u2640\ufe0f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  golfing_man: {
    keywords: [ "sports", "business" ],
    char: "\ud83c\udfcc",
    fitzpatrick_scale: true,
    category: "activity"
  },
  ping_pong: {
    keywords: [ "sports", "pingpong" ],
    char: "\ud83c\udfd3",
    fitzpatrick_scale: false,
    category: "activity"
  },
  badminton: {
    keywords: [ "sports" ],
    char: "\ud83c\udff8",
    fitzpatrick_scale: false,
    category: "activity"
  },
  goal_net: {
    keywords: [ "sports" ],
    char: "\ud83e\udd45",
    fitzpatrick_scale: false,
    category: "activity"
  },
  ice_hockey: {
    keywords: [ "sports" ],
    char: "\ud83c\udfd2",
    fitzpatrick_scale: false,
    category: "activity"
  },
  field_hockey: {
    keywords: [ "sports" ],
    char: "\ud83c\udfd1",
    fitzpatrick_scale: false,
    category: "activity"
  },
  lacrosse: {
    keywords: [ "sports", "ball", "stick" ],
    char: "\ud83e\udd4d",
    fitzpatrick_scale: false,
    category: "activity"
  },
  cricket: {
    keywords: [ "sports" ],
    char: "\ud83c\udfcf",
    fitzpatrick_scale: false,
    category: "activity"
  },
  ski: {
    keywords: [ "sports", "winter", "cold", "snow" ],
    char: "\ud83c\udfbf",
    fitzpatrick_scale: false,
    category: "activity"
  },
  skier: {
    keywords: [ "sports", "winter", "snow" ],
    char: "\u26f7",
    fitzpatrick_scale: false,
    category: "activity"
  },
  snowboarder: {
    keywords: [ "sports", "winter" ],
    char: "\ud83c\udfc2",
    fitzpatrick_scale: true,
    category: "activity"
  },
  person_fencing: {
    keywords: [ "sports", "fencing", "sword" ],
    char: "\ud83e\udd3a",
    fitzpatrick_scale: false,
    category: "activity"
  },
  women_wrestling: {
    keywords: [ "sports", "wrestlers" ],
    char: "\ud83e\udd3c\u200d\u2640\ufe0f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  men_wrestling: {
    keywords: [ "sports", "wrestlers" ],
    char: "\ud83e\udd3c\u200d\u2642\ufe0f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  woman_cartwheeling: {
    keywords: [ "gymnastics" ],
    char: "\ud83e\udd38\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  man_cartwheeling: {
    keywords: [ "gymnastics" ],
    char: "\ud83e\udd38\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  woman_playing_handball: {
    keywords: [ "sports" ],
    char: "\ud83e\udd3e\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  man_playing_handball: {
    keywords: [ "sports" ],
    char: "\ud83e\udd3e\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  ice_skate: {
    keywords: [ "sports" ],
    char: "\u26f8",
    fitzpatrick_scale: false,
    category: "activity"
  },
  curling_stone: {
    keywords: [ "sports" ],
    char: "\ud83e\udd4c",
    fitzpatrick_scale: false,
    category: "activity"
  },
  skateboard: {
    keywords: [ "board" ],
    char: "\ud83d\udef9",
    fitzpatrick_scale: false,
    category: "activity"
  },
  sled: {
    keywords: [ "sleigh", "luge", "toboggan" ],
    char: "\ud83d\udef7",
    fitzpatrick_scale: false,
    category: "activity"
  },
  bow_and_arrow: {
    keywords: [ "sports" ],
    char: "\ud83c\udff9",
    fitzpatrick_scale: false,
    category: "activity"
  },
  fishing_pole_and_fish: {
    keywords: [ "food", "hobby", "summer" ],
    char: "\ud83c\udfa3",
    fitzpatrick_scale: false,
    category: "activity"
  },
  boxing_glove: {
    keywords: [ "sports", "fighting" ],
    char: "\ud83e\udd4a",
    fitzpatrick_scale: false,
    category: "activity"
  },
  martial_arts_uniform: {
    keywords: [ "judo", "karate", "taekwondo" ],
    char: "\ud83e\udd4b",
    fitzpatrick_scale: false,
    category: "activity"
  },
  rowing_woman: {
    keywords: [ "sports", "hobby", "water", "ship", "woman", "female" ],
    char: "\ud83d\udea3\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  rowing_man: {
    keywords: [ "sports", "hobby", "water", "ship" ],
    char: "\ud83d\udea3",
    fitzpatrick_scale: true,
    category: "activity"
  },
  climbing_woman: {
    keywords: [ "sports", "hobby", "woman", "female", "rock" ],
    char: "\ud83e\uddd7\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  climbing_man: {
    keywords: [ "sports", "hobby", "man", "male", "rock" ],
    char: "\ud83e\uddd7\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  swimming_woman: {
    keywords: [ "sports", "exercise", "human", "athlete", "water", "summer", "woman", "female" ],
    char: "\ud83c\udfca\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  swimming_man: {
    keywords: [ "sports", "exercise", "human", "athlete", "water", "summer" ],
    char: "\ud83c\udfca",
    fitzpatrick_scale: true,
    category: "activity"
  },
  woman_playing_water_polo: {
    keywords: [ "sports", "pool" ],
    char: "\ud83e\udd3d\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  man_playing_water_polo: {
    keywords: [ "sports", "pool" ],
    char: "\ud83e\udd3d\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  woman_in_lotus_position: {
    keywords: [ "woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness" ],
    char: "\ud83e\uddd8\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  man_in_lotus_position: {
    keywords: [ "man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness" ],
    char: "\ud83e\uddd8\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  surfing_woman: {
    keywords: [ "sports", "ocean", "sea", "summer", "beach", "woman", "female" ],
    char: "\ud83c\udfc4\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  surfing_man: {
    keywords: [ "sports", "ocean", "sea", "summer", "beach" ],
    char: "\ud83c\udfc4",
    fitzpatrick_scale: true,
    category: "activity"
  },
  bath: {
    keywords: [ "clean", "shower", "bathroom" ],
    char: "\ud83d\udec0",
    fitzpatrick_scale: true,
    category: "activity"
  },
  basketball_woman: {
    keywords: [ "sports", "human", "woman", "female" ],
    char: "\u26f9\ufe0f\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  basketball_man: {
    keywords: [ "sports", "human" ],
    char: "\u26f9",
    fitzpatrick_scale: true,
    category: "activity"
  },
  weight_lifting_woman: {
    keywords: [ "sports", "training", "exercise", "woman", "female" ],
    char: "\ud83c\udfcb\ufe0f\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  weight_lifting_man: {
    keywords: [ "sports", "training", "exercise" ],
    char: "\ud83c\udfcb",
    fitzpatrick_scale: true,
    category: "activity"
  },
  biking_woman: {
    keywords: [ "sports", "bike", "exercise", "hipster", "woman", "female" ],
    char: "\ud83d\udeb4\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  biking_man: {
    keywords: [ "sports", "bike", "exercise", "hipster" ],
    char: "\ud83d\udeb4",
    fitzpatrick_scale: true,
    category: "activity"
  },
  mountain_biking_woman: {
    keywords: [ "transportation", "sports", "human", "race", "bike", "woman", "female" ],
    char: "\ud83d\udeb5\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  mountain_biking_man: {
    keywords: [ "transportation", "sports", "human", "race", "bike" ],
    char: "\ud83d\udeb5",
    fitzpatrick_scale: true,
    category: "activity"
  },
  horse_racing: {
    keywords: [ "animal", "betting", "competition", "gambling", "luck" ],
    char: "\ud83c\udfc7",
    fitzpatrick_scale: true,
    category: "activity"
  },
  business_suit_levitating: {
    keywords: [ "suit", "business", "levitate", "hover", "jump" ],
    char: "\ud83d\udd74",
    fitzpatrick_scale: true,
    category: "activity"
  },
  trophy: {
    keywords: [ "win", "award", "contest", "place", "ftw", "ceremony" ],
    char: "\ud83c\udfc6",
    fitzpatrick_scale: false,
    category: "activity"
  },
  running_shirt_with_sash: {
    keywords: [ "play", "pageant" ],
    char: "\ud83c\udfbd",
    fitzpatrick_scale: false,
    category: "activity"
  },
  medal_sports: {
    keywords: [ "award", "winning" ],
    char: "\ud83c\udfc5",
    fitzpatrick_scale: false,
    category: "activity"
  },
  medal_military: {
    keywords: [ "award", "winning", "army" ],
    char: "\ud83c\udf96",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "1st_place_medal": {
    keywords: [ "award", "winning", "first" ],
    char: "\ud83e\udd47",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "2nd_place_medal": {
    keywords: [ "award", "second" ],
    char: "\ud83e\udd48",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "3rd_place_medal": {
    keywords: [ "award", "third" ],
    char: "\ud83e\udd49",
    fitzpatrick_scale: false,
    category: "activity"
  },
  reminder_ribbon: {
    keywords: [ "sports", "cause", "support", "awareness" ],
    char: "\ud83c\udf97",
    fitzpatrick_scale: false,
    category: "activity"
  },
  rosette: {
    keywords: [ "flower", "decoration", "military" ],
    char: "\ud83c\udff5",
    fitzpatrick_scale: false,
    category: "activity"
  },
  ticket: {
    keywords: [ "event", "concert", "pass" ],
    char: "\ud83c\udfab",
    fitzpatrick_scale: false,
    category: "activity"
  },
  tickets: {
    keywords: [ "sports", "concert", "entrance" ],
    char: "\ud83c\udf9f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  performing_arts: {
    keywords: [ "acting", "theater", "drama" ],
    char: "\ud83c\udfad",
    fitzpatrick_scale: false,
    category: "activity"
  },
  art: {
    keywords: [ "design", "paint", "draw", "colors" ],
    char: "\ud83c\udfa8",
    fitzpatrick_scale: false,
    category: "activity"
  },
  circus_tent: {
    keywords: [ "festival", "carnival", "party" ],
    char: "\ud83c\udfaa",
    fitzpatrick_scale: false,
    category: "activity"
  },
  woman_juggling: {
    keywords: [ "juggle", "balance", "skill", "multitask" ],
    char: "\ud83e\udd39\u200d\u2640\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  man_juggling: {
    keywords: [ "juggle", "balance", "skill", "multitask" ],
    char: "\ud83e\udd39\u200d\u2642\ufe0f",
    fitzpatrick_scale: true,
    category: "activity"
  },
  microphone: {
    keywords: [ "sound", "music", "PA", "sing", "talkshow" ],
    char: "\ud83c\udfa4",
    fitzpatrick_scale: false,
    category: "activity"
  },
  headphones: {
    keywords: [ "music", "score", "gadgets" ],
    char: "\ud83c\udfa7",
    fitzpatrick_scale: false,
    category: "activity"
  },
  musical_score: {
    keywords: [ "treble", "clef", "compose" ],
    char: "\ud83c\udfbc",
    fitzpatrick_scale: false,
    category: "activity"
  },
  musical_keyboard: {
    keywords: [ "piano", "instrument", "compose" ],
    char: "\ud83c\udfb9",
    fitzpatrick_scale: false,
    category: "activity"
  },
  drum: {
    keywords: [ "music", "instrument", "drumsticks", "snare" ],
    char: "\ud83e\udd41",
    fitzpatrick_scale: false,
    category: "activity"
  },
  saxophone: {
    keywords: [ "music", "instrument", "jazz", "blues" ],
    char: "\ud83c\udfb7",
    fitzpatrick_scale: false,
    category: "activity"
  },
  trumpet: {
    keywords: [ "music", "brass" ],
    char: "\ud83c\udfba",
    fitzpatrick_scale: false,
    category: "activity"
  },
  guitar: {
    keywords: [ "music", "instrument" ],
    char: "\ud83c\udfb8",
    fitzpatrick_scale: false,
    category: "activity"
  },
  violin: {
    keywords: [ "music", "instrument", "orchestra", "symphony" ],
    char: "\ud83c\udfbb",
    fitzpatrick_scale: false,
    category: "activity"
  },
  clapper: {
    keywords: [ "movie", "film", "record" ],
    char: "\ud83c\udfac",
    fitzpatrick_scale: false,
    category: "activity"
  },
  video_game: {
    keywords: [ "play", "console", "PS4", "controller" ],
    char: "\ud83c\udfae",
    fitzpatrick_scale: false,
    category: "activity"
  },
  space_invader: {
    keywords: [ "game", "arcade", "play" ],
    char: "\ud83d\udc7e",
    fitzpatrick_scale: false,
    category: "activity"
  },
  dart: {
    keywords: [ "game", "play", "bar", "target", "bullseye" ],
    char: "\ud83c\udfaf",
    fitzpatrick_scale: false,
    category: "activity"
  },
  game_die: {
    keywords: [ "dice", "random", "tabletop", "play", "luck" ],
    char: "\ud83c\udfb2",
    fitzpatrick_scale: false,
    category: "activity"
  },
  chess_pawn: {
    keywords: [ "expendable" ],
    char: "\u265f",
    fitzpatrick_scale: false,
    category: "activity"
  },
  slot_machine: {
    keywords: [ "bet", "gamble", "vegas", "fruit machine", "luck", "casino" ],
    char: "\ud83c\udfb0",
    fitzpatrick_scale: false,
    category: "activity"
  },
  jigsaw: {
    keywords: [ "interlocking", "puzzle", "piece" ],
    char: "\ud83e\udde9",
    fitzpatrick_scale: false,
    category: "activity"
  },
  bowling: {
    keywords: [ "sports", "fun", "play" ],
    char: "\ud83c\udfb3",
    fitzpatrick_scale: false,
    category: "activity"
  },
  red_car: {
    keywords: [ "red", "transportation", "vehicle" ],
    char: "\ud83d\ude97",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  taxi: {
    keywords: [ "uber", "vehicle", "cars", "transportation" ],
    char: "\ud83d\ude95",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  blue_car: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude99",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bus: {
    keywords: [ "car", "vehicle", "transportation" ],
    char: "\ud83d\ude8c",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  trolleybus: {
    keywords: [ "bart", "transportation", "vehicle" ],
    char: "\ud83d\ude8e",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  racing_car: {
    keywords: [ "sports", "race", "fast", "formula", "f1" ],
    char: "\ud83c\udfce",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  police_car: {
    keywords: [ "vehicle", "cars", "transportation", "law", "legal", "enforcement" ],
    char: "\ud83d\ude93",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  ambulance: {
    keywords: [ "health", "911", "hospital" ],
    char: "\ud83d\ude91",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  fire_engine: {
    keywords: [ "transportation", "cars", "vehicle" ],
    char: "\ud83d\ude92",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  minibus: {
    keywords: [ "vehicle", "car", "transportation" ],
    char: "\ud83d\ude90",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  truck: {
    keywords: [ "cars", "transportation" ],
    char: "\ud83d\ude9a",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  articulated_lorry: {
    keywords: [ "vehicle", "cars", "transportation", "express" ],
    char: "\ud83d\ude9b",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  tractor: {
    keywords: [ "vehicle", "car", "farming", "agriculture" ],
    char: "\ud83d\ude9c",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  kick_scooter: {
    keywords: [ "vehicle", "kick", "razor" ],
    char: "\ud83d\udef4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  motorcycle: {
    keywords: [ "race", "sports", "fast" ],
    char: "\ud83c\udfcd",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bike: {
    keywords: [ "sports", "bicycle", "exercise", "hipster" ],
    char: "\ud83d\udeb2",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  motor_scooter: {
    keywords: [ "vehicle", "vespa", "sasha" ],
    char: "\ud83d\udef5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  rotating_light: {
    keywords: [ "police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal" ],
    char: "\ud83d\udea8",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  oncoming_police_car: {
    keywords: [ "vehicle", "law", "legal", "enforcement", "911" ],
    char: "\ud83d\ude94",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  oncoming_bus: {
    keywords: [ "vehicle", "transportation" ],
    char: "\ud83d\ude8d",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  oncoming_automobile: {
    keywords: [ "car", "vehicle", "transportation" ],
    char: "\ud83d\ude98",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  oncoming_taxi: {
    keywords: [ "vehicle", "cars", "uber" ],
    char: "\ud83d\ude96",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  aerial_tramway: {
    keywords: [ "transportation", "vehicle", "ski" ],
    char: "\ud83d\udea1",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mountain_cableway: {
    keywords: [ "transportation", "vehicle", "ski" ],
    char: "\ud83d\udea0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  suspension_railway: {
    keywords: [ "vehicle", "transportation" ],
    char: "\ud83d\ude9f",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  railway_car: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude83",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  train: {
    keywords: [ "transportation", "vehicle", "carriage", "public", "travel" ],
    char: "\ud83d\ude8b",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  monorail: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude9d",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bullettrain_side: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude84",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bullettrain_front: {
    keywords: [ "transportation", "vehicle", "speed", "fast", "public", "travel" ],
    char: "\ud83d\ude85",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  light_rail: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude88",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mountain_railway: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude9e",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  steam_locomotive: {
    keywords: [ "transportation", "vehicle", "train" ],
    char: "\ud83d\ude82",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  train2: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude86",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  metro: {
    keywords: [ "transportation", "blue-square", "mrt", "underground", "tube" ],
    char: "\ud83d\ude87",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  tram: {
    keywords: [ "transportation", "vehicle" ],
    char: "\ud83d\ude8a",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  station: {
    keywords: [ "transportation", "vehicle", "public" ],
    char: "\ud83d\ude89",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  flying_saucer: {
    keywords: [ "transportation", "vehicle", "ufo" ],
    char: "\ud83d\udef8",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  helicopter: {
    keywords: [ "transportation", "vehicle", "fly" ],
    char: "\ud83d\ude81",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  small_airplane: {
    keywords: [ "flight", "transportation", "fly", "vehicle" ],
    char: "\ud83d\udee9",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  airplane: {
    keywords: [ "vehicle", "transportation", "flight", "fly" ],
    char: "\u2708\ufe0f",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  flight_departure: {
    keywords: [ "airport", "flight", "landing" ],
    char: "\ud83d\udeeb",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  flight_arrival: {
    keywords: [ "airport", "flight", "boarding" ],
    char: "\ud83d\udeec",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  sailboat: {
    keywords: [ "ship", "summer", "transportation", "water", "sailing" ],
    char: "\u26f5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  motor_boat: {
    keywords: [ "ship" ],
    char: "\ud83d\udee5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  speedboat: {
    keywords: [ "ship", "transportation", "vehicle", "summer" ],
    char: "\ud83d\udea4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  ferry: {
    keywords: [ "boat", "ship", "yacht" ],
    char: "\u26f4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  passenger_ship: {
    keywords: [ "yacht", "cruise", "ferry" ],
    char: "\ud83d\udef3",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  rocket: {
    keywords: [ "launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly" ],
    char: "\ud83d\ude80",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  artificial_satellite: {
    keywords: [ "communication", "gps", "orbit", "spaceflight", "NASA", "ISS" ],
    char: "\ud83d\udef0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  seat: {
    keywords: [ "sit", "airplane", "transport", "bus", "flight", "fly" ],
    char: "\ud83d\udcba",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  canoe: {
    keywords: [ "boat", "paddle", "water", "ship" ],
    char: "\ud83d\udef6",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  anchor: {
    keywords: [ "ship", "ferry", "sea", "boat" ],
    char: "\u2693",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  construction: {
    keywords: [ "wip", "progress", "caution", "warning" ],
    char: "\ud83d\udea7",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  fuelpump: {
    keywords: [ "gas station", "petroleum" ],
    char: "\u26fd",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  busstop: {
    keywords: [ "transportation", "wait" ],
    char: "\ud83d\ude8f",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  vertical_traffic_light: {
    keywords: [ "transportation", "driving" ],
    char: "\ud83d\udea6",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  traffic_light: {
    keywords: [ "transportation", "signal" ],
    char: "\ud83d\udea5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  checkered_flag: {
    keywords: [ "contest", "finishline", "race", "gokart" ],
    char: "\ud83c\udfc1",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  ship: {
    keywords: [ "transportation", "titanic", "deploy" ],
    char: "\ud83d\udea2",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  ferris_wheel: {
    keywords: [ "photo", "carnival", "londoneye" ],
    char: "\ud83c\udfa1",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  roller_coaster: {
    keywords: [ "carnival", "playground", "photo", "fun" ],
    char: "\ud83c\udfa2",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  carousel_horse: {
    keywords: [ "photo", "carnival" ],
    char: "\ud83c\udfa0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  building_construction: {
    keywords: [ "wip", "working", "progress" ],
    char: "\ud83c\udfd7",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  foggy: {
    keywords: [ "photo", "mountain" ],
    char: "\ud83c\udf01",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  tokyo_tower: {
    keywords: [ "photo", "japanese" ],
    char: "\ud83d\uddfc",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  factory: {
    keywords: [ "building", "industry", "pollution", "smoke" ],
    char: "\ud83c\udfed",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  fountain: {
    keywords: [ "photo", "summer", "water", "fresh" ],
    char: "\u26f2",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  rice_scene: {
    keywords: [ "photo", "japan", "asia", "tsukimi" ],
    char: "\ud83c\udf91",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mountain: {
    keywords: [ "photo", "nature", "environment" ],
    char: "\u26f0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mountain_snow: {
    keywords: [ "photo", "nature", "environment", "winter", "cold" ],
    char: "\ud83c\udfd4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mount_fuji: {
    keywords: [ "photo", "mountain", "nature", "japanese" ],
    char: "\ud83d\uddfb",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  volcano: {
    keywords: [ "photo", "nature", "disaster" ],
    char: "\ud83c\udf0b",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  japan: {
    keywords: [ "nation", "country", "japanese", "asia" ],
    char: "\ud83d\uddfe",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  camping: {
    keywords: [ "photo", "outdoors", "tent" ],
    char: "\ud83c\udfd5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  tent: {
    keywords: [ "photo", "camping", "outdoors" ],
    char: "\u26fa",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  national_park: {
    keywords: [ "photo", "environment", "nature" ],
    char: "\ud83c\udfde",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  motorway: {
    keywords: [ "road", "cupertino", "interstate", "highway" ],
    char: "\ud83d\udee3",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  railway_track: {
    keywords: [ "train", "transportation" ],
    char: "\ud83d\udee4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  sunrise: {
    keywords: [ "morning", "view", "vacation", "photo" ],
    char: "\ud83c\udf05",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  sunrise_over_mountains: {
    keywords: [ "view", "vacation", "photo" ],
    char: "\ud83c\udf04",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  desert: {
    keywords: [ "photo", "warm", "saharah" ],
    char: "\ud83c\udfdc",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  beach_umbrella: {
    keywords: [ "weather", "summer", "sunny", "sand", "mojito" ],
    char: "\ud83c\udfd6",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  desert_island: {
    keywords: [ "photo", "tropical", "mojito" ],
    char: "\ud83c\udfdd",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  city_sunrise: {
    keywords: [ "photo", "good morning", "dawn" ],
    char: "\ud83c\udf07",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  city_sunset: {
    keywords: [ "photo", "evening", "sky", "buildings" ],
    char: "\ud83c\udf06",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  cityscape: {
    keywords: [ "photo", "night life", "urban" ],
    char: "\ud83c\udfd9",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  night_with_stars: {
    keywords: [ "evening", "city", "downtown" ],
    char: "\ud83c\udf03",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bridge_at_night: {
    keywords: [ "photo", "sanfrancisco" ],
    char: "\ud83c\udf09",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  milky_way: {
    keywords: [ "photo", "space", "stars" ],
    char: "\ud83c\udf0c",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  stars: {
    keywords: [ "night", "photo" ],
    char: "\ud83c\udf20",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  sparkler: {
    keywords: [ "stars", "night", "shine" ],
    char: "\ud83c\udf87",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  fireworks: {
    keywords: [ "photo", "festival", "carnival", "congratulations" ],
    char: "\ud83c\udf86",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  rainbow: {
    keywords: [ "nature", "happy", "unicorn_face", "photo", "sky", "spring" ],
    char: "\ud83c\udf08",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  houses: {
    keywords: [ "buildings", "photo" ],
    char: "\ud83c\udfd8",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  european_castle: {
    keywords: [ "building", "royalty", "history" ],
    char: "\ud83c\udff0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  japanese_castle: {
    keywords: [ "photo", "building" ],
    char: "\ud83c\udfef",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  stadium: {
    keywords: [ "photo", "place", "sports", "concert", "venue" ],
    char: "\ud83c\udfdf",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  statue_of_liberty: {
    keywords: [ "american", "newyork" ],
    char: "\ud83d\uddfd",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  house: {
    keywords: [ "building", "home" ],
    char: "\ud83c\udfe0",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  house_with_garden: {
    keywords: [ "home", "plant", "nature" ],
    char: "\ud83c\udfe1",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  derelict_house: {
    keywords: [ "abandon", "evict", "broken", "building" ],
    char: "\ud83c\udfda",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  office: {
    keywords: [ "building", "bureau", "work" ],
    char: "\ud83c\udfe2",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  department_store: {
    keywords: [ "building", "shopping", "mall" ],
    char: "\ud83c\udfec",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  post_office: {
    keywords: [ "building", "envelope", "communication" ],
    char: "\ud83c\udfe3",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  european_post_office: {
    keywords: [ "building", "email" ],
    char: "\ud83c\udfe4",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  hospital: {
    keywords: [ "building", "health", "surgery", "doctor" ],
    char: "\ud83c\udfe5",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  bank: {
    keywords: [ "building", "money", "sales", "cash", "business", "enterprise" ],
    char: "\ud83c\udfe6",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  hotel: {
    keywords: [ "building", "accomodation", "checkin" ],
    char: "\ud83c\udfe8",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  convenience_store: {
    keywords: [ "building", "shopping", "groceries" ],
    char: "\ud83c\udfea",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  school: {
    keywords: [ "building", "student", "education", "learn", "teach" ],
    char: "\ud83c\udfeb",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  love_hotel: {
    keywords: [ "like", "affection", "dating" ],
    char: "\ud83c\udfe9",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  wedding: {
    keywords: [ "love", "like", "affection", "couple", "marriage", "bride", "groom" ],
    char: "\ud83d\udc92",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  classical_building: {
    keywords: [ "art", "culture", "history" ],
    char: "\ud83c\udfdb",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  church: {
    keywords: [ "building", "religion", "christ" ],
    char: "\u26ea",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  mosque: {
    keywords: [ "islam", "worship", "minaret" ],
    char: "\ud83d\udd4c",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  synagogue: {
    keywords: [ "judaism", "worship", "temple", "jewish" ],
    char: "\ud83d\udd4d",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  kaaba: {
    keywords: [ "mecca", "mosque", "islam" ],
    char: "\ud83d\udd4b",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  shinto_shrine: {
    keywords: [ "temple", "japan", "kyoto" ],
    char: "\u26e9",
    fitzpatrick_scale: false,
    category: "travel_and_places"
  },
  watch: {
    keywords: [ "time", "accessories" ],
    char: "\u231a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  iphone: {
    keywords: [ "technology", "apple", "gadgets", "dial" ],
    char: "\ud83d\udcf1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  calling: {
    keywords: [ "iphone", "incoming" ],
    char: "\ud83d\udcf2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  computer: {
    keywords: [ "technology", "laptop", "screen", "display", "monitor" ],
    char: "\ud83d\udcbb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  keyboard: {
    keywords: [ "technology", "computer", "type", "input", "text" ],
    char: "\u2328",
    fitzpatrick_scale: false,
    category: "objects"
  },
  desktop_computer: {
    keywords: [ "technology", "computing", "screen" ],
    char: "\ud83d\udda5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  printer: {
    keywords: [ "paper", "ink" ],
    char: "\ud83d\udda8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  computer_mouse: {
    keywords: [ "click" ],
    char: "\ud83d\uddb1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  trackball: {
    keywords: [ "technology", "trackpad" ],
    char: "\ud83d\uddb2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  joystick: {
    keywords: [ "game", "play" ],
    char: "\ud83d\udd79",
    fitzpatrick_scale: false,
    category: "objects"
  },
  clamp: {
    keywords: [ "tool" ],
    char: "\ud83d\udddc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  minidisc: {
    keywords: [ "technology", "record", "data", "disk", "90s" ],
    char: "\ud83d\udcbd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  floppy_disk: {
    keywords: [ "oldschool", "technology", "save", "90s", "80s" ],
    char: "\ud83d\udcbe",
    fitzpatrick_scale: false,
    category: "objects"
  },
  cd: {
    keywords: [ "technology", "dvd", "disk", "disc", "90s" ],
    char: "\ud83d\udcbf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  dvd: {
    keywords: [ "cd", "disk", "disc" ],
    char: "\ud83d\udcc0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  vhs: {
    keywords: [ "record", "video", "oldschool", "90s", "80s" ],
    char: "\ud83d\udcfc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  camera: {
    keywords: [ "gadgets", "photography" ],
    char: "\ud83d\udcf7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  camera_flash: {
    keywords: [ "photography", "gadgets" ],
    char: "\ud83d\udcf8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  video_camera: {
    keywords: [ "film", "record" ],
    char: "\ud83d\udcf9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  movie_camera: {
    keywords: [ "film", "record" ],
    char: "\ud83c\udfa5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  film_projector: {
    keywords: [ "video", "tape", "record", "movie" ],
    char: "\ud83d\udcfd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  film_strip: {
    keywords: [ "movie" ],
    char: "\ud83c\udf9e",
    fitzpatrick_scale: false,
    category: "objects"
  },
  telephone_receiver: {
    keywords: [ "technology", "communication", "dial" ],
    char: "\ud83d\udcde",
    fitzpatrick_scale: false,
    category: "objects"
  },
  phone: {
    keywords: [ "technology", "communication", "dial", "telephone" ],
    char: "\u260e\ufe0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pager: {
    keywords: [ "bbcall", "oldschool", "90s" ],
    char: "\ud83d\udcdf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  fax: {
    keywords: [ "communication", "technology" ],
    char: "\ud83d\udce0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  tv: {
    keywords: [ "technology", "program", "oldschool", "show", "television" ],
    char: "\ud83d\udcfa",
    fitzpatrick_scale: false,
    category: "objects"
  },
  radio: {
    keywords: [ "communication", "music", "podcast", "program" ],
    char: "\ud83d\udcfb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  studio_microphone: {
    keywords: [ "sing", "recording", "artist", "talkshow" ],
    char: "\ud83c\udf99",
    fitzpatrick_scale: false,
    category: "objects"
  },
  level_slider: {
    keywords: [ "scale" ],
    char: "\ud83c\udf9a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  control_knobs: {
    keywords: [ "dial" ],
    char: "\ud83c\udf9b",
    fitzpatrick_scale: false,
    category: "objects"
  },
  compass: {
    keywords: [ "magnetic", "navigation", "orienteering" ],
    char: "\ud83e\udded",
    fitzpatrick_scale: false,
    category: "objects"
  },
  stopwatch: {
    keywords: [ "time", "deadline" ],
    char: "\u23f1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  timer_clock: {
    keywords: [ "alarm" ],
    char: "\u23f2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  alarm_clock: {
    keywords: [ "time", "wake" ],
    char: "\u23f0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mantelpiece_clock: {
    keywords: [ "time" ],
    char: "\ud83d\udd70",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hourglass_flowing_sand: {
    keywords: [ "oldschool", "time", "countdown" ],
    char: "\u23f3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hourglass: {
    keywords: [ "time", "clock", "oldschool", "limit", "exam", "quiz", "test" ],
    char: "\u231b",
    fitzpatrick_scale: false,
    category: "objects"
  },
  satellite: {
    keywords: [ "communication", "future", "radio", "space" ],
    char: "\ud83d\udce1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  battery: {
    keywords: [ "power", "energy", "sustain" ],
    char: "\ud83d\udd0b",
    fitzpatrick_scale: false,
    category: "objects"
  },
  electric_plug: {
    keywords: [ "charger", "power" ],
    char: "\ud83d\udd0c",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bulb: {
    keywords: [ "light", "electricity", "idea" ],
    char: "\ud83d\udca1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  flashlight: {
    keywords: [ "dark", "camping", "sight", "night" ],
    char: "\ud83d\udd26",
    fitzpatrick_scale: false,
    category: "objects"
  },
  candle: {
    keywords: [ "fire", "wax" ],
    char: "\ud83d\udd6f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  fire_extinguisher: {
    keywords: [ "quench" ],
    char: "\ud83e\uddef",
    fitzpatrick_scale: false,
    category: "objects"
  },
  wastebasket: {
    keywords: [ "bin", "trash", "rubbish", "garbage", "toss" ],
    char: "\ud83d\uddd1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  oil_drum: {
    keywords: [ "barrell" ],
    char: "\ud83d\udee2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  money_with_wings: {
    keywords: [ "dollar", "bills", "payment", "sale" ],
    char: "\ud83d\udcb8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  dollar: {
    keywords: [ "money", "sales", "bill", "currency" ],
    char: "\ud83d\udcb5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  yen: {
    keywords: [ "money", "sales", "japanese", "dollar", "currency" ],
    char: "\ud83d\udcb4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  euro: {
    keywords: [ "money", "sales", "dollar", "currency" ],
    char: "\ud83d\udcb6",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pound: {
    keywords: [ "british", "sterling", "money", "sales", "bills", "uk", "england", "currency" ],
    char: "\ud83d\udcb7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  moneybag: {
    keywords: [ "dollar", "payment", "coins", "sale" ],
    char: "\ud83d\udcb0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  credit_card: {
    keywords: [ "money", "sales", "dollar", "bill", "payment", "shopping" ],
    char: "\ud83d\udcb3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  gem: {
    keywords: [ "blue", "ruby", "diamond", "jewelry" ],
    char: "\ud83d\udc8e",
    fitzpatrick_scale: false,
    category: "objects"
  },
  balance_scale: {
    keywords: [ "law", "fairness", "weight" ],
    char: "\u2696",
    fitzpatrick_scale: false,
    category: "objects"
  },
  toolbox: {
    keywords: [ "tools", "diy", "fix", "maintainer", "mechanic" ],
    char: "\ud83e\uddf0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  wrench: {
    keywords: [ "tools", "diy", "ikea", "fix", "maintainer" ],
    char: "\ud83d\udd27",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hammer: {
    keywords: [ "tools", "build", "create" ],
    char: "\ud83d\udd28",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hammer_and_pick: {
    keywords: [ "tools", "build", "create" ],
    char: "\u2692",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hammer_and_wrench: {
    keywords: [ "tools", "build", "create" ],
    char: "\ud83d\udee0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pick: {
    keywords: [ "tools", "dig" ],
    char: "\u26cf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  nut_and_bolt: {
    keywords: [ "handy", "tools", "fix" ],
    char: "\ud83d\udd29",
    fitzpatrick_scale: false,
    category: "objects"
  },
  gear: {
    keywords: [ "cog" ],
    char: "\u2699",
    fitzpatrick_scale: false,
    category: "objects"
  },
  brick: {
    keywords: [ "bricks" ],
    char: "\ud83e\uddf1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  chains: {
    keywords: [ "lock", "arrest" ],
    char: "\u26d3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  magnet: {
    keywords: [ "attraction", "magnetic" ],
    char: "\ud83e\uddf2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  gun: {
    keywords: [ "violence", "weapon", "pistol", "revolver" ],
    char: "\ud83d\udd2b",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bomb: {
    keywords: [ "boom", "explode", "explosion", "terrorism" ],
    char: "\ud83d\udca3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  firecracker: {
    keywords: [ "dynamite", "boom", "explode", "explosion", "explosive" ],
    char: "\ud83e\udde8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hocho: {
    keywords: [ "knife", "blade", "cutlery", "kitchen", "weapon" ],
    char: "\ud83d\udd2a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  dagger: {
    keywords: [ "weapon" ],
    char: "\ud83d\udde1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  crossed_swords: {
    keywords: [ "weapon" ],
    char: "\u2694",
    fitzpatrick_scale: false,
    category: "objects"
  },
  shield: {
    keywords: [ "protection", "security" ],
    char: "\ud83d\udee1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  smoking: {
    keywords: [ "kills", "tobacco", "cigarette", "joint", "smoke" ],
    char: "\ud83d\udeac",
    fitzpatrick_scale: false,
    category: "objects"
  },
  skull_and_crossbones: {
    keywords: [ "poison", "danger", "deadly", "scary", "death", "pirate", "evil" ],
    char: "\u2620",
    fitzpatrick_scale: false,
    category: "objects"
  },
  coffin: {
    keywords: [ "vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box" ],
    char: "\u26b0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  funeral_urn: {
    keywords: [ "dead", "die", "death", "rip", "ashes" ],
    char: "\u26b1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  amphora: {
    keywords: [ "vase", "jar" ],
    char: "\ud83c\udffa",
    fitzpatrick_scale: false,
    category: "objects"
  },
  crystal_ball: {
    keywords: [ "disco", "party", "magic", "circus", "fortune_teller" ],
    char: "\ud83d\udd2e",
    fitzpatrick_scale: false,
    category: "objects"
  },
  prayer_beads: {
    keywords: [ "dhikr", "religious" ],
    char: "\ud83d\udcff",
    fitzpatrick_scale: false,
    category: "objects"
  },
  nazar_amulet: {
    keywords: [ "bead", "charm" ],
    char: "\ud83e\uddff",
    fitzpatrick_scale: false,
    category: "objects"
  },
  barber: {
    keywords: [ "hair", "salon", "style" ],
    char: "\ud83d\udc88",
    fitzpatrick_scale: false,
    category: "objects"
  },
  alembic: {
    keywords: [ "distilling", "science", "experiment", "chemistry" ],
    char: "\u2697",
    fitzpatrick_scale: false,
    category: "objects"
  },
  telescope: {
    keywords: [ "stars", "space", "zoom", "science", "astronomy" ],
    char: "\ud83d\udd2d",
    fitzpatrick_scale: false,
    category: "objects"
  },
  microscope: {
    keywords: [ "laboratory", "experiment", "zoomin", "science", "study" ],
    char: "\ud83d\udd2c",
    fitzpatrick_scale: false,
    category: "objects"
  },
  hole: {
    keywords: [ "embarrassing" ],
    char: "\ud83d\udd73",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pill: {
    keywords: [ "health", "medicine", "doctor", "pharmacy", "drug" ],
    char: "\ud83d\udc8a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  syringe: {
    keywords: [ "health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse" ],
    char: "\ud83d\udc89",
    fitzpatrick_scale: false,
    category: "objects"
  },
  dna: {
    keywords: [ "biologist", "genetics", "life" ],
    char: "\ud83e\uddec",
    fitzpatrick_scale: false,
    category: "objects"
  },
  microbe: {
    keywords: [ "amoeba", "bacteria", "germs" ],
    char: "\ud83e\udda0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  petri_dish: {
    keywords: [ "bacteria", "biology", "culture", "lab" ],
    char: "\ud83e\uddeb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  test_tube: {
    keywords: [ "chemistry", "experiment", "lab", "science" ],
    char: "\ud83e\uddea",
    fitzpatrick_scale: false,
    category: "objects"
  },
  thermometer: {
    keywords: [ "weather", "temperature", "hot", "cold" ],
    char: "\ud83c\udf21",
    fitzpatrick_scale: false,
    category: "objects"
  },
  broom: {
    keywords: [ "cleaning", "sweeping", "witch" ],
    char: "\ud83e\uddf9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  basket: {
    keywords: [ "laundry" ],
    char: "\ud83e\uddfa",
    fitzpatrick_scale: false,
    category: "objects"
  },
  toilet_paper: {
    keywords: [ "roll" ],
    char: "\ud83e\uddfb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  label: {
    keywords: [ "sale", "tag" ],
    char: "\ud83c\udff7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bookmark: {
    keywords: [ "favorite", "label", "save" ],
    char: "\ud83d\udd16",
    fitzpatrick_scale: false,
    category: "objects"
  },
  toilet: {
    keywords: [ "restroom", "wc", "washroom", "bathroom", "potty" ],
    char: "\ud83d\udebd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  shower: {
    keywords: [ "clean", "water", "bathroom" ],
    char: "\ud83d\udebf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bathtub: {
    keywords: [ "clean", "shower", "bathroom" ],
    char: "\ud83d\udec1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  soap: {
    keywords: [ "bar", "bathing", "cleaning", "lather" ],
    char: "\ud83e\uddfc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  sponge: {
    keywords: [ "absorbing", "cleaning", "porous" ],
    char: "\ud83e\uddfd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  lotion_bottle: {
    keywords: [ "moisturizer", "sunscreen" ],
    char: "\ud83e\uddf4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  key: {
    keywords: [ "lock", "door", "password" ],
    char: "\ud83d\udd11",
    fitzpatrick_scale: false,
    category: "objects"
  },
  old_key: {
    keywords: [ "lock", "door", "password" ],
    char: "\ud83d\udddd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  couch_and_lamp: {
    keywords: [ "read", "chill" ],
    char: "\ud83d\udecb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  sleeping_bed: {
    keywords: [ "bed", "rest" ],
    char: "\ud83d\udecc",
    fitzpatrick_scale: true,
    category: "objects"
  },
  bed: {
    keywords: [ "sleep", "rest" ],
    char: "\ud83d\udecf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  door: {
    keywords: [ "house", "entry", "exit" ],
    char: "\ud83d\udeaa",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bellhop_bell: {
    keywords: [ "service" ],
    char: "\ud83d\udece",
    fitzpatrick_scale: false,
    category: "objects"
  },
  teddy_bear: {
    keywords: [ "plush", "stuffed" ],
    char: "\ud83e\uddf8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  framed_picture: {
    keywords: [ "photography" ],
    char: "\ud83d\uddbc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  world_map: {
    keywords: [ "location", "direction" ],
    char: "\ud83d\uddfa",
    fitzpatrick_scale: false,
    category: "objects"
  },
  parasol_on_ground: {
    keywords: [ "weather", "summer" ],
    char: "\u26f1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  moyai: {
    keywords: [ "rock", "easter island", "moai" ],
    char: "\ud83d\uddff",
    fitzpatrick_scale: false,
    category: "objects"
  },
  shopping: {
    keywords: [ "mall", "buy", "purchase" ],
    char: "\ud83d\udecd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  shopping_cart: {
    keywords: [ "trolley" ],
    char: "\ud83d\uded2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  balloon: {
    keywords: [ "party", "celebration", "birthday", "circus" ],
    char: "\ud83c\udf88",
    fitzpatrick_scale: false,
    category: "objects"
  },
  flags: {
    keywords: [ "fish", "japanese", "koinobori", "carp", "banner" ],
    char: "\ud83c\udf8f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  ribbon: {
    keywords: [ "decoration", "pink", "girl", "bowtie" ],
    char: "\ud83c\udf80",
    fitzpatrick_scale: false,
    category: "objects"
  },
  gift: {
    keywords: [ "present", "birthday", "christmas", "xmas" ],
    char: "\ud83c\udf81",
    fitzpatrick_scale: false,
    category: "objects"
  },
  confetti_ball: {
    keywords: [ "festival", "party", "birthday", "circus" ],
    char: "\ud83c\udf8a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  tada: {
    keywords: [ "party", "congratulations", "birthday", "magic", "circus", "celebration" ],
    char: "\ud83c\udf89",
    fitzpatrick_scale: false,
    category: "objects"
  },
  dolls: {
    keywords: [ "japanese", "toy", "kimono" ],
    char: "\ud83c\udf8e",
    fitzpatrick_scale: false,
    category: "objects"
  },
  wind_chime: {
    keywords: [ "nature", "ding", "spring", "bell" ],
    char: "\ud83c\udf90",
    fitzpatrick_scale: false,
    category: "objects"
  },
  crossed_flags: {
    keywords: [ "japanese", "nation", "country", "border" ],
    char: "\ud83c\udf8c",
    fitzpatrick_scale: false,
    category: "objects"
  },
  izakaya_lantern: {
    keywords: [ "light", "paper", "halloween", "spooky" ],
    char: "\ud83c\udfee",
    fitzpatrick_scale: false,
    category: "objects"
  },
  red_envelope: {
    keywords: [ "gift" ],
    char: "\ud83e\udde7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  email: {
    keywords: [ "letter", "postal", "inbox", "communication" ],
    char: "\u2709\ufe0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  envelope_with_arrow: {
    keywords: [ "email", "communication" ],
    char: "\ud83d\udce9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  incoming_envelope: {
    keywords: [ "email", "inbox" ],
    char: "\ud83d\udce8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  "e-mail": {
    keywords: [ "communication", "inbox" ],
    char: "\ud83d\udce7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  love_letter: {
    keywords: [ "email", "like", "affection", "envelope", "valentines" ],
    char: "\ud83d\udc8c",
    fitzpatrick_scale: false,
    category: "objects"
  },
  postbox: {
    keywords: [ "email", "letter", "envelope" ],
    char: "\ud83d\udcee",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mailbox_closed: {
    keywords: [ "email", "communication", "inbox" ],
    char: "\ud83d\udcea",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mailbox: {
    keywords: [ "email", "inbox", "communication" ],
    char: "\ud83d\udceb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mailbox_with_mail: {
    keywords: [ "email", "inbox", "communication" ],
    char: "\ud83d\udcec",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mailbox_with_no_mail: {
    keywords: [ "email", "inbox" ],
    char: "\ud83d\udced",
    fitzpatrick_scale: false,
    category: "objects"
  },
  package: {
    keywords: [ "mail", "gift", "cardboard", "box", "moving" ],
    char: "\ud83d\udce6",
    fitzpatrick_scale: false,
    category: "objects"
  },
  postal_horn: {
    keywords: [ "instrument", "music" ],
    char: "\ud83d\udcef",
    fitzpatrick_scale: false,
    category: "objects"
  },
  inbox_tray: {
    keywords: [ "email", "documents" ],
    char: "\ud83d\udce5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  outbox_tray: {
    keywords: [ "inbox", "email" ],
    char: "\ud83d\udce4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  scroll: {
    keywords: [ "documents", "ancient", "history", "paper" ],
    char: "\ud83d\udcdc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  page_with_curl: {
    keywords: [ "documents", "office", "paper" ],
    char: "\ud83d\udcc3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bookmark_tabs: {
    keywords: [ "favorite", "save", "order", "tidy" ],
    char: "\ud83d\udcd1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  receipt: {
    keywords: [ "accounting", "expenses" ],
    char: "\ud83e\uddfe",
    fitzpatrick_scale: false,
    category: "objects"
  },
  bar_chart: {
    keywords: [ "graph", "presentation", "stats" ],
    char: "\ud83d\udcca",
    fitzpatrick_scale: false,
    category: "objects"
  },
  chart_with_upwards_trend: {
    keywords: [ "graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success" ],
    char: "\ud83d\udcc8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  chart_with_downwards_trend: {
    keywords: [ "graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure" ],
    char: "\ud83d\udcc9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  page_facing_up: {
    keywords: [ "documents", "office", "paper", "information" ],
    char: "\ud83d\udcc4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  date: {
    keywords: [ "calendar", "schedule" ],
    char: "\ud83d\udcc5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  calendar: {
    keywords: [ "schedule", "date", "planning" ],
    char: "\ud83d\udcc6",
    fitzpatrick_scale: false,
    category: "objects"
  },
  spiral_calendar: {
    keywords: [ "date", "schedule", "planning" ],
    char: "\ud83d\uddd3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  card_index: {
    keywords: [ "business", "stationery" ],
    char: "\ud83d\udcc7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  card_file_box: {
    keywords: [ "business", "stationery" ],
    char: "\ud83d\uddc3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  ballot_box: {
    keywords: [ "election", "vote" ],
    char: "\ud83d\uddf3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  file_cabinet: {
    keywords: [ "filing", "organizing" ],
    char: "\ud83d\uddc4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  clipboard: {
    keywords: [ "stationery", "documents" ],
    char: "\ud83d\udccb",
    fitzpatrick_scale: false,
    category: "objects"
  },
  spiral_notepad: {
    keywords: [ "memo", "stationery" ],
    char: "\ud83d\uddd2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  file_folder: {
    keywords: [ "documents", "business", "office" ],
    char: "\ud83d\udcc1",
    fitzpatrick_scale: false,
    category: "objects"
  },
  open_file_folder: {
    keywords: [ "documents", "load" ],
    char: "\ud83d\udcc2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  card_index_dividers: {
    keywords: [ "organizing", "business", "stationery" ],
    char: "\ud83d\uddc2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  newspaper_roll: {
    keywords: [ "press", "headline" ],
    char: "\ud83d\uddde",
    fitzpatrick_scale: false,
    category: "objects"
  },
  newspaper: {
    keywords: [ "press", "headline" ],
    char: "\ud83d\udcf0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  notebook: {
    keywords: [ "stationery", "record", "notes", "paper", "study" ],
    char: "\ud83d\udcd3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  closed_book: {
    keywords: [ "read", "library", "knowledge", "textbook", "learn" ],
    char: "\ud83d\udcd5",
    fitzpatrick_scale: false,
    category: "objects"
  },
  green_book: {
    keywords: [ "read", "library", "knowledge", "study" ],
    char: "\ud83d\udcd7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  blue_book: {
    keywords: [ "read", "library", "knowledge", "learn", "study" ],
    char: "\ud83d\udcd8",
    fitzpatrick_scale: false,
    category: "objects"
  },
  orange_book: {
    keywords: [ "read", "library", "knowledge", "textbook", "study" ],
    char: "\ud83d\udcd9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  notebook_with_decorative_cover: {
    keywords: [ "classroom", "notes", "record", "paper", "study" ],
    char: "\ud83d\udcd4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  ledger: {
    keywords: [ "notes", "paper" ],
    char: "\ud83d\udcd2",
    fitzpatrick_scale: false,
    category: "objects"
  },
  books: {
    keywords: [ "literature", "library", "study" ],
    char: "\ud83d\udcda",
    fitzpatrick_scale: false,
    category: "objects"
  },
  open_book: {
    keywords: [ "book", "read", "library", "knowledge", "literature", "learn", "study" ],
    char: "\ud83d\udcd6",
    fitzpatrick_scale: false,
    category: "objects"
  },
  safety_pin: {
    keywords: [ "diaper" ],
    char: "\ud83e\uddf7",
    fitzpatrick_scale: false,
    category: "objects"
  },
  link: {
    keywords: [ "rings", "url" ],
    char: "\ud83d\udd17",
    fitzpatrick_scale: false,
    category: "objects"
  },
  paperclip: {
    keywords: [ "documents", "stationery" ],
    char: "\ud83d\udcce",
    fitzpatrick_scale: false,
    category: "objects"
  },
  paperclips: {
    keywords: [ "documents", "stationery" ],
    char: "\ud83d\udd87",
    fitzpatrick_scale: false,
    category: "objects"
  },
  scissors: {
    keywords: [ "stationery", "cut" ],
    char: "\u2702\ufe0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  triangular_ruler: {
    keywords: [ "stationery", "math", "architect", "sketch" ],
    char: "\ud83d\udcd0",
    fitzpatrick_scale: false,
    category: "objects"
  },
  straight_ruler: {
    keywords: [ "stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch" ],
    char: "\ud83d\udccf",
    fitzpatrick_scale: false,
    category: "objects"
  },
  abacus: {
    keywords: [ "calculation" ],
    char: "\ud83e\uddee",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pushpin: {
    keywords: [ "stationery", "mark", "here" ],
    char: "\ud83d\udccc",
    fitzpatrick_scale: false,
    category: "objects"
  },
  round_pushpin: {
    keywords: [ "stationery", "location", "map", "here" ],
    char: "\ud83d\udccd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  triangular_flag_on_post: {
    keywords: [ "mark", "milestone", "place" ],
    char: "\ud83d\udea9",
    fitzpatrick_scale: false,
    category: "objects"
  },
  white_flag: {
    keywords: [ "losing", "loser", "lost", "surrender", "give up", "fail" ],
    char: "\ud83c\udff3",
    fitzpatrick_scale: false,
    category: "objects"
  },
  black_flag: {
    keywords: [ "pirate" ],
    char: "\ud83c\udff4",
    fitzpatrick_scale: false,
    category: "objects"
  },
  rainbow_flag: {
    keywords: [ "flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender" ],
    char: "\ud83c\udff3\ufe0f\u200d\ud83c\udf08",
    fitzpatrick_scale: false,
    category: "objects"
  },
  closed_lock_with_key: {
    keywords: [ "security", "privacy" ],
    char: "\ud83d\udd10",
    fitzpatrick_scale: false,
    category: "objects"
  },
  lock: {
    keywords: [ "security", "password", "padlock" ],
    char: "\ud83d\udd12",
    fitzpatrick_scale: false,
    category: "objects"
  },
  unlock: {
    keywords: [ "privacy", "security" ],
    char: "\ud83d\udd13",
    fitzpatrick_scale: false,
    category: "objects"
  },
  lock_with_ink_pen: {
    keywords: [ "security", "secret" ],
    char: "\ud83d\udd0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pen: {
    keywords: [ "stationery", "writing", "write" ],
    char: "\ud83d\udd8a",
    fitzpatrick_scale: false,
    category: "objects"
  },
  fountain_pen: {
    keywords: [ "stationery", "writing", "write" ],
    char: "\ud83d\udd8b",
    fitzpatrick_scale: false,
    category: "objects"
  },
  black_nib: {
    keywords: [ "pen", "stationery", "writing", "write" ],
    char: "\u2712\ufe0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  memo: {
    keywords: [ "write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose" ],
    char: "\ud83d\udcdd",
    fitzpatrick_scale: false,
    category: "objects"
  },
  pencil2: {
    keywords: [ "stationery", "write", "paper", "writing", "school", "study" ],
    char: "\u270f\ufe0f",
    fitzpatrick_scale: false,
    category: "objects"
  },
  crayon: {
    keywords: [ "drawing", "creativity" ],
    char: "\ud83d\udd8d",
    fitzpatrick_scale: false,
    category: "objects"
  },
  paintbrush: {
    keywords: [ "drawing", "creativity", "art" ],
    char: "\ud83d\udd8c",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mag: {
    keywords: [ "search", "zoom", "find", "detective" ],
    char: "\ud83d\udd0d",
    fitzpatrick_scale: false,
    category: "objects"
  },
  mag_right: {
    keywords: [ "search", "zoom", "find", "detective" ],
    char: "\ud83d\udd0e",
    fitzpatrick_scale: false,
    category: "objects"
  },
  heart: {
    keywords: [ "love", "like", "valentines" ],
    char: "\u2764\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  orange_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83e\udde1",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  yellow_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc9b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  green_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc9a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  blue_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc99",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  purple_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc9c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_heart: {
    keywords: [ "evil" ],
    char: "\ud83d\udda4",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  broken_heart: {
    keywords: [ "sad", "sorry", "break", "heart", "heartbreak" ],
    char: "\ud83d\udc94",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_heart_exclamation: {
    keywords: [ "decoration", "love" ],
    char: "\u2763",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  two_hearts: {
    keywords: [ "love", "like", "affection", "valentines", "heart" ],
    char: "\ud83d\udc95",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  revolving_hearts: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc9e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heartbeat: {
    keywords: [ "love", "like", "affection", "valentines", "pink", "heart" ],
    char: "\ud83d\udc93",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heartpulse: {
    keywords: [ "like", "love", "affection", "valentines", "pink" ],
    char: "\ud83d\udc97",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sparkling_heart: {
    keywords: [ "love", "like", "affection", "valentines" ],
    char: "\ud83d\udc96",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cupid: {
    keywords: [ "love", "like", "heart", "affection", "valentines" ],
    char: "\ud83d\udc98",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  gift_heart: {
    keywords: [ "love", "valentines" ],
    char: "\ud83d\udc9d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heart_decoration: {
    keywords: [ "purple-square", "love", "like" ],
    char: "\ud83d\udc9f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  peace_symbol: {
    keywords: [ "hippie" ],
    char: "\u262e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  latin_cross: {
    keywords: [ "christianity" ],
    char: "\u271d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  star_and_crescent: {
    keywords: [ "islam" ],
    char: "\u262a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  om: {
    keywords: [ "hinduism", "buddhism", "sikhism", "jainism" ],
    char: "\ud83d\udd49",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  wheel_of_dharma: {
    keywords: [ "hinduism", "buddhism", "sikhism", "jainism" ],
    char: "\u2638",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  star_of_david: {
    keywords: [ "judaism" ],
    char: "\u2721",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  six_pointed_star: {
    keywords: [ "purple-square", "religion", "jewish", "hexagram" ],
    char: "\ud83d\udd2f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  menorah: {
    keywords: [ "hanukkah", "candles", "jewish" ],
    char: "\ud83d\udd4e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  yin_yang: {
    keywords: [ "balance" ],
    char: "\u262f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  orthodox_cross: {
    keywords: [ "suppedaneum", "religion" ],
    char: "\u2626",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  place_of_worship: {
    keywords: [ "religion", "church", "temple", "prayer" ],
    char: "\ud83d\uded0",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ophiuchus: {
    keywords: [ "sign", "purple-square", "constellation", "astrology" ],
    char: "\u26ce",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  aries: {
    keywords: [ "sign", "purple-square", "zodiac", "astrology" ],
    char: "\u2648",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  taurus: {
    keywords: [ "purple-square", "sign", "zodiac", "astrology" ],
    char: "\u2649",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  gemini: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology" ],
    char: "\u264a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cancer: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology" ],
    char: "\u264b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  leo: {
    keywords: [ "sign", "purple-square", "zodiac", "astrology" ],
    char: "\u264c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  virgo: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology" ],
    char: "\u264d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  libra: {
    keywords: [ "sign", "purple-square", "zodiac", "astrology" ],
    char: "\u264e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  scorpius: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology", "scorpio" ],
    char: "\u264f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sagittarius: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology" ],
    char: "\u2650",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  capricorn: {
    keywords: [ "sign", "zodiac", "purple-square", "astrology" ],
    char: "\u2651",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  aquarius: {
    keywords: [ "sign", "purple-square", "zodiac", "astrology" ],
    char: "\u2652",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  pisces: {
    keywords: [ "purple-square", "sign", "zodiac", "astrology" ],
    char: "\u2653",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  id: {
    keywords: [ "purple-square", "words" ],
    char: "\ud83c\udd94",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  atom_symbol: {
    keywords: [ "science", "physics", "chemistry" ],
    char: "\u269b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u7a7a: {
    keywords: [ "kanji", "japanese", "chinese", "empty", "sky", "blue-square" ],
    char: "\ud83c\ude33",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u5272: {
    keywords: [ "cut", "divide", "chinese", "kanji", "pink-square" ],
    char: "\ud83c\ude39",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  radioactive: {
    keywords: [ "nuclear", "danger" ],
    char: "\u2622",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  biohazard: {
    keywords: [ "danger" ],
    char: "\u2623",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  mobile_phone_off: {
    keywords: [ "mute", "orange-square", "silence", "quiet" ],
    char: "\ud83d\udcf4",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  vibration_mode: {
    keywords: [ "orange-square", "phone" ],
    char: "\ud83d\udcf3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u6709: {
    keywords: [ "orange-square", "chinese", "have", "kanji" ],
    char: "\ud83c\ude36",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u7121: {
    keywords: [ "nothing", "chinese", "kanji", "japanese", "orange-square" ],
    char: "\ud83c\ude1a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u7533: {
    keywords: [ "chinese", "japanese", "kanji", "orange-square" ],
    char: "\ud83c\ude38",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u55b6: {
    keywords: [ "japanese", "opening hours", "orange-square" ],
    char: "\ud83c\ude3a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u6708: {
    keywords: [ "chinese", "month", "moon", "japanese", "orange-square", "kanji" ],
    char: "\ud83c\ude37\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  eight_pointed_black_star: {
    keywords: [ "orange-square", "shape", "polygon" ],
    char: "\u2734\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  vs: {
    keywords: [ "words", "orange-square" ],
    char: "\ud83c\udd9a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  accept: {
    keywords: [ "ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle" ],
    char: "\ud83c\ude51",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_flower: {
    keywords: [ "japanese", "spring" ],
    char: "\ud83d\udcae",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ideograph_advantage: {
    keywords: [ "chinese", "kanji", "obtain", "get", "circle" ],
    char: "\ud83c\ude50",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  secret: {
    keywords: [ "privacy", "chinese", "sshh", "kanji", "red-circle" ],
    char: "\u3299\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  congratulations: {
    keywords: [ "chinese", "kanji", "japanese", "red-circle" ],
    char: "\u3297\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u5408: {
    keywords: [ "japanese", "chinese", "join", "kanji", "red-square" ],
    char: "\ud83c\ude34",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u6e80: {
    keywords: [ "full", "chinese", "japanese", "red-square", "kanji" ],
    char: "\ud83c\ude35",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u7981: {
    keywords: [ "kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square" ],
    char: "\ud83c\ude32",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  a: {
    keywords: [ "red-square", "alphabet", "letter" ],
    char: "\ud83c\udd70\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  b: {
    keywords: [ "red-square", "alphabet", "letter" ],
    char: "\ud83c\udd71\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ab: {
    keywords: [ "red-square", "alphabet" ],
    char: "\ud83c\udd8e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cl: {
    keywords: [ "alphabet", "words", "red-square" ],
    char: "\ud83c\udd91",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  o2: {
    keywords: [ "alphabet", "red-square", "letter" ],
    char: "\ud83c\udd7e\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sos: {
    keywords: [ "help", "red-square", "words", "emergency", "911" ],
    char: "\ud83c\udd98",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_entry: {
    keywords: [ "limit", "security", "privacy", "bad", "denied", "stop", "circle" ],
    char: "\u26d4",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  name_badge: {
    keywords: [ "fire", "forbid" ],
    char: "\ud83d\udcdb",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_entry_sign: {
    keywords: [ "forbid", "stop", "limit", "denied", "disallow", "circle" ],
    char: "\ud83d\udeab",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  x: {
    keywords: [ "no", "delete", "remove", "cancel", "red" ],
    char: "\u274c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  o: {
    keywords: [ "circle", "round" ],
    char: "\u2b55",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  stop_sign: {
    keywords: [ "stop" ],
    char: "\ud83d\uded1",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  anger: {
    keywords: [ "angry", "mad" ],
    char: "\ud83d\udca2",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  hotsprings: {
    keywords: [ "bath", "warm", "relax" ],
    char: "\u2668\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_pedestrians: {
    keywords: [ "rules", "crossing", "walking", "circle" ],
    char: "\ud83d\udeb7",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  do_not_litter: {
    keywords: [ "trash", "bin", "garbage", "circle" ],
    char: "\ud83d\udeaf",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_bicycles: {
    keywords: [ "cyclist", "prohibited", "circle" ],
    char: "\ud83d\udeb3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  "non-potable_water": {
    keywords: [ "drink", "faucet", "tap", "circle" ],
    char: "\ud83d\udeb1",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  underage: {
    keywords: [ "18", "drink", "pub", "night", "minor", "circle" ],
    char: "\ud83d\udd1e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_mobile_phones: {
    keywords: [ "iphone", "mute", "circle" ],
    char: "\ud83d\udcf5",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  exclamation: {
    keywords: [ "heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning" ],
    char: "\u2757",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  grey_exclamation: {
    keywords: [ "surprise", "punctuation", "gray", "wow", "warning" ],
    char: "\u2755",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  question: {
    keywords: [ "doubt", "confused" ],
    char: "\u2753",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  grey_question: {
    keywords: [ "doubts", "gray", "huh", "confused" ],
    char: "\u2754",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  bangbang: {
    keywords: [ "exclamation", "surprise" ],
    char: "\u203c\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  interrobang: {
    keywords: [ "wat", "punctuation", "surprise" ],
    char: "\u2049\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  100: {
    keywords: [ "score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred" ],
    char: "\ud83d\udcaf",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  low_brightness: {
    keywords: [ "sun", "afternoon", "warm", "summer" ],
    char: "\ud83d\udd05",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  high_brightness: {
    keywords: [ "sun", "light" ],
    char: "\ud83d\udd06",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  trident: {
    keywords: [ "weapon", "spear" ],
    char: "\ud83d\udd31",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  fleur_de_lis: {
    keywords: [ "decorative", "scout" ],
    char: "\u269c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  part_alternation_mark: {
    keywords: [ "graph", "presentation", "stats", "business", "economics", "bad" ],
    char: "\u303d\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  warning: {
    keywords: [ "exclamation", "wip", "alert", "error", "problem", "issue" ],
    char: "\u26a0\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  children_crossing: {
    keywords: [ "school", "warning", "danger", "sign", "driving", "yellow-diamond" ],
    char: "\ud83d\udeb8",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  beginner: {
    keywords: [ "badge", "shield" ],
    char: "\ud83d\udd30",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  recycle: {
    keywords: [ "arrow", "environment", "garbage", "trash" ],
    char: "\u267b\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  u6307: {
    keywords: [ "chinese", "point", "green-square", "kanji" ],
    char: "\ud83c\ude2f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  chart: {
    keywords: [ "green-square", "graph", "presentation", "stats" ],
    char: "\ud83d\udcb9",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sparkle: {
    keywords: [ "stars", "green-square", "awesome", "good", "fireworks" ],
    char: "\u2747\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  eight_spoked_asterisk: {
    keywords: [ "star", "sparkle", "green-square" ],
    char: "\u2733\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  negative_squared_cross_mark: {
    keywords: [ "x", "green-square", "no", "deny" ],
    char: "\u274e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_check_mark: {
    keywords: [ "green-square", "ok", "agree", "vote", "election", "answer", "tick" ],
    char: "\u2705",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  diamond_shape_with_a_dot_inside: {
    keywords: [ "jewel", "blue", "gem", "crystal", "fancy" ],
    char: "\ud83d\udca0",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cyclone: {
    keywords: [ "weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon" ],
    char: "\ud83c\udf00",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  loop: {
    keywords: [ "tape", "cassette" ],
    char: "\u27bf",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  globe_with_meridians: {
    keywords: [ "earth", "international", "world", "internet", "interweb", "i18n" ],
    char: "\ud83c\udf10",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  m: {
    keywords: [ "alphabet", "blue-circle", "letter" ],
    char: "\u24c2\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  atm: {
    keywords: [ "money", "sales", "cash", "blue-square", "payment", "bank" ],
    char: "\ud83c\udfe7",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sa: {
    keywords: [ "japanese", "blue-square", "katakana" ],
    char: "\ud83c\ude02\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  passport_control: {
    keywords: [ "custom", "blue-square" ],
    char: "\ud83d\udec2",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  customs: {
    keywords: [ "passport", "border", "blue-square" ],
    char: "\ud83d\udec3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  baggage_claim: {
    keywords: [ "blue-square", "airport", "transport" ],
    char: "\ud83d\udec4",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  left_luggage: {
    keywords: [ "blue-square", "travel" ],
    char: "\ud83d\udec5",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  wheelchair: {
    keywords: [ "blue-square", "disabled", "a11y", "accessibility" ],
    char: "\u267f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_smoking: {
    keywords: [ "cigarette", "blue-square", "smell", "smoke" ],
    char: "\ud83d\udead",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  wc: {
    keywords: [ "toilet", "restroom", "blue-square" ],
    char: "\ud83d\udebe",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  parking: {
    keywords: [ "cars", "blue-square", "alphabet", "letter" ],
    char: "\ud83c\udd7f\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  potable_water: {
    keywords: [ "blue-square", "liquid", "restroom", "cleaning", "faucet" ],
    char: "\ud83d\udeb0",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  mens: {
    keywords: [ "toilet", "restroom", "wc", "blue-square", "gender", "male" ],
    char: "\ud83d\udeb9",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  womens: {
    keywords: [ "purple-square", "woman", "female", "toilet", "loo", "restroom", "gender" ],
    char: "\ud83d\udeba",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  baby_symbol: {
    keywords: [ "orange-square", "child" ],
    char: "\ud83d\udebc",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  restroom: {
    keywords: [ "blue-square", "toilet", "refresh", "wc", "gender" ],
    char: "\ud83d\udebb",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  put_litter_in_its_place: {
    keywords: [ "blue-square", "sign", "human", "info" ],
    char: "\ud83d\udeae",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cinema: {
    keywords: [ "blue-square", "record", "film", "movie", "curtain", "stage", "theater" ],
    char: "\ud83c\udfa6",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  signal_strength: {
    keywords: [ "blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars" ],
    char: "\ud83d\udcf6",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  koko: {
    keywords: [ "blue-square", "here", "katakana", "japanese", "destination" ],
    char: "\ud83c\ude01",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ng: {
    keywords: [ "blue-square", "words", "shape", "icon" ],
    char: "\ud83c\udd96",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ok: {
    keywords: [ "good", "agree", "yes", "blue-square" ],
    char: "\ud83c\udd97",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  up: {
    keywords: [ "blue-square", "above", "high" ],
    char: "\ud83c\udd99",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  cool: {
    keywords: [ "words", "blue-square" ],
    char: "\ud83c\udd92",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  new: {
    keywords: [ "blue-square", "words", "start" ],
    char: "\ud83c\udd95",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  free: {
    keywords: [ "blue-square", "words" ],
    char: "\ud83c\udd93",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  zero: {
    keywords: [ "0", "numbers", "blue-square", "null" ],
    char: "0\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  one: {
    keywords: [ "blue-square", "numbers", "1" ],
    char: "1\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  two: {
    keywords: [ "numbers", "2", "prime", "blue-square" ],
    char: "2\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  three: {
    keywords: [ "3", "numbers", "prime", "blue-square" ],
    char: "3\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  four: {
    keywords: [ "4", "numbers", "blue-square" ],
    char: "4\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  five: {
    keywords: [ "5", "numbers", "blue-square", "prime" ],
    char: "5\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  six: {
    keywords: [ "6", "numbers", "blue-square" ],
    char: "6\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  seven: {
    keywords: [ "7", "numbers", "blue-square", "prime" ],
    char: "7\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  eight: {
    keywords: [ "8", "blue-square", "numbers" ],
    char: "8\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  nine: {
    keywords: [ "blue-square", "numbers", "9" ],
    char: "9\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  keycap_ten: {
    keywords: [ "numbers", "10", "blue-square" ],
    char: "\ud83d\udd1f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  asterisk: {
    keywords: [ "star", "keycap" ],
    char: "*\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  1234: {
    keywords: [ "numbers", "blue-square" ],
    char: "\ud83d\udd22",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  eject_button: {
    keywords: [ "blue-square" ],
    char: "\u23cf\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_forward: {
    keywords: [ "blue-square", "right", "direction", "play" ],
    char: "\u25b6\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  pause_button: {
    keywords: [ "pause", "blue-square" ],
    char: "\u23f8",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  next_track_button: {
    keywords: [ "forward", "next", "blue-square" ],
    char: "\u23ed",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  stop_button: {
    keywords: [ "blue-square" ],
    char: "\u23f9",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  record_button: {
    keywords: [ "blue-square" ],
    char: "\u23fa",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  play_or_pause_button: {
    keywords: [ "blue-square", "play", "pause" ],
    char: "\u23ef",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  previous_track_button: {
    keywords: [ "backward" ],
    char: "\u23ee",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  fast_forward: {
    keywords: [ "blue-square", "play", "speed", "continue" ],
    char: "\u23e9",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  rewind: {
    keywords: [ "play", "blue-square" ],
    char: "\u23ea",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  twisted_rightwards_arrows: {
    keywords: [ "blue-square", "shuffle", "music", "random" ],
    char: "\ud83d\udd00",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  repeat: {
    keywords: [ "loop", "record" ],
    char: "\ud83d\udd01",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  repeat_one: {
    keywords: [ "blue-square", "loop" ],
    char: "\ud83d\udd02",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_backward: {
    keywords: [ "blue-square", "left", "direction" ],
    char: "\u25c0\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_up_small: {
    keywords: [ "blue-square", "triangle", "direction", "point", "forward", "top" ],
    char: "\ud83d\udd3c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_down_small: {
    keywords: [ "blue-square", "direction", "bottom" ],
    char: "\ud83d\udd3d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_double_up: {
    keywords: [ "blue-square", "direction", "top" ],
    char: "\u23eb",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_double_down: {
    keywords: [ "blue-square", "direction", "bottom" ],
    char: "\u23ec",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_right: {
    keywords: [ "blue-square", "next" ],
    char: "\u27a1\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_left: {
    keywords: [ "blue-square", "previous", "back" ],
    char: "\u2b05\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_up: {
    keywords: [ "blue-square", "continue", "top", "direction" ],
    char: "\u2b06\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_down: {
    keywords: [ "blue-square", "direction", "bottom" ],
    char: "\u2b07\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_upper_right: {
    keywords: [ "blue-square", "point", "direction", "diagonal", "northeast" ],
    char: "\u2197\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_lower_right: {
    keywords: [ "blue-square", "direction", "diagonal", "southeast" ],
    char: "\u2198\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_lower_left: {
    keywords: [ "blue-square", "direction", "diagonal", "southwest" ],
    char: "\u2199\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_upper_left: {
    keywords: [ "blue-square", "point", "direction", "diagonal", "northwest" ],
    char: "\u2196\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_up_down: {
    keywords: [ "blue-square", "direction", "way", "vertical" ],
    char: "\u2195\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  left_right_arrow: {
    keywords: [ "shape", "direction", "horizontal", "sideways" ],
    char: "\u2194\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrows_counterclockwise: {
    keywords: [ "blue-square", "sync", "cycle" ],
    char: "\ud83d\udd04",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_right_hook: {
    keywords: [ "blue-square", "return", "rotate", "direction" ],
    char: "\u21aa\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  leftwards_arrow_with_hook: {
    keywords: [ "back", "return", "blue-square", "undo", "enter" ],
    char: "\u21a9\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_heading_up: {
    keywords: [ "blue-square", "direction", "top" ],
    char: "\u2934\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrow_heading_down: {
    keywords: [ "blue-square", "direction", "bottom" ],
    char: "\u2935\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  hash: {
    keywords: [ "symbol", "blue-square", "twitter" ],
    char: "#\ufe0f\u20e3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  information_source: {
    keywords: [ "blue-square", "alphabet", "letter" ],
    char: "\u2139\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  abc: {
    keywords: [ "blue-square", "alphabet" ],
    char: "\ud83d\udd24",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  abcd: {
    keywords: [ "blue-square", "alphabet" ],
    char: "\ud83d\udd21",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  capital_abcd: {
    keywords: [ "alphabet", "words", "blue-square" ],
    char: "\ud83d\udd20",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  symbols: {
    keywords: [ "blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters" ],
    char: "\ud83d\udd23",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  musical_note: {
    keywords: [ "score", "tone", "sound" ],
    char: "\ud83c\udfb5",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  notes: {
    keywords: [ "music", "score" ],
    char: "\ud83c\udfb6",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  wavy_dash: {
    keywords: [ "draw", "line", "moustache", "mustache", "squiggle", "scribble" ],
    char: "\u3030\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  curly_loop: {
    keywords: [ "scribble", "draw", "shape", "squiggle" ],
    char: "\u27b0",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_check_mark: {
    keywords: [ "ok", "nike", "answer", "yes", "tick" ],
    char: "\u2714\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  arrows_clockwise: {
    keywords: [ "sync", "cycle", "round", "repeat" ],
    char: "\ud83d\udd03",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_plus_sign: {
    keywords: [ "math", "calculation", "addition", "more", "increase" ],
    char: "\u2795",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_minus_sign: {
    keywords: [ "math", "calculation", "subtract", "less" ],
    char: "\u2796",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_division_sign: {
    keywords: [ "divide", "math", "calculation" ],
    char: "\u2797",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_multiplication_x: {
    keywords: [ "math", "calculation" ],
    char: "\u2716\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  infinity: {
    keywords: [ "forever" ],
    char: "\u267e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  heavy_dollar_sign: {
    keywords: [ "money", "sales", "payment", "currency", "buck" ],
    char: "\ud83d\udcb2",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  currency_exchange: {
    keywords: [ "money", "sales", "dollar", "travel" ],
    char: "\ud83d\udcb1",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  copyright: {
    keywords: [ "ip", "license", "circle", "law", "legal" ],
    char: "\xa9\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  registered: {
    keywords: [ "alphabet", "circle" ],
    char: "\xae\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  tm: {
    keywords: [ "trademark", "brand", "law", "legal" ],
    char: "\u2122\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  end: {
    keywords: [ "words", "arrow" ],
    char: "\ud83d\udd1a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  back: {
    keywords: [ "arrow", "words", "return" ],
    char: "\ud83d\udd19",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  on: {
    keywords: [ "arrow", "words" ],
    char: "\ud83d\udd1b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  top: {
    keywords: [ "words", "blue-square" ],
    char: "\ud83d\udd1d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  soon: {
    keywords: [ "arrow", "words" ],
    char: "\ud83d\udd1c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  ballot_box_with_check: {
    keywords: [ "ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick" ],
    char: "\u2611\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  radio_button: {
    keywords: [ "input", "old", "music", "circle" ],
    char: "\ud83d\udd18",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_circle: {
    keywords: [ "shape", "round" ],
    char: "\u26aa",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_circle: {
    keywords: [ "shape", "button", "round" ],
    char: "\u26ab",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  red_circle: {
    keywords: [ "shape", "error", "danger" ],
    char: "\ud83d\udd34",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  large_blue_circle: {
    keywords: [ "shape", "icon", "button" ],
    char: "\ud83d\udd35",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  small_orange_diamond: {
    keywords: [ "shape", "jewel", "gem" ],
    char: "\ud83d\udd38",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  small_blue_diamond: {
    keywords: [ "shape", "jewel", "gem" ],
    char: "\ud83d\udd39",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  large_orange_diamond: {
    keywords: [ "shape", "jewel", "gem" ],
    char: "\ud83d\udd36",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  large_blue_diamond: {
    keywords: [ "shape", "jewel", "gem" ],
    char: "\ud83d\udd37",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  small_red_triangle: {
    keywords: [ "shape", "direction", "up", "top" ],
    char: "\ud83d\udd3a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_small_square: {
    keywords: [ "shape", "icon" ],
    char: "\u25aa\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_small_square: {
    keywords: [ "shape", "icon" ],
    char: "\u25ab\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_large_square: {
    keywords: [ "shape", "icon", "button" ],
    char: "\u2b1b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_large_square: {
    keywords: [ "shape", "icon", "stone", "button" ],
    char: "\u2b1c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  small_red_triangle_down: {
    keywords: [ "shape", "direction", "bottom" ],
    char: "\ud83d\udd3b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_medium_square: {
    keywords: [ "shape", "button", "icon" ],
    char: "\u25fc\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_medium_square: {
    keywords: [ "shape", "stone", "icon" ],
    char: "\u25fb\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_medium_small_square: {
    keywords: [ "icon", "shape", "button" ],
    char: "\u25fe",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_medium_small_square: {
    keywords: [ "shape", "stone", "icon", "button" ],
    char: "\u25fd",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_square_button: {
    keywords: [ "shape", "input", "frame" ],
    char: "\ud83d\udd32",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  white_square_button: {
    keywords: [ "shape", "input" ],
    char: "\ud83d\udd33",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  speaker: {
    keywords: [ "sound", "volume", "silence", "broadcast" ],
    char: "\ud83d\udd08",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  sound: {
    keywords: [ "volume", "speaker", "broadcast" ],
    char: "\ud83d\udd09",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  loud_sound: {
    keywords: [ "volume", "noise", "noisy", "speaker", "broadcast" ],
    char: "\ud83d\udd0a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  mute: {
    keywords: [ "sound", "volume", "silence", "quiet" ],
    char: "\ud83d\udd07",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  mega: {
    keywords: [ "sound", "speaker", "volume" ],
    char: "\ud83d\udce3",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  loudspeaker: {
    keywords: [ "volume", "sound" ],
    char: "\ud83d\udce2",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  bell: {
    keywords: [ "sound", "notification", "christmas", "xmas", "chime" ],
    char: "\ud83d\udd14",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  no_bell: {
    keywords: [ "sound", "volume", "mute", "quiet", "silent" ],
    char: "\ud83d\udd15",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  black_joker: {
    keywords: [ "poker", "cards", "game", "play", "magic" ],
    char: "\ud83c\udccf",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  mahjong: {
    keywords: [ "game", "play", "chinese", "kanji" ],
    char: "\ud83c\udc04",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  spades: {
    keywords: [ "poker", "cards", "suits", "magic" ],
    char: "\u2660\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clubs: {
    keywords: [ "poker", "cards", "magic", "suits" ],
    char: "\u2663\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  hearts: {
    keywords: [ "poker", "cards", "magic", "suits" ],
    char: "\u2665\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  diamonds: {
    keywords: [ "poker", "cards", "magic", "suits" ],
    char: "\u2666\ufe0f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  flower_playing_cards: {
    keywords: [ "game", "sunset", "red" ],
    char: "\ud83c\udfb4",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  thought_balloon: {
    keywords: [ "bubble", "cloud", "speech", "thinking", "dream" ],
    char: "\ud83d\udcad",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  right_anger_bubble: {
    keywords: [ "caption", "speech", "thinking", "mad" ],
    char: "\ud83d\uddef",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  speech_balloon: {
    keywords: [ "bubble", "words", "message", "talk", "chatting" ],
    char: "\ud83d\udcac",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  left_speech_bubble: {
    keywords: [ "words", "message", "talk", "chatting" ],
    char: "\ud83d\udde8",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock1: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd50",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock2: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd51",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock3: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd52",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock4: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd53",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock5: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd54",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock6: {
    keywords: [ "time", "late", "early", "schedule", "dawn", "dusk" ],
    char: "\ud83d\udd55",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock7: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd56",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock8: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd57",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock9: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd58",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock10: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd59",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock11: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd5a",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock12: {
    keywords: [ "time", "noon", "midnight", "midday", "late", "early", "schedule" ],
    char: "\ud83d\udd5b",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock130: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd5c",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock230: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd5d",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock330: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd5e",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock430: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd5f",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock530: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd60",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock630: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd61",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock730: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd62",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock830: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd63",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock930: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd64",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock1030: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd65",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock1130: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd66",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  clock1230: {
    keywords: [ "time", "late", "early", "schedule" ],
    char: "\ud83d\udd67",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  afghanistan: {
    keywords: [ "af", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  aland_islands: {
    keywords: [ "\xc5land", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddfd",
    fitzpatrick_scale: false,
    category: "flags"
  },
  albania: {
    keywords: [ "al", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  algeria: {
    keywords: [ "dz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  american_samoa: {
    keywords: [ "american", "ws", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  andorra: {
    keywords: [ "ad", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  angola: {
    keywords: [ "ao", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  anguilla: {
    keywords: [ "ai", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  antarctica: {
    keywords: [ "aq", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  antigua_barbuda: {
    keywords: [ "antigua", "barbuda", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  argentina: {
    keywords: [ "ar", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  armenia: {
    keywords: [ "am", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  aruba: {
    keywords: [ "aw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  australia: {
    keywords: [ "au", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  austria: {
    keywords: [ "at", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  azerbaijan: {
    keywords: [ "az", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bahamas: {
    keywords: [ "bs", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bahrain: {
    keywords: [ "bh", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bangladesh: {
    keywords: [ "bd", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  barbados: {
    keywords: [ "bb", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\udde7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  belarus: {
    keywords: [ "by", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  belgium: {
    keywords: [ "be", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  belize: {
    keywords: [ "bz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  benin: {
    keywords: [ "bj", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddef",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bermuda: {
    keywords: [ "bm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bhutan: {
    keywords: [ "bt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bolivia: {
    keywords: [ "bo", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  caribbean_netherlands: {
    keywords: [ "bonaire", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bosnia_herzegovina: {
    keywords: [ "bosnia", "herzegovina", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  botswana: {
    keywords: [ "bw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  brazil: {
    keywords: [ "br", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  british_indian_ocean_territory: {
    keywords: [ "british", "indian", "ocean", "territory", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  british_virgin_islands: {
    keywords: [ "british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  brunei: {
    keywords: [ "bn", "darussalam", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  bulgaria: {
    keywords: [ "bg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  burkina_faso: {
    keywords: [ "burkina", "faso", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  burundi: {
    keywords: [ "bi", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cape_verde: {
    keywords: [ "cabo", "verde", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddfb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cambodia: {
    keywords: [ "kh", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cameroon: {
    keywords: [ "cm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  canada: {
    keywords: [ "ca", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  canary_islands: {
    keywords: [ "canary", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cayman_islands: {
    keywords: [ "cayman", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  central_african_republic: {
    keywords: [ "central", "african", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  chad: {
    keywords: [ "td", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  chile: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cn: {
    keywords: [ "china", "chinese", "prc", "flag", "country", "nation", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  christmas_island: {
    keywords: [ "christmas", "island", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddfd",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cocos_islands: {
    keywords: [ "cocos", "keeling", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  colombia: {
    keywords: [ "co", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  comoros: {
    keywords: [ "km", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  congo_brazzaville: {
    keywords: [ "congo", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  congo_kinshasa: {
    keywords: [ "congo", "democratic", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cook_islands: {
    keywords: [ "cook", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  costa_rica: {
    keywords: [ "costa", "rica", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  croatia: {
    keywords: [ "hr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udded\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cuba: {
    keywords: [ "cu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  curacao: {
    keywords: [ "cura\xe7ao", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cyprus: {
    keywords: [ "cy", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  czech_republic: {
    keywords: [ "cz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  denmark: {
    keywords: [ "dk", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  djibouti: {
    keywords: [ "dj", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddef",
    fitzpatrick_scale: false,
    category: "flags"
  },
  dominica: {
    keywords: [ "dm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  dominican_republic: {
    keywords: [ "dominican", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ecuador: {
    keywords: [ "ec", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  egypt: {
    keywords: [ "eg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  el_salvador: {
    keywords: [ "el", "salvador", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddfb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  equatorial_guinea: {
    keywords: [ "equatorial", "gn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  eritrea: {
    keywords: [ "er", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  estonia: {
    keywords: [ "ee", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ethiopia: {
    keywords: [ "et", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  eu: {
    keywords: [ "european", "union", "flag", "banner" ],
    char: "\ud83c\uddea\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  falkland_islands: {
    keywords: [ "falkland", "islands", "malvinas", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddeb\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  faroe_islands: {
    keywords: [ "faroe", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddeb\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  fiji: {
    keywords: [ "fj", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddeb\ud83c\uddef",
    fitzpatrick_scale: false,
    category: "flags"
  },
  finland: {
    keywords: [ "fi", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddeb\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  fr: {
    keywords: [ "banner", "flag", "nation", "france", "french", "country" ],
    char: "\ud83c\uddeb\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  french_guiana: {
    keywords: [ "french", "guiana", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  french_polynesia: {
    keywords: [ "french", "polynesia", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  french_southern_territories: {
    keywords: [ "french", "southern", "territories", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  gabon: {
    keywords: [ "ga", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  gambia: {
    keywords: [ "gm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  georgia: {
    keywords: [ "ge", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  de: {
    keywords: [ "german", "nation", "flag", "country", "banner" ],
    char: "\ud83c\udde9\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ghana: {
    keywords: [ "gh", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  gibraltar: {
    keywords: [ "gi", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  greece: {
    keywords: [ "gr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  greenland: {
    keywords: [ "gl", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  grenada: {
    keywords: [ "gd", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guadeloupe: {
    keywords: [ "gp", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf5",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guam: {
    keywords: [ "gu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guatemala: {
    keywords: [ "gt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guernsey: {
    keywords: [ "gg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guinea: {
    keywords: [ "gn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guinea_bissau: {
    keywords: [ "gw", "bissau", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  guyana: {
    keywords: [ "gy", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  haiti: {
    keywords: [ "ht", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udded\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  honduras: {
    keywords: [ "hn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udded\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  hong_kong: {
    keywords: [ "hong", "kong", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udded\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  hungary: {
    keywords: [ "hu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udded\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  iceland: {
    keywords: [ "is", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  india: {
    keywords: [ "in", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  indonesia: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  iran: {
    keywords: [ "iran,", "islamic", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  iraq: {
    keywords: [ "iq", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ireland: {
    keywords: [ "ie", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  isle_of_man: {
    keywords: [ "isle", "man", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  israel: {
    keywords: [ "il", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  it: {
    keywords: [ "italy", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddee\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  cote_divoire: {
    keywords: [ "ivory", "coast", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  jamaica: {
    keywords: [ "jm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddef\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  jp: {
    keywords: [ "japanese", "nation", "flag", "country", "banner" ],
    char: "\ud83c\uddef\ud83c\uddf5",
    fitzpatrick_scale: false,
    category: "flags"
  },
  jersey: {
    keywords: [ "je", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddef\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  jordan: {
    keywords: [ "jo", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddef\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kazakhstan: {
    keywords: [ "kz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kenya: {
    keywords: [ "ke", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kiribati: {
    keywords: [ "ki", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kosovo: {
    keywords: [ "xk", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfd\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kuwait: {
    keywords: [ "kw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kyrgyzstan: {
    keywords: [ "kg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  laos: {
    keywords: [ "lao", "democratic", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  latvia: {
    keywords: [ "lv", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddfb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  lebanon: {
    keywords: [ "lb", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\udde7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  lesotho: {
    keywords: [ "ls", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  liberia: {
    keywords: [ "lr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  libya: {
    keywords: [ "ly", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  liechtenstein: {
    keywords: [ "li", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  lithuania: {
    keywords: [ "lt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  luxembourg: {
    keywords: [ "lu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  macau: {
    keywords: [ "macao", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  macedonia: {
    keywords: [ "macedonia,", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  madagascar: {
    keywords: [ "mg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  malawi: {
    keywords: [ "mw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  malaysia: {
    keywords: [ "my", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  maldives: {
    keywords: [ "mv", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddfb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mali: {
    keywords: [ "ml", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  malta: {
    keywords: [ "mt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  marshall_islands: {
    keywords: [ "marshall", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  martinique: {
    keywords: [ "mq", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mauritania: {
    keywords: [ "mr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mauritius: {
    keywords: [ "mu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mayotte: {
    keywords: [ "yt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfe\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mexico: {
    keywords: [ "mx", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddfd",
    fitzpatrick_scale: false,
    category: "flags"
  },
  micronesia: {
    keywords: [ "micronesia,", "federated", "states", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddeb\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  moldova: {
    keywords: [ "moldova,", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  monaco: {
    keywords: [ "mc", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mongolia: {
    keywords: [ "mn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  montenegro: {
    keywords: [ "me", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  montserrat: {
    keywords: [ "ms", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  morocco: {
    keywords: [ "ma", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  mozambique: {
    keywords: [ "mz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  myanmar: {
    keywords: [ "mm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  namibia: {
    keywords: [ "na", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  nauru: {
    keywords: [ "nr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  nepal: {
    keywords: [ "np", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddf5",
    fitzpatrick_scale: false,
    category: "flags"
  },
  netherlands: {
    keywords: [ "nl", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  new_caledonia: {
    keywords: [ "new", "caledonia", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  new_zealand: {
    keywords: [ "new", "zealand", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  nicaragua: {
    keywords: [ "ni", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  niger: {
    keywords: [ "ne", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  nigeria: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  niue: {
    keywords: [ "nu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  norfolk_island: {
    keywords: [ "norfolk", "island", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  northern_mariana_islands: {
    keywords: [ "northern", "mariana", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf2\ud83c\uddf5",
    fitzpatrick_scale: false,
    category: "flags"
  },
  north_korea: {
    keywords: [ "north", "korea", "nation", "flag", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddf5",
    fitzpatrick_scale: false,
    category: "flags"
  },
  norway: {
    keywords: [ "no", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf3\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  oman: {
    keywords: [ "om_symbol", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf4\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  pakistan: {
    keywords: [ "pk", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  palau: {
    keywords: [ "pw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  palestinian_territories: {
    keywords: [ "palestine", "palestinian", "territories", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  panama: {
    keywords: [ "pa", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  papua_new_guinea: {
    keywords: [ "papua", "new", "guinea", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  paraguay: {
    keywords: [ "py", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  peru: {
    keywords: [ "pe", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  philippines: {
    keywords: [ "ph", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  pitcairn_islands: {
    keywords: [ "pitcairn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  poland: {
    keywords: [ "pl", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  portugal: {
    keywords: [ "pt", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  puerto_rico: {
    keywords: [ "puerto", "rico", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  qatar: {
    keywords: [ "qa", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf6\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  reunion: {
    keywords: [ "r\xe9union", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf7\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  romania: {
    keywords: [ "ro", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf7\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ru: {
    keywords: [ "russian", "federation", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf7\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  rwanda: {
    keywords: [ "rw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf7\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_barthelemy: {
    keywords: [ "saint", "barth\xe9lemy", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde7\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_helena: {
    keywords: [ "saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_kitts_nevis: {
    keywords: [ "saint", "kitts", "nevis", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_lucia: {
    keywords: [ "saint", "lucia", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_pierre_miquelon: {
    keywords: [ "saint", "pierre", "miquelon", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf5\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  st_vincent_grenadines: {
    keywords: [ "saint", "vincent", "grenadines", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  samoa: {
    keywords: [ "ws", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfc\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  san_marino: {
    keywords: [ "san", "marino", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sao_tome_principe: {
    keywords: [ "sao", "tome", "principe", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  saudi_arabia: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  senegal: {
    keywords: [ "sn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  serbia: {
    keywords: [ "rs", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf7\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  seychelles: {
    keywords: [ "sc", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sierra_leone: {
    keywords: [ "sierra", "leone", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  singapore: {
    keywords: [ "sg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sint_maarten: {
    keywords: [ "sint", "maarten", "dutch", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddfd",
    fitzpatrick_scale: false,
    category: "flags"
  },
  slovakia: {
    keywords: [ "sk", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  slovenia: {
    keywords: [ "si", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  solomon_islands: {
    keywords: [ "solomon", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\udde7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  somalia: {
    keywords: [ "so", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  south_africa: {
    keywords: [ "south", "africa", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddff\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  south_georgia_south_sandwich_islands: {
    keywords: [ "south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddec\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  kr: {
    keywords: [ "south", "korea", "nation", "flag", "country", "banner" ],
    char: "\ud83c\uddf0\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  south_sudan: {
    keywords: [ "south", "sd", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  es: {
    keywords: [ "spain", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sri_lanka: {
    keywords: [ "sri", "lanka", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf1\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sudan: {
    keywords: [ "sd", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\udde9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  suriname: {
    keywords: [ "sr", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  swaziland: {
    keywords: [ "sz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  sweden: {
    keywords: [ "se", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  switzerland: {
    keywords: [ "ch", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde8\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  syria: {
    keywords: [ "syrian", "arab", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf8\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  taiwan: {
    keywords: [ "tw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tajikistan: {
    keywords: [ "tj", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddef",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tanzania: {
    keywords: [ "tanzania,", "united", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  thailand: {
    keywords: [ "th", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  timor_leste: {
    keywords: [ "timor", "leste", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf1",
    fitzpatrick_scale: false,
    category: "flags"
  },
  togo: {
    keywords: [ "tg", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tokelau: {
    keywords: [ "tk", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf0",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tonga: {
    keywords: [ "to", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf4",
    fitzpatrick_scale: false,
    category: "flags"
  },
  trinidad_tobago: {
    keywords: [ "trinidad", "tobago", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf9",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tunisia: {
    keywords: [ "tn", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tr: {
    keywords: [ "turkey", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  turkmenistan: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  turks_caicos_islands: {
    keywords: [ "turks", "caicos", "islands", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\udde8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  tuvalu: {
    keywords: [ "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddf9\ud83c\uddfb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  uganda: {
    keywords: [ "ug", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfa\ud83c\uddec",
    fitzpatrick_scale: false,
    category: "flags"
  },
  ukraine: {
    keywords: [ "ua", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfa\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  united_arab_emirates: {
    keywords: [ "united", "arab", "emirates", "flag", "nation", "country", "banner" ],
    char: "\ud83c\udde6\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  uk: {
    keywords: [ "united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack" ],
    char: "\ud83c\uddec\ud83c\udde7",
    fitzpatrick_scale: false,
    category: "flags"
  },
  england: {
    keywords: [ "flag", "english" ],
    char: "\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f",
    fitzpatrick_scale: false,
    category: "flags"
  },
  scotland: {
    keywords: [ "flag", "scottish" ],
    char: "\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f",
    fitzpatrick_scale: false,
    category: "flags"
  },
  wales: {
    keywords: [ "flag", "welsh" ],
    char: "\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f",
    fitzpatrick_scale: false,
    category: "flags"
  },
  us: {
    keywords: [ "united", "states", "america", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfa\ud83c\uddf8",
    fitzpatrick_scale: false,
    category: "flags"
  },
  us_virgin_islands: {
    keywords: [ "virgin", "islands", "us", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\uddee",
    fitzpatrick_scale: false,
    category: "flags"
  },
  uruguay: {
    keywords: [ "uy", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfa\ud83c\uddfe",
    fitzpatrick_scale: false,
    category: "flags"
  },
  uzbekistan: {
    keywords: [ "uz", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfa\ud83c\uddff",
    fitzpatrick_scale: false,
    category: "flags"
  },
  vanuatu: {
    keywords: [ "vu", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\uddfa",
    fitzpatrick_scale: false,
    category: "flags"
  },
  vatican_city: {
    keywords: [ "vatican", "city", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\udde6",
    fitzpatrick_scale: false,
    category: "flags"
  },
  venezuela: {
    keywords: [ "ve", "bolivarian", "republic", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  vietnam: {
    keywords: [ "viet", "nam", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfb\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  wallis_futuna: {
    keywords: [ "wallis", "futuna", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfc\ud83c\uddeb",
    fitzpatrick_scale: false,
    category: "flags"
  },
  western_sahara: {
    keywords: [ "western", "sahara", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddea\ud83c\udded",
    fitzpatrick_scale: false,
    category: "flags"
  },
  yemen: {
    keywords: [ "ye", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddfe\ud83c\uddea",
    fitzpatrick_scale: false,
    category: "flags"
  },
  zambia: {
    keywords: [ "zm", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddff\ud83c\uddf2",
    fitzpatrick_scale: false,
    category: "flags"
  },
  zimbabwe: {
    keywords: [ "zw", "flag", "nation", "country", "banner" ],
    char: "\ud83c\uddff\ud83c\uddfc",
    fitzpatrick_scale: false,
    category: "flags"
  },
  united_nations: {
    keywords: [ "un", "flag", "banner" ],
    char: "\ud83c\uddfa\ud83c\uddf3",
    fitzpatrick_scale: false,
    category: "flags"
  },
  pirate_flag: {
    keywords: [ "skull", "crossbones", "flag", "banner" ],
    char: "\ud83c\udff4\u200d\u2620\ufe0f",
    fitzpatrick_scale: false,
    category: "flags"
  }
});

/***/ }),

/***/ "ebd6":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "advlist" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/advlist')
//   ES2015:
//     import 'tinymce/plugins/advlist'
__webpack_require__("baf7");

/***/ }),

/***/ "f016":
/***/ (function(module, exports, __webpack_require__) {

// Exports the "preview" plugin for usage with module loaders
// Usage:
//   CommonJS:
//     require('tinymce/plugins/preview')
//   ES2015:
//     import 'tinymce/plugins/preview'
__webpack_require__("4948");

/***/ }),

/***/ "f2a5":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$4 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var isString = isType('string');
    var isFunction = isSimpleType('function');

    var noop = function () {
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var never = constant(false);
    var always = constant(true);

    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.XHR');

    var getCreationDateClasses = function (editor) {
      return editor.getParam('template_cdate_classes', 'cdate');
    };
    var getModificationDateClasses = function (editor) {
      return editor.getParam('template_mdate_classes', 'mdate');
    };
    var getSelectedContentClasses = function (editor) {
      return editor.getParam('template_selected_content_classes', 'selcontent');
    };
    var getPreviewReplaceValues = function (editor) {
      return editor.getParam('template_preview_replace_values');
    };
    var getContentStyle = function (editor) {
      return editor.getParam('content_style', '', 'string');
    };
    var shouldUseContentCssCors = function (editor) {
      return editor.getParam('content_css_cors', false, 'boolean');
    };
    var getTemplateReplaceValues = function (editor) {
      return editor.getParam('template_replace_values');
    };
    var getTemplates = function (editor) {
      return editor.getParam('templates');
    };
    var getCdateFormat = function (editor) {
      return editor.getParam('template_cdate_format', editor.translate('%Y-%m-%d'));
    };
    var getMdateFormat = function (editor) {
      return editor.getParam('template_mdate_format', editor.translate('%Y-%m-%d'));
    };
    var getBodyClassFromHash = function (editor) {
      var bodyClass = editor.getParam('body_class', '', 'hash');
      return bodyClass[editor.id] || '';
    };
    var getBodyClass = function (editor) {
      var bodyClass = editor.getParam('body_class', '', 'string');
      if (bodyClass.indexOf('=') === -1) {
        return bodyClass;
      } else {
        return getBodyClassFromHash(editor);
      }
    };

    var addZeros = function (value, len) {
      value = '' + value;
      if (value.length < len) {
        for (var i = 0; i < len - value.length; i++) {
          value = '0' + value;
        }
      }
      return value;
    };
    var getDateTime = function (editor, fmt, date) {
      if (date === void 0) {
        date = new Date();
      }
      var daysShort = 'Sun Mon Tue Wed Thu Fri Sat Sun'.split(' ');
      var daysLong = 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday'.split(' ');
      var monthsShort = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' ');
      var monthsLong = 'January February March April May June July August September October November December'.split(' ');
      fmt = fmt.replace('%D', '%m/%d/%Y');
      fmt = fmt.replace('%r', '%I:%M:%S %p');
      fmt = fmt.replace('%Y', '' + date.getFullYear());
      fmt = fmt.replace('%y', '' + date.getYear());
      fmt = fmt.replace('%m', addZeros(date.getMonth() + 1, 2));
      fmt = fmt.replace('%d', addZeros(date.getDate(), 2));
      fmt = fmt.replace('%H', '' + addZeros(date.getHours(), 2));
      fmt = fmt.replace('%M', '' + addZeros(date.getMinutes(), 2));
      fmt = fmt.replace('%S', '' + addZeros(date.getSeconds(), 2));
      fmt = fmt.replace('%I', '' + ((date.getHours() + 11) % 12 + 1));
      fmt = fmt.replace('%p', '' + (date.getHours() < 12 ? 'AM' : 'PM'));
      fmt = fmt.replace('%B', '' + editor.translate(monthsLong[date.getMonth()]));
      fmt = fmt.replace('%b', '' + editor.translate(monthsShort[date.getMonth()]));
      fmt = fmt.replace('%A', '' + editor.translate(daysLong[date.getDay()]));
      fmt = fmt.replace('%a', '' + editor.translate(daysShort[date.getDay()]));
      fmt = fmt.replace('%%', '%');
      return fmt;
    };

    var createTemplateList = function (editor, callback) {
      return function () {
        var templateList = getTemplates(editor);
        if (isFunction(templateList)) {
          templateList(callback);
        } else if (isString(templateList)) {
          global$2.send({
            url: templateList,
            success: function (text) {
              callback(JSON.parse(text));
            }
          });
        } else {
          callback(templateList);
        }
      };
    };
    var replaceTemplateValues = function (html, templateValues) {
      global$3.each(templateValues, function (v, k) {
        if (isFunction(v)) {
          v = v(k);
        }
        html = html.replace(new RegExp('\\{\\$' + k + '\\}', 'g'), v);
      });
      return html;
    };
    var replaceVals = function (editor, scope) {
      var dom = editor.dom, vl = getTemplateReplaceValues(editor);
      global$3.each(dom.select('*', scope), function (e) {
        global$3.each(vl, function (v, k) {
          if (dom.hasClass(e, k)) {
            if (isFunction(v)) {
              v(e);
            }
          }
        });
      });
    };
    var hasClass = function (n, c) {
      return new RegExp('\\b' + c + '\\b', 'g').test(n.className);
    };
    var insertTemplate = function (editor, _ui, html) {
      var dom = editor.dom;
      var sel = editor.selection.getContent();
      html = replaceTemplateValues(html, getTemplateReplaceValues(editor));
      var el = dom.create('div', null, html);
      var n = dom.select('.mceTmpl', el);
      if (n && n.length > 0) {
        el = dom.create('div', null);
        el.appendChild(n[0].cloneNode(true));
      }
      global$3.each(dom.select('*', el), function (n) {
        if (hasClass(n, getCreationDateClasses(editor).replace(/\s+/g, '|'))) {
          n.innerHTML = getDateTime(editor, getCdateFormat(editor));
        }
        if (hasClass(n, getModificationDateClasses(editor).replace(/\s+/g, '|'))) {
          n.innerHTML = getDateTime(editor, getMdateFormat(editor));
        }
        if (hasClass(n, getSelectedContentClasses(editor).replace(/\s+/g, '|'))) {
          n.innerHTML = sel;
        }
      });
      replaceVals(editor, el);
      editor.execCommand('mceInsertContent', false, el.innerHTML);
      editor.addVisual();
    };

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var call = function (thunk) {
        return thunk();
      };
      var id = identity;
      var me = {
        fold: function (n, _s) {
          return n();
        },
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || 'error: getOrDie called on none.');
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: function () {
          return none();
        },
        toArray: function () {
          return [];
        },
        toString: constant('none()')
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return 'some(' + a + ')';
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Optional = {
      some: some,
      none: none,
      from: from
    };

    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find = function (xs, pred) {
      return findUntil(xs, pred, never);
    };

    var global$1 = tinymce.util.Tools.resolve('tinymce.Env');

    var global = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var hasOwnProperty = Object.hasOwnProperty;
    var get = function (obj, key) {
      return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    var entitiesAttr = {
      '"': '&quot;',
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '\'': '&#039;'
    };
    var htmlEscape = function (html) {
      return html.replace(/["'<>&]/g, function (match) {
        return get(entitiesAttr, match).getOr(match);
      });
    };

    var getPreviewContent = function (editor, html) {
      if (html.indexOf('<html>') === -1) {
        var contentCssEntries_1 = '';
        var contentStyle = getContentStyle(editor);
        var cors_1 = shouldUseContentCssCors(editor) ? ' crossorigin="anonymous"' : '';
        global$3.each(editor.contentCSS, function (url) {
          contentCssEntries_1 += '<link type="text/css" rel="stylesheet" href="' + editor.documentBaseURI.toAbsolute(url) + '"' + cors_1 + '>';
        });
        if (contentStyle) {
          contentCssEntries_1 += '<style type="text/css">' + contentStyle + '</style>';
        }
        var bodyClass = getBodyClass(editor);
        var encode = editor.dom.encode;
        var isMetaKeyPressed = global$1.mac ? 'e.metaKey' : 'e.ctrlKey && !e.altKey';
        var preventClicksOnLinksScript = '<script>' + 'document.addEventListener && document.addEventListener("click", function(e) {' + 'for (var elm = e.target; elm; elm = elm.parentNode) {' + 'if (elm.nodeName === "A" && !(' + isMetaKeyPressed + ')) {' + 'e.preventDefault();' + '}' + '}' + '}, false);' + '</script> ';
        var directionality = editor.getBody().dir;
        var dirAttr = directionality ? ' dir="' + encode(directionality) + '"' : '';
        html = '<!DOCTYPE html>' + '<html>' + '<head>' + '<base href="' + encode(editor.documentBaseURI.getURI()) + '">' + contentCssEntries_1 + preventClicksOnLinksScript + '</head>' + '<body class="' + encode(bodyClass) + '"' + dirAttr + '>' + html + '</body>' + '</html>';
      }
      return replaceTemplateValues(html, getPreviewReplaceValues(editor));
    };
    var open = function (editor, templateList) {
      var createTemplates = function () {
        if (!templateList || templateList.length === 0) {
          var message = editor.translate('No templates defined.');
          editor.notificationManager.open({
            text: message,
            type: 'info'
          });
          return Optional.none();
        }
        return Optional.from(global$3.map(templateList, function (template, index) {
          var isUrlTemplate = function (t) {
            return t.url !== undefined;
          };
          return {
            selected: index === 0,
            text: template.title,
            value: {
              url: isUrlTemplate(template) ? Optional.from(template.url) : Optional.none(),
              content: !isUrlTemplate(template) ? Optional.from(template.content) : Optional.none(),
              description: template.description
            }
          };
        }));
      };
      var createSelectBoxItems = function (templates) {
        return map(templates, function (t) {
          return {
            text: t.text,
            value: t.text
          };
        });
      };
      var findTemplate = function (templates, templateTitle) {
        return find(templates, function (t) {
          return t.text === templateTitle;
        });
      };
      var loadFailedAlert = function (api) {
        editor.windowManager.alert('Could not load the specified template.', function () {
          return api.focus('template');
        });
      };
      var getTemplateContent = function (t) {
        return new global(function (resolve, reject) {
          t.value.url.fold(function () {
            return resolve(t.value.content.getOr(''));
          }, function (url) {
            return global$2.send({
              url: url,
              success: function (html) {
                resolve(html);
              },
              error: function (e) {
                reject(e);
              }
            });
          });
        });
      };
      var onChange = function (templates, updateDialog) {
        return function (api, change) {
          if (change.name === 'template') {
            var newTemplateTitle = api.getData().template;
            findTemplate(templates, newTemplateTitle).each(function (t) {
              api.block('Loading...');
              getTemplateContent(t).then(function (previewHtml) {
                updateDialog(api, t, previewHtml);
              }).catch(function () {
                updateDialog(api, t, '');
                api.disable('save');
                loadFailedAlert(api);
              });
            });
          }
        };
      };
      var onSubmit = function (templates) {
        return function (api) {
          var data = api.getData();
          findTemplate(templates, data.template).each(function (t) {
            getTemplateContent(t).then(function (previewHtml) {
              editor.execCommand('mceInsertTemplate', false, previewHtml);
              api.close();
            }).catch(function () {
              api.disable('save');
              loadFailedAlert(api);
            });
          });
        };
      };
      var openDialog = function (templates) {
        var selectBoxItems = createSelectBoxItems(templates);
        var buildDialogSpec = function (bodyItems, initialData) {
          return {
            title: 'Insert Template',
            size: 'large',
            body: {
              type: 'panel',
              items: bodyItems
            },
            initialData: initialData,
            buttons: [
              {
                type: 'cancel',
                name: 'cancel',
                text: 'Cancel'
              },
              {
                type: 'submit',
                name: 'save',
                text: 'Save',
                primary: true
              }
            ],
            onSubmit: onSubmit(templates),
            onChange: onChange(templates, updateDialog)
          };
        };
        var updateDialog = function (dialogApi, template, previewHtml) {
          var content = getPreviewContent(editor, previewHtml);
          var bodyItems = [
            {
              type: 'selectbox',
              name: 'template',
              label: 'Templates',
              items: selectBoxItems
            },
            {
              type: 'htmlpanel',
              html: '<p aria-live="polite">' + htmlEscape(template.value.description) + '</p>'
            },
            {
              label: 'Preview',
              type: 'iframe',
              name: 'preview',
              sandboxed: false
            }
          ];
          var initialData = {
            template: template.text,
            preview: content
          };
          dialogApi.unblock();
          dialogApi.redial(buildDialogSpec(bodyItems, initialData));
          dialogApi.focus('template');
        };
        var dialogApi = editor.windowManager.open(buildDialogSpec([], {
          template: '',
          preview: ''
        }));
        dialogApi.block('Loading...');
        getTemplateContent(templates[0]).then(function (previewHtml) {
          updateDialog(dialogApi, templates[0], previewHtml);
        }).catch(function () {
          updateDialog(dialogApi, templates[0], '');
          dialogApi.disable('save');
          loadFailedAlert(dialogApi);
        });
      };
      var optTemplates = createTemplates();
      optTemplates.each(openDialog);
    };

    var showDialog = function (editor) {
      return function (templates) {
        open(editor, templates);
      };
    };
    var register$1 = function (editor) {
      editor.addCommand('mceInsertTemplate', curry(insertTemplate, editor));
      editor.addCommand('mceTemplate', createTemplateList(editor, showDialog(editor)));
    };

    var setup = function (editor) {
      editor.on('PreProcess', function (o) {
        var dom = editor.dom, dateFormat = getMdateFormat(editor);
        global$3.each(dom.select('div', o.node), function (e) {
          if (dom.hasClass(e, 'mceTmpl')) {
            global$3.each(dom.select('*', e), function (e) {
              if (dom.hasClass(e, getModificationDateClasses(editor).replace(/\s+/g, '|'))) {
                e.innerHTML = getDateTime(editor, dateFormat);
              }
            });
            replaceVals(editor, e);
          }
        });
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mceTemplate');
      };
      editor.ui.registry.addButton('template', {
        icon: 'template',
        tooltip: 'Insert template',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('template', {
        icon: 'template',
        text: 'Insert template...',
        onAction: onAction
      });
    };

    function Plugin () {
      global$4.add('template', function (editor) {
        register(editor);
        register$1(editor);
        setup(editor);
      });
    }

    Plugin();

}());


/***/ }),

/***/ "fb04":
/***/ (function(module, exports) {

/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var global = tinymce.util.Tools.resolve('tinymce.Env');

    var getSeparatorHtml = function (editor) {
      return editor.getParam('pagebreak_separator', '<!-- pagebreak -->');
    };
    var shouldSplitBlock = function (editor) {
      return editor.getParam('pagebreak_split_block', false);
    };

    var pageBreakClass = 'mce-pagebreak';
    var getPlaceholderHtml = function (shouldSplitBlock) {
      var html = '<img src="' + global.transparentSrc + '" class="' + pageBreakClass + '" data-mce-resize="false" data-mce-placeholder />';
      return shouldSplitBlock ? '<p>' + html + '</p>' : html;
    };
    var setup$1 = function (editor) {
      var separatorHtml = getSeparatorHtml(editor);
      var shouldSplitBlock$1 = function () {
        return shouldSplitBlock(editor);
      };
      var pageBreakSeparatorRegExp = new RegExp(separatorHtml.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, function (a) {
        return '\\' + a;
      }), 'gi');
      editor.on('BeforeSetContent', function (e) {
        e.content = e.content.replace(pageBreakSeparatorRegExp, getPlaceholderHtml(shouldSplitBlock$1()));
      });
      editor.on('PreInit', function () {
        editor.serializer.addNodeFilter('img', function (nodes) {
          var i = nodes.length, node, className;
          while (i--) {
            node = nodes[i];
            className = node.attr('class');
            if (className && className.indexOf(pageBreakClass) !== -1) {
              var parentNode = node.parent;
              if (editor.schema.getBlockElements()[parentNode.name] && shouldSplitBlock$1()) {
                parentNode.type = 3;
                parentNode.value = separatorHtml;
                parentNode.raw = true;
                node.remove();
                continue;
              }
              node.type = 3;
              node.value = separatorHtml;
              node.raw = true;
            }
          }
        });
      });
    };

    var register$1 = function (editor) {
      editor.addCommand('mcePageBreak', function () {
        editor.insertContent(getPlaceholderHtml(shouldSplitBlock(editor)));
      });
    };

    var setup = function (editor) {
      editor.on('ResolveName', function (e) {
        if (e.target.nodeName === 'IMG' && editor.dom.hasClass(e.target, pageBreakClass)) {
          e.name = 'pagebreak';
        }
      });
    };

    var register = function (editor) {
      var onAction = function () {
        return editor.execCommand('mcePageBreak');
      };
      editor.ui.registry.addButton('pagebreak', {
        icon: 'page-break',
        tooltip: 'Page break',
        onAction: onAction
      });
      editor.ui.registry.addMenuItem('pagebreak', {
        text: 'Page break',
        icon: 'page-break',
        onAction: onAction
      });
    };

    function Plugin () {
      global$1.add('pagebreak', function (editor) {
        register$1(editor);
        register(editor);
        setup$1(editor);
        setup(editor);
      });
    }

    Plugin();

}());


/***/ })

}]);
//# sourceMappingURL=DgiotamisEditor.common.7.js.map